// Copyright IBM Corp. 2025 All Rights Reserved.
// Licensed under the Mozilla Public License v2.0

/*
 * IBM OpenAPI Terraform Generator Version: 3.97.2-fc613b62-20241203-155509
 */

package vmware

import (
	"context"
	"fmt"
	"log"
	"strings"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/resource"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/IBM-Cloud/terraform-provider-ibm/ibm/conns"
	"github.com/IBM-Cloud/terraform-provider-ibm/ibm/flex"
	"github.com/IBM-Cloud/terraform-provider-ibm/ibm/validate"
	"github.com/IBM/vmware-go-sdk/vmwarev1"
)

func ResourceIbmVmaasTransitGatewayConnection() *schema.Resource {
	return &schema.Resource{
		CreateContext: resourceIbmVmaasTransitGatewayConnectionCreate,
		ReadContext:   resourceIbmVmaasTransitGatewayConnectionRead,
		UpdateContext: resourceIbmVmaasTransitGatewayConnectionUpdate,
		DeleteContext: resourceIbmVmaasTransitGatewayConnectionDelete,
		Importer:      &schema.ResourceImporter{},
		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(15 * time.Minute),
			Update: schema.DefaultTimeout(25 * time.Minute),
			Delete: schema.DefaultTimeout(40 * time.Minute),
		},

		Schema: map[string]*schema.Schema{
			"vdc_id": &schema.Schema{
				Type:         schema.TypeString,
				Required:     true,
				ForceNew:     true,
				ValidateFunc: validate.InvokeValidator("ibm_vmaas_transit_gateway_connection", "vdc_id"),
				Description:  "A unique ID for a virtual data center.",
			},
			"edge_id": &schema.Schema{
				Type:         schema.TypeString,
				Required:     true,
				ForceNew:     true,
				ValidateFunc: validate.InvokeValidator("ibm_vmaas_transit_gateway_connection", "edge_id"),
				Description:  "A unique ID for an edge.",
			},
			"region": &schema.Schema{
				Type:         schema.TypeString,
				Optional:     true,
				Computed:     true,
				ValidateFunc: validate.InvokeValidator("ibm_vmaas_transit_gateway_connection", "region"),
				Description:  "The region where the IBM Transit Gateway is deployed.",
			},
			"connections": &schema.Schema{
				Type:        schema.TypeList,
				Computed:    true,
				Description: "IBM Transit Gateway connections.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": &schema.Schema{
							Type:        schema.TypeString,
							Computed:    true,
							Description: "The autogenerated name for this connection.",
						},
						"transit_gateway_connection_name": &schema.Schema{
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "The user-defined name of the connection created on the IBM Transit Gateway.",
						},
						"status": &schema.Schema{
							Type:        schema.TypeString,
							Computed:    true,
							Description: "Determines the state of the connection.",
						},
						"local_gateway_ip": &schema.Schema{
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Local gateway IP address for the connection.",
						},
						"remote_gateway_ip": &schema.Schema{
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Remote gateway IP address for the connection.",
						},
						"local_tunnel_ip": &schema.Schema{
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Local tunnel IP address for the connection.",
						},
						"remote_tunnel_ip": &schema.Schema{
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Remote tunnel IP address for the connection.",
						},
						"local_bgp_asn": &schema.Schema{
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "Local network BGP ASN for the connection.",
						},
						"remote_bgp_asn": &schema.Schema{
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
							Description: "Remote network BGP ASN for the connection.",
						},
						"network_account_id": &schema.Schema{
							Type:        schema.TypeString,
							Computed:    true,
							Description: "The ID of the account that owns the connected network.",
						},
						"network_type": &schema.Schema{
							Type:        schema.TypeString,
							Computed:    true,
							Description: "The type of the network that is connected through this connection. Only \"unbound_gre_tunnel\" is supported.",
						},
						"base_network_type": &schema.Schema{
							Type:        schema.TypeString,
							Computed:    true,
							Description: "The type of the network that the unbound GRE tunnel is targeting. Only \"classic\" is supported.",
						},
						"zone": &schema.Schema{
							Type:        schema.TypeString,
							Computed:    true,
							Description: "The location of the connection.",
						},
					},
				},
			},
			"status": &schema.Schema{
				Type:        schema.TypeString,
				Computed:    true,
				Description: "Determines the state of the IBM Transit Gateway based on its connections.",
			},
			"vmaas_transit_gateway_connection_id": &schema.Schema{
				Type:         schema.TypeString,
				Required:     true,
				ForceNew:     true,
				ValidateFunc: validate.InvokeValidator("ibm_vmaas_transit_gateway_connection", "vmaas_transit_gateways_connection_id"),
				Description:  "A unique ID for an IBM Transit Gateway.",
			},
		},
	}
}

func ResourceIbmVmaasTransitGatewayConnectionValidator() *validate.ResourceValidator {
	validateSchema := make([]validate.ValidateSchema, 0)
	validateSchema = append(validateSchema,
		validate.ValidateSchema{
			Identifier:                 "vdc_id",
			ValidateFunctionIdentifier: validate.ValidateRegexpLen,
			Type:                       validate.TypeString,
			Required:                   true,
			Regexp:                     `^[A-Za-z0-9_-]{1,128}$`,
			MinValueLength:             1,
			MaxValueLength:             128,
		},
		validate.ValidateSchema{
			Identifier:                 "edge_id",
			ValidateFunctionIdentifier: validate.ValidateRegexpLen,
			Type:                       validate.TypeString,
			Required:                   true,
			Regexp:                     `^[A-Za-z0-9_-]{1,128}$`,
			MinValueLength:             1,
			MaxValueLength:             128,
		},
		validate.ValidateSchema{
			Identifier:                 "region",
			ValidateFunctionIdentifier: validate.ValidateRegexpLen,
			Type:                       validate.TypeString,
			Optional:                   true,
			Regexp:                     `^.+$`,
			MinValueLength:             1,
			MaxValueLength:             25,
		},
		validate.ValidateSchema{
			Identifier:                 "vmaas_transit_gateway_connection_id",
			ValidateFunctionIdentifier: validate.ValidateRegexpLen,
			Type:                       validate.TypeString,
			Optional:                   true,
			Regexp:                     `^[A-Za-z0-9_-]{1,128}$`,
			MinValueLength:             1,
			MaxValueLength:             128,
		},
	)

	resourceValidator := validate.ResourceValidator{ResourceName: "ibm_vmaas_transit_gateway_connection", Schema: validateSchema}
	return &resourceValidator
}

func resourceIbmVmaasTransitGatewayConnectionCreate(context context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	vmwareClient, err := meta.(conns.ClientSession).VmwareV1()
	if err != nil {
		tfErr := flex.DiscriminatedTerraformErrorf(err, err.Error(), "ibm_vmaas_transit_gateway_connection", "create", "initialize-client")
		log.Printf("[DEBUG]\n%s", tfErr.GetDebugMessage())
		return tfErr.GetDiag()
	}

	addTransitGatewayConnectionsOptions := &vmwarev1.AddTransitGatewayConnectionsOptions{}
	addTransitGatewayConnectionsOptions.SetVdcID(d.Get("vdc_id").(string))
	addTransitGatewayConnectionsOptions.SetEdgeID(d.Get("edge_id").(string))
	addTransitGatewayConnectionsOptions.SetID(d.Get("vmaas_transit_gateway_connection_id").(string))

	if v, ok := d.GetOk("region"); ok {
		addTransitGatewayConnectionsOptions.SetRegion(v.(string))
	}

	transitGateway, _, err := vmwareClient.AddTransitGatewayConnectionsWithContext(context, addTransitGatewayConnectionsOptions)
	if err != nil {
		tfErr := flex.TerraformErrorf(err, fmt.Sprintf("AddTransitGatewayConnectionsWithContext failed: %s", err.Error()), "ibm_vmaas_transit_gateway_connection", "create")
		log.Printf("[DEBUG]\n%s", tfErr.GetDebugMessage())
		return tfErr.GetDiag()
	}

	vdcID := *addTransitGatewayConnectionsOptions.VdcID
	edgeID := *addTransitGatewayConnectionsOptions.EdgeID
	tgwID := *transitGateway.ID

	d.SetId(fmt.Sprintf("%s/%s/%s", vdcID, edgeID, tgwID))

	fmt.Println("[INFO] Transit Gateway connection created, waiting for tunnel IP...")

	tgw, err := waitForTransitGatewayConnectionTunnelIp(context, vdcID, edgeID, tgwID, meta)
	if err != nil {
		return diag.FromErr(err)
	}
	d.Set("connections", flattenTransitGatewayConnections(tgw.Connections))
	d.Set("region", tgw.Region)

	return resourceIbmVmaasTransitGatewayConnectionRead(context, d, meta)
}

func resourceIbmVmaasTransitGatewayConnectionRead(context context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	parts := strings.Split(d.Id(), "/")
	if len(parts) < 3 {
		err := fmt.Errorf("unexpected ID format (%q), expected vdcID/edgeID/transitGatewayID", d.Id())
		return flex.TerraformErrorf(err, err.Error(), "ibm_vmaas_transit_gateway_connection", "read").GetDiag()
	}
	vdcID := parts[0]
	edgeID := parts[1]
	tgwID := parts[2]

	vmwareClient, err := meta.(conns.ClientSession).VmwareV1()
	if err != nil {
		return diag.FromErr(err)
	}

	getVdcOptions := &vmwarev1.GetVdcOptions{}
	getVdcOptions.SetID(vdcID)

	vdc, _, err := vmwareClient.GetVdcWithContext(context, getVdcOptions)

	if err != nil {
		return diag.FromErr(err)
	}

	var foundEdge *vmwarev1.Edge
	for _, edge := range vdc.Edges {
		if *edge.ID == edgeID {
			foundEdge = &edge
			break
		}
	}
	if foundEdge == nil {
		return diag.Errorf("Edge %q not found in VDC %q", edgeID, vdcID)
	}

	var foundTGW *vmwarev1.TransitGateway
	for _, conn := range foundEdge.TransitGateways {
		if *conn.ID == tgwID {
			foundTGW = &conn
			break
		}
	}
	if foundTGW == nil {
		return diag.Errorf("Transit Gateway %q not found in edge %q", tgwID, edgeID)
	}

	d.Set("vdc_id", vdcID)
	d.Set("edge_id", edgeID)
	d.Set("vmaas_transit_gateway_connection_id", tgwID)
	d.Set("connections", flattenTransitGatewayConnections(foundTGW.Connections))
	d.Set("region", foundTGW.Region)

	return nil
}

func resourceIbmVmaasTransitGatewayConnectionUpdate(context context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	vmwareClient, err := meta.(conns.ClientSession).VmwareV1()
	if err != nil {
		tfErr := flex.DiscriminatedTerraformErrorf(err, err.Error(), "ibm_vmaas_transit_gateway_connection", "update", "initialize-client")
		log.Printf("[DEBUG]\n%s", tfErr.GetDebugMessage())
		return tfErr.GetDiag()
	}

	swapHaEdgeSitesOptions := &vmwarev1.SwapHaEdgeSitesOptions{}

	parts, err := flex.SepIdParts(d.Id(), "/")
	if err != nil {
		return flex.DiscriminatedTerraformErrorf(err, err.Error(), "ibm_vmaas_transit_gateway_connection", "update", "sep-id-parts").GetDiag()
	}

	swapHaEdgeSitesOptions.SetVdcID(parts[0])
	swapHaEdgeSitesOptions.SetEdgeID(parts[1])

	_, _, err = vmwareClient.SwapHaEdgeSitesWithContext(context, swapHaEdgeSitesOptions)
	if err != nil {
		tfErr := flex.TerraformErrorf(err, fmt.Sprintf("SwapHaEdgeSitesWithContext failed: %s", err.Error()), "ibm_vmaas_transit_gateway_connection", "update")
		log.Printf("[DEBUG]\n%s", tfErr.GetDebugMessage())
		return tfErr.GetDiag()
	}

	return resourceIbmVmaasTransitGatewayConnectionRead(context, d, meta)
}

func resourceIbmVmaasTransitGatewayConnectionDelete(context context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	vmwareClient, err := meta.(conns.ClientSession).VmwareV1()
	if err != nil {
		tfErr := flex.DiscriminatedTerraformErrorf(err, err.Error(), "ibm_vmaas_transit_gateway_connection", "delete", "initialize-client")
		log.Printf("[DEBUG]\n%s", tfErr.GetDebugMessage())
		return tfErr.GetDiag()
	}

	removeTransitGatewayConnectionsOptions := &vmwarev1.RemoveTransitGatewayConnectionsOptions{}

	parts, err := flex.SepIdParts(d.Id(), "/")
	if err != nil {
		return flex.DiscriminatedTerraformErrorf(err, err.Error(), "ibm_vmaas_transit_gateway_connection", "delete", "sep-id-parts").GetDiag()
	}
	removeTransitGatewayConnectionsOptions.SetVdcID(parts[0])
	removeTransitGatewayConnectionsOptions.SetEdgeID(parts[1])
	removeTransitGatewayConnectionsOptions.SetID(parts[2])

	_, _, err = vmwareClient.RemoveTransitGatewayConnectionsWithContext(context, removeTransitGatewayConnectionsOptions)

	if err != nil {
		tfErr := flex.TerraformErrorf(err, fmt.Sprintf("RemoveTransitGatewayConnectionsWithContext failed: %s", err.Error()), "ibm_vmaas_transit_gateway_connection", "delete")
		log.Printf("[DEBUG]\n%s", tfErr.GetDebugMessage())
		return tfErr.GetDiag()
	}
	fmt.Println("[INFO] Waiting for Transit Gateway connection " + *removeTransitGatewayConnectionsOptions.ID + " to be deleted...")

	err = waitForTransitGatewayConnectionDelete(context, *removeTransitGatewayConnectionsOptions.VdcID, *removeTransitGatewayConnectionsOptions.EdgeID, *removeTransitGatewayConnectionsOptions.ID, meta)

	if err != nil {
		tfErr := flex.TerraformErrorf(err, fmt.Sprintf("Timeout waiting for Transit Gateway connection %q to be deleted", *removeTransitGatewayConnectionsOptions.ID), "ibm_vmaas_transit_gateway_connection", "delete")
		log.Printf("[DEBUG]\n%s", tfErr.GetDebugMessage())
		return tfErr.GetDiag()
	}
	d.SetId("")

	return nil
}

func waitForTransitGatewayConnectionDelete(
	context context.Context,
	vdcID, edgeID, tgwID string,
	meta interface{},
) error {
	vmwareClient, err := meta.(conns.ClientSession).VmwareV1()
	if err != nil {
		return err
	}

	getVdcOptions := &vmwarev1.GetVdcOptions{}
	getVdcOptions.SetID(vdcID)

	stateConf := &resource.StateChangeConf{
		Pending: []string{"exists"},
		Target:  []string{"deleted"},
		Refresh: func() (interface{}, string, error) {
			vdc, _, err := vmwareClient.GetVdcWithContext(context, getVdcOptions)

			if err != nil {
				return nil, "", err
			}

			for _, edge := range vdc.Edges {
				if edge.ID != nil && *edge.ID == edgeID {
					for _, tgw := range edge.TransitGateways {
						if tgw.ID != nil && *tgw.ID == tgwID {
							fmt.Println("[INFO] Transit Gateway connection " + tgwID + " still exists.")
							return vdc, "exists", nil
						}
					}
					break
				}
			}

			fmt.Println("[INFO] Transit Gateway connection " + tgwID + " successfully deleted.")
			return vdc, "deleted", nil
		},
		Timeout:    40 * time.Minute,
		MinTimeout: 40 * time.Second,
		Delay:      40 * time.Second,
	}

	_, err = stateConf.WaitForStateContext(context)
	return err
}

func waitForTransitGatewayConnectionTunnelIp(
	context context.Context,
	vdcID, edgeID, tgwID string,
	meta interface{},
) (*vmwarev1.TransitGateway, error) {
	vmwareClient, err := meta.(conns.ClientSession).VmwareV1()
	if err != nil {
		return nil, err
	}

	getVdcOptions := &vmwarev1.GetVdcOptions{}
	getVdcOptions.SetID(vdcID)

	stateConf := &resource.StateChangeConf{
		Pending: []string{"not_ready"},
		Target:  []string{"ready"},
		Refresh: func() (interface{}, string, error) {
			vdc, response, err := vmwareClient.GetVdcWithContext(context, getVdcOptions)

			if err != nil {
				if response != nil && response.StatusCode == 404 {
					return nil, "", nil // Resource deleted
				}
				return nil, "", err
			}

			var foundEdge *vmwarev1.Edge
			for _, edge := range vdc.Edges {
				if *edge.ID == edgeID {
					foundEdge = &edge
					break
				}
			}
			if foundEdge == nil {
				return nil, "", fmt.Errorf("edge %q not found in VDC %q", edgeID, vdcID)
			}

			var foundTGW *vmwarev1.TransitGateway
			for _, conn := range foundEdge.TransitGateways {
				if *conn.ID == tgwID {
					foundTGW = &conn
					break
				}
			}
			if foundTGW == nil {
				return nil, "", fmt.Errorf("transit gateway %q not found in edge %q", tgwID, edgeID)
			}

			if len(foundTGW.Connections) == 0 || foundTGW.Connections[0].LocalTunnelIp == nil || *foundTGW.Connections[0].LocalTunnelIp == "" {
				fmt.Println("[INFO] Transit Gateway tunnel IP not assigned yet...")
				return foundTGW, "not_ready", nil
			}

			fmt.Println("[INFO] Transit Gateway tunnel IP assigned")
			return foundTGW, "ready", nil
		},
		Timeout:    10 * time.Minute,
		MinTimeout: 10 * time.Second,
		Delay:      10 * time.Second,
	}

	result, err := stateConf.WaitForStateContext(context)
	if err != nil {
		return nil, err
	}

	return result.(*vmwarev1.TransitGateway), nil
}

func flattenTransitGatewayConnections(connections []vmwarev1.TransitGatewayConnection) []interface{} {
	var result []interface{}

	for _, conn := range connections {
		connMap, err := ResourceIbmVmaasTransitGatewayConnectionTransitGatewayConnectionToMap(&conn)
		if err != nil {
			tfErr := flex.TerraformErrorf(err, fmt.Sprintf("flattenTransitGatewayConnections failed: %s", err.Error()), "ibm_vmaas_transit_gateway_connection", "read")
			log.Printf("[DEBUG]\n%s", tfErr.GetDebugMessage())
		}
		result = append(result, connMap)
	}
	return result
}

func ResourceIbmVmaasTransitGatewayConnectionTransitGatewayConnectionToMap(model *vmwarev1.TransitGatewayConnection) (map[string]interface{}, error) {
	modelMap := make(map[string]interface{})
	modelMap["name"] = *model.Name
	if model.TransitGatewayConnectionName != nil {
		modelMap["transit_gateway_connection_name"] = *model.TransitGatewayConnectionName
	}
	modelMap["status"] = *model.Status
	if model.LocalGatewayIp != nil {
		modelMap["local_gateway_ip"] = *model.LocalGatewayIp
	}
	if model.RemoteGatewayIp != nil {
		modelMap["remote_gateway_ip"] = *model.RemoteGatewayIp
	}
	if model.LocalTunnelIp != nil {
		modelMap["local_tunnel_ip"] = *model.LocalTunnelIp
	}
	if model.RemoteTunnelIp != nil {
		modelMap["remote_tunnel_ip"] = *model.RemoteTunnelIp
	}
	if model.LocalBgpAsn != nil {
		modelMap["local_bgp_asn"] = flex.IntValue(model.LocalBgpAsn)
	}
	if model.RemoteBgpAsn != nil {
		modelMap["remote_bgp_asn"] = flex.IntValue(model.RemoteBgpAsn)
	}
	modelMap["network_account_id"] = *model.NetworkAccountID
	modelMap["network_type"] = *model.NetworkType
	modelMap["base_network_type"] = *model.BaseNetworkType
	modelMap["zone"] = *model.Zone
	return modelMap, nil
}
