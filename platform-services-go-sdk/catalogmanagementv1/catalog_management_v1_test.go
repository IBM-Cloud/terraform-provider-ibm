/**
 * (C) Copyright IBM Corp. 2025.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package catalogmanagementv1_test

import (
	"bytes"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/http/httptest"
	"os"
	"time"

	"github.com/IBM/go-sdk-core/v5/core"
	"github.com/IBM/platform-services-go-sdk/catalogmanagementv1"
	"github.com/go-openapi/strfmt"
	. "github.com/onsi/ginkgo"
	. "github.com/onsi/gomega"
)

var _ = Describe(`CatalogManagementV1`, func() {
	var testServer *httptest.Server
	Describe(`Service constructor tests`, func() {
		It(`Instantiate service client`, func() {
			catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
				Authenticator: &core.NoAuthAuthenticator{},
			})
			Expect(catalogManagementService).ToNot(BeNil())
			Expect(serviceErr).To(BeNil())
		})
		It(`Instantiate service client with error: Invalid URL`, func() {
			catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
				URL: "{BAD_URL_STRING",
			})
			Expect(catalogManagementService).To(BeNil())
			Expect(serviceErr).ToNot(BeNil())
		})
		It(`Instantiate service client with error: Invalid Auth`, func() {
			catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
				URL: "https://catalogmanagementv1/api",
				Authenticator: &core.BasicAuthenticator{
					Username: "",
					Password: "",
				},
			})
			Expect(catalogManagementService).To(BeNil())
			Expect(serviceErr).ToNot(BeNil())
		})
	})
	Describe(`Service constructor tests using external config`, func() {
		Context(`Using external config, construct service client instances`, func() {
			// Map containing environment variables used in testing.
			var testEnvironment = map[string]string{
				"CATALOG_MANAGEMENT_URL":       "https://catalogmanagementv1/api",
				"CATALOG_MANAGEMENT_AUTH_TYPE": "noauth",
			}

			It(`Create service client using external config successfully`, func() {
				SetTestEnvironment(testEnvironment)
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1UsingExternalConfig(&catalogmanagementv1.CatalogManagementV1Options{})
				Expect(catalogManagementService).ToNot(BeNil())
				Expect(serviceErr).To(BeNil())
				ClearTestEnvironment(testEnvironment)

				clone := catalogManagementService.Clone()
				Expect(clone).ToNot(BeNil())
				Expect(clone.Service != catalogManagementService.Service).To(BeTrue())
				Expect(clone.GetServiceURL()).To(Equal(catalogManagementService.GetServiceURL()))
				Expect(clone.Service.Options.Authenticator).To(Equal(catalogManagementService.Service.Options.Authenticator))
			})
			It(`Create service client using external config and set url from constructor successfully`, func() {
				SetTestEnvironment(testEnvironment)
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1UsingExternalConfig(&catalogmanagementv1.CatalogManagementV1Options{
					URL: "https://testService/api",
				})
				Expect(catalogManagementService).ToNot(BeNil())
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService.Service.GetServiceURL()).To(Equal("https://testService/api"))
				ClearTestEnvironment(testEnvironment)

				clone := catalogManagementService.Clone()
				Expect(clone).ToNot(BeNil())
				Expect(clone.Service != catalogManagementService.Service).To(BeTrue())
				Expect(clone.GetServiceURL()).To(Equal(catalogManagementService.GetServiceURL()))
				Expect(clone.Service.Options.Authenticator).To(Equal(catalogManagementService.Service.Options.Authenticator))
			})
			It(`Create service client using external config and set url programatically successfully`, func() {
				SetTestEnvironment(testEnvironment)
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1UsingExternalConfig(&catalogmanagementv1.CatalogManagementV1Options{})
				err := catalogManagementService.SetServiceURL("https://testService/api")
				Expect(err).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService.Service.GetServiceURL()).To(Equal("https://testService/api"))
				ClearTestEnvironment(testEnvironment)

				clone := catalogManagementService.Clone()
				Expect(clone).ToNot(BeNil())
				Expect(clone.Service != catalogManagementService.Service).To(BeTrue())
				Expect(clone.GetServiceURL()).To(Equal(catalogManagementService.GetServiceURL()))
				Expect(clone.Service.Options.Authenticator).To(Equal(catalogManagementService.Service.Options.Authenticator))
			})
		})
		Context(`Using external config, construct service client instances with error: Invalid Auth`, func() {
			// Map containing environment variables used in testing.
			var testEnvironment = map[string]string{
				"CATALOG_MANAGEMENT_URL":       "https://catalogmanagementv1/api",
				"CATALOG_MANAGEMENT_AUTH_TYPE": "someOtherAuth",
			}

			SetTestEnvironment(testEnvironment)
			catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1UsingExternalConfig(&catalogmanagementv1.CatalogManagementV1Options{})

			It(`Instantiate service client with error`, func() {
				Expect(catalogManagementService).To(BeNil())
				Expect(serviceErr).ToNot(BeNil())
				ClearTestEnvironment(testEnvironment)
			})
		})
		Context(`Using external config, construct service client instances with error: Invalid URL`, func() {
			// Map containing environment variables used in testing.
			var testEnvironment = map[string]string{
				"CATALOG_MANAGEMENT_AUTH_TYPE": "NOAuth",
			}

			SetTestEnvironment(testEnvironment)
			catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1UsingExternalConfig(&catalogmanagementv1.CatalogManagementV1Options{
				URL: "{BAD_URL_STRING",
			})

			It(`Instantiate service client with error`, func() {
				Expect(catalogManagementService).To(BeNil())
				Expect(serviceErr).ToNot(BeNil())
				ClearTestEnvironment(testEnvironment)
			})
		})
	})
	Describe(`Regional endpoint tests`, func() {
		It(`GetServiceURLForRegion(region string)`, func() {
			var url string
			var err error
			url, err = catalogmanagementv1.GetServiceURLForRegion("INVALID_REGION")
			Expect(url).To(BeEmpty())
			Expect(err).ToNot(BeNil())
			fmt.Fprintf(GinkgoWriter, "Expected error: %s\n", err.Error())
		})
	})
	Describe(`GetCatalogAccount(getCatalogAccountOptions *GetCatalogAccountOptions) - Operation response error`, func() {
		getCatalogAccountPath := "/catalogaccount"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getCatalogAccountPath))
					Expect(req.Method).To(Equal("GET"))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetCatalogAccount with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetCatalogAccountOptions model
				getCatalogAccountOptionsModel := new(catalogmanagementv1.GetCatalogAccountOptions)
				getCatalogAccountOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.GetCatalogAccount(getCatalogAccountOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.GetCatalogAccount(getCatalogAccountOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetCatalogAccount(getCatalogAccountOptions *GetCatalogAccountOptions)`, func() {
		getCatalogAccountPath := "/catalogaccount"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getCatalogAccountPath))
					Expect(req.Method).To(Equal("GET"))

					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "hide_IBM_cloud_catalog": false, "account_filters": {"include_all": true, "category_filters": {"mapKey": {"include": false, "filter": {"filter_terms": ["FilterTerms"]}}}, "id_filters": {"include": {"filter_terms": ["FilterTerms"]}, "exclude": {"filter_terms": ["FilterTerms"]}}}, "region_filter": "RegionFilter"}`)
				}))
			})
			It(`Invoke GetCatalogAccount successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the GetCatalogAccountOptions model
				getCatalogAccountOptionsModel := new(catalogmanagementv1.GetCatalogAccountOptions)
				getCatalogAccountOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.GetCatalogAccountWithContext(ctx, getCatalogAccountOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.GetCatalogAccount(getCatalogAccountOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.GetCatalogAccountWithContext(ctx, getCatalogAccountOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getCatalogAccountPath))
					Expect(req.Method).To(Equal("GET"))

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "hide_IBM_cloud_catalog": false, "account_filters": {"include_all": true, "category_filters": {"mapKey": {"include": false, "filter": {"filter_terms": ["FilterTerms"]}}}, "id_filters": {"include": {"filter_terms": ["FilterTerms"]}, "exclude": {"filter_terms": ["FilterTerms"]}}}, "region_filter": "RegionFilter"}`)
				}))
			})
			It(`Invoke GetCatalogAccount successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.GetCatalogAccount(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetCatalogAccountOptions model
				getCatalogAccountOptionsModel := new(catalogmanagementv1.GetCatalogAccountOptions)
				getCatalogAccountOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.GetCatalogAccount(getCatalogAccountOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetCatalogAccount with error: Operation request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetCatalogAccountOptions model
				getCatalogAccountOptionsModel := new(catalogmanagementv1.GetCatalogAccountOptions)
				getCatalogAccountOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.GetCatalogAccount(getCatalogAccountOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetCatalogAccount successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetCatalogAccountOptions model
				getCatalogAccountOptionsModel := new(catalogmanagementv1.GetCatalogAccountOptions)
				getCatalogAccountOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.GetCatalogAccount(getCatalogAccountOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`UpdateCatalogAccount(updateCatalogAccountOptions *UpdateCatalogAccountOptions) - Operation response error`, func() {
		updateCatalogAccountPath := "/catalogaccount"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updateCatalogAccountPath))
					Expect(req.Method).To(Equal("PUT"))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke UpdateCatalogAccount with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the FilterTerms model
				filterTermsModel := new(catalogmanagementv1.FilterTerms)
				filterTermsModel.FilterTerms = []string{"testString"}

				// Construct an instance of the CategoryFilter model
				categoryFilterModel := new(catalogmanagementv1.CategoryFilter)
				categoryFilterModel.Include = core.BoolPtr(true)
				categoryFilterModel.Filter = filterTermsModel

				// Construct an instance of the IDFilter model
				idFilterModel := new(catalogmanagementv1.IDFilter)
				idFilterModel.Include = filterTermsModel
				idFilterModel.Exclude = filterTermsModel

				// Construct an instance of the Filters model
				filtersModel := new(catalogmanagementv1.Filters)
				filtersModel.IncludeAll = core.BoolPtr(true)
				filtersModel.CategoryFilters = map[string]catalogmanagementv1.CategoryFilter{"key1": *categoryFilterModel}
				filtersModel.IDFilters = idFilterModel
				filtersModel.CategoryFilters["foo"] = *categoryFilterModel

				// Construct an instance of the UpdateCatalogAccountOptions model
				updateCatalogAccountOptionsModel := new(catalogmanagementv1.UpdateCatalogAccountOptions)
				updateCatalogAccountOptionsModel.ID = core.StringPtr("testString")
				updateCatalogAccountOptionsModel.Rev = core.StringPtr("testString")
				updateCatalogAccountOptionsModel.HideIBMCloudCatalog = core.BoolPtr(true)
				updateCatalogAccountOptionsModel.AccountFilters = filtersModel
				updateCatalogAccountOptionsModel.RegionFilter = core.StringPtr("testString")
				updateCatalogAccountOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.UpdateCatalogAccount(updateCatalogAccountOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.UpdateCatalogAccount(updateCatalogAccountOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`UpdateCatalogAccount(updateCatalogAccountOptions *UpdateCatalogAccountOptions)`, func() {
		updateCatalogAccountPath := "/catalogaccount"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updateCatalogAccountPath))
					Expect(req.Method).To(Equal("PUT"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "hide_IBM_cloud_catalog": false, "account_filters": {"include_all": true, "category_filters": {"mapKey": {"include": false, "filter": {"filter_terms": ["FilterTerms"]}}}, "id_filters": {"include": {"filter_terms": ["FilterTerms"]}, "exclude": {"filter_terms": ["FilterTerms"]}}}, "region_filter": "RegionFilter"}`)
				}))
			})
			It(`Invoke UpdateCatalogAccount successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the FilterTerms model
				filterTermsModel := new(catalogmanagementv1.FilterTerms)
				filterTermsModel.FilterTerms = []string{"testString"}

				// Construct an instance of the CategoryFilter model
				categoryFilterModel := new(catalogmanagementv1.CategoryFilter)
				categoryFilterModel.Include = core.BoolPtr(true)
				categoryFilterModel.Filter = filterTermsModel

				// Construct an instance of the IDFilter model
				idFilterModel := new(catalogmanagementv1.IDFilter)
				idFilterModel.Include = filterTermsModel
				idFilterModel.Exclude = filterTermsModel

				// Construct an instance of the Filters model
				filtersModel := new(catalogmanagementv1.Filters)
				filtersModel.IncludeAll = core.BoolPtr(true)
				filtersModel.CategoryFilters = map[string]catalogmanagementv1.CategoryFilter{"key1": *categoryFilterModel}
				filtersModel.IDFilters = idFilterModel
				filtersModel.CategoryFilters["foo"] = *categoryFilterModel

				// Construct an instance of the UpdateCatalogAccountOptions model
				updateCatalogAccountOptionsModel := new(catalogmanagementv1.UpdateCatalogAccountOptions)
				updateCatalogAccountOptionsModel.ID = core.StringPtr("testString")
				updateCatalogAccountOptionsModel.Rev = core.StringPtr("testString")
				updateCatalogAccountOptionsModel.HideIBMCloudCatalog = core.BoolPtr(true)
				updateCatalogAccountOptionsModel.AccountFilters = filtersModel
				updateCatalogAccountOptionsModel.RegionFilter = core.StringPtr("testString")
				updateCatalogAccountOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.UpdateCatalogAccountWithContext(ctx, updateCatalogAccountOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.UpdateCatalogAccount(updateCatalogAccountOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.UpdateCatalogAccountWithContext(ctx, updateCatalogAccountOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updateCatalogAccountPath))
					Expect(req.Method).To(Equal("PUT"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "hide_IBM_cloud_catalog": false, "account_filters": {"include_all": true, "category_filters": {"mapKey": {"include": false, "filter": {"filter_terms": ["FilterTerms"]}}}, "id_filters": {"include": {"filter_terms": ["FilterTerms"]}, "exclude": {"filter_terms": ["FilterTerms"]}}}, "region_filter": "RegionFilter"}`)
				}))
			})
			It(`Invoke UpdateCatalogAccount successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.UpdateCatalogAccount(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the FilterTerms model
				filterTermsModel := new(catalogmanagementv1.FilterTerms)
				filterTermsModel.FilterTerms = []string{"testString"}

				// Construct an instance of the CategoryFilter model
				categoryFilterModel := new(catalogmanagementv1.CategoryFilter)
				categoryFilterModel.Include = core.BoolPtr(true)
				categoryFilterModel.Filter = filterTermsModel

				// Construct an instance of the IDFilter model
				idFilterModel := new(catalogmanagementv1.IDFilter)
				idFilterModel.Include = filterTermsModel
				idFilterModel.Exclude = filterTermsModel

				// Construct an instance of the Filters model
				filtersModel := new(catalogmanagementv1.Filters)
				filtersModel.IncludeAll = core.BoolPtr(true)
				filtersModel.CategoryFilters = map[string]catalogmanagementv1.CategoryFilter{"key1": *categoryFilterModel}
				filtersModel.IDFilters = idFilterModel
				filtersModel.CategoryFilters["foo"] = *categoryFilterModel

				// Construct an instance of the UpdateCatalogAccountOptions model
				updateCatalogAccountOptionsModel := new(catalogmanagementv1.UpdateCatalogAccountOptions)
				updateCatalogAccountOptionsModel.ID = core.StringPtr("testString")
				updateCatalogAccountOptionsModel.Rev = core.StringPtr("testString")
				updateCatalogAccountOptionsModel.HideIBMCloudCatalog = core.BoolPtr(true)
				updateCatalogAccountOptionsModel.AccountFilters = filtersModel
				updateCatalogAccountOptionsModel.RegionFilter = core.StringPtr("testString")
				updateCatalogAccountOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.UpdateCatalogAccount(updateCatalogAccountOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke UpdateCatalogAccount with error: Operation request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the FilterTerms model
				filterTermsModel := new(catalogmanagementv1.FilterTerms)
				filterTermsModel.FilterTerms = []string{"testString"}

				// Construct an instance of the CategoryFilter model
				categoryFilterModel := new(catalogmanagementv1.CategoryFilter)
				categoryFilterModel.Include = core.BoolPtr(true)
				categoryFilterModel.Filter = filterTermsModel

				// Construct an instance of the IDFilter model
				idFilterModel := new(catalogmanagementv1.IDFilter)
				idFilterModel.Include = filterTermsModel
				idFilterModel.Exclude = filterTermsModel

				// Construct an instance of the Filters model
				filtersModel := new(catalogmanagementv1.Filters)
				filtersModel.IncludeAll = core.BoolPtr(true)
				filtersModel.CategoryFilters = map[string]catalogmanagementv1.CategoryFilter{"key1": *categoryFilterModel}
				filtersModel.IDFilters = idFilterModel
				filtersModel.CategoryFilters["foo"] = *categoryFilterModel

				// Construct an instance of the UpdateCatalogAccountOptions model
				updateCatalogAccountOptionsModel := new(catalogmanagementv1.UpdateCatalogAccountOptions)
				updateCatalogAccountOptionsModel.ID = core.StringPtr("testString")
				updateCatalogAccountOptionsModel.Rev = core.StringPtr("testString")
				updateCatalogAccountOptionsModel.HideIBMCloudCatalog = core.BoolPtr(true)
				updateCatalogAccountOptionsModel.AccountFilters = filtersModel
				updateCatalogAccountOptionsModel.RegionFilter = core.StringPtr("testString")
				updateCatalogAccountOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.UpdateCatalogAccount(updateCatalogAccountOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke UpdateCatalogAccount successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the FilterTerms model
				filterTermsModel := new(catalogmanagementv1.FilterTerms)
				filterTermsModel.FilterTerms = []string{"testString"}

				// Construct an instance of the CategoryFilter model
				categoryFilterModel := new(catalogmanagementv1.CategoryFilter)
				categoryFilterModel.Include = core.BoolPtr(true)
				categoryFilterModel.Filter = filterTermsModel

				// Construct an instance of the IDFilter model
				idFilterModel := new(catalogmanagementv1.IDFilter)
				idFilterModel.Include = filterTermsModel
				idFilterModel.Exclude = filterTermsModel

				// Construct an instance of the Filters model
				filtersModel := new(catalogmanagementv1.Filters)
				filtersModel.IncludeAll = core.BoolPtr(true)
				filtersModel.CategoryFilters = map[string]catalogmanagementv1.CategoryFilter{"key1": *categoryFilterModel}
				filtersModel.IDFilters = idFilterModel
				filtersModel.CategoryFilters["foo"] = *categoryFilterModel

				// Construct an instance of the UpdateCatalogAccountOptions model
				updateCatalogAccountOptionsModel := new(catalogmanagementv1.UpdateCatalogAccountOptions)
				updateCatalogAccountOptionsModel.ID = core.StringPtr("testString")
				updateCatalogAccountOptionsModel.Rev = core.StringPtr("testString")
				updateCatalogAccountOptionsModel.HideIBMCloudCatalog = core.BoolPtr(true)
				updateCatalogAccountOptionsModel.AccountFilters = filtersModel
				updateCatalogAccountOptionsModel.RegionFilter = core.StringPtr("testString")
				updateCatalogAccountOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.UpdateCatalogAccount(updateCatalogAccountOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListCatalogAccountAudits(listCatalogAccountAuditsOptions *ListCatalogAccountAuditsOptions) - Operation response error`, func() {
		listCatalogAccountAuditsPath := "/catalogaccount/audits"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listCatalogAccountAuditsPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.URL.Query()["start"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(10))}))
					// TODO: Add check for lookupnames query parameter
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ListCatalogAccountAudits with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ListCatalogAccountAuditsOptions model
				listCatalogAccountAuditsOptionsModel := new(catalogmanagementv1.ListCatalogAccountAuditsOptions)
				listCatalogAccountAuditsOptionsModel.Start = core.StringPtr("testString")
				listCatalogAccountAuditsOptionsModel.Limit = core.Int64Ptr(int64(10))
				listCatalogAccountAuditsOptionsModel.Lookupnames = core.BoolPtr(true)
				listCatalogAccountAuditsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.ListCatalogAccountAudits(listCatalogAccountAuditsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.ListCatalogAccountAudits(listCatalogAccountAuditsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListCatalogAccountAudits(listCatalogAccountAuditsOptions *ListCatalogAccountAuditsOptions)`, func() {
		listCatalogAccountAuditsPath := "/catalogaccount/audits"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listCatalogAccountAuditsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.URL.Query()["start"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(10))}))
					// TODO: Add check for lookupnames query parameter
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"start": "Start", "limit": 5, "total_count": 10, "resource_count": 13, "first": {"href": "Href", "start": "Start"}, "next": {"href": "Href", "start": "Start"}, "prev": {"href": "Href", "start": "Start"}, "last": {"href": "Href", "start": "Start"}, "audits": [{"id": "ID", "_rev": "Rev", "created": "2019-01-01T12:00:00.000Z", "change_type": "ChangeType", "target_type": "TargetType", "target_id": "TargetID", "who_email": "WhoEmail", "who_delegate_email": "WhoDelegateEmail", "message": "Message"}]}`)
				}))
			})
			It(`Invoke ListCatalogAccountAudits successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the ListCatalogAccountAuditsOptions model
				listCatalogAccountAuditsOptionsModel := new(catalogmanagementv1.ListCatalogAccountAuditsOptions)
				listCatalogAccountAuditsOptionsModel.Start = core.StringPtr("testString")
				listCatalogAccountAuditsOptionsModel.Limit = core.Int64Ptr(int64(10))
				listCatalogAccountAuditsOptionsModel.Lookupnames = core.BoolPtr(true)
				listCatalogAccountAuditsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.ListCatalogAccountAuditsWithContext(ctx, listCatalogAccountAuditsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.ListCatalogAccountAudits(listCatalogAccountAuditsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.ListCatalogAccountAuditsWithContext(ctx, listCatalogAccountAuditsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listCatalogAccountAuditsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.URL.Query()["start"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(10))}))
					// TODO: Add check for lookupnames query parameter
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"start": "Start", "limit": 5, "total_count": 10, "resource_count": 13, "first": {"href": "Href", "start": "Start"}, "next": {"href": "Href", "start": "Start"}, "prev": {"href": "Href", "start": "Start"}, "last": {"href": "Href", "start": "Start"}, "audits": [{"id": "ID", "_rev": "Rev", "created": "2019-01-01T12:00:00.000Z", "change_type": "ChangeType", "target_type": "TargetType", "target_id": "TargetID", "who_email": "WhoEmail", "who_delegate_email": "WhoDelegateEmail", "message": "Message"}]}`)
				}))
			})
			It(`Invoke ListCatalogAccountAudits successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.ListCatalogAccountAudits(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ListCatalogAccountAuditsOptions model
				listCatalogAccountAuditsOptionsModel := new(catalogmanagementv1.ListCatalogAccountAuditsOptions)
				listCatalogAccountAuditsOptionsModel.Start = core.StringPtr("testString")
				listCatalogAccountAuditsOptionsModel.Limit = core.Int64Ptr(int64(10))
				listCatalogAccountAuditsOptionsModel.Lookupnames = core.BoolPtr(true)
				listCatalogAccountAuditsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.ListCatalogAccountAudits(listCatalogAccountAuditsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ListCatalogAccountAudits with error: Operation request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ListCatalogAccountAuditsOptions model
				listCatalogAccountAuditsOptionsModel := new(catalogmanagementv1.ListCatalogAccountAuditsOptions)
				listCatalogAccountAuditsOptionsModel.Start = core.StringPtr("testString")
				listCatalogAccountAuditsOptionsModel.Limit = core.Int64Ptr(int64(10))
				listCatalogAccountAuditsOptionsModel.Lookupnames = core.BoolPtr(true)
				listCatalogAccountAuditsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.ListCatalogAccountAudits(listCatalogAccountAuditsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ListCatalogAccountAudits successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ListCatalogAccountAuditsOptions model
				listCatalogAccountAuditsOptionsModel := new(catalogmanagementv1.ListCatalogAccountAuditsOptions)
				listCatalogAccountAuditsOptionsModel.Start = core.StringPtr("testString")
				listCatalogAccountAuditsOptionsModel.Limit = core.Int64Ptr(int64(10))
				listCatalogAccountAuditsOptionsModel.Lookupnames = core.BoolPtr(true)
				listCatalogAccountAuditsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.ListCatalogAccountAudits(listCatalogAccountAuditsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Test pagination helper method on response`, func() {
			It(`Invoke GetNextStart successfully`, func() {
				responseObject := new(catalogmanagementv1.AuditLogs)
				nextObject := new(catalogmanagementv1.PaginationTokenLink)
				nextObject.Start = core.StringPtr("abc-123")
				responseObject.Next = nextObject

				value, err := responseObject.GetNextStart()
				Expect(err).To(BeNil())
				Expect(value).To(Equal(core.StringPtr("abc-123")))
			})
			It(`Invoke GetNextStart without a "Next" property in the response`, func() {
				responseObject := new(catalogmanagementv1.AuditLogs)

				value, err := responseObject.GetNextStart()
				Expect(err).To(BeNil())
				Expect(value).To(BeNil())
			})
		})
		Context(`Using mock server endpoint - paginated response`, func() {
			BeforeEach(func() {
				var requestNumber int = 0
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listCatalogAccountAuditsPath))
					Expect(req.Method).To(Equal("GET"))

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					requestNumber++
					if requestNumber == 1 {
						fmt.Fprintf(res, "%s", `{"next":{"start":"1"},"total_count":2,"limit":1,"audits":[{"id":"ID","_rev":"Rev","created":"2019-01-01T12:00:00.000Z","change_type":"ChangeType","target_type":"TargetType","target_id":"TargetID","who_email":"WhoEmail","who_delegate_email":"WhoDelegateEmail","message":"Message"}]}`)
					} else if requestNumber == 2 {
						fmt.Fprintf(res, "%s", `{"total_count":2,"limit":1,"audits":[{"id":"ID","_rev":"Rev","created":"2019-01-01T12:00:00.000Z","change_type":"ChangeType","target_type":"TargetType","target_id":"TargetID","who_email":"WhoEmail","who_delegate_email":"WhoDelegateEmail","message":"Message"}]}`)
					} else {
						res.WriteHeader(400)
					}
				}))
			})
			It(`Use CatalogAccountAuditsPager.GetNext successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				listCatalogAccountAuditsOptionsModel := &catalogmanagementv1.ListCatalogAccountAuditsOptions{
					Limit:       core.Int64Ptr(int64(10)),
					Lookupnames: core.BoolPtr(true),
				}

				pager, err := catalogManagementService.NewCatalogAccountAuditsPager(listCatalogAccountAuditsOptionsModel)
				Expect(err).To(BeNil())
				Expect(pager).ToNot(BeNil())

				var allResults []catalogmanagementv1.AuditLogDigest
				for pager.HasNext() {
					nextPage, err := pager.GetNext()
					Expect(err).To(BeNil())
					Expect(nextPage).ToNot(BeNil())
					allResults = append(allResults, nextPage...)
				}
				Expect(len(allResults)).To(Equal(2))
			})
			It(`Use CatalogAccountAuditsPager.GetAll successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				listCatalogAccountAuditsOptionsModel := &catalogmanagementv1.ListCatalogAccountAuditsOptions{
					Limit:       core.Int64Ptr(int64(10)),
					Lookupnames: core.BoolPtr(true),
				}

				pager, err := catalogManagementService.NewCatalogAccountAuditsPager(listCatalogAccountAuditsOptionsModel)
				Expect(err).To(BeNil())
				Expect(pager).ToNot(BeNil())

				allResults, err := pager.GetAll()
				Expect(err).To(BeNil())
				Expect(allResults).ToNot(BeNil())
				Expect(len(allResults)).To(Equal(2))
			})
		})
	})
	Describe(`GetCatalogAccountAudit(getCatalogAccountAuditOptions *GetCatalogAccountAuditOptions) - Operation response error`, func() {
		getCatalogAccountAuditPath := "/catalogaccount/audits/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getCatalogAccountAuditPath))
					Expect(req.Method).To(Equal("GET"))
					// TODO: Add check for lookupnames query parameter
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetCatalogAccountAudit with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetCatalogAccountAuditOptions model
				getCatalogAccountAuditOptionsModel := new(catalogmanagementv1.GetCatalogAccountAuditOptions)
				getCatalogAccountAuditOptionsModel.AuditlogIdentifier = core.StringPtr("testString")
				getCatalogAccountAuditOptionsModel.Lookupnames = core.BoolPtr(true)
				getCatalogAccountAuditOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.GetCatalogAccountAudit(getCatalogAccountAuditOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.GetCatalogAccountAudit(getCatalogAccountAuditOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetCatalogAccountAudit(getCatalogAccountAuditOptions *GetCatalogAccountAuditOptions)`, func() {
		getCatalogAccountAuditPath := "/catalogaccount/audits/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getCatalogAccountAuditPath))
					Expect(req.Method).To(Equal("GET"))

					// TODO: Add check for lookupnames query parameter
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "created": "2019-01-01T12:00:00.000Z", "change_type": "ChangeType", "target_type": "TargetType", "target_id": "TargetID", "who_email": "WhoEmail", "who_delegate_email": "WhoDelegateEmail", "message": "Message", "gid": "Gid", "who_id": "WhoID", "who_name": "WhoName", "who_delegate_id": "WhoDelegateID", "who_delegate_name": "WhoDelegateName", "data": "anyValue"}`)
				}))
			})
			It(`Invoke GetCatalogAccountAudit successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the GetCatalogAccountAuditOptions model
				getCatalogAccountAuditOptionsModel := new(catalogmanagementv1.GetCatalogAccountAuditOptions)
				getCatalogAccountAuditOptionsModel.AuditlogIdentifier = core.StringPtr("testString")
				getCatalogAccountAuditOptionsModel.Lookupnames = core.BoolPtr(true)
				getCatalogAccountAuditOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.GetCatalogAccountAuditWithContext(ctx, getCatalogAccountAuditOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.GetCatalogAccountAudit(getCatalogAccountAuditOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.GetCatalogAccountAuditWithContext(ctx, getCatalogAccountAuditOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getCatalogAccountAuditPath))
					Expect(req.Method).To(Equal("GET"))

					// TODO: Add check for lookupnames query parameter
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "created": "2019-01-01T12:00:00.000Z", "change_type": "ChangeType", "target_type": "TargetType", "target_id": "TargetID", "who_email": "WhoEmail", "who_delegate_email": "WhoDelegateEmail", "message": "Message", "gid": "Gid", "who_id": "WhoID", "who_name": "WhoName", "who_delegate_id": "WhoDelegateID", "who_delegate_name": "WhoDelegateName", "data": "anyValue"}`)
				}))
			})
			It(`Invoke GetCatalogAccountAudit successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.GetCatalogAccountAudit(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetCatalogAccountAuditOptions model
				getCatalogAccountAuditOptionsModel := new(catalogmanagementv1.GetCatalogAccountAuditOptions)
				getCatalogAccountAuditOptionsModel.AuditlogIdentifier = core.StringPtr("testString")
				getCatalogAccountAuditOptionsModel.Lookupnames = core.BoolPtr(true)
				getCatalogAccountAuditOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.GetCatalogAccountAudit(getCatalogAccountAuditOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetCatalogAccountAudit with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetCatalogAccountAuditOptions model
				getCatalogAccountAuditOptionsModel := new(catalogmanagementv1.GetCatalogAccountAuditOptions)
				getCatalogAccountAuditOptionsModel.AuditlogIdentifier = core.StringPtr("testString")
				getCatalogAccountAuditOptionsModel.Lookupnames = core.BoolPtr(true)
				getCatalogAccountAuditOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.GetCatalogAccountAudit(getCatalogAccountAuditOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetCatalogAccountAuditOptions model with no property values
				getCatalogAccountAuditOptionsModelNew := new(catalogmanagementv1.GetCatalogAccountAuditOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.GetCatalogAccountAudit(getCatalogAccountAuditOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetCatalogAccountAudit successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetCatalogAccountAuditOptions model
				getCatalogAccountAuditOptionsModel := new(catalogmanagementv1.GetCatalogAccountAuditOptions)
				getCatalogAccountAuditOptionsModel.AuditlogIdentifier = core.StringPtr("testString")
				getCatalogAccountAuditOptionsModel.Lookupnames = core.BoolPtr(true)
				getCatalogAccountAuditOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.GetCatalogAccountAudit(getCatalogAccountAuditOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetCatalogAccountFilters(getCatalogAccountFiltersOptions *GetCatalogAccountFiltersOptions) - Operation response error`, func() {
		getCatalogAccountFiltersPath := "/catalogaccount/filters"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getCatalogAccountFiltersPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.URL.Query()["catalog"]).To(Equal([]string{"testString"}))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetCatalogAccountFilters with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetCatalogAccountFiltersOptions model
				getCatalogAccountFiltersOptionsModel := new(catalogmanagementv1.GetCatalogAccountFiltersOptions)
				getCatalogAccountFiltersOptionsModel.Catalog = core.StringPtr("testString")
				getCatalogAccountFiltersOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.GetCatalogAccountFilters(getCatalogAccountFiltersOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.GetCatalogAccountFilters(getCatalogAccountFiltersOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetCatalogAccountFilters(getCatalogAccountFiltersOptions *GetCatalogAccountFiltersOptions)`, func() {
		getCatalogAccountFiltersPath := "/catalogaccount/filters"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getCatalogAccountFiltersPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.URL.Query()["catalog"]).To(Equal([]string{"testString"}))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"hide_IBM_cloud_catalog": false, "account_filters": [{"include_all": true, "category_filters": {"mapKey": {"include": false, "filter": {"filter_terms": ["FilterTerms"]}}}, "id_filters": {"include": {"filter_terms": ["FilterTerms"]}, "exclude": {"filter_terms": ["FilterTerms"]}}}], "catalog_filters": [{"catalog": {"id": "ID", "name": "Name"}, "filters": {"include_all": true, "category_filters": {"mapKey": {"include": false, "filter": {"filter_terms": ["FilterTerms"]}}}, "id_filters": {"include": {"filter_terms": ["FilterTerms"]}, "exclude": {"filter_terms": ["FilterTerms"]}}}}], "region_filters": ["RegionFilters"], "filtered_regions": ["FilteredRegions"], "filter_regions": false}`)
				}))
			})
			It(`Invoke GetCatalogAccountFilters successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the GetCatalogAccountFiltersOptions model
				getCatalogAccountFiltersOptionsModel := new(catalogmanagementv1.GetCatalogAccountFiltersOptions)
				getCatalogAccountFiltersOptionsModel.Catalog = core.StringPtr("testString")
				getCatalogAccountFiltersOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.GetCatalogAccountFiltersWithContext(ctx, getCatalogAccountFiltersOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.GetCatalogAccountFilters(getCatalogAccountFiltersOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.GetCatalogAccountFiltersWithContext(ctx, getCatalogAccountFiltersOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getCatalogAccountFiltersPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.URL.Query()["catalog"]).To(Equal([]string{"testString"}))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"hide_IBM_cloud_catalog": false, "account_filters": [{"include_all": true, "category_filters": {"mapKey": {"include": false, "filter": {"filter_terms": ["FilterTerms"]}}}, "id_filters": {"include": {"filter_terms": ["FilterTerms"]}, "exclude": {"filter_terms": ["FilterTerms"]}}}], "catalog_filters": [{"catalog": {"id": "ID", "name": "Name"}, "filters": {"include_all": true, "category_filters": {"mapKey": {"include": false, "filter": {"filter_terms": ["FilterTerms"]}}}, "id_filters": {"include": {"filter_terms": ["FilterTerms"]}, "exclude": {"filter_terms": ["FilterTerms"]}}}}], "region_filters": ["RegionFilters"], "filtered_regions": ["FilteredRegions"], "filter_regions": false}`)
				}))
			})
			It(`Invoke GetCatalogAccountFilters successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.GetCatalogAccountFilters(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetCatalogAccountFiltersOptions model
				getCatalogAccountFiltersOptionsModel := new(catalogmanagementv1.GetCatalogAccountFiltersOptions)
				getCatalogAccountFiltersOptionsModel.Catalog = core.StringPtr("testString")
				getCatalogAccountFiltersOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.GetCatalogAccountFilters(getCatalogAccountFiltersOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetCatalogAccountFilters with error: Operation request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetCatalogAccountFiltersOptions model
				getCatalogAccountFiltersOptionsModel := new(catalogmanagementv1.GetCatalogAccountFiltersOptions)
				getCatalogAccountFiltersOptionsModel.Catalog = core.StringPtr("testString")
				getCatalogAccountFiltersOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.GetCatalogAccountFilters(getCatalogAccountFiltersOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetCatalogAccountFilters successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetCatalogAccountFiltersOptions model
				getCatalogAccountFiltersOptionsModel := new(catalogmanagementv1.GetCatalogAccountFiltersOptions)
				getCatalogAccountFiltersOptionsModel.Catalog = core.StringPtr("testString")
				getCatalogAccountFiltersOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.GetCatalogAccountFilters(getCatalogAccountFiltersOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetShareApprovalList(getShareApprovalListOptions *GetShareApprovalListOptions) - Operation response error`, func() {
		getShareApprovalListPath := "/shareapproval/offering/access"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getShareApprovalListPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.URL.Query()["start"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(10))}))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetShareApprovalList with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetShareApprovalListOptions model
				getShareApprovalListOptionsModel := new(catalogmanagementv1.GetShareApprovalListOptions)
				getShareApprovalListOptionsModel.ObjectType = core.StringPtr("offering")
				getShareApprovalListOptionsModel.Start = core.StringPtr("testString")
				getShareApprovalListOptionsModel.Limit = core.Int64Ptr(int64(10))
				getShareApprovalListOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.GetShareApprovalList(getShareApprovalListOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.GetShareApprovalList(getShareApprovalListOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetShareApprovalList(getShareApprovalListOptions *GetShareApprovalListOptions)`, func() {
		getShareApprovalListPath := "/shareapproval/offering/access"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getShareApprovalListPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.URL.Query()["start"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(10))}))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"start": "Start", "limit": 5, "total_count": 10, "resource_count": 13, "first": {"href": "Href", "start": "Start"}, "next": {"href": "Href", "start": "Start"}, "prev": {"href": "Href", "start": "Start"}, "last": {"href": "Href", "start": "Start"}, "resources": [{"id": "ID", "account": "Account", "account_type": 11, "target_account": "TargetAccount", "target_kind": "TargetKind", "created": "2019-01-01T12:00:00.000Z", "approval_state": "ApprovalState"}]}`)
				}))
			})
			It(`Invoke GetShareApprovalList successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the GetShareApprovalListOptions model
				getShareApprovalListOptionsModel := new(catalogmanagementv1.GetShareApprovalListOptions)
				getShareApprovalListOptionsModel.ObjectType = core.StringPtr("offering")
				getShareApprovalListOptionsModel.Start = core.StringPtr("testString")
				getShareApprovalListOptionsModel.Limit = core.Int64Ptr(int64(10))
				getShareApprovalListOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.GetShareApprovalListWithContext(ctx, getShareApprovalListOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.GetShareApprovalList(getShareApprovalListOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.GetShareApprovalListWithContext(ctx, getShareApprovalListOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getShareApprovalListPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.URL.Query()["start"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(10))}))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"start": "Start", "limit": 5, "total_count": 10, "resource_count": 13, "first": {"href": "Href", "start": "Start"}, "next": {"href": "Href", "start": "Start"}, "prev": {"href": "Href", "start": "Start"}, "last": {"href": "Href", "start": "Start"}, "resources": [{"id": "ID", "account": "Account", "account_type": 11, "target_account": "TargetAccount", "target_kind": "TargetKind", "created": "2019-01-01T12:00:00.000Z", "approval_state": "ApprovalState"}]}`)
				}))
			})
			It(`Invoke GetShareApprovalList successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.GetShareApprovalList(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetShareApprovalListOptions model
				getShareApprovalListOptionsModel := new(catalogmanagementv1.GetShareApprovalListOptions)
				getShareApprovalListOptionsModel.ObjectType = core.StringPtr("offering")
				getShareApprovalListOptionsModel.Start = core.StringPtr("testString")
				getShareApprovalListOptionsModel.Limit = core.Int64Ptr(int64(10))
				getShareApprovalListOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.GetShareApprovalList(getShareApprovalListOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetShareApprovalList with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetShareApprovalListOptions model
				getShareApprovalListOptionsModel := new(catalogmanagementv1.GetShareApprovalListOptions)
				getShareApprovalListOptionsModel.ObjectType = core.StringPtr("offering")
				getShareApprovalListOptionsModel.Start = core.StringPtr("testString")
				getShareApprovalListOptionsModel.Limit = core.Int64Ptr(int64(10))
				getShareApprovalListOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.GetShareApprovalList(getShareApprovalListOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetShareApprovalListOptions model with no property values
				getShareApprovalListOptionsModelNew := new(catalogmanagementv1.GetShareApprovalListOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.GetShareApprovalList(getShareApprovalListOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetShareApprovalList successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetShareApprovalListOptions model
				getShareApprovalListOptionsModel := new(catalogmanagementv1.GetShareApprovalListOptions)
				getShareApprovalListOptionsModel.ObjectType = core.StringPtr("offering")
				getShareApprovalListOptionsModel.Start = core.StringPtr("testString")
				getShareApprovalListOptionsModel.Limit = core.Int64Ptr(int64(10))
				getShareApprovalListOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.GetShareApprovalList(getShareApprovalListOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Test pagination helper method on response`, func() {
			It(`Invoke GetNextStart successfully`, func() {
				responseObject := new(catalogmanagementv1.ShareApprovalListAccessResult)
				nextObject := new(catalogmanagementv1.PaginationTokenLink)
				nextObject.Start = core.StringPtr("abc-123")
				responseObject.Next = nextObject

				value, err := responseObject.GetNextStart()
				Expect(err).To(BeNil())
				Expect(value).To(Equal(core.StringPtr("abc-123")))
			})
			It(`Invoke GetNextStart without a "Next" property in the response`, func() {
				responseObject := new(catalogmanagementv1.ShareApprovalListAccessResult)

				value, err := responseObject.GetNextStart()
				Expect(err).To(BeNil())
				Expect(value).To(BeNil())
			})
		})
		Context(`Using mock server endpoint - paginated response`, func() {
			BeforeEach(func() {
				var requestNumber int = 0
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getShareApprovalListPath))
					Expect(req.Method).To(Equal("GET"))

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					requestNumber++
					if requestNumber == 1 {
						fmt.Fprintf(res, "%s", `{"next":{"start":"1"},"total_count":2,"limit":1,"resources":[{"id":"ID","account":"Account","account_type":11,"target_account":"TargetAccount","target_kind":"TargetKind","created":"2019-01-01T12:00:00.000Z","approval_state":"ApprovalState"}]}`)
					} else if requestNumber == 2 {
						fmt.Fprintf(res, "%s", `{"total_count":2,"limit":1,"resources":[{"id":"ID","account":"Account","account_type":11,"target_account":"TargetAccount","target_kind":"TargetKind","created":"2019-01-01T12:00:00.000Z","approval_state":"ApprovalState"}]}`)
					} else {
						res.WriteHeader(400)
					}
				}))
			})
			It(`Use GetShareApprovalListPager.GetNext successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				getShareApprovalListOptionsModel := &catalogmanagementv1.GetShareApprovalListOptions{
					ObjectType: core.StringPtr("offering"),
					Limit:      core.Int64Ptr(int64(10)),
				}

				pager, err := catalogManagementService.NewGetShareApprovalListPager(getShareApprovalListOptionsModel)
				Expect(err).To(BeNil())
				Expect(pager).ToNot(BeNil())

				var allResults []catalogmanagementv1.ShareApprovalAccess
				for pager.HasNext() {
					nextPage, err := pager.GetNext()
					Expect(err).To(BeNil())
					Expect(nextPage).ToNot(BeNil())
					allResults = append(allResults, nextPage...)
				}
				Expect(len(allResults)).To(Equal(2))
			})
			It(`Use GetShareApprovalListPager.GetAll successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				getShareApprovalListOptionsModel := &catalogmanagementv1.GetShareApprovalListOptions{
					ObjectType: core.StringPtr("offering"),
					Limit:      core.Int64Ptr(int64(10)),
				}

				pager, err := catalogManagementService.NewGetShareApprovalListPager(getShareApprovalListOptionsModel)
				Expect(err).To(BeNil())
				Expect(pager).ToNot(BeNil())

				allResults, err := pager.GetAll()
				Expect(err).To(BeNil())
				Expect(allResults).ToNot(BeNil())
				Expect(len(allResults)).To(Equal(2))
			})
		})
	})
	Describe(`DeleteShareApprovalList(deleteShareApprovalListOptions *DeleteShareApprovalListOptions) - Operation response error`, func() {
		deleteShareApprovalListPath := "/shareapproval/offering/access"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deleteShareApprovalListPath))
					Expect(req.Method).To(Equal("DELETE"))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke DeleteShareApprovalList with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the DeleteShareApprovalListOptions model
				deleteShareApprovalListOptionsModel := new(catalogmanagementv1.DeleteShareApprovalListOptions)
				deleteShareApprovalListOptionsModel.ObjectType = core.StringPtr("offering")
				deleteShareApprovalListOptionsModel.Accesses = []string{"testString"}
				deleteShareApprovalListOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.DeleteShareApprovalList(deleteShareApprovalListOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.DeleteShareApprovalList(deleteShareApprovalListOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`DeleteShareApprovalList(deleteShareApprovalListOptions *DeleteShareApprovalListOptions)`, func() {
		deleteShareApprovalListPath := "/shareapproval/offering/access"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deleteShareApprovalListPath))
					Expect(req.Method).To(Equal("DELETE"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"errors": {"mapKey": "Inner"}}`)
				}))
			})
			It(`Invoke DeleteShareApprovalList successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the DeleteShareApprovalListOptions model
				deleteShareApprovalListOptionsModel := new(catalogmanagementv1.DeleteShareApprovalListOptions)
				deleteShareApprovalListOptionsModel.ObjectType = core.StringPtr("offering")
				deleteShareApprovalListOptionsModel.Accesses = []string{"testString"}
				deleteShareApprovalListOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.DeleteShareApprovalListWithContext(ctx, deleteShareApprovalListOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.DeleteShareApprovalList(deleteShareApprovalListOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.DeleteShareApprovalListWithContext(ctx, deleteShareApprovalListOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deleteShareApprovalListPath))
					Expect(req.Method).To(Equal("DELETE"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"errors": {"mapKey": "Inner"}}`)
				}))
			})
			It(`Invoke DeleteShareApprovalList successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.DeleteShareApprovalList(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the DeleteShareApprovalListOptions model
				deleteShareApprovalListOptionsModel := new(catalogmanagementv1.DeleteShareApprovalListOptions)
				deleteShareApprovalListOptionsModel.ObjectType = core.StringPtr("offering")
				deleteShareApprovalListOptionsModel.Accesses = []string{"testString"}
				deleteShareApprovalListOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.DeleteShareApprovalList(deleteShareApprovalListOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke DeleteShareApprovalList with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the DeleteShareApprovalListOptions model
				deleteShareApprovalListOptionsModel := new(catalogmanagementv1.DeleteShareApprovalListOptions)
				deleteShareApprovalListOptionsModel.ObjectType = core.StringPtr("offering")
				deleteShareApprovalListOptionsModel.Accesses = []string{"testString"}
				deleteShareApprovalListOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.DeleteShareApprovalList(deleteShareApprovalListOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the DeleteShareApprovalListOptions model with no property values
				deleteShareApprovalListOptionsModelNew := new(catalogmanagementv1.DeleteShareApprovalListOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.DeleteShareApprovalList(deleteShareApprovalListOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke DeleteShareApprovalList successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the DeleteShareApprovalListOptions model
				deleteShareApprovalListOptionsModel := new(catalogmanagementv1.DeleteShareApprovalListOptions)
				deleteShareApprovalListOptionsModel.ObjectType = core.StringPtr("offering")
				deleteShareApprovalListOptionsModel.Accesses = []string{"testString"}
				deleteShareApprovalListOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.DeleteShareApprovalList(deleteShareApprovalListOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`AddShareApprovalList(addShareApprovalListOptions *AddShareApprovalListOptions) - Operation response error`, func() {
		addShareApprovalListPath := "/shareapproval/offering/access"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(addShareApprovalListPath))
					Expect(req.Method).To(Equal("POST"))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke AddShareApprovalList with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the AddShareApprovalListOptions model
				addShareApprovalListOptionsModel := new(catalogmanagementv1.AddShareApprovalListOptions)
				addShareApprovalListOptionsModel.ObjectType = core.StringPtr("offering")
				addShareApprovalListOptionsModel.Accesses = []string{"testString"}
				addShareApprovalListOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.AddShareApprovalList(addShareApprovalListOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.AddShareApprovalList(addShareApprovalListOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`AddShareApprovalList(addShareApprovalListOptions *AddShareApprovalListOptions)`, func() {
		addShareApprovalListPath := "/shareapproval/offering/access"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(addShareApprovalListPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"errors": {"mapKey": "Inner"}}`)
				}))
			})
			It(`Invoke AddShareApprovalList successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the AddShareApprovalListOptions model
				addShareApprovalListOptionsModel := new(catalogmanagementv1.AddShareApprovalListOptions)
				addShareApprovalListOptionsModel.ObjectType = core.StringPtr("offering")
				addShareApprovalListOptionsModel.Accesses = []string{"testString"}
				addShareApprovalListOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.AddShareApprovalListWithContext(ctx, addShareApprovalListOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.AddShareApprovalList(addShareApprovalListOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.AddShareApprovalListWithContext(ctx, addShareApprovalListOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(addShareApprovalListPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"errors": {"mapKey": "Inner"}}`)
				}))
			})
			It(`Invoke AddShareApprovalList successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.AddShareApprovalList(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the AddShareApprovalListOptions model
				addShareApprovalListOptionsModel := new(catalogmanagementv1.AddShareApprovalListOptions)
				addShareApprovalListOptionsModel.ObjectType = core.StringPtr("offering")
				addShareApprovalListOptionsModel.Accesses = []string{"testString"}
				addShareApprovalListOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.AddShareApprovalList(addShareApprovalListOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke AddShareApprovalList with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the AddShareApprovalListOptions model
				addShareApprovalListOptionsModel := new(catalogmanagementv1.AddShareApprovalListOptions)
				addShareApprovalListOptionsModel.ObjectType = core.StringPtr("offering")
				addShareApprovalListOptionsModel.Accesses = []string{"testString"}
				addShareApprovalListOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.AddShareApprovalList(addShareApprovalListOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the AddShareApprovalListOptions model with no property values
				addShareApprovalListOptionsModelNew := new(catalogmanagementv1.AddShareApprovalListOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.AddShareApprovalList(addShareApprovalListOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(201)
				}))
			})
			It(`Invoke AddShareApprovalList successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the AddShareApprovalListOptions model
				addShareApprovalListOptionsModel := new(catalogmanagementv1.AddShareApprovalListOptions)
				addShareApprovalListOptionsModel.ObjectType = core.StringPtr("offering")
				addShareApprovalListOptionsModel.Accesses = []string{"testString"}
				addShareApprovalListOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.AddShareApprovalList(addShareApprovalListOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetShareApprovalListAsSource(getShareApprovalListAsSourceOptions *GetShareApprovalListAsSourceOptions) - Operation response error`, func() {
		getShareApprovalListAsSourcePath := "/shareapproval/offering/access/source/approved"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getShareApprovalListAsSourcePath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.URL.Query()["start"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(10))}))
					Expect(req.URL.Query()["enterprise_id"]).To(Equal([]string{"testString"}))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetShareApprovalListAsSource with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetShareApprovalListAsSourceOptions model
				getShareApprovalListAsSourceOptionsModel := new(catalogmanagementv1.GetShareApprovalListAsSourceOptions)
				getShareApprovalListAsSourceOptionsModel.ObjectType = core.StringPtr("offering")
				getShareApprovalListAsSourceOptionsModel.ApprovalStateIdentifier = core.StringPtr("approved")
				getShareApprovalListAsSourceOptionsModel.Start = core.StringPtr("testString")
				getShareApprovalListAsSourceOptionsModel.Limit = core.Int64Ptr(int64(10))
				getShareApprovalListAsSourceOptionsModel.EnterpriseID = core.StringPtr("testString")
				getShareApprovalListAsSourceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.GetShareApprovalListAsSource(getShareApprovalListAsSourceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.GetShareApprovalListAsSource(getShareApprovalListAsSourceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetShareApprovalListAsSource(getShareApprovalListAsSourceOptions *GetShareApprovalListAsSourceOptions)`, func() {
		getShareApprovalListAsSourcePath := "/shareapproval/offering/access/source/approved"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getShareApprovalListAsSourcePath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.URL.Query()["start"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(10))}))
					Expect(req.URL.Query()["enterprise_id"]).To(Equal([]string{"testString"}))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"start": "Start", "limit": 5, "total_count": 10, "resource_count": 13, "first": {"href": "Href", "start": "Start"}, "next": {"href": "Href", "start": "Start"}, "prev": {"href": "Href", "start": "Start"}, "last": {"href": "Href", "start": "Start"}, "resources": [{"id": "ID", "account": "Account", "account_type": 11, "target_account": "TargetAccount", "target_kind": "TargetKind", "created": "2019-01-01T12:00:00.000Z", "approval_state": "ApprovalState"}]}`)
				}))
			})
			It(`Invoke GetShareApprovalListAsSource successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the GetShareApprovalListAsSourceOptions model
				getShareApprovalListAsSourceOptionsModel := new(catalogmanagementv1.GetShareApprovalListAsSourceOptions)
				getShareApprovalListAsSourceOptionsModel.ObjectType = core.StringPtr("offering")
				getShareApprovalListAsSourceOptionsModel.ApprovalStateIdentifier = core.StringPtr("approved")
				getShareApprovalListAsSourceOptionsModel.Start = core.StringPtr("testString")
				getShareApprovalListAsSourceOptionsModel.Limit = core.Int64Ptr(int64(10))
				getShareApprovalListAsSourceOptionsModel.EnterpriseID = core.StringPtr("testString")
				getShareApprovalListAsSourceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.GetShareApprovalListAsSourceWithContext(ctx, getShareApprovalListAsSourceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.GetShareApprovalListAsSource(getShareApprovalListAsSourceOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.GetShareApprovalListAsSourceWithContext(ctx, getShareApprovalListAsSourceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getShareApprovalListAsSourcePath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.URL.Query()["start"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(10))}))
					Expect(req.URL.Query()["enterprise_id"]).To(Equal([]string{"testString"}))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"start": "Start", "limit": 5, "total_count": 10, "resource_count": 13, "first": {"href": "Href", "start": "Start"}, "next": {"href": "Href", "start": "Start"}, "prev": {"href": "Href", "start": "Start"}, "last": {"href": "Href", "start": "Start"}, "resources": [{"id": "ID", "account": "Account", "account_type": 11, "target_account": "TargetAccount", "target_kind": "TargetKind", "created": "2019-01-01T12:00:00.000Z", "approval_state": "ApprovalState"}]}`)
				}))
			})
			It(`Invoke GetShareApprovalListAsSource successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.GetShareApprovalListAsSource(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetShareApprovalListAsSourceOptions model
				getShareApprovalListAsSourceOptionsModel := new(catalogmanagementv1.GetShareApprovalListAsSourceOptions)
				getShareApprovalListAsSourceOptionsModel.ObjectType = core.StringPtr("offering")
				getShareApprovalListAsSourceOptionsModel.ApprovalStateIdentifier = core.StringPtr("approved")
				getShareApprovalListAsSourceOptionsModel.Start = core.StringPtr("testString")
				getShareApprovalListAsSourceOptionsModel.Limit = core.Int64Ptr(int64(10))
				getShareApprovalListAsSourceOptionsModel.EnterpriseID = core.StringPtr("testString")
				getShareApprovalListAsSourceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.GetShareApprovalListAsSource(getShareApprovalListAsSourceOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetShareApprovalListAsSource with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetShareApprovalListAsSourceOptions model
				getShareApprovalListAsSourceOptionsModel := new(catalogmanagementv1.GetShareApprovalListAsSourceOptions)
				getShareApprovalListAsSourceOptionsModel.ObjectType = core.StringPtr("offering")
				getShareApprovalListAsSourceOptionsModel.ApprovalStateIdentifier = core.StringPtr("approved")
				getShareApprovalListAsSourceOptionsModel.Start = core.StringPtr("testString")
				getShareApprovalListAsSourceOptionsModel.Limit = core.Int64Ptr(int64(10))
				getShareApprovalListAsSourceOptionsModel.EnterpriseID = core.StringPtr("testString")
				getShareApprovalListAsSourceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.GetShareApprovalListAsSource(getShareApprovalListAsSourceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetShareApprovalListAsSourceOptions model with no property values
				getShareApprovalListAsSourceOptionsModelNew := new(catalogmanagementv1.GetShareApprovalListAsSourceOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.GetShareApprovalListAsSource(getShareApprovalListAsSourceOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetShareApprovalListAsSource successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetShareApprovalListAsSourceOptions model
				getShareApprovalListAsSourceOptionsModel := new(catalogmanagementv1.GetShareApprovalListAsSourceOptions)
				getShareApprovalListAsSourceOptionsModel.ObjectType = core.StringPtr("offering")
				getShareApprovalListAsSourceOptionsModel.ApprovalStateIdentifier = core.StringPtr("approved")
				getShareApprovalListAsSourceOptionsModel.Start = core.StringPtr("testString")
				getShareApprovalListAsSourceOptionsModel.Limit = core.Int64Ptr(int64(10))
				getShareApprovalListAsSourceOptionsModel.EnterpriseID = core.StringPtr("testString")
				getShareApprovalListAsSourceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.GetShareApprovalListAsSource(getShareApprovalListAsSourceOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Test pagination helper method on response`, func() {
			It(`Invoke GetNextStart successfully`, func() {
				responseObject := new(catalogmanagementv1.ShareApprovalListAccessResult)
				nextObject := new(catalogmanagementv1.PaginationTokenLink)
				nextObject.Start = core.StringPtr("abc-123")
				responseObject.Next = nextObject

				value, err := responseObject.GetNextStart()
				Expect(err).To(BeNil())
				Expect(value).To(Equal(core.StringPtr("abc-123")))
			})
			It(`Invoke GetNextStart without a "Next" property in the response`, func() {
				responseObject := new(catalogmanagementv1.ShareApprovalListAccessResult)

				value, err := responseObject.GetNextStart()
				Expect(err).To(BeNil())
				Expect(value).To(BeNil())
			})
		})
		Context(`Using mock server endpoint - paginated response`, func() {
			BeforeEach(func() {
				var requestNumber int = 0
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getShareApprovalListAsSourcePath))
					Expect(req.Method).To(Equal("GET"))

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					requestNumber++
					if requestNumber == 1 {
						fmt.Fprintf(res, "%s", `{"next":{"start":"1"},"total_count":2,"limit":1,"resources":[{"id":"ID","account":"Account","account_type":11,"target_account":"TargetAccount","target_kind":"TargetKind","created":"2019-01-01T12:00:00.000Z","approval_state":"ApprovalState"}]}`)
					} else if requestNumber == 2 {
						fmt.Fprintf(res, "%s", `{"total_count":2,"limit":1,"resources":[{"id":"ID","account":"Account","account_type":11,"target_account":"TargetAccount","target_kind":"TargetKind","created":"2019-01-01T12:00:00.000Z","approval_state":"ApprovalState"}]}`)
					} else {
						res.WriteHeader(400)
					}
				}))
			})
			It(`Use GetShareApprovalListAsSourcePager.GetNext successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				getShareApprovalListAsSourceOptionsModel := &catalogmanagementv1.GetShareApprovalListAsSourceOptions{
					ObjectType:              core.StringPtr("offering"),
					ApprovalStateIdentifier: core.StringPtr("approved"),
					Limit:                   core.Int64Ptr(int64(10)),
					EnterpriseID:            core.StringPtr("testString"),
				}

				pager, err := catalogManagementService.NewGetShareApprovalListAsSourcePager(getShareApprovalListAsSourceOptionsModel)
				Expect(err).To(BeNil())
				Expect(pager).ToNot(BeNil())

				var allResults []catalogmanagementv1.ShareApprovalAccess
				for pager.HasNext() {
					nextPage, err := pager.GetNext()
					Expect(err).To(BeNil())
					Expect(nextPage).ToNot(BeNil())
					allResults = append(allResults, nextPage...)
				}
				Expect(len(allResults)).To(Equal(2))
			})
			It(`Use GetShareApprovalListAsSourcePager.GetAll successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				getShareApprovalListAsSourceOptionsModel := &catalogmanagementv1.GetShareApprovalListAsSourceOptions{
					ObjectType:              core.StringPtr("offering"),
					ApprovalStateIdentifier: core.StringPtr("approved"),
					Limit:                   core.Int64Ptr(int64(10)),
					EnterpriseID:            core.StringPtr("testString"),
				}

				pager, err := catalogManagementService.NewGetShareApprovalListAsSourcePager(getShareApprovalListAsSourceOptionsModel)
				Expect(err).To(BeNil())
				Expect(pager).ToNot(BeNil())

				allResults, err := pager.GetAll()
				Expect(err).To(BeNil())
				Expect(allResults).ToNot(BeNil())
				Expect(len(allResults)).To(Equal(2))
			})
		})
	})
	Describe(`UpdateShareApprovalListAsSource(updateShareApprovalListAsSourceOptions *UpdateShareApprovalListAsSourceOptions) - Operation response error`, func() {
		updateShareApprovalListAsSourcePath := "/shareapproval/offering/access/source/approved"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updateShareApprovalListAsSourcePath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.URL.Query()["enterprise_id"]).To(Equal([]string{"testString"}))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke UpdateShareApprovalListAsSource with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the UpdateShareApprovalListAsSourceOptions model
				updateShareApprovalListAsSourceOptionsModel := new(catalogmanagementv1.UpdateShareApprovalListAsSourceOptions)
				updateShareApprovalListAsSourceOptionsModel.ObjectType = core.StringPtr("offering")
				updateShareApprovalListAsSourceOptionsModel.ApprovalStateIdentifier = core.StringPtr("approved")
				updateShareApprovalListAsSourceOptionsModel.Accesses = []string{"testString"}
				updateShareApprovalListAsSourceOptionsModel.EnterpriseID = core.StringPtr("testString")
				updateShareApprovalListAsSourceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.UpdateShareApprovalListAsSource(updateShareApprovalListAsSourceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.UpdateShareApprovalListAsSource(updateShareApprovalListAsSourceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`UpdateShareApprovalListAsSource(updateShareApprovalListAsSourceOptions *UpdateShareApprovalListAsSourceOptions)`, func() {
		updateShareApprovalListAsSourcePath := "/shareapproval/offering/access/source/approved"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updateShareApprovalListAsSourcePath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.URL.Query()["enterprise_id"]).To(Equal([]string{"testString"}))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"errors": {"mapKey": "Inner"}}`)
				}))
			})
			It(`Invoke UpdateShareApprovalListAsSource successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the UpdateShareApprovalListAsSourceOptions model
				updateShareApprovalListAsSourceOptionsModel := new(catalogmanagementv1.UpdateShareApprovalListAsSourceOptions)
				updateShareApprovalListAsSourceOptionsModel.ObjectType = core.StringPtr("offering")
				updateShareApprovalListAsSourceOptionsModel.ApprovalStateIdentifier = core.StringPtr("approved")
				updateShareApprovalListAsSourceOptionsModel.Accesses = []string{"testString"}
				updateShareApprovalListAsSourceOptionsModel.EnterpriseID = core.StringPtr("testString")
				updateShareApprovalListAsSourceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.UpdateShareApprovalListAsSourceWithContext(ctx, updateShareApprovalListAsSourceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.UpdateShareApprovalListAsSource(updateShareApprovalListAsSourceOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.UpdateShareApprovalListAsSourceWithContext(ctx, updateShareApprovalListAsSourceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updateShareApprovalListAsSourcePath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.URL.Query()["enterprise_id"]).To(Equal([]string{"testString"}))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"errors": {"mapKey": "Inner"}}`)
				}))
			})
			It(`Invoke UpdateShareApprovalListAsSource successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.UpdateShareApprovalListAsSource(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the UpdateShareApprovalListAsSourceOptions model
				updateShareApprovalListAsSourceOptionsModel := new(catalogmanagementv1.UpdateShareApprovalListAsSourceOptions)
				updateShareApprovalListAsSourceOptionsModel.ObjectType = core.StringPtr("offering")
				updateShareApprovalListAsSourceOptionsModel.ApprovalStateIdentifier = core.StringPtr("approved")
				updateShareApprovalListAsSourceOptionsModel.Accesses = []string{"testString"}
				updateShareApprovalListAsSourceOptionsModel.EnterpriseID = core.StringPtr("testString")
				updateShareApprovalListAsSourceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.UpdateShareApprovalListAsSource(updateShareApprovalListAsSourceOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke UpdateShareApprovalListAsSource with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the UpdateShareApprovalListAsSourceOptions model
				updateShareApprovalListAsSourceOptionsModel := new(catalogmanagementv1.UpdateShareApprovalListAsSourceOptions)
				updateShareApprovalListAsSourceOptionsModel.ObjectType = core.StringPtr("offering")
				updateShareApprovalListAsSourceOptionsModel.ApprovalStateIdentifier = core.StringPtr("approved")
				updateShareApprovalListAsSourceOptionsModel.Accesses = []string{"testString"}
				updateShareApprovalListAsSourceOptionsModel.EnterpriseID = core.StringPtr("testString")
				updateShareApprovalListAsSourceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.UpdateShareApprovalListAsSource(updateShareApprovalListAsSourceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the UpdateShareApprovalListAsSourceOptions model with no property values
				updateShareApprovalListAsSourceOptionsModelNew := new(catalogmanagementv1.UpdateShareApprovalListAsSourceOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.UpdateShareApprovalListAsSource(updateShareApprovalListAsSourceOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(201)
				}))
			})
			It(`Invoke UpdateShareApprovalListAsSource successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the UpdateShareApprovalListAsSourceOptions model
				updateShareApprovalListAsSourceOptionsModel := new(catalogmanagementv1.UpdateShareApprovalListAsSourceOptions)
				updateShareApprovalListAsSourceOptionsModel.ObjectType = core.StringPtr("offering")
				updateShareApprovalListAsSourceOptionsModel.ApprovalStateIdentifier = core.StringPtr("approved")
				updateShareApprovalListAsSourceOptionsModel.Accesses = []string{"testString"}
				updateShareApprovalListAsSourceOptionsModel.EnterpriseID = core.StringPtr("testString")
				updateShareApprovalListAsSourceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.UpdateShareApprovalListAsSource(updateShareApprovalListAsSourceOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListCatalogs(listCatalogsOptions *ListCatalogsOptions) - Operation response error`, func() {
		listCatalogsPath := "/catalogs"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listCatalogsPath))
					Expect(req.Method).To(Equal("GET"))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ListCatalogs with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ListCatalogsOptions model
				listCatalogsOptionsModel := new(catalogmanagementv1.ListCatalogsOptions)
				listCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.ListCatalogs(listCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.ListCatalogs(listCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListCatalogs(listCatalogsOptions *ListCatalogsOptions)`, func() {
		listCatalogsPath := "/catalogs"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listCatalogsPath))
					Expect(req.Method).To(Equal("GET"))

					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"total_count": 10, "resources": [{"id": "ID", "_rev": "Rev", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "catalog_icon_url": "CatalogIconURL", "catalog_banner_url": "CatalogBannerURL", "tags": ["Tags"], "url": "URL", "crn": "CRN", "offerings_url": "OfferingsURL", "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "disabled": true, "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "resource_group_id": "ResourceGroupID", "owning_account": "OwningAccount", "catalog_filters": {"include_all": true, "category_filters": {"mapKey": {"include": false, "filter": {"filter_terms": ["FilterTerms"]}}}, "id_filters": {"include": {"filter_terms": ["FilterTerms"]}, "exclude": {"filter_terms": ["FilterTerms"]}}}, "kind": "Kind", "metadata": {"anyKey": "anyValue"}, "target_account_contexts": [{"api_key": "APIKey", "trusted_profile": {"trusted_profile_id": "TrustedProfileID", "catalog_crn": "CatalogCRN", "catalog_name": "CatalogName", "target_service_id": "TargetServiceID"}, "name": "Name", "label": "Label", "project_id": "ProjectID"}]}]}`)
				}))
			})
			It(`Invoke ListCatalogs successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the ListCatalogsOptions model
				listCatalogsOptionsModel := new(catalogmanagementv1.ListCatalogsOptions)
				listCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.ListCatalogsWithContext(ctx, listCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.ListCatalogs(listCatalogsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.ListCatalogsWithContext(ctx, listCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listCatalogsPath))
					Expect(req.Method).To(Equal("GET"))

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"total_count": 10, "resources": [{"id": "ID", "_rev": "Rev", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "catalog_icon_url": "CatalogIconURL", "catalog_banner_url": "CatalogBannerURL", "tags": ["Tags"], "url": "URL", "crn": "CRN", "offerings_url": "OfferingsURL", "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "disabled": true, "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "resource_group_id": "ResourceGroupID", "owning_account": "OwningAccount", "catalog_filters": {"include_all": true, "category_filters": {"mapKey": {"include": false, "filter": {"filter_terms": ["FilterTerms"]}}}, "id_filters": {"include": {"filter_terms": ["FilterTerms"]}, "exclude": {"filter_terms": ["FilterTerms"]}}}, "kind": "Kind", "metadata": {"anyKey": "anyValue"}, "target_account_contexts": [{"api_key": "APIKey", "trusted_profile": {"trusted_profile_id": "TrustedProfileID", "catalog_crn": "CatalogCRN", "catalog_name": "CatalogName", "target_service_id": "TargetServiceID"}, "name": "Name", "label": "Label", "project_id": "ProjectID"}]}]}`)
				}))
			})
			It(`Invoke ListCatalogs successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.ListCatalogs(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ListCatalogsOptions model
				listCatalogsOptionsModel := new(catalogmanagementv1.ListCatalogsOptions)
				listCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.ListCatalogs(listCatalogsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ListCatalogs with error: Operation request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ListCatalogsOptions model
				listCatalogsOptionsModel := new(catalogmanagementv1.ListCatalogsOptions)
				listCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.ListCatalogs(listCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ListCatalogs successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ListCatalogsOptions model
				listCatalogsOptionsModel := new(catalogmanagementv1.ListCatalogsOptions)
				listCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.ListCatalogs(listCatalogsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateCatalog(createCatalogOptions *CreateCatalogOptions) - Operation response error`, func() {
		createCatalogPath := "/catalogs"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createCatalogPath))
					Expect(req.Method).To(Equal("POST"))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke CreateCatalog with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the Feature model
				featureModel := new(catalogmanagementv1.Feature)
				featureModel.Title = core.StringPtr("testString")
				featureModel.TitleI18n = map[string]string{"key1": "testString"}
				featureModel.Description = core.StringPtr("testString")
				featureModel.DescriptionI18n = map[string]string{"key1": "testString"}

				// Construct an instance of the FilterTerms model
				filterTermsModel := new(catalogmanagementv1.FilterTerms)
				filterTermsModel.FilterTerms = []string{"testString"}

				// Construct an instance of the CategoryFilter model
				categoryFilterModel := new(catalogmanagementv1.CategoryFilter)
				categoryFilterModel.Include = core.BoolPtr(true)
				categoryFilterModel.Filter = filterTermsModel

				// Construct an instance of the IDFilter model
				idFilterModel := new(catalogmanagementv1.IDFilter)
				idFilterModel.Include = filterTermsModel
				idFilterModel.Exclude = filterTermsModel

				// Construct an instance of the Filters model
				filtersModel := new(catalogmanagementv1.Filters)
				filtersModel.IncludeAll = core.BoolPtr(true)
				filtersModel.CategoryFilters = map[string]catalogmanagementv1.CategoryFilter{"key1": *categoryFilterModel}
				filtersModel.IDFilters = idFilterModel
				filtersModel.CategoryFilters["foo"] = *categoryFilterModel

				// Construct an instance of the TrustedProfileInfo model
				trustedProfileInfoModel := new(catalogmanagementv1.TrustedProfileInfo)
				trustedProfileInfoModel.TrustedProfileID = core.StringPtr("testString")
				trustedProfileInfoModel.CatalogCRN = core.StringPtr("testString")
				trustedProfileInfoModel.CatalogName = core.StringPtr("testString")
				trustedProfileInfoModel.TargetServiceID = core.StringPtr("testString")

				// Construct an instance of the TargetAccountContext model
				targetAccountContextModel := new(catalogmanagementv1.TargetAccountContext)
				targetAccountContextModel.APIKey = core.StringPtr("testString")
				targetAccountContextModel.TrustedProfile = trustedProfileInfoModel
				targetAccountContextModel.Name = core.StringPtr("testString")
				targetAccountContextModel.Label = core.StringPtr("testString")
				targetAccountContextModel.ProjectID = core.StringPtr("testString")

				// Construct an instance of the CreateCatalogOptions model
				createCatalogOptionsModel := new(catalogmanagementv1.CreateCatalogOptions)
				createCatalogOptionsModel.Label = core.StringPtr("testString")
				createCatalogOptionsModel.LabelI18n = map[string]string{"key1": "testString"}
				createCatalogOptionsModel.ShortDescription = core.StringPtr("testString")
				createCatalogOptionsModel.ShortDescriptionI18n = map[string]string{"key1": "testString"}
				createCatalogOptionsModel.CatalogIconURL = core.StringPtr("testString")
				createCatalogOptionsModel.CatalogBannerURL = core.StringPtr("testString")
				createCatalogOptionsModel.Tags = []string{"testString"}
				createCatalogOptionsModel.Features = []catalogmanagementv1.Feature{*featureModel}
				createCatalogOptionsModel.Disabled = core.BoolPtr(true)
				createCatalogOptionsModel.ResourceGroupID = core.StringPtr("testString")
				createCatalogOptionsModel.OwningAccount = core.StringPtr("testString")
				createCatalogOptionsModel.CatalogFilters = filtersModel
				createCatalogOptionsModel.Kind = core.StringPtr("testString")
				createCatalogOptionsModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				createCatalogOptionsModel.TargetAccountContexts = []catalogmanagementv1.TargetAccountContext{*targetAccountContextModel}
				createCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.CreateCatalog(createCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.CreateCatalog(createCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateCatalog(createCatalogOptions *CreateCatalogOptions)`, func() {
		createCatalogPath := "/catalogs"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createCatalogPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "catalog_icon_url": "CatalogIconURL", "catalog_banner_url": "CatalogBannerURL", "tags": ["Tags"], "url": "URL", "crn": "CRN", "offerings_url": "OfferingsURL", "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "disabled": true, "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "resource_group_id": "ResourceGroupID", "owning_account": "OwningAccount", "catalog_filters": {"include_all": true, "category_filters": {"mapKey": {"include": false, "filter": {"filter_terms": ["FilterTerms"]}}}, "id_filters": {"include": {"filter_terms": ["FilterTerms"]}, "exclude": {"filter_terms": ["FilterTerms"]}}}, "kind": "Kind", "metadata": {"anyKey": "anyValue"}, "target_account_contexts": [{"api_key": "APIKey", "trusted_profile": {"trusted_profile_id": "TrustedProfileID", "catalog_crn": "CatalogCRN", "catalog_name": "CatalogName", "target_service_id": "TargetServiceID"}, "name": "Name", "label": "Label", "project_id": "ProjectID"}]}`)
				}))
			})
			It(`Invoke CreateCatalog successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the Feature model
				featureModel := new(catalogmanagementv1.Feature)
				featureModel.Title = core.StringPtr("testString")
				featureModel.TitleI18n = map[string]string{"key1": "testString"}
				featureModel.Description = core.StringPtr("testString")
				featureModel.DescriptionI18n = map[string]string{"key1": "testString"}

				// Construct an instance of the FilterTerms model
				filterTermsModel := new(catalogmanagementv1.FilterTerms)
				filterTermsModel.FilterTerms = []string{"testString"}

				// Construct an instance of the CategoryFilter model
				categoryFilterModel := new(catalogmanagementv1.CategoryFilter)
				categoryFilterModel.Include = core.BoolPtr(true)
				categoryFilterModel.Filter = filterTermsModel

				// Construct an instance of the IDFilter model
				idFilterModel := new(catalogmanagementv1.IDFilter)
				idFilterModel.Include = filterTermsModel
				idFilterModel.Exclude = filterTermsModel

				// Construct an instance of the Filters model
				filtersModel := new(catalogmanagementv1.Filters)
				filtersModel.IncludeAll = core.BoolPtr(true)
				filtersModel.CategoryFilters = map[string]catalogmanagementv1.CategoryFilter{"key1": *categoryFilterModel}
				filtersModel.IDFilters = idFilterModel
				filtersModel.CategoryFilters["foo"] = *categoryFilterModel

				// Construct an instance of the TrustedProfileInfo model
				trustedProfileInfoModel := new(catalogmanagementv1.TrustedProfileInfo)
				trustedProfileInfoModel.TrustedProfileID = core.StringPtr("testString")
				trustedProfileInfoModel.CatalogCRN = core.StringPtr("testString")
				trustedProfileInfoModel.CatalogName = core.StringPtr("testString")
				trustedProfileInfoModel.TargetServiceID = core.StringPtr("testString")

				// Construct an instance of the TargetAccountContext model
				targetAccountContextModel := new(catalogmanagementv1.TargetAccountContext)
				targetAccountContextModel.APIKey = core.StringPtr("testString")
				targetAccountContextModel.TrustedProfile = trustedProfileInfoModel
				targetAccountContextModel.Name = core.StringPtr("testString")
				targetAccountContextModel.Label = core.StringPtr("testString")
				targetAccountContextModel.ProjectID = core.StringPtr("testString")

				// Construct an instance of the CreateCatalogOptions model
				createCatalogOptionsModel := new(catalogmanagementv1.CreateCatalogOptions)
				createCatalogOptionsModel.Label = core.StringPtr("testString")
				createCatalogOptionsModel.LabelI18n = map[string]string{"key1": "testString"}
				createCatalogOptionsModel.ShortDescription = core.StringPtr("testString")
				createCatalogOptionsModel.ShortDescriptionI18n = map[string]string{"key1": "testString"}
				createCatalogOptionsModel.CatalogIconURL = core.StringPtr("testString")
				createCatalogOptionsModel.CatalogBannerURL = core.StringPtr("testString")
				createCatalogOptionsModel.Tags = []string{"testString"}
				createCatalogOptionsModel.Features = []catalogmanagementv1.Feature{*featureModel}
				createCatalogOptionsModel.Disabled = core.BoolPtr(true)
				createCatalogOptionsModel.ResourceGroupID = core.StringPtr("testString")
				createCatalogOptionsModel.OwningAccount = core.StringPtr("testString")
				createCatalogOptionsModel.CatalogFilters = filtersModel
				createCatalogOptionsModel.Kind = core.StringPtr("testString")
				createCatalogOptionsModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				createCatalogOptionsModel.TargetAccountContexts = []catalogmanagementv1.TargetAccountContext{*targetAccountContextModel}
				createCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.CreateCatalogWithContext(ctx, createCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.CreateCatalog(createCatalogOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.CreateCatalogWithContext(ctx, createCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createCatalogPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "catalog_icon_url": "CatalogIconURL", "catalog_banner_url": "CatalogBannerURL", "tags": ["Tags"], "url": "URL", "crn": "CRN", "offerings_url": "OfferingsURL", "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "disabled": true, "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "resource_group_id": "ResourceGroupID", "owning_account": "OwningAccount", "catalog_filters": {"include_all": true, "category_filters": {"mapKey": {"include": false, "filter": {"filter_terms": ["FilterTerms"]}}}, "id_filters": {"include": {"filter_terms": ["FilterTerms"]}, "exclude": {"filter_terms": ["FilterTerms"]}}}, "kind": "Kind", "metadata": {"anyKey": "anyValue"}, "target_account_contexts": [{"api_key": "APIKey", "trusted_profile": {"trusted_profile_id": "TrustedProfileID", "catalog_crn": "CatalogCRN", "catalog_name": "CatalogName", "target_service_id": "TargetServiceID"}, "name": "Name", "label": "Label", "project_id": "ProjectID"}]}`)
				}))
			})
			It(`Invoke CreateCatalog successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.CreateCatalog(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the Feature model
				featureModel := new(catalogmanagementv1.Feature)
				featureModel.Title = core.StringPtr("testString")
				featureModel.TitleI18n = map[string]string{"key1": "testString"}
				featureModel.Description = core.StringPtr("testString")
				featureModel.DescriptionI18n = map[string]string{"key1": "testString"}

				// Construct an instance of the FilterTerms model
				filterTermsModel := new(catalogmanagementv1.FilterTerms)
				filterTermsModel.FilterTerms = []string{"testString"}

				// Construct an instance of the CategoryFilter model
				categoryFilterModel := new(catalogmanagementv1.CategoryFilter)
				categoryFilterModel.Include = core.BoolPtr(true)
				categoryFilterModel.Filter = filterTermsModel

				// Construct an instance of the IDFilter model
				idFilterModel := new(catalogmanagementv1.IDFilter)
				idFilterModel.Include = filterTermsModel
				idFilterModel.Exclude = filterTermsModel

				// Construct an instance of the Filters model
				filtersModel := new(catalogmanagementv1.Filters)
				filtersModel.IncludeAll = core.BoolPtr(true)
				filtersModel.CategoryFilters = map[string]catalogmanagementv1.CategoryFilter{"key1": *categoryFilterModel}
				filtersModel.IDFilters = idFilterModel
				filtersModel.CategoryFilters["foo"] = *categoryFilterModel

				// Construct an instance of the TrustedProfileInfo model
				trustedProfileInfoModel := new(catalogmanagementv1.TrustedProfileInfo)
				trustedProfileInfoModel.TrustedProfileID = core.StringPtr("testString")
				trustedProfileInfoModel.CatalogCRN = core.StringPtr("testString")
				trustedProfileInfoModel.CatalogName = core.StringPtr("testString")
				trustedProfileInfoModel.TargetServiceID = core.StringPtr("testString")

				// Construct an instance of the TargetAccountContext model
				targetAccountContextModel := new(catalogmanagementv1.TargetAccountContext)
				targetAccountContextModel.APIKey = core.StringPtr("testString")
				targetAccountContextModel.TrustedProfile = trustedProfileInfoModel
				targetAccountContextModel.Name = core.StringPtr("testString")
				targetAccountContextModel.Label = core.StringPtr("testString")
				targetAccountContextModel.ProjectID = core.StringPtr("testString")

				// Construct an instance of the CreateCatalogOptions model
				createCatalogOptionsModel := new(catalogmanagementv1.CreateCatalogOptions)
				createCatalogOptionsModel.Label = core.StringPtr("testString")
				createCatalogOptionsModel.LabelI18n = map[string]string{"key1": "testString"}
				createCatalogOptionsModel.ShortDescription = core.StringPtr("testString")
				createCatalogOptionsModel.ShortDescriptionI18n = map[string]string{"key1": "testString"}
				createCatalogOptionsModel.CatalogIconURL = core.StringPtr("testString")
				createCatalogOptionsModel.CatalogBannerURL = core.StringPtr("testString")
				createCatalogOptionsModel.Tags = []string{"testString"}
				createCatalogOptionsModel.Features = []catalogmanagementv1.Feature{*featureModel}
				createCatalogOptionsModel.Disabled = core.BoolPtr(true)
				createCatalogOptionsModel.ResourceGroupID = core.StringPtr("testString")
				createCatalogOptionsModel.OwningAccount = core.StringPtr("testString")
				createCatalogOptionsModel.CatalogFilters = filtersModel
				createCatalogOptionsModel.Kind = core.StringPtr("testString")
				createCatalogOptionsModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				createCatalogOptionsModel.TargetAccountContexts = []catalogmanagementv1.TargetAccountContext{*targetAccountContextModel}
				createCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.CreateCatalog(createCatalogOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke CreateCatalog with error: Operation request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the Feature model
				featureModel := new(catalogmanagementv1.Feature)
				featureModel.Title = core.StringPtr("testString")
				featureModel.TitleI18n = map[string]string{"key1": "testString"}
				featureModel.Description = core.StringPtr("testString")
				featureModel.DescriptionI18n = map[string]string{"key1": "testString"}

				// Construct an instance of the FilterTerms model
				filterTermsModel := new(catalogmanagementv1.FilterTerms)
				filterTermsModel.FilterTerms = []string{"testString"}

				// Construct an instance of the CategoryFilter model
				categoryFilterModel := new(catalogmanagementv1.CategoryFilter)
				categoryFilterModel.Include = core.BoolPtr(true)
				categoryFilterModel.Filter = filterTermsModel

				// Construct an instance of the IDFilter model
				idFilterModel := new(catalogmanagementv1.IDFilter)
				idFilterModel.Include = filterTermsModel
				idFilterModel.Exclude = filterTermsModel

				// Construct an instance of the Filters model
				filtersModel := new(catalogmanagementv1.Filters)
				filtersModel.IncludeAll = core.BoolPtr(true)
				filtersModel.CategoryFilters = map[string]catalogmanagementv1.CategoryFilter{"key1": *categoryFilterModel}
				filtersModel.IDFilters = idFilterModel
				filtersModel.CategoryFilters["foo"] = *categoryFilterModel

				// Construct an instance of the TrustedProfileInfo model
				trustedProfileInfoModel := new(catalogmanagementv1.TrustedProfileInfo)
				trustedProfileInfoModel.TrustedProfileID = core.StringPtr("testString")
				trustedProfileInfoModel.CatalogCRN = core.StringPtr("testString")
				trustedProfileInfoModel.CatalogName = core.StringPtr("testString")
				trustedProfileInfoModel.TargetServiceID = core.StringPtr("testString")

				// Construct an instance of the TargetAccountContext model
				targetAccountContextModel := new(catalogmanagementv1.TargetAccountContext)
				targetAccountContextModel.APIKey = core.StringPtr("testString")
				targetAccountContextModel.TrustedProfile = trustedProfileInfoModel
				targetAccountContextModel.Name = core.StringPtr("testString")
				targetAccountContextModel.Label = core.StringPtr("testString")
				targetAccountContextModel.ProjectID = core.StringPtr("testString")

				// Construct an instance of the CreateCatalogOptions model
				createCatalogOptionsModel := new(catalogmanagementv1.CreateCatalogOptions)
				createCatalogOptionsModel.Label = core.StringPtr("testString")
				createCatalogOptionsModel.LabelI18n = map[string]string{"key1": "testString"}
				createCatalogOptionsModel.ShortDescription = core.StringPtr("testString")
				createCatalogOptionsModel.ShortDescriptionI18n = map[string]string{"key1": "testString"}
				createCatalogOptionsModel.CatalogIconURL = core.StringPtr("testString")
				createCatalogOptionsModel.CatalogBannerURL = core.StringPtr("testString")
				createCatalogOptionsModel.Tags = []string{"testString"}
				createCatalogOptionsModel.Features = []catalogmanagementv1.Feature{*featureModel}
				createCatalogOptionsModel.Disabled = core.BoolPtr(true)
				createCatalogOptionsModel.ResourceGroupID = core.StringPtr("testString")
				createCatalogOptionsModel.OwningAccount = core.StringPtr("testString")
				createCatalogOptionsModel.CatalogFilters = filtersModel
				createCatalogOptionsModel.Kind = core.StringPtr("testString")
				createCatalogOptionsModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				createCatalogOptionsModel.TargetAccountContexts = []catalogmanagementv1.TargetAccountContext{*targetAccountContextModel}
				createCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.CreateCatalog(createCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(201)
				}))
			})
			It(`Invoke CreateCatalog successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the Feature model
				featureModel := new(catalogmanagementv1.Feature)
				featureModel.Title = core.StringPtr("testString")
				featureModel.TitleI18n = map[string]string{"key1": "testString"}
				featureModel.Description = core.StringPtr("testString")
				featureModel.DescriptionI18n = map[string]string{"key1": "testString"}

				// Construct an instance of the FilterTerms model
				filterTermsModel := new(catalogmanagementv1.FilterTerms)
				filterTermsModel.FilterTerms = []string{"testString"}

				// Construct an instance of the CategoryFilter model
				categoryFilterModel := new(catalogmanagementv1.CategoryFilter)
				categoryFilterModel.Include = core.BoolPtr(true)
				categoryFilterModel.Filter = filterTermsModel

				// Construct an instance of the IDFilter model
				idFilterModel := new(catalogmanagementv1.IDFilter)
				idFilterModel.Include = filterTermsModel
				idFilterModel.Exclude = filterTermsModel

				// Construct an instance of the Filters model
				filtersModel := new(catalogmanagementv1.Filters)
				filtersModel.IncludeAll = core.BoolPtr(true)
				filtersModel.CategoryFilters = map[string]catalogmanagementv1.CategoryFilter{"key1": *categoryFilterModel}
				filtersModel.IDFilters = idFilterModel
				filtersModel.CategoryFilters["foo"] = *categoryFilterModel

				// Construct an instance of the TrustedProfileInfo model
				trustedProfileInfoModel := new(catalogmanagementv1.TrustedProfileInfo)
				trustedProfileInfoModel.TrustedProfileID = core.StringPtr("testString")
				trustedProfileInfoModel.CatalogCRN = core.StringPtr("testString")
				trustedProfileInfoModel.CatalogName = core.StringPtr("testString")
				trustedProfileInfoModel.TargetServiceID = core.StringPtr("testString")

				// Construct an instance of the TargetAccountContext model
				targetAccountContextModel := new(catalogmanagementv1.TargetAccountContext)
				targetAccountContextModel.APIKey = core.StringPtr("testString")
				targetAccountContextModel.TrustedProfile = trustedProfileInfoModel
				targetAccountContextModel.Name = core.StringPtr("testString")
				targetAccountContextModel.Label = core.StringPtr("testString")
				targetAccountContextModel.ProjectID = core.StringPtr("testString")

				// Construct an instance of the CreateCatalogOptions model
				createCatalogOptionsModel := new(catalogmanagementv1.CreateCatalogOptions)
				createCatalogOptionsModel.Label = core.StringPtr("testString")
				createCatalogOptionsModel.LabelI18n = map[string]string{"key1": "testString"}
				createCatalogOptionsModel.ShortDescription = core.StringPtr("testString")
				createCatalogOptionsModel.ShortDescriptionI18n = map[string]string{"key1": "testString"}
				createCatalogOptionsModel.CatalogIconURL = core.StringPtr("testString")
				createCatalogOptionsModel.CatalogBannerURL = core.StringPtr("testString")
				createCatalogOptionsModel.Tags = []string{"testString"}
				createCatalogOptionsModel.Features = []catalogmanagementv1.Feature{*featureModel}
				createCatalogOptionsModel.Disabled = core.BoolPtr(true)
				createCatalogOptionsModel.ResourceGroupID = core.StringPtr("testString")
				createCatalogOptionsModel.OwningAccount = core.StringPtr("testString")
				createCatalogOptionsModel.CatalogFilters = filtersModel
				createCatalogOptionsModel.Kind = core.StringPtr("testString")
				createCatalogOptionsModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				createCatalogOptionsModel.TargetAccountContexts = []catalogmanagementv1.TargetAccountContext{*targetAccountContextModel}
				createCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.CreateCatalog(createCatalogOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetCatalog(getCatalogOptions *GetCatalogOptions) - Operation response error`, func() {
		getCatalogPath := "/catalogs/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getCatalogPath))
					Expect(req.Method).To(Equal("GET"))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetCatalog with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetCatalogOptions model
				getCatalogOptionsModel := new(catalogmanagementv1.GetCatalogOptions)
				getCatalogOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.GetCatalog(getCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.GetCatalog(getCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetCatalog(getCatalogOptions *GetCatalogOptions)`, func() {
		getCatalogPath := "/catalogs/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getCatalogPath))
					Expect(req.Method).To(Equal("GET"))

					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "catalog_icon_url": "CatalogIconURL", "catalog_banner_url": "CatalogBannerURL", "tags": ["Tags"], "url": "URL", "crn": "CRN", "offerings_url": "OfferingsURL", "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "disabled": true, "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "resource_group_id": "ResourceGroupID", "owning_account": "OwningAccount", "catalog_filters": {"include_all": true, "category_filters": {"mapKey": {"include": false, "filter": {"filter_terms": ["FilterTerms"]}}}, "id_filters": {"include": {"filter_terms": ["FilterTerms"]}, "exclude": {"filter_terms": ["FilterTerms"]}}}, "kind": "Kind", "metadata": {"anyKey": "anyValue"}, "target_account_contexts": [{"api_key": "APIKey", "trusted_profile": {"trusted_profile_id": "TrustedProfileID", "catalog_crn": "CatalogCRN", "catalog_name": "CatalogName", "target_service_id": "TargetServiceID"}, "name": "Name", "label": "Label", "project_id": "ProjectID"}]}`)
				}))
			})
			It(`Invoke GetCatalog successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the GetCatalogOptions model
				getCatalogOptionsModel := new(catalogmanagementv1.GetCatalogOptions)
				getCatalogOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.GetCatalogWithContext(ctx, getCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.GetCatalog(getCatalogOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.GetCatalogWithContext(ctx, getCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getCatalogPath))
					Expect(req.Method).To(Equal("GET"))

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "catalog_icon_url": "CatalogIconURL", "catalog_banner_url": "CatalogBannerURL", "tags": ["Tags"], "url": "URL", "crn": "CRN", "offerings_url": "OfferingsURL", "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "disabled": true, "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "resource_group_id": "ResourceGroupID", "owning_account": "OwningAccount", "catalog_filters": {"include_all": true, "category_filters": {"mapKey": {"include": false, "filter": {"filter_terms": ["FilterTerms"]}}}, "id_filters": {"include": {"filter_terms": ["FilterTerms"]}, "exclude": {"filter_terms": ["FilterTerms"]}}}, "kind": "Kind", "metadata": {"anyKey": "anyValue"}, "target_account_contexts": [{"api_key": "APIKey", "trusted_profile": {"trusted_profile_id": "TrustedProfileID", "catalog_crn": "CatalogCRN", "catalog_name": "CatalogName", "target_service_id": "TargetServiceID"}, "name": "Name", "label": "Label", "project_id": "ProjectID"}]}`)
				}))
			})
			It(`Invoke GetCatalog successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.GetCatalog(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetCatalogOptions model
				getCatalogOptionsModel := new(catalogmanagementv1.GetCatalogOptions)
				getCatalogOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.GetCatalog(getCatalogOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetCatalog with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetCatalogOptions model
				getCatalogOptionsModel := new(catalogmanagementv1.GetCatalogOptions)
				getCatalogOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.GetCatalog(getCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetCatalogOptions model with no property values
				getCatalogOptionsModelNew := new(catalogmanagementv1.GetCatalogOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.GetCatalog(getCatalogOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetCatalog successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetCatalogOptions model
				getCatalogOptionsModel := new(catalogmanagementv1.GetCatalogOptions)
				getCatalogOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.GetCatalog(getCatalogOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ReplaceCatalog(replaceCatalogOptions *ReplaceCatalogOptions) - Operation response error`, func() {
		replaceCatalogPath := "/catalogs/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(replaceCatalogPath))
					Expect(req.Method).To(Equal("PUT"))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ReplaceCatalog with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the Feature model
				featureModel := new(catalogmanagementv1.Feature)
				featureModel.Title = core.StringPtr("testString")
				featureModel.TitleI18n = map[string]string{"key1": "testString"}
				featureModel.Description = core.StringPtr("testString")
				featureModel.DescriptionI18n = map[string]string{"key1": "testString"}

				// Construct an instance of the FilterTerms model
				filterTermsModel := new(catalogmanagementv1.FilterTerms)
				filterTermsModel.FilterTerms = []string{"testString"}

				// Construct an instance of the CategoryFilter model
				categoryFilterModel := new(catalogmanagementv1.CategoryFilter)
				categoryFilterModel.Include = core.BoolPtr(true)
				categoryFilterModel.Filter = filterTermsModel

				// Construct an instance of the IDFilter model
				idFilterModel := new(catalogmanagementv1.IDFilter)
				idFilterModel.Include = filterTermsModel
				idFilterModel.Exclude = filterTermsModel

				// Construct an instance of the Filters model
				filtersModel := new(catalogmanagementv1.Filters)
				filtersModel.IncludeAll = core.BoolPtr(true)
				filtersModel.CategoryFilters = map[string]catalogmanagementv1.CategoryFilter{"key1": *categoryFilterModel}
				filtersModel.IDFilters = idFilterModel
				filtersModel.CategoryFilters["foo"] = *categoryFilterModel

				// Construct an instance of the TrustedProfileInfo model
				trustedProfileInfoModel := new(catalogmanagementv1.TrustedProfileInfo)
				trustedProfileInfoModel.TrustedProfileID = core.StringPtr("testString")
				trustedProfileInfoModel.CatalogCRN = core.StringPtr("testString")
				trustedProfileInfoModel.CatalogName = core.StringPtr("testString")
				trustedProfileInfoModel.TargetServiceID = core.StringPtr("testString")

				// Construct an instance of the TargetAccountContext model
				targetAccountContextModel := new(catalogmanagementv1.TargetAccountContext)
				targetAccountContextModel.APIKey = core.StringPtr("testString")
				targetAccountContextModel.TrustedProfile = trustedProfileInfoModel
				targetAccountContextModel.Name = core.StringPtr("testString")
				targetAccountContextModel.Label = core.StringPtr("testString")
				targetAccountContextModel.ProjectID = core.StringPtr("testString")

				// Construct an instance of the ReplaceCatalogOptions model
				replaceCatalogOptionsModel := new(catalogmanagementv1.ReplaceCatalogOptions)
				replaceCatalogOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				replaceCatalogOptionsModel.ID = core.StringPtr("testString")
				replaceCatalogOptionsModel.Rev = core.StringPtr("testString")
				replaceCatalogOptionsModel.Label = core.StringPtr("testString")
				replaceCatalogOptionsModel.LabelI18n = map[string]string{"key1": "testString"}
				replaceCatalogOptionsModel.ShortDescription = core.StringPtr("testString")
				replaceCatalogOptionsModel.ShortDescriptionI18n = map[string]string{"key1": "testString"}
				replaceCatalogOptionsModel.CatalogIconURL = core.StringPtr("testString")
				replaceCatalogOptionsModel.CatalogBannerURL = core.StringPtr("testString")
				replaceCatalogOptionsModel.Tags = []string{"testString"}
				replaceCatalogOptionsModel.Features = []catalogmanagementv1.Feature{*featureModel}
				replaceCatalogOptionsModel.Disabled = core.BoolPtr(true)
				replaceCatalogOptionsModel.ResourceGroupID = core.StringPtr("testString")
				replaceCatalogOptionsModel.OwningAccount = core.StringPtr("testString")
				replaceCatalogOptionsModel.CatalogFilters = filtersModel
				replaceCatalogOptionsModel.Kind = core.StringPtr("testString")
				replaceCatalogOptionsModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				replaceCatalogOptionsModel.TargetAccountContexts = []catalogmanagementv1.TargetAccountContext{*targetAccountContextModel}
				replaceCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.ReplaceCatalog(replaceCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.ReplaceCatalog(replaceCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ReplaceCatalog(replaceCatalogOptions *ReplaceCatalogOptions)`, func() {
		replaceCatalogPath := "/catalogs/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(replaceCatalogPath))
					Expect(req.Method).To(Equal("PUT"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "catalog_icon_url": "CatalogIconURL", "catalog_banner_url": "CatalogBannerURL", "tags": ["Tags"], "url": "URL", "crn": "CRN", "offerings_url": "OfferingsURL", "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "disabled": true, "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "resource_group_id": "ResourceGroupID", "owning_account": "OwningAccount", "catalog_filters": {"include_all": true, "category_filters": {"mapKey": {"include": false, "filter": {"filter_terms": ["FilterTerms"]}}}, "id_filters": {"include": {"filter_terms": ["FilterTerms"]}, "exclude": {"filter_terms": ["FilterTerms"]}}}, "kind": "Kind", "metadata": {"anyKey": "anyValue"}, "target_account_contexts": [{"api_key": "APIKey", "trusted_profile": {"trusted_profile_id": "TrustedProfileID", "catalog_crn": "CatalogCRN", "catalog_name": "CatalogName", "target_service_id": "TargetServiceID"}, "name": "Name", "label": "Label", "project_id": "ProjectID"}]}`)
				}))
			})
			It(`Invoke ReplaceCatalog successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the Feature model
				featureModel := new(catalogmanagementv1.Feature)
				featureModel.Title = core.StringPtr("testString")
				featureModel.TitleI18n = map[string]string{"key1": "testString"}
				featureModel.Description = core.StringPtr("testString")
				featureModel.DescriptionI18n = map[string]string{"key1": "testString"}

				// Construct an instance of the FilterTerms model
				filterTermsModel := new(catalogmanagementv1.FilterTerms)
				filterTermsModel.FilterTerms = []string{"testString"}

				// Construct an instance of the CategoryFilter model
				categoryFilterModel := new(catalogmanagementv1.CategoryFilter)
				categoryFilterModel.Include = core.BoolPtr(true)
				categoryFilterModel.Filter = filterTermsModel

				// Construct an instance of the IDFilter model
				idFilterModel := new(catalogmanagementv1.IDFilter)
				idFilterModel.Include = filterTermsModel
				idFilterModel.Exclude = filterTermsModel

				// Construct an instance of the Filters model
				filtersModel := new(catalogmanagementv1.Filters)
				filtersModel.IncludeAll = core.BoolPtr(true)
				filtersModel.CategoryFilters = map[string]catalogmanagementv1.CategoryFilter{"key1": *categoryFilterModel}
				filtersModel.IDFilters = idFilterModel
				filtersModel.CategoryFilters["foo"] = *categoryFilterModel

				// Construct an instance of the TrustedProfileInfo model
				trustedProfileInfoModel := new(catalogmanagementv1.TrustedProfileInfo)
				trustedProfileInfoModel.TrustedProfileID = core.StringPtr("testString")
				trustedProfileInfoModel.CatalogCRN = core.StringPtr("testString")
				trustedProfileInfoModel.CatalogName = core.StringPtr("testString")
				trustedProfileInfoModel.TargetServiceID = core.StringPtr("testString")

				// Construct an instance of the TargetAccountContext model
				targetAccountContextModel := new(catalogmanagementv1.TargetAccountContext)
				targetAccountContextModel.APIKey = core.StringPtr("testString")
				targetAccountContextModel.TrustedProfile = trustedProfileInfoModel
				targetAccountContextModel.Name = core.StringPtr("testString")
				targetAccountContextModel.Label = core.StringPtr("testString")
				targetAccountContextModel.ProjectID = core.StringPtr("testString")

				// Construct an instance of the ReplaceCatalogOptions model
				replaceCatalogOptionsModel := new(catalogmanagementv1.ReplaceCatalogOptions)
				replaceCatalogOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				replaceCatalogOptionsModel.ID = core.StringPtr("testString")
				replaceCatalogOptionsModel.Rev = core.StringPtr("testString")
				replaceCatalogOptionsModel.Label = core.StringPtr("testString")
				replaceCatalogOptionsModel.LabelI18n = map[string]string{"key1": "testString"}
				replaceCatalogOptionsModel.ShortDescription = core.StringPtr("testString")
				replaceCatalogOptionsModel.ShortDescriptionI18n = map[string]string{"key1": "testString"}
				replaceCatalogOptionsModel.CatalogIconURL = core.StringPtr("testString")
				replaceCatalogOptionsModel.CatalogBannerURL = core.StringPtr("testString")
				replaceCatalogOptionsModel.Tags = []string{"testString"}
				replaceCatalogOptionsModel.Features = []catalogmanagementv1.Feature{*featureModel}
				replaceCatalogOptionsModel.Disabled = core.BoolPtr(true)
				replaceCatalogOptionsModel.ResourceGroupID = core.StringPtr("testString")
				replaceCatalogOptionsModel.OwningAccount = core.StringPtr("testString")
				replaceCatalogOptionsModel.CatalogFilters = filtersModel
				replaceCatalogOptionsModel.Kind = core.StringPtr("testString")
				replaceCatalogOptionsModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				replaceCatalogOptionsModel.TargetAccountContexts = []catalogmanagementv1.TargetAccountContext{*targetAccountContextModel}
				replaceCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.ReplaceCatalogWithContext(ctx, replaceCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.ReplaceCatalog(replaceCatalogOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.ReplaceCatalogWithContext(ctx, replaceCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(replaceCatalogPath))
					Expect(req.Method).To(Equal("PUT"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "catalog_icon_url": "CatalogIconURL", "catalog_banner_url": "CatalogBannerURL", "tags": ["Tags"], "url": "URL", "crn": "CRN", "offerings_url": "OfferingsURL", "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "disabled": true, "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "resource_group_id": "ResourceGroupID", "owning_account": "OwningAccount", "catalog_filters": {"include_all": true, "category_filters": {"mapKey": {"include": false, "filter": {"filter_terms": ["FilterTerms"]}}}, "id_filters": {"include": {"filter_terms": ["FilterTerms"]}, "exclude": {"filter_terms": ["FilterTerms"]}}}, "kind": "Kind", "metadata": {"anyKey": "anyValue"}, "target_account_contexts": [{"api_key": "APIKey", "trusted_profile": {"trusted_profile_id": "TrustedProfileID", "catalog_crn": "CatalogCRN", "catalog_name": "CatalogName", "target_service_id": "TargetServiceID"}, "name": "Name", "label": "Label", "project_id": "ProjectID"}]}`)
				}))
			})
			It(`Invoke ReplaceCatalog successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.ReplaceCatalog(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the Feature model
				featureModel := new(catalogmanagementv1.Feature)
				featureModel.Title = core.StringPtr("testString")
				featureModel.TitleI18n = map[string]string{"key1": "testString"}
				featureModel.Description = core.StringPtr("testString")
				featureModel.DescriptionI18n = map[string]string{"key1": "testString"}

				// Construct an instance of the FilterTerms model
				filterTermsModel := new(catalogmanagementv1.FilterTerms)
				filterTermsModel.FilterTerms = []string{"testString"}

				// Construct an instance of the CategoryFilter model
				categoryFilterModel := new(catalogmanagementv1.CategoryFilter)
				categoryFilterModel.Include = core.BoolPtr(true)
				categoryFilterModel.Filter = filterTermsModel

				// Construct an instance of the IDFilter model
				idFilterModel := new(catalogmanagementv1.IDFilter)
				idFilterModel.Include = filterTermsModel
				idFilterModel.Exclude = filterTermsModel

				// Construct an instance of the Filters model
				filtersModel := new(catalogmanagementv1.Filters)
				filtersModel.IncludeAll = core.BoolPtr(true)
				filtersModel.CategoryFilters = map[string]catalogmanagementv1.CategoryFilter{"key1": *categoryFilterModel}
				filtersModel.IDFilters = idFilterModel
				filtersModel.CategoryFilters["foo"] = *categoryFilterModel

				// Construct an instance of the TrustedProfileInfo model
				trustedProfileInfoModel := new(catalogmanagementv1.TrustedProfileInfo)
				trustedProfileInfoModel.TrustedProfileID = core.StringPtr("testString")
				trustedProfileInfoModel.CatalogCRN = core.StringPtr("testString")
				trustedProfileInfoModel.CatalogName = core.StringPtr("testString")
				trustedProfileInfoModel.TargetServiceID = core.StringPtr("testString")

				// Construct an instance of the TargetAccountContext model
				targetAccountContextModel := new(catalogmanagementv1.TargetAccountContext)
				targetAccountContextModel.APIKey = core.StringPtr("testString")
				targetAccountContextModel.TrustedProfile = trustedProfileInfoModel
				targetAccountContextModel.Name = core.StringPtr("testString")
				targetAccountContextModel.Label = core.StringPtr("testString")
				targetAccountContextModel.ProjectID = core.StringPtr("testString")

				// Construct an instance of the ReplaceCatalogOptions model
				replaceCatalogOptionsModel := new(catalogmanagementv1.ReplaceCatalogOptions)
				replaceCatalogOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				replaceCatalogOptionsModel.ID = core.StringPtr("testString")
				replaceCatalogOptionsModel.Rev = core.StringPtr("testString")
				replaceCatalogOptionsModel.Label = core.StringPtr("testString")
				replaceCatalogOptionsModel.LabelI18n = map[string]string{"key1": "testString"}
				replaceCatalogOptionsModel.ShortDescription = core.StringPtr("testString")
				replaceCatalogOptionsModel.ShortDescriptionI18n = map[string]string{"key1": "testString"}
				replaceCatalogOptionsModel.CatalogIconURL = core.StringPtr("testString")
				replaceCatalogOptionsModel.CatalogBannerURL = core.StringPtr("testString")
				replaceCatalogOptionsModel.Tags = []string{"testString"}
				replaceCatalogOptionsModel.Features = []catalogmanagementv1.Feature{*featureModel}
				replaceCatalogOptionsModel.Disabled = core.BoolPtr(true)
				replaceCatalogOptionsModel.ResourceGroupID = core.StringPtr("testString")
				replaceCatalogOptionsModel.OwningAccount = core.StringPtr("testString")
				replaceCatalogOptionsModel.CatalogFilters = filtersModel
				replaceCatalogOptionsModel.Kind = core.StringPtr("testString")
				replaceCatalogOptionsModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				replaceCatalogOptionsModel.TargetAccountContexts = []catalogmanagementv1.TargetAccountContext{*targetAccountContextModel}
				replaceCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.ReplaceCatalog(replaceCatalogOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ReplaceCatalog with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the Feature model
				featureModel := new(catalogmanagementv1.Feature)
				featureModel.Title = core.StringPtr("testString")
				featureModel.TitleI18n = map[string]string{"key1": "testString"}
				featureModel.Description = core.StringPtr("testString")
				featureModel.DescriptionI18n = map[string]string{"key1": "testString"}

				// Construct an instance of the FilterTerms model
				filterTermsModel := new(catalogmanagementv1.FilterTerms)
				filterTermsModel.FilterTerms = []string{"testString"}

				// Construct an instance of the CategoryFilter model
				categoryFilterModel := new(catalogmanagementv1.CategoryFilter)
				categoryFilterModel.Include = core.BoolPtr(true)
				categoryFilterModel.Filter = filterTermsModel

				// Construct an instance of the IDFilter model
				idFilterModel := new(catalogmanagementv1.IDFilter)
				idFilterModel.Include = filterTermsModel
				idFilterModel.Exclude = filterTermsModel

				// Construct an instance of the Filters model
				filtersModel := new(catalogmanagementv1.Filters)
				filtersModel.IncludeAll = core.BoolPtr(true)
				filtersModel.CategoryFilters = map[string]catalogmanagementv1.CategoryFilter{"key1": *categoryFilterModel}
				filtersModel.IDFilters = idFilterModel
				filtersModel.CategoryFilters["foo"] = *categoryFilterModel

				// Construct an instance of the TrustedProfileInfo model
				trustedProfileInfoModel := new(catalogmanagementv1.TrustedProfileInfo)
				trustedProfileInfoModel.TrustedProfileID = core.StringPtr("testString")
				trustedProfileInfoModel.CatalogCRN = core.StringPtr("testString")
				trustedProfileInfoModel.CatalogName = core.StringPtr("testString")
				trustedProfileInfoModel.TargetServiceID = core.StringPtr("testString")

				// Construct an instance of the TargetAccountContext model
				targetAccountContextModel := new(catalogmanagementv1.TargetAccountContext)
				targetAccountContextModel.APIKey = core.StringPtr("testString")
				targetAccountContextModel.TrustedProfile = trustedProfileInfoModel
				targetAccountContextModel.Name = core.StringPtr("testString")
				targetAccountContextModel.Label = core.StringPtr("testString")
				targetAccountContextModel.ProjectID = core.StringPtr("testString")

				// Construct an instance of the ReplaceCatalogOptions model
				replaceCatalogOptionsModel := new(catalogmanagementv1.ReplaceCatalogOptions)
				replaceCatalogOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				replaceCatalogOptionsModel.ID = core.StringPtr("testString")
				replaceCatalogOptionsModel.Rev = core.StringPtr("testString")
				replaceCatalogOptionsModel.Label = core.StringPtr("testString")
				replaceCatalogOptionsModel.LabelI18n = map[string]string{"key1": "testString"}
				replaceCatalogOptionsModel.ShortDescription = core.StringPtr("testString")
				replaceCatalogOptionsModel.ShortDescriptionI18n = map[string]string{"key1": "testString"}
				replaceCatalogOptionsModel.CatalogIconURL = core.StringPtr("testString")
				replaceCatalogOptionsModel.CatalogBannerURL = core.StringPtr("testString")
				replaceCatalogOptionsModel.Tags = []string{"testString"}
				replaceCatalogOptionsModel.Features = []catalogmanagementv1.Feature{*featureModel}
				replaceCatalogOptionsModel.Disabled = core.BoolPtr(true)
				replaceCatalogOptionsModel.ResourceGroupID = core.StringPtr("testString")
				replaceCatalogOptionsModel.OwningAccount = core.StringPtr("testString")
				replaceCatalogOptionsModel.CatalogFilters = filtersModel
				replaceCatalogOptionsModel.Kind = core.StringPtr("testString")
				replaceCatalogOptionsModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				replaceCatalogOptionsModel.TargetAccountContexts = []catalogmanagementv1.TargetAccountContext{*targetAccountContextModel}
				replaceCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.ReplaceCatalog(replaceCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the ReplaceCatalogOptions model with no property values
				replaceCatalogOptionsModelNew := new(catalogmanagementv1.ReplaceCatalogOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.ReplaceCatalog(replaceCatalogOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ReplaceCatalog successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the Feature model
				featureModel := new(catalogmanagementv1.Feature)
				featureModel.Title = core.StringPtr("testString")
				featureModel.TitleI18n = map[string]string{"key1": "testString"}
				featureModel.Description = core.StringPtr("testString")
				featureModel.DescriptionI18n = map[string]string{"key1": "testString"}

				// Construct an instance of the FilterTerms model
				filterTermsModel := new(catalogmanagementv1.FilterTerms)
				filterTermsModel.FilterTerms = []string{"testString"}

				// Construct an instance of the CategoryFilter model
				categoryFilterModel := new(catalogmanagementv1.CategoryFilter)
				categoryFilterModel.Include = core.BoolPtr(true)
				categoryFilterModel.Filter = filterTermsModel

				// Construct an instance of the IDFilter model
				idFilterModel := new(catalogmanagementv1.IDFilter)
				idFilterModel.Include = filterTermsModel
				idFilterModel.Exclude = filterTermsModel

				// Construct an instance of the Filters model
				filtersModel := new(catalogmanagementv1.Filters)
				filtersModel.IncludeAll = core.BoolPtr(true)
				filtersModel.CategoryFilters = map[string]catalogmanagementv1.CategoryFilter{"key1": *categoryFilterModel}
				filtersModel.IDFilters = idFilterModel
				filtersModel.CategoryFilters["foo"] = *categoryFilterModel

				// Construct an instance of the TrustedProfileInfo model
				trustedProfileInfoModel := new(catalogmanagementv1.TrustedProfileInfo)
				trustedProfileInfoModel.TrustedProfileID = core.StringPtr("testString")
				trustedProfileInfoModel.CatalogCRN = core.StringPtr("testString")
				trustedProfileInfoModel.CatalogName = core.StringPtr("testString")
				trustedProfileInfoModel.TargetServiceID = core.StringPtr("testString")

				// Construct an instance of the TargetAccountContext model
				targetAccountContextModel := new(catalogmanagementv1.TargetAccountContext)
				targetAccountContextModel.APIKey = core.StringPtr("testString")
				targetAccountContextModel.TrustedProfile = trustedProfileInfoModel
				targetAccountContextModel.Name = core.StringPtr("testString")
				targetAccountContextModel.Label = core.StringPtr("testString")
				targetAccountContextModel.ProjectID = core.StringPtr("testString")

				// Construct an instance of the ReplaceCatalogOptions model
				replaceCatalogOptionsModel := new(catalogmanagementv1.ReplaceCatalogOptions)
				replaceCatalogOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				replaceCatalogOptionsModel.ID = core.StringPtr("testString")
				replaceCatalogOptionsModel.Rev = core.StringPtr("testString")
				replaceCatalogOptionsModel.Label = core.StringPtr("testString")
				replaceCatalogOptionsModel.LabelI18n = map[string]string{"key1": "testString"}
				replaceCatalogOptionsModel.ShortDescription = core.StringPtr("testString")
				replaceCatalogOptionsModel.ShortDescriptionI18n = map[string]string{"key1": "testString"}
				replaceCatalogOptionsModel.CatalogIconURL = core.StringPtr("testString")
				replaceCatalogOptionsModel.CatalogBannerURL = core.StringPtr("testString")
				replaceCatalogOptionsModel.Tags = []string{"testString"}
				replaceCatalogOptionsModel.Features = []catalogmanagementv1.Feature{*featureModel}
				replaceCatalogOptionsModel.Disabled = core.BoolPtr(true)
				replaceCatalogOptionsModel.ResourceGroupID = core.StringPtr("testString")
				replaceCatalogOptionsModel.OwningAccount = core.StringPtr("testString")
				replaceCatalogOptionsModel.CatalogFilters = filtersModel
				replaceCatalogOptionsModel.Kind = core.StringPtr("testString")
				replaceCatalogOptionsModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				replaceCatalogOptionsModel.TargetAccountContexts = []catalogmanagementv1.TargetAccountContext{*targetAccountContextModel}
				replaceCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.ReplaceCatalog(replaceCatalogOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`DeleteCatalog(deleteCatalogOptions *DeleteCatalogOptions)`, func() {
		deleteCatalogPath := "/catalogs/testString"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deleteCatalogPath))
					Expect(req.Method).To(Equal("DELETE"))

					res.WriteHeader(200)
				}))
			})
			It(`Invoke DeleteCatalog successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := catalogManagementService.DeleteCatalog(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the DeleteCatalogOptions model
				deleteCatalogOptionsModel := new(catalogmanagementv1.DeleteCatalogOptions)
				deleteCatalogOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				deleteCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = catalogManagementService.DeleteCatalog(deleteCatalogOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke DeleteCatalog with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the DeleteCatalogOptions model
				deleteCatalogOptionsModel := new(catalogmanagementv1.DeleteCatalogOptions)
				deleteCatalogOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				deleteCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := catalogManagementService.DeleteCatalog(deleteCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the DeleteCatalogOptions model with no property values
				deleteCatalogOptionsModelNew := new(catalogmanagementv1.DeleteCatalogOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = catalogManagementService.DeleteCatalog(deleteCatalogOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListCatalogAudits(listCatalogAuditsOptions *ListCatalogAuditsOptions) - Operation response error`, func() {
		listCatalogAuditsPath := "/catalogs/testString/audits"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listCatalogAuditsPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.URL.Query()["start"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(10))}))
					// TODO: Add check for lookupnames query parameter
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ListCatalogAudits with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ListCatalogAuditsOptions model
				listCatalogAuditsOptionsModel := new(catalogmanagementv1.ListCatalogAuditsOptions)
				listCatalogAuditsOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				listCatalogAuditsOptionsModel.Start = core.StringPtr("testString")
				listCatalogAuditsOptionsModel.Limit = core.Int64Ptr(int64(10))
				listCatalogAuditsOptionsModel.Lookupnames = core.BoolPtr(true)
				listCatalogAuditsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.ListCatalogAudits(listCatalogAuditsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.ListCatalogAudits(listCatalogAuditsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListCatalogAudits(listCatalogAuditsOptions *ListCatalogAuditsOptions)`, func() {
		listCatalogAuditsPath := "/catalogs/testString/audits"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listCatalogAuditsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.URL.Query()["start"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(10))}))
					// TODO: Add check for lookupnames query parameter
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"start": "Start", "limit": 5, "total_count": 10, "resource_count": 13, "first": {"href": "Href", "start": "Start"}, "next": {"href": "Href", "start": "Start"}, "prev": {"href": "Href", "start": "Start"}, "last": {"href": "Href", "start": "Start"}, "audits": [{"id": "ID", "_rev": "Rev", "created": "2019-01-01T12:00:00.000Z", "change_type": "ChangeType", "target_type": "TargetType", "target_id": "TargetID", "who_email": "WhoEmail", "who_delegate_email": "WhoDelegateEmail", "message": "Message"}]}`)
				}))
			})
			It(`Invoke ListCatalogAudits successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the ListCatalogAuditsOptions model
				listCatalogAuditsOptionsModel := new(catalogmanagementv1.ListCatalogAuditsOptions)
				listCatalogAuditsOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				listCatalogAuditsOptionsModel.Start = core.StringPtr("testString")
				listCatalogAuditsOptionsModel.Limit = core.Int64Ptr(int64(10))
				listCatalogAuditsOptionsModel.Lookupnames = core.BoolPtr(true)
				listCatalogAuditsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.ListCatalogAuditsWithContext(ctx, listCatalogAuditsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.ListCatalogAudits(listCatalogAuditsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.ListCatalogAuditsWithContext(ctx, listCatalogAuditsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listCatalogAuditsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.URL.Query()["start"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(10))}))
					// TODO: Add check for lookupnames query parameter
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"start": "Start", "limit": 5, "total_count": 10, "resource_count": 13, "first": {"href": "Href", "start": "Start"}, "next": {"href": "Href", "start": "Start"}, "prev": {"href": "Href", "start": "Start"}, "last": {"href": "Href", "start": "Start"}, "audits": [{"id": "ID", "_rev": "Rev", "created": "2019-01-01T12:00:00.000Z", "change_type": "ChangeType", "target_type": "TargetType", "target_id": "TargetID", "who_email": "WhoEmail", "who_delegate_email": "WhoDelegateEmail", "message": "Message"}]}`)
				}))
			})
			It(`Invoke ListCatalogAudits successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.ListCatalogAudits(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ListCatalogAuditsOptions model
				listCatalogAuditsOptionsModel := new(catalogmanagementv1.ListCatalogAuditsOptions)
				listCatalogAuditsOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				listCatalogAuditsOptionsModel.Start = core.StringPtr("testString")
				listCatalogAuditsOptionsModel.Limit = core.Int64Ptr(int64(10))
				listCatalogAuditsOptionsModel.Lookupnames = core.BoolPtr(true)
				listCatalogAuditsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.ListCatalogAudits(listCatalogAuditsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ListCatalogAudits with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ListCatalogAuditsOptions model
				listCatalogAuditsOptionsModel := new(catalogmanagementv1.ListCatalogAuditsOptions)
				listCatalogAuditsOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				listCatalogAuditsOptionsModel.Start = core.StringPtr("testString")
				listCatalogAuditsOptionsModel.Limit = core.Int64Ptr(int64(10))
				listCatalogAuditsOptionsModel.Lookupnames = core.BoolPtr(true)
				listCatalogAuditsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.ListCatalogAudits(listCatalogAuditsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the ListCatalogAuditsOptions model with no property values
				listCatalogAuditsOptionsModelNew := new(catalogmanagementv1.ListCatalogAuditsOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.ListCatalogAudits(listCatalogAuditsOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ListCatalogAudits successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ListCatalogAuditsOptions model
				listCatalogAuditsOptionsModel := new(catalogmanagementv1.ListCatalogAuditsOptions)
				listCatalogAuditsOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				listCatalogAuditsOptionsModel.Start = core.StringPtr("testString")
				listCatalogAuditsOptionsModel.Limit = core.Int64Ptr(int64(10))
				listCatalogAuditsOptionsModel.Lookupnames = core.BoolPtr(true)
				listCatalogAuditsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.ListCatalogAudits(listCatalogAuditsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Test pagination helper method on response`, func() {
			It(`Invoke GetNextStart successfully`, func() {
				responseObject := new(catalogmanagementv1.AuditLogs)
				nextObject := new(catalogmanagementv1.PaginationTokenLink)
				nextObject.Start = core.StringPtr("abc-123")
				responseObject.Next = nextObject

				value, err := responseObject.GetNextStart()
				Expect(err).To(BeNil())
				Expect(value).To(Equal(core.StringPtr("abc-123")))
			})
			It(`Invoke GetNextStart without a "Next" property in the response`, func() {
				responseObject := new(catalogmanagementv1.AuditLogs)

				value, err := responseObject.GetNextStart()
				Expect(err).To(BeNil())
				Expect(value).To(BeNil())
			})
		})
		Context(`Using mock server endpoint - paginated response`, func() {
			BeforeEach(func() {
				var requestNumber int = 0
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listCatalogAuditsPath))
					Expect(req.Method).To(Equal("GET"))

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					requestNumber++
					if requestNumber == 1 {
						fmt.Fprintf(res, "%s", `{"next":{"start":"1"},"total_count":2,"limit":1,"audits":[{"id":"ID","_rev":"Rev","created":"2019-01-01T12:00:00.000Z","change_type":"ChangeType","target_type":"TargetType","target_id":"TargetID","who_email":"WhoEmail","who_delegate_email":"WhoDelegateEmail","message":"Message"}]}`)
					} else if requestNumber == 2 {
						fmt.Fprintf(res, "%s", `{"total_count":2,"limit":1,"audits":[{"id":"ID","_rev":"Rev","created":"2019-01-01T12:00:00.000Z","change_type":"ChangeType","target_type":"TargetType","target_id":"TargetID","who_email":"WhoEmail","who_delegate_email":"WhoDelegateEmail","message":"Message"}]}`)
					} else {
						res.WriteHeader(400)
					}
				}))
			})
			It(`Use CatalogAuditsPager.GetNext successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				listCatalogAuditsOptionsModel := &catalogmanagementv1.ListCatalogAuditsOptions{
					CatalogIdentifier: core.StringPtr("testString"),
					Limit:             core.Int64Ptr(int64(10)),
					Lookupnames:       core.BoolPtr(true),
				}

				pager, err := catalogManagementService.NewCatalogAuditsPager(listCatalogAuditsOptionsModel)
				Expect(err).To(BeNil())
				Expect(pager).ToNot(BeNil())

				var allResults []catalogmanagementv1.AuditLogDigest
				for pager.HasNext() {
					nextPage, err := pager.GetNext()
					Expect(err).To(BeNil())
					Expect(nextPage).ToNot(BeNil())
					allResults = append(allResults, nextPage...)
				}
				Expect(len(allResults)).To(Equal(2))
			})
			It(`Use CatalogAuditsPager.GetAll successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				listCatalogAuditsOptionsModel := &catalogmanagementv1.ListCatalogAuditsOptions{
					CatalogIdentifier: core.StringPtr("testString"),
					Limit:             core.Int64Ptr(int64(10)),
					Lookupnames:       core.BoolPtr(true),
				}

				pager, err := catalogManagementService.NewCatalogAuditsPager(listCatalogAuditsOptionsModel)
				Expect(err).To(BeNil())
				Expect(pager).ToNot(BeNil())

				allResults, err := pager.GetAll()
				Expect(err).To(BeNil())
				Expect(allResults).ToNot(BeNil())
				Expect(len(allResults)).To(Equal(2))
			})
		})
	})
	Describe(`GetCatalogAudit(getCatalogAuditOptions *GetCatalogAuditOptions) - Operation response error`, func() {
		getCatalogAuditPath := "/catalogs/testString/audits/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getCatalogAuditPath))
					Expect(req.Method).To(Equal("GET"))
					// TODO: Add check for lookupnames query parameter
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetCatalogAudit with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetCatalogAuditOptions model
				getCatalogAuditOptionsModel := new(catalogmanagementv1.GetCatalogAuditOptions)
				getCatalogAuditOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getCatalogAuditOptionsModel.AuditlogIdentifier = core.StringPtr("testString")
				getCatalogAuditOptionsModel.Lookupnames = core.BoolPtr(true)
				getCatalogAuditOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.GetCatalogAudit(getCatalogAuditOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.GetCatalogAudit(getCatalogAuditOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetCatalogAudit(getCatalogAuditOptions *GetCatalogAuditOptions)`, func() {
		getCatalogAuditPath := "/catalogs/testString/audits/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getCatalogAuditPath))
					Expect(req.Method).To(Equal("GET"))

					// TODO: Add check for lookupnames query parameter
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "created": "2019-01-01T12:00:00.000Z", "change_type": "ChangeType", "target_type": "TargetType", "target_id": "TargetID", "who_email": "WhoEmail", "who_delegate_email": "WhoDelegateEmail", "message": "Message", "gid": "Gid", "who_id": "WhoID", "who_name": "WhoName", "who_delegate_id": "WhoDelegateID", "who_delegate_name": "WhoDelegateName", "data": "anyValue"}`)
				}))
			})
			It(`Invoke GetCatalogAudit successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the GetCatalogAuditOptions model
				getCatalogAuditOptionsModel := new(catalogmanagementv1.GetCatalogAuditOptions)
				getCatalogAuditOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getCatalogAuditOptionsModel.AuditlogIdentifier = core.StringPtr("testString")
				getCatalogAuditOptionsModel.Lookupnames = core.BoolPtr(true)
				getCatalogAuditOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.GetCatalogAuditWithContext(ctx, getCatalogAuditOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.GetCatalogAudit(getCatalogAuditOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.GetCatalogAuditWithContext(ctx, getCatalogAuditOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getCatalogAuditPath))
					Expect(req.Method).To(Equal("GET"))

					// TODO: Add check for lookupnames query parameter
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "created": "2019-01-01T12:00:00.000Z", "change_type": "ChangeType", "target_type": "TargetType", "target_id": "TargetID", "who_email": "WhoEmail", "who_delegate_email": "WhoDelegateEmail", "message": "Message", "gid": "Gid", "who_id": "WhoID", "who_name": "WhoName", "who_delegate_id": "WhoDelegateID", "who_delegate_name": "WhoDelegateName", "data": "anyValue"}`)
				}))
			})
			It(`Invoke GetCatalogAudit successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.GetCatalogAudit(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetCatalogAuditOptions model
				getCatalogAuditOptionsModel := new(catalogmanagementv1.GetCatalogAuditOptions)
				getCatalogAuditOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getCatalogAuditOptionsModel.AuditlogIdentifier = core.StringPtr("testString")
				getCatalogAuditOptionsModel.Lookupnames = core.BoolPtr(true)
				getCatalogAuditOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.GetCatalogAudit(getCatalogAuditOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetCatalogAudit with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetCatalogAuditOptions model
				getCatalogAuditOptionsModel := new(catalogmanagementv1.GetCatalogAuditOptions)
				getCatalogAuditOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getCatalogAuditOptionsModel.AuditlogIdentifier = core.StringPtr("testString")
				getCatalogAuditOptionsModel.Lookupnames = core.BoolPtr(true)
				getCatalogAuditOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.GetCatalogAudit(getCatalogAuditOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetCatalogAuditOptions model with no property values
				getCatalogAuditOptionsModelNew := new(catalogmanagementv1.GetCatalogAuditOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.GetCatalogAudit(getCatalogAuditOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetCatalogAudit successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetCatalogAuditOptions model
				getCatalogAuditOptionsModel := new(catalogmanagementv1.GetCatalogAuditOptions)
				getCatalogAuditOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getCatalogAuditOptionsModel.AuditlogIdentifier = core.StringPtr("testString")
				getCatalogAuditOptionsModel.Lookupnames = core.BoolPtr(true)
				getCatalogAuditOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.GetCatalogAudit(getCatalogAuditOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListEnterpriseAudits(listEnterpriseAuditsOptions *ListEnterpriseAuditsOptions) - Operation response error`, func() {
		listEnterpriseAuditsPath := "/enterprises/testString/audits"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listEnterpriseAuditsPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.URL.Query()["start"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(10))}))
					// TODO: Add check for lookupnames query parameter
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ListEnterpriseAudits with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ListEnterpriseAuditsOptions model
				listEnterpriseAuditsOptionsModel := new(catalogmanagementv1.ListEnterpriseAuditsOptions)
				listEnterpriseAuditsOptionsModel.EnterpriseIdentifier = core.StringPtr("testString")
				listEnterpriseAuditsOptionsModel.Start = core.StringPtr("testString")
				listEnterpriseAuditsOptionsModel.Limit = core.Int64Ptr(int64(10))
				listEnterpriseAuditsOptionsModel.Lookupnames = core.BoolPtr(true)
				listEnterpriseAuditsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.ListEnterpriseAudits(listEnterpriseAuditsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.ListEnterpriseAudits(listEnterpriseAuditsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListEnterpriseAudits(listEnterpriseAuditsOptions *ListEnterpriseAuditsOptions)`, func() {
		listEnterpriseAuditsPath := "/enterprises/testString/audits"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listEnterpriseAuditsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.URL.Query()["start"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(10))}))
					// TODO: Add check for lookupnames query parameter
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"start": "Start", "limit": 5, "total_count": 10, "resource_count": 13, "first": {"href": "Href", "start": "Start"}, "next": {"href": "Href", "start": "Start"}, "prev": {"href": "Href", "start": "Start"}, "last": {"href": "Href", "start": "Start"}, "audits": [{"id": "ID", "_rev": "Rev", "created": "2019-01-01T12:00:00.000Z", "change_type": "ChangeType", "target_type": "TargetType", "target_id": "TargetID", "who_email": "WhoEmail", "who_delegate_email": "WhoDelegateEmail", "message": "Message"}]}`)
				}))
			})
			It(`Invoke ListEnterpriseAudits successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the ListEnterpriseAuditsOptions model
				listEnterpriseAuditsOptionsModel := new(catalogmanagementv1.ListEnterpriseAuditsOptions)
				listEnterpriseAuditsOptionsModel.EnterpriseIdentifier = core.StringPtr("testString")
				listEnterpriseAuditsOptionsModel.Start = core.StringPtr("testString")
				listEnterpriseAuditsOptionsModel.Limit = core.Int64Ptr(int64(10))
				listEnterpriseAuditsOptionsModel.Lookupnames = core.BoolPtr(true)
				listEnterpriseAuditsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.ListEnterpriseAuditsWithContext(ctx, listEnterpriseAuditsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.ListEnterpriseAudits(listEnterpriseAuditsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.ListEnterpriseAuditsWithContext(ctx, listEnterpriseAuditsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listEnterpriseAuditsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.URL.Query()["start"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(10))}))
					// TODO: Add check for lookupnames query parameter
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"start": "Start", "limit": 5, "total_count": 10, "resource_count": 13, "first": {"href": "Href", "start": "Start"}, "next": {"href": "Href", "start": "Start"}, "prev": {"href": "Href", "start": "Start"}, "last": {"href": "Href", "start": "Start"}, "audits": [{"id": "ID", "_rev": "Rev", "created": "2019-01-01T12:00:00.000Z", "change_type": "ChangeType", "target_type": "TargetType", "target_id": "TargetID", "who_email": "WhoEmail", "who_delegate_email": "WhoDelegateEmail", "message": "Message"}]}`)
				}))
			})
			It(`Invoke ListEnterpriseAudits successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.ListEnterpriseAudits(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ListEnterpriseAuditsOptions model
				listEnterpriseAuditsOptionsModel := new(catalogmanagementv1.ListEnterpriseAuditsOptions)
				listEnterpriseAuditsOptionsModel.EnterpriseIdentifier = core.StringPtr("testString")
				listEnterpriseAuditsOptionsModel.Start = core.StringPtr("testString")
				listEnterpriseAuditsOptionsModel.Limit = core.Int64Ptr(int64(10))
				listEnterpriseAuditsOptionsModel.Lookupnames = core.BoolPtr(true)
				listEnterpriseAuditsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.ListEnterpriseAudits(listEnterpriseAuditsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ListEnterpriseAudits with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ListEnterpriseAuditsOptions model
				listEnterpriseAuditsOptionsModel := new(catalogmanagementv1.ListEnterpriseAuditsOptions)
				listEnterpriseAuditsOptionsModel.EnterpriseIdentifier = core.StringPtr("testString")
				listEnterpriseAuditsOptionsModel.Start = core.StringPtr("testString")
				listEnterpriseAuditsOptionsModel.Limit = core.Int64Ptr(int64(10))
				listEnterpriseAuditsOptionsModel.Lookupnames = core.BoolPtr(true)
				listEnterpriseAuditsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.ListEnterpriseAudits(listEnterpriseAuditsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the ListEnterpriseAuditsOptions model with no property values
				listEnterpriseAuditsOptionsModelNew := new(catalogmanagementv1.ListEnterpriseAuditsOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.ListEnterpriseAudits(listEnterpriseAuditsOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ListEnterpriseAudits successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ListEnterpriseAuditsOptions model
				listEnterpriseAuditsOptionsModel := new(catalogmanagementv1.ListEnterpriseAuditsOptions)
				listEnterpriseAuditsOptionsModel.EnterpriseIdentifier = core.StringPtr("testString")
				listEnterpriseAuditsOptionsModel.Start = core.StringPtr("testString")
				listEnterpriseAuditsOptionsModel.Limit = core.Int64Ptr(int64(10))
				listEnterpriseAuditsOptionsModel.Lookupnames = core.BoolPtr(true)
				listEnterpriseAuditsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.ListEnterpriseAudits(listEnterpriseAuditsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Test pagination helper method on response`, func() {
			It(`Invoke GetNextStart successfully`, func() {
				responseObject := new(catalogmanagementv1.AuditLogs)
				nextObject := new(catalogmanagementv1.PaginationTokenLink)
				nextObject.Start = core.StringPtr("abc-123")
				responseObject.Next = nextObject

				value, err := responseObject.GetNextStart()
				Expect(err).To(BeNil())
				Expect(value).To(Equal(core.StringPtr("abc-123")))
			})
			It(`Invoke GetNextStart without a "Next" property in the response`, func() {
				responseObject := new(catalogmanagementv1.AuditLogs)

				value, err := responseObject.GetNextStart()
				Expect(err).To(BeNil())
				Expect(value).To(BeNil())
			})
		})
		Context(`Using mock server endpoint - paginated response`, func() {
			BeforeEach(func() {
				var requestNumber int = 0
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listEnterpriseAuditsPath))
					Expect(req.Method).To(Equal("GET"))

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					requestNumber++
					if requestNumber == 1 {
						fmt.Fprintf(res, "%s", `{"next":{"start":"1"},"total_count":2,"limit":1,"audits":[{"id":"ID","_rev":"Rev","created":"2019-01-01T12:00:00.000Z","change_type":"ChangeType","target_type":"TargetType","target_id":"TargetID","who_email":"WhoEmail","who_delegate_email":"WhoDelegateEmail","message":"Message"}]}`)
					} else if requestNumber == 2 {
						fmt.Fprintf(res, "%s", `{"total_count":2,"limit":1,"audits":[{"id":"ID","_rev":"Rev","created":"2019-01-01T12:00:00.000Z","change_type":"ChangeType","target_type":"TargetType","target_id":"TargetID","who_email":"WhoEmail","who_delegate_email":"WhoDelegateEmail","message":"Message"}]}`)
					} else {
						res.WriteHeader(400)
					}
				}))
			})
			It(`Use EnterpriseAuditsPager.GetNext successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				listEnterpriseAuditsOptionsModel := &catalogmanagementv1.ListEnterpriseAuditsOptions{
					EnterpriseIdentifier: core.StringPtr("testString"),
					Limit:                core.Int64Ptr(int64(10)),
					Lookupnames:          core.BoolPtr(true),
				}

				pager, err := catalogManagementService.NewEnterpriseAuditsPager(listEnterpriseAuditsOptionsModel)
				Expect(err).To(BeNil())
				Expect(pager).ToNot(BeNil())

				var allResults []catalogmanagementv1.AuditLogDigest
				for pager.HasNext() {
					nextPage, err := pager.GetNext()
					Expect(err).To(BeNil())
					Expect(nextPage).ToNot(BeNil())
					allResults = append(allResults, nextPage...)
				}
				Expect(len(allResults)).To(Equal(2))
			})
			It(`Use EnterpriseAuditsPager.GetAll successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				listEnterpriseAuditsOptionsModel := &catalogmanagementv1.ListEnterpriseAuditsOptions{
					EnterpriseIdentifier: core.StringPtr("testString"),
					Limit:                core.Int64Ptr(int64(10)),
					Lookupnames:          core.BoolPtr(true),
				}

				pager, err := catalogManagementService.NewEnterpriseAuditsPager(listEnterpriseAuditsOptionsModel)
				Expect(err).To(BeNil())
				Expect(pager).ToNot(BeNil())

				allResults, err := pager.GetAll()
				Expect(err).To(BeNil())
				Expect(allResults).ToNot(BeNil())
				Expect(len(allResults)).To(Equal(2))
			})
		})
	})
	Describe(`GetEnterpriseAudit(getEnterpriseAuditOptions *GetEnterpriseAuditOptions) - Operation response error`, func() {
		getEnterpriseAuditPath := "/enterprises/testString/audits/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getEnterpriseAuditPath))
					Expect(req.Method).To(Equal("GET"))
					// TODO: Add check for lookupnames query parameter
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetEnterpriseAudit with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetEnterpriseAuditOptions model
				getEnterpriseAuditOptionsModel := new(catalogmanagementv1.GetEnterpriseAuditOptions)
				getEnterpriseAuditOptionsModel.EnterpriseIdentifier = core.StringPtr("testString")
				getEnterpriseAuditOptionsModel.AuditlogIdentifier = core.StringPtr("testString")
				getEnterpriseAuditOptionsModel.Lookupnames = core.BoolPtr(true)
				getEnterpriseAuditOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.GetEnterpriseAudit(getEnterpriseAuditOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.GetEnterpriseAudit(getEnterpriseAuditOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetEnterpriseAudit(getEnterpriseAuditOptions *GetEnterpriseAuditOptions)`, func() {
		getEnterpriseAuditPath := "/enterprises/testString/audits/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getEnterpriseAuditPath))
					Expect(req.Method).To(Equal("GET"))

					// TODO: Add check for lookupnames query parameter
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "created": "2019-01-01T12:00:00.000Z", "change_type": "ChangeType", "target_type": "TargetType", "target_id": "TargetID", "who_email": "WhoEmail", "who_delegate_email": "WhoDelegateEmail", "message": "Message", "gid": "Gid", "who_id": "WhoID", "who_name": "WhoName", "who_delegate_id": "WhoDelegateID", "who_delegate_name": "WhoDelegateName", "data": "anyValue"}`)
				}))
			})
			It(`Invoke GetEnterpriseAudit successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the GetEnterpriseAuditOptions model
				getEnterpriseAuditOptionsModel := new(catalogmanagementv1.GetEnterpriseAuditOptions)
				getEnterpriseAuditOptionsModel.EnterpriseIdentifier = core.StringPtr("testString")
				getEnterpriseAuditOptionsModel.AuditlogIdentifier = core.StringPtr("testString")
				getEnterpriseAuditOptionsModel.Lookupnames = core.BoolPtr(true)
				getEnterpriseAuditOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.GetEnterpriseAuditWithContext(ctx, getEnterpriseAuditOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.GetEnterpriseAudit(getEnterpriseAuditOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.GetEnterpriseAuditWithContext(ctx, getEnterpriseAuditOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getEnterpriseAuditPath))
					Expect(req.Method).To(Equal("GET"))

					// TODO: Add check for lookupnames query parameter
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "created": "2019-01-01T12:00:00.000Z", "change_type": "ChangeType", "target_type": "TargetType", "target_id": "TargetID", "who_email": "WhoEmail", "who_delegate_email": "WhoDelegateEmail", "message": "Message", "gid": "Gid", "who_id": "WhoID", "who_name": "WhoName", "who_delegate_id": "WhoDelegateID", "who_delegate_name": "WhoDelegateName", "data": "anyValue"}`)
				}))
			})
			It(`Invoke GetEnterpriseAudit successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.GetEnterpriseAudit(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetEnterpriseAuditOptions model
				getEnterpriseAuditOptionsModel := new(catalogmanagementv1.GetEnterpriseAuditOptions)
				getEnterpriseAuditOptionsModel.EnterpriseIdentifier = core.StringPtr("testString")
				getEnterpriseAuditOptionsModel.AuditlogIdentifier = core.StringPtr("testString")
				getEnterpriseAuditOptionsModel.Lookupnames = core.BoolPtr(true)
				getEnterpriseAuditOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.GetEnterpriseAudit(getEnterpriseAuditOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetEnterpriseAudit with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetEnterpriseAuditOptions model
				getEnterpriseAuditOptionsModel := new(catalogmanagementv1.GetEnterpriseAuditOptions)
				getEnterpriseAuditOptionsModel.EnterpriseIdentifier = core.StringPtr("testString")
				getEnterpriseAuditOptionsModel.AuditlogIdentifier = core.StringPtr("testString")
				getEnterpriseAuditOptionsModel.Lookupnames = core.BoolPtr(true)
				getEnterpriseAuditOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.GetEnterpriseAudit(getEnterpriseAuditOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetEnterpriseAuditOptions model with no property values
				getEnterpriseAuditOptionsModelNew := new(catalogmanagementv1.GetEnterpriseAuditOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.GetEnterpriseAudit(getEnterpriseAuditOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetEnterpriseAudit successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetEnterpriseAuditOptions model
				getEnterpriseAuditOptionsModel := new(catalogmanagementv1.GetEnterpriseAuditOptions)
				getEnterpriseAuditOptionsModel.EnterpriseIdentifier = core.StringPtr("testString")
				getEnterpriseAuditOptionsModel.AuditlogIdentifier = core.StringPtr("testString")
				getEnterpriseAuditOptionsModel.Lookupnames = core.BoolPtr(true)
				getEnterpriseAuditOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.GetEnterpriseAudit(getEnterpriseAuditOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetConsumptionOfferings(getConsumptionOfferingsOptions *GetConsumptionOfferingsOptions) - Operation response error`, func() {
		getConsumptionOfferingsPath := "/offerings"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getConsumptionOfferingsPath))
					Expect(req.Method).To(Equal("GET"))
					// TODO: Add check for digest query parameter
					Expect(req.URL.Query()["catalog"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["select"]).To(Equal([]string{"all"}))
					// TODO: Add check for includeHidden query parameter
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(10))}))
					Expect(req.URL.Query()["offset"]).To(Equal([]string{fmt.Sprint(int64(0))}))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetConsumptionOfferings with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetConsumptionOfferingsOptions model
				getConsumptionOfferingsOptionsModel := new(catalogmanagementv1.GetConsumptionOfferingsOptions)
				getConsumptionOfferingsOptionsModel.Digest = core.BoolPtr(true)
				getConsumptionOfferingsOptionsModel.Catalog = core.StringPtr("testString")
				getConsumptionOfferingsOptionsModel.Select = core.StringPtr("all")
				getConsumptionOfferingsOptionsModel.IncludeHidden = core.BoolPtr(true)
				getConsumptionOfferingsOptionsModel.Limit = core.Int64Ptr(int64(10))
				getConsumptionOfferingsOptionsModel.Offset = core.Int64Ptr(int64(0))
				getConsumptionOfferingsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.GetConsumptionOfferings(getConsumptionOfferingsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.GetConsumptionOfferings(getConsumptionOfferingsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetConsumptionOfferings(getConsumptionOfferingsOptions *GetConsumptionOfferingsOptions)`, func() {
		getConsumptionOfferingsPath := "/offerings"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getConsumptionOfferingsPath))
					Expect(req.Method).To(Equal("GET"))

					// TODO: Add check for digest query parameter
					Expect(req.URL.Query()["catalog"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["select"]).To(Equal([]string{"all"}))
					// TODO: Add check for includeHidden query parameter
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(10))}))
					Expect(req.URL.Query()["offset"]).To(Equal([]string{fmt.Sprint(int64(0))}))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"offset": 6, "limit": 5, "total_count": 10, "resource_count": 13, "first": "First", "last": "Last", "prev": "Prev", "next": "Next", "resources": [{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "name": "Name", "offering_icon_url": "OfferingIconURL", "offering_docs_url": "OfferingDocsURL", "offering_support_url": "OfferingSupportURL", "tags": ["Tags"], "keywords": ["Keywords"], "rating": {"one_star_count": 12, "two_star_count": 12, "three_star_count": 14, "four_star_count": 13}, "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "kinds": [{"id": "ID", "format_kind": "FormatKind", "format_kind_label": "FormatKindLabel", "install_kind": "InstallKind", "install_kind_label": "InstallKindLabel", "target_kind": "TargetKind", "target_kind_label": "TargetKindLabel", "metadata": {"anyKey": "anyValue"}, "tags": ["Tags"], "additional_features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "versions": [{"id": "ID", "_rev": "Rev", "crn": "CRN", "version": "Version", "flavor": {"name": "Name", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "index": 5}, "sha": "Sha", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "offering_id": "OfferingID", "catalog_id": "CatalogID", "kind_id": "KindID", "tags": ["Tags"], "repo_url": "RepoURL", "source_url": "SourceURL", "tgz_url": "TgzURL", "configuration": [{"key": "Key", "type": "Type", "default_value": "anyValue", "display_name": "DisplayName", "value_constraint": "ValueConstraint", "description": "Description", "required": true, "options": ["anyValue"], "hidden": true, "custom_config": {"type": "Type", "grouping": "Grouping", "original_grouping": "OriginalGrouping", "grouping_index": 13, "config_constraints": {"anyKey": "anyValue"}, "associations": {"parameters": [{"name": "Name", "optionsRefresh": true}]}}, "type_metadata": "TypeMetadata"}], "outputs": [{"key": "Key", "description": "Description"}], "iam_permissions": [{"service_name": "ServiceName", "role_crns": ["RoleCrns"], "resources": [{"name": "Name", "description": "Description", "role_crns": ["RoleCrns"]}]}], "metadata": {"anyKey": "anyValue"}, "validation": {"validated": "2019-01-01T12:00:00.000Z", "requested": "2019-01-01T12:00:00.000Z", "state": "State", "last_operation": "LastOperation", "target": {"anyKey": "anyValue"}, "message": "Message"}, "required_resources": [{"type": "mem", "value": "anyValue"}], "single_instance": true, "schematics_env_values": {"value": "[{\"name\": \"TF_LOG\",\"value\": \"TRACE\",\"secure\": false,\"hidden\": false}]", "sm_ref": "cmsm_v1:{\"name\": \"envVarSecret\",\"id\":\"1234567890\",\"service_id\":\"crn:v1:bluemix:public:secrets-manager:eu-gb:a/1234567890:1234567890::\",\"service_name\":\"My SM Instance\",\"group_id\":\"1234567890\",\"group_name\":\"My SM Group\",\"resource_group_id\":\"1234567890\",\"region\":\"eu-gb\",\"type\":\"arbitrary\"}"}, "install": {"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}, "pre_install": [{"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}], "scripts": {"mapKey": {"short_description": "ShortDescription", "type": "ansible", "path": "scripts/validate-post-ansible-playbook.yaml", "stage": "pre", "action": "validate"}}, "entitlement": {"provider_name": "ProviderName", "provider_id": "ProviderID", "product_id": "ProductID", "part_numbers": ["PartNumbers"], "image_repo_name": "ImageRepoName"}, "licenses": [{"id": "ID", "name": "Name", "type": "Type", "url": "URL", "description": "Description"}], "image_manifest_url": "ImageManifestURL", "deprecated": true, "package_version": "PackageVersion", "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "version_locator": "VersionLocator", "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "whitelisted_accounts": ["WhitelistedAccounts"], "image_pull_key_name": "ImagePullKeyName", "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "solution_info": {"architecture_diagrams": [{"diagram": {"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "cost_estimate": {"version": "Version", "currency": "Currency", "projects": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "pastBreakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "breakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "diff": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}}], "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}, "totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "pastTotalHourlyCost": "PastTotalHourlyCost", "pastTotalMonthlyCost": "PastTotalMonthlyCost", "diffTotalHourlyCost": "DiffTotalHourlyCost", "diffTotalMonthlyCost": "DiffTotalMonthlyCost", "timeGenerated": "2019-01-01T12:00:00.000Z"}, "dependencies": [{"catalog_id": "CatalogID", "id": "ID", "name": "Name", "kind": "Kind", "version": "Version", "description": "Description", "default_flavor": "DefaultFlavor", "flavors": ["Flavors"], "optional": true, "on_by_default": false}], "install_type": "InstallType"}, "is_consumable": true, "compliance_v3": {"authority": "Authority", "claims": {"profiles": [{"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}], "controls": [{"profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "names": ["Names"]}]}, "evaluations": [{"scan_id": "ScanID", "account_id": "AccountID", "profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "result": {"failure_count": 12, "scan_time": "2019-01-01T12:00:00.000Z", "error_message": "ErrorMessage", "complete_scan": true, "unscanned_resources": ["UnscannedResources"]}, "controls": [{"id": "ID", "name": "Name", "description": "Description", "specifications": [{"id": "ID", "description": "Description", "component_name": "ComponentName", "assessments": [{"id": "ID", "description": "Description", "version": "Version", "type": "Type", "method": "Method", "ui_href": "UIHref"}], "ui_href": "UIHref"}], "failure_count": 12, "pass_count": 9, "parent": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "parent_name": "ParentName", "specifications": [{"id": "ID", "description": "Description", "component_name": "ComponentName", "assessments": [{"id": "ID", "description": "Description", "version": "Version", "type": "Type", "method": "Method", "ui_href": "UIHref"}], "ui_href": "UIHref"}], "ui_href": "UIHref"}, "ui_href": "UIHref"}]}]}, "change_notices": {"breaking": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "new": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "update": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}]}, "plan_ids": ["PlanIds"], "stack": {"anyKey": "anyValue"}, "minimum_compatible_version": "MinimumCompatibleVersion"}], "all_versions": {"first": {"href": "Href", "start": "Start"}, "next": {"href": "Href", "start": "Start"}}}], "publish": {"pc_managed": false, "approval_type": "ApprovalType", "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "original_crn": "OriginalCRN", "public_crn": "PublicCRN", "approval_record": {"anyKey": "anyValue"}, "permit_ibm_public_publish": true, "ibm_approved": false, "public_approved": true}, "pc_managed": false, "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "public_original_crn": "PublicOriginalCRN", "publish_public_crn": "PublishPublicCRN", "portal_approval_record": "PortalApprovalRecord", "portal_ui_url": "PortalUIURL", "catalog_id": "CatalogID", "catalog_name": "CatalogName", "metadata": {"anyKey": "anyValue"}, "disclaimer": "Disclaimer", "hidden": true, "provider": "Provider", "provider_info": {"id": "ID", "name": "Name"}, "repo_info": {"token": "Token", "type": "Type"}, "image_pull_keys": [{"name": "Name", "value": "Value", "description": "Description"}], "support": {"url": "URL", "process": "Process", "process_i18n": {"mapKey": "Inner"}, "locations": ["Locations"], "support_details": [{"type": "Type", "contact": "Contact", "response_wait_time": {"value": 5, "type": "Type"}, "availability": {"times": [{"day": 3, "start_time": "StartTime", "end_time": "EndTime"}], "timezone": "Timezone", "always_available": false}}], "support_escalation": {"escalation_wait_time": {"value": 5, "type": "Type"}, "response_wait_time": {"value": 5, "type": "Type"}, "contact": "Contact"}, "support_type": "SupportType"}, "media": [{"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}], "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "product_kind": "ProductKind", "badges": [{"id": "ID", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}, "icon": "Icon", "authority": "Authority", "tag": "Tag", "learn_more_links": {"first_party": "FirstParty", "third_party": "ThirdParty"}, "constraints": [{"type": "Type", "rule": "anyValue"}]}], "plans": [{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "offering_id": "OfferingID", "catalog_id": "CatalogID", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "name": "Name", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "pricing_tags": ["PricingTags"], "version_range": {"kinds": ["Kinds"], "version": "Version", "flavors": ["Flavors"]}, "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "metadata": {"anyKey": "anyValue"}, "publish_approved": false}]}]}`)
				}))
			})
			It(`Invoke GetConsumptionOfferings successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the GetConsumptionOfferingsOptions model
				getConsumptionOfferingsOptionsModel := new(catalogmanagementv1.GetConsumptionOfferingsOptions)
				getConsumptionOfferingsOptionsModel.Digest = core.BoolPtr(true)
				getConsumptionOfferingsOptionsModel.Catalog = core.StringPtr("testString")
				getConsumptionOfferingsOptionsModel.Select = core.StringPtr("all")
				getConsumptionOfferingsOptionsModel.IncludeHidden = core.BoolPtr(true)
				getConsumptionOfferingsOptionsModel.Limit = core.Int64Ptr(int64(10))
				getConsumptionOfferingsOptionsModel.Offset = core.Int64Ptr(int64(0))
				getConsumptionOfferingsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.GetConsumptionOfferingsWithContext(ctx, getConsumptionOfferingsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.GetConsumptionOfferings(getConsumptionOfferingsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.GetConsumptionOfferingsWithContext(ctx, getConsumptionOfferingsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getConsumptionOfferingsPath))
					Expect(req.Method).To(Equal("GET"))

					// TODO: Add check for digest query parameter
					Expect(req.URL.Query()["catalog"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["select"]).To(Equal([]string{"all"}))
					// TODO: Add check for includeHidden query parameter
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(10))}))
					Expect(req.URL.Query()["offset"]).To(Equal([]string{fmt.Sprint(int64(0))}))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"offset": 6, "limit": 5, "total_count": 10, "resource_count": 13, "first": "First", "last": "Last", "prev": "Prev", "next": "Next", "resources": [{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "name": "Name", "offering_icon_url": "OfferingIconURL", "offering_docs_url": "OfferingDocsURL", "offering_support_url": "OfferingSupportURL", "tags": ["Tags"], "keywords": ["Keywords"], "rating": {"one_star_count": 12, "two_star_count": 12, "three_star_count": 14, "four_star_count": 13}, "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "kinds": [{"id": "ID", "format_kind": "FormatKind", "format_kind_label": "FormatKindLabel", "install_kind": "InstallKind", "install_kind_label": "InstallKindLabel", "target_kind": "TargetKind", "target_kind_label": "TargetKindLabel", "metadata": {"anyKey": "anyValue"}, "tags": ["Tags"], "additional_features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "versions": [{"id": "ID", "_rev": "Rev", "crn": "CRN", "version": "Version", "flavor": {"name": "Name", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "index": 5}, "sha": "Sha", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "offering_id": "OfferingID", "catalog_id": "CatalogID", "kind_id": "KindID", "tags": ["Tags"], "repo_url": "RepoURL", "source_url": "SourceURL", "tgz_url": "TgzURL", "configuration": [{"key": "Key", "type": "Type", "default_value": "anyValue", "display_name": "DisplayName", "value_constraint": "ValueConstraint", "description": "Description", "required": true, "options": ["anyValue"], "hidden": true, "custom_config": {"type": "Type", "grouping": "Grouping", "original_grouping": "OriginalGrouping", "grouping_index": 13, "config_constraints": {"anyKey": "anyValue"}, "associations": {"parameters": [{"name": "Name", "optionsRefresh": true}]}}, "type_metadata": "TypeMetadata"}], "outputs": [{"key": "Key", "description": "Description"}], "iam_permissions": [{"service_name": "ServiceName", "role_crns": ["RoleCrns"], "resources": [{"name": "Name", "description": "Description", "role_crns": ["RoleCrns"]}]}], "metadata": {"anyKey": "anyValue"}, "validation": {"validated": "2019-01-01T12:00:00.000Z", "requested": "2019-01-01T12:00:00.000Z", "state": "State", "last_operation": "LastOperation", "target": {"anyKey": "anyValue"}, "message": "Message"}, "required_resources": [{"type": "mem", "value": "anyValue"}], "single_instance": true, "schematics_env_values": {"value": "[{\"name\": \"TF_LOG\",\"value\": \"TRACE\",\"secure\": false,\"hidden\": false}]", "sm_ref": "cmsm_v1:{\"name\": \"envVarSecret\",\"id\":\"1234567890\",\"service_id\":\"crn:v1:bluemix:public:secrets-manager:eu-gb:a/1234567890:1234567890::\",\"service_name\":\"My SM Instance\",\"group_id\":\"1234567890\",\"group_name\":\"My SM Group\",\"resource_group_id\":\"1234567890\",\"region\":\"eu-gb\",\"type\":\"arbitrary\"}"}, "install": {"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}, "pre_install": [{"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}], "scripts": {"mapKey": {"short_description": "ShortDescription", "type": "ansible", "path": "scripts/validate-post-ansible-playbook.yaml", "stage": "pre", "action": "validate"}}, "entitlement": {"provider_name": "ProviderName", "provider_id": "ProviderID", "product_id": "ProductID", "part_numbers": ["PartNumbers"], "image_repo_name": "ImageRepoName"}, "licenses": [{"id": "ID", "name": "Name", "type": "Type", "url": "URL", "description": "Description"}], "image_manifest_url": "ImageManifestURL", "deprecated": true, "package_version": "PackageVersion", "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "version_locator": "VersionLocator", "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "whitelisted_accounts": ["WhitelistedAccounts"], "image_pull_key_name": "ImagePullKeyName", "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "solution_info": {"architecture_diagrams": [{"diagram": {"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "cost_estimate": {"version": "Version", "currency": "Currency", "projects": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "pastBreakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "breakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "diff": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}}], "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}, "totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "pastTotalHourlyCost": "PastTotalHourlyCost", "pastTotalMonthlyCost": "PastTotalMonthlyCost", "diffTotalHourlyCost": "DiffTotalHourlyCost", "diffTotalMonthlyCost": "DiffTotalMonthlyCost", "timeGenerated": "2019-01-01T12:00:00.000Z"}, "dependencies": [{"catalog_id": "CatalogID", "id": "ID", "name": "Name", "kind": "Kind", "version": "Version", "description": "Description", "default_flavor": "DefaultFlavor", "flavors": ["Flavors"], "optional": true, "on_by_default": false}], "install_type": "InstallType"}, "is_consumable": true, "compliance_v3": {"authority": "Authority", "claims": {"profiles": [{"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}], "controls": [{"profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "names": ["Names"]}]}, "evaluations": [{"scan_id": "ScanID", "account_id": "AccountID", "profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "result": {"failure_count": 12, "scan_time": "2019-01-01T12:00:00.000Z", "error_message": "ErrorMessage", "complete_scan": true, "unscanned_resources": ["UnscannedResources"]}, "controls": [{"id": "ID", "name": "Name", "description": "Description", "specifications": [{"id": "ID", "description": "Description", "component_name": "ComponentName", "assessments": [{"id": "ID", "description": "Description", "version": "Version", "type": "Type", "method": "Method", "ui_href": "UIHref"}], "ui_href": "UIHref"}], "failure_count": 12, "pass_count": 9, "parent": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "parent_name": "ParentName", "specifications": [{"id": "ID", "description": "Description", "component_name": "ComponentName", "assessments": [{"id": "ID", "description": "Description", "version": "Version", "type": "Type", "method": "Method", "ui_href": "UIHref"}], "ui_href": "UIHref"}], "ui_href": "UIHref"}, "ui_href": "UIHref"}]}]}, "change_notices": {"breaking": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "new": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "update": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}]}, "plan_ids": ["PlanIds"], "stack": {"anyKey": "anyValue"}, "minimum_compatible_version": "MinimumCompatibleVersion"}], "all_versions": {"first": {"href": "Href", "start": "Start"}, "next": {"href": "Href", "start": "Start"}}}], "publish": {"pc_managed": false, "approval_type": "ApprovalType", "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "original_crn": "OriginalCRN", "public_crn": "PublicCRN", "approval_record": {"anyKey": "anyValue"}, "permit_ibm_public_publish": true, "ibm_approved": false, "public_approved": true}, "pc_managed": false, "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "public_original_crn": "PublicOriginalCRN", "publish_public_crn": "PublishPublicCRN", "portal_approval_record": "PortalApprovalRecord", "portal_ui_url": "PortalUIURL", "catalog_id": "CatalogID", "catalog_name": "CatalogName", "metadata": {"anyKey": "anyValue"}, "disclaimer": "Disclaimer", "hidden": true, "provider": "Provider", "provider_info": {"id": "ID", "name": "Name"}, "repo_info": {"token": "Token", "type": "Type"}, "image_pull_keys": [{"name": "Name", "value": "Value", "description": "Description"}], "support": {"url": "URL", "process": "Process", "process_i18n": {"mapKey": "Inner"}, "locations": ["Locations"], "support_details": [{"type": "Type", "contact": "Contact", "response_wait_time": {"value": 5, "type": "Type"}, "availability": {"times": [{"day": 3, "start_time": "StartTime", "end_time": "EndTime"}], "timezone": "Timezone", "always_available": false}}], "support_escalation": {"escalation_wait_time": {"value": 5, "type": "Type"}, "response_wait_time": {"value": 5, "type": "Type"}, "contact": "Contact"}, "support_type": "SupportType"}, "media": [{"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}], "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "product_kind": "ProductKind", "badges": [{"id": "ID", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}, "icon": "Icon", "authority": "Authority", "tag": "Tag", "learn_more_links": {"first_party": "FirstParty", "third_party": "ThirdParty"}, "constraints": [{"type": "Type", "rule": "anyValue"}]}], "plans": [{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "offering_id": "OfferingID", "catalog_id": "CatalogID", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "name": "Name", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "pricing_tags": ["PricingTags"], "version_range": {"kinds": ["Kinds"], "version": "Version", "flavors": ["Flavors"]}, "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "metadata": {"anyKey": "anyValue"}, "publish_approved": false}]}]}`)
				}))
			})
			It(`Invoke GetConsumptionOfferings successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.GetConsumptionOfferings(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetConsumptionOfferingsOptions model
				getConsumptionOfferingsOptionsModel := new(catalogmanagementv1.GetConsumptionOfferingsOptions)
				getConsumptionOfferingsOptionsModel.Digest = core.BoolPtr(true)
				getConsumptionOfferingsOptionsModel.Catalog = core.StringPtr("testString")
				getConsumptionOfferingsOptionsModel.Select = core.StringPtr("all")
				getConsumptionOfferingsOptionsModel.IncludeHidden = core.BoolPtr(true)
				getConsumptionOfferingsOptionsModel.Limit = core.Int64Ptr(int64(10))
				getConsumptionOfferingsOptionsModel.Offset = core.Int64Ptr(int64(0))
				getConsumptionOfferingsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.GetConsumptionOfferings(getConsumptionOfferingsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetConsumptionOfferings with error: Operation request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetConsumptionOfferingsOptions model
				getConsumptionOfferingsOptionsModel := new(catalogmanagementv1.GetConsumptionOfferingsOptions)
				getConsumptionOfferingsOptionsModel.Digest = core.BoolPtr(true)
				getConsumptionOfferingsOptionsModel.Catalog = core.StringPtr("testString")
				getConsumptionOfferingsOptionsModel.Select = core.StringPtr("all")
				getConsumptionOfferingsOptionsModel.IncludeHidden = core.BoolPtr(true)
				getConsumptionOfferingsOptionsModel.Limit = core.Int64Ptr(int64(10))
				getConsumptionOfferingsOptionsModel.Offset = core.Int64Ptr(int64(0))
				getConsumptionOfferingsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.GetConsumptionOfferings(getConsumptionOfferingsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetConsumptionOfferings successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetConsumptionOfferingsOptions model
				getConsumptionOfferingsOptionsModel := new(catalogmanagementv1.GetConsumptionOfferingsOptions)
				getConsumptionOfferingsOptionsModel.Digest = core.BoolPtr(true)
				getConsumptionOfferingsOptionsModel.Catalog = core.StringPtr("testString")
				getConsumptionOfferingsOptionsModel.Select = core.StringPtr("all")
				getConsumptionOfferingsOptionsModel.IncludeHidden = core.BoolPtr(true)
				getConsumptionOfferingsOptionsModel.Limit = core.Int64Ptr(int64(10))
				getConsumptionOfferingsOptionsModel.Offset = core.Int64Ptr(int64(0))
				getConsumptionOfferingsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.GetConsumptionOfferings(getConsumptionOfferingsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Test pagination helper method on response`, func() {
			It(`Invoke GetNextOffset successfully`, func() {
				responseObject := new(catalogmanagementv1.OfferingSearchResult)
				responseObject.Next = core.StringPtr("ibm.com?offset=135")

				value, err := responseObject.GetNextOffset()
				Expect(err).To(BeNil())
				Expect(value).To(Equal(core.Int64Ptr(int64(135))))
			})
			It(`Invoke GetNextOffset without a "Next" property in the response`, func() {
				responseObject := new(catalogmanagementv1.OfferingSearchResult)

				value, err := responseObject.GetNextOffset()
				Expect(err).To(BeNil())
				Expect(value).To(BeNil())
			})
			It(`Invoke GetNextOffset without any query params in the "Next" URL`, func() {
				responseObject := new(catalogmanagementv1.OfferingSearchResult)
				responseObject.Next = core.StringPtr("ibm.com")

				value, err := responseObject.GetNextOffset()
				Expect(err).To(BeNil())
				Expect(value).To(BeNil())
			})
			It(`Invoke GetNextOffset with a non-integer query param in the "Next" URL`, func() {
				responseObject := new(catalogmanagementv1.OfferingSearchResult)
				responseObject.Next = core.StringPtr("ibm.com?offset=tiger")

				value, err := responseObject.GetNextOffset()
				Expect(err).NotTo(BeNil())
				Expect(value).To(BeNil())
			})
		})
		Context(`Using mock server endpoint - paginated response`, func() {
			BeforeEach(func() {
				var requestNumber int = 0
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getConsumptionOfferingsPath))
					Expect(req.Method).To(Equal("GET"))

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					requestNumber++
					if requestNumber == 1 {
						fmt.Fprintf(res, "%s", `{"next":"https://myhost.com/somePath?offset=1","total_count":2,"limit":1,"resources":[{"id":"ID","_rev":"Rev","url":"URL","crn":"CRN","label":"Label","label_i18n":{"mapKey":"Inner"},"name":"Name","offering_icon_url":"OfferingIconURL","offering_docs_url":"OfferingDocsURL","offering_support_url":"OfferingSupportURL","tags":["Tags"],"keywords":["Keywords"],"rating":{"one_star_count":12,"two_star_count":12,"three_star_count":14,"four_star_count":13},"created":"2019-01-01T12:00:00.000Z","updated":"2019-01-01T12:00:00.000Z","short_description":"ShortDescription","short_description_i18n":{"mapKey":"Inner"},"long_description":"LongDescription","long_description_i18n":{"mapKey":"Inner"},"features":[{"title":"Title","title_i18n":{"mapKey":"Inner"},"description":"Description","description_i18n":{"mapKey":"Inner"}}],"kinds":[{"id":"ID","format_kind":"FormatKind","format_kind_label":"FormatKindLabel","install_kind":"InstallKind","install_kind_label":"InstallKindLabel","target_kind":"TargetKind","target_kind_label":"TargetKindLabel","metadata":{"anyKey":"anyValue"},"tags":["Tags"],"additional_features":[{"title":"Title","title_i18n":{"mapKey":"Inner"},"description":"Description","description_i18n":{"mapKey":"Inner"}}],"created":"2019-01-01T12:00:00.000Z","updated":"2019-01-01T12:00:00.000Z","versions":[{"id":"ID","_rev":"Rev","crn":"CRN","version":"Version","flavor":{"name":"Name","label":"Label","label_i18n":{"mapKey":"Inner"},"index":5},"sha":"Sha","created":"2019-01-01T12:00:00.000Z","updated":"2019-01-01T12:00:00.000Z","offering_id":"OfferingID","catalog_id":"CatalogID","kind_id":"KindID","tags":["Tags"],"repo_url":"RepoURL","source_url":"SourceURL","tgz_url":"TgzURL","configuration":[{"key":"Key","type":"Type","default_value":"anyValue","display_name":"DisplayName","value_constraint":"ValueConstraint","description":"Description","required":true,"options":["anyValue"],"hidden":true,"custom_config":{"type":"Type","grouping":"Grouping","original_grouping":"OriginalGrouping","grouping_index":13,"config_constraints":{"anyKey":"anyValue"},"associations":{"parameters":[{"name":"Name","optionsRefresh":true}]}},"type_metadata":"TypeMetadata"}],"outputs":[{"key":"Key","description":"Description"}],"iam_permissions":[{"service_name":"ServiceName","role_crns":["RoleCrns"],"resources":[{"name":"Name","description":"Description","role_crns":["RoleCrns"]}]}],"metadata":{"anyKey":"anyValue"},"validation":{"validated":"2019-01-01T12:00:00.000Z","requested":"2019-01-01T12:00:00.000Z","state":"State","last_operation":"LastOperation","target":{"anyKey":"anyValue"},"message":"Message"},"required_resources":[{"type":"mem","value":"anyValue"}],"single_instance":true,"schematics_env_values":{"value":"[{\"name\": \"TF_LOG\",\"value\": \"TRACE\",\"secure\": false,\"hidden\": false}]","sm_ref":"cmsm_v1:{\"name\": \"envVarSecret\",\"id\":\"1234567890\",\"service_id\":\"crn:v1:bluemix:public:secrets-manager:eu-gb:a/1234567890:1234567890::\",\"service_name\":\"My SM Instance\",\"group_id\":\"1234567890\",\"group_name\":\"My SM Group\",\"resource_group_id\":\"1234567890\",\"region\":\"eu-gb\",\"type\":\"arbitrary\"}"},"install":{"instructions":"Instructions","instructions_i18n":{"mapKey":"Inner"},"script":"Script","script_permission":"ScriptPermission","delete_script":"DeleteScript","scope":"Scope"},"pre_install":[{"instructions":"Instructions","instructions_i18n":{"mapKey":"Inner"},"script":"Script","script_permission":"ScriptPermission","delete_script":"DeleteScript","scope":"Scope"}],"scripts":{"mapKey":{"short_description":"ShortDescription","type":"ansible","path":"scripts/validate-post-ansible-playbook.yaml","stage":"pre","action":"validate"}},"entitlement":{"provider_name":"ProviderName","provider_id":"ProviderID","product_id":"ProductID","part_numbers":["PartNumbers"],"image_repo_name":"ImageRepoName"},"licenses":[{"id":"ID","name":"Name","type":"Type","url":"URL","description":"Description"}],"image_manifest_url":"ImageManifestURL","deprecated":true,"package_version":"PackageVersion","state":{"current":"Current","current_entered":"2019-01-01T12:00:00.000Z","pending":"Pending","pending_requested":"2019-01-01T12:00:00.000Z","previous":"Previous"},"version_locator":"VersionLocator","long_description":"LongDescription","long_description_i18n":{"mapKey":"Inner"},"whitelisted_accounts":["WhitelistedAccounts"],"image_pull_key_name":"ImagePullKeyName","deprecate_pending":{"deprecate_date":"2019-01-01T12:00:00.000Z","deprecate_state":"DeprecateState","description":"Description"},"solution_info":{"architecture_diagrams":[{"diagram":{"url":"URL","api_url":"APIURL","url_proxy":{"url":"URL","sha":"Sha"},"caption":"Caption","caption_i18n":{"mapKey":"Inner"},"type":"Type","thumbnail_url":"ThumbnailURL"},"description":"Description","description_i18n":{"mapKey":"Inner"}}],"features":[{"title":"Title","title_i18n":{"mapKey":"Inner"},"description":"Description","description_i18n":{"mapKey":"Inner"}}],"cost_estimate":{"version":"Version","currency":"Currency","projects":[{"name":"Name","metadata":{"anyKey":"anyValue"},"pastBreakdown":{"totalHourlyCost":"TotalHourlyCost","totalMonthlyCost":"TotalMonthlyCost","resources":[{"name":"Name","metadata":{"anyKey":"anyValue"},"hourlyCost":"HourlyCost","monthlyCost":"MonthlyCost","costComponents":[{"name":"Name","unit":"Unit","hourlyQuantity":"HourlyQuantity","monthlyQuantity":"MonthlyQuantity","price":"Price","hourlyCost":"HourlyCost","monthlyCost":"MonthlyCost"}]}]},"breakdown":{"totalHourlyCost":"TotalHourlyCost","totalMonthlyCost":"TotalMonthlyCost","resources":[{"name":"Name","metadata":{"anyKey":"anyValue"},"hourlyCost":"HourlyCost","monthlyCost":"MonthlyCost","costComponents":[{"name":"Name","unit":"Unit","hourlyQuantity":"HourlyQuantity","monthlyQuantity":"MonthlyQuantity","price":"Price","hourlyCost":"HourlyCost","monthlyCost":"MonthlyCost"}]}]},"diff":{"totalHourlyCost":"TotalHourlyCost","totalMonthlyCost":"TotalMonthlyCost","resources":[{"name":"Name","metadata":{"anyKey":"anyValue"},"hourlyCost":"HourlyCost","monthlyCost":"MonthlyCost","costComponents":[{"name":"Name","unit":"Unit","hourlyQuantity":"HourlyQuantity","monthlyQuantity":"MonthlyQuantity","price":"Price","hourlyCost":"HourlyCost","monthlyCost":"MonthlyCost"}]}]},"summary":{"totalDetectedResources":22,"totalSupportedResources":23,"totalUnsupportedResources":25,"totalUsageBasedResources":24,"totalNoPriceResources":21,"unsupportedResourceCounts":{"mapKey":5},"noPriceResourceCounts":{"mapKey":5}}}],"summary":{"totalDetectedResources":22,"totalSupportedResources":23,"totalUnsupportedResources":25,"totalUsageBasedResources":24,"totalNoPriceResources":21,"unsupportedResourceCounts":{"mapKey":5},"noPriceResourceCounts":{"mapKey":5}},"totalHourlyCost":"TotalHourlyCost","totalMonthlyCost":"TotalMonthlyCost","pastTotalHourlyCost":"PastTotalHourlyCost","pastTotalMonthlyCost":"PastTotalMonthlyCost","diffTotalHourlyCost":"DiffTotalHourlyCost","diffTotalMonthlyCost":"DiffTotalMonthlyCost","timeGenerated":"2019-01-01T12:00:00.000Z"},"dependencies":[{"catalog_id":"CatalogID","id":"ID","name":"Name","kind":"Kind","version":"Version","description":"Description","default_flavor":"DefaultFlavor","flavors":["Flavors"],"optional":true,"on_by_default":false}],"install_type":"InstallType"},"is_consumable":true,"compliance_v3":{"authority":"Authority","claims":{"profiles":[{"id":"ID","name":"Name","version":"Version","description":"Description","type":"Type","ui_href":"UIHref"}],"controls":[{"profile":{"id":"ID","name":"Name","version":"Version","description":"Description","type":"Type","ui_href":"UIHref"},"names":["Names"]}]},"evaluations":[{"scan_id":"ScanID","account_id":"AccountID","profile":{"id":"ID","name":"Name","version":"Version","description":"Description","type":"Type","ui_href":"UIHref"},"result":{"failure_count":12,"scan_time":"2019-01-01T12:00:00.000Z","error_message":"ErrorMessage","complete_scan":true,"unscanned_resources":["UnscannedResources"]},"controls":[{"id":"ID","name":"Name","description":"Description","specifications":[{"id":"ID","description":"Description","component_name":"ComponentName","assessments":[{"id":"ID","description":"Description","version":"Version","type":"Type","method":"Method","ui_href":"UIHref"}],"ui_href":"UIHref"}],"failure_count":12,"pass_count":9,"parent":{"id":"ID","name":"Name","version":"Version","description":"Description","profile":{"id":"ID","name":"Name","version":"Version","description":"Description","type":"Type","ui_href":"UIHref"},"parent_name":"ParentName","specifications":[{"id":"ID","description":"Description","component_name":"ComponentName","assessments":[{"id":"ID","description":"Description","version":"Version","type":"Type","method":"Method","ui_href":"UIHref"}],"ui_href":"UIHref"}],"ui_href":"UIHref"},"ui_href":"UIHref"}]}]},"change_notices":{"breaking":[{"title":"Title","title_i18n":{"mapKey":"Inner"},"description":"Description","description_i18n":{"mapKey":"Inner"}}],"new":[{"title":"Title","title_i18n":{"mapKey":"Inner"},"description":"Description","description_i18n":{"mapKey":"Inner"}}],"update":[{"title":"Title","title_i18n":{"mapKey":"Inner"},"description":"Description","description_i18n":{"mapKey":"Inner"}}]},"plan_ids":["PlanIds"],"stack":{"anyKey":"anyValue"},"minimum_compatible_version":"MinimumCompatibleVersion"}],"all_versions":{"first":{"href":"Href","start":"Start"},"next":{"href":"Href","start":"Start"}}}],"publish":{"pc_managed":false,"approval_type":"ApprovalType","publish_approved":false,"share_with_all":true,"share_with_ibm":true,"share_enabled":true,"original_crn":"OriginalCRN","public_crn":"PublicCRN","approval_record":{"anyKey":"anyValue"},"permit_ibm_public_publish":true,"ibm_approved":false,"public_approved":true},"pc_managed":false,"publish_approved":false,"share_with_all":true,"share_with_ibm":true,"share_enabled":true,"public_original_crn":"PublicOriginalCRN","publish_public_crn":"PublishPublicCRN","portal_approval_record":"PortalApprovalRecord","portal_ui_url":"PortalUIURL","catalog_id":"CatalogID","catalog_name":"CatalogName","metadata":{"anyKey":"anyValue"},"disclaimer":"Disclaimer","hidden":true,"provider":"Provider","provider_info":{"id":"ID","name":"Name"},"repo_info":{"token":"Token","type":"Type"},"image_pull_keys":[{"name":"Name","value":"Value","description":"Description"}],"support":{"url":"URL","process":"Process","process_i18n":{"mapKey":"Inner"},"locations":["Locations"],"support_details":[{"type":"Type","contact":"Contact","response_wait_time":{"value":5,"type":"Type"},"availability":{"times":[{"day":3,"start_time":"StartTime","end_time":"EndTime"}],"timezone":"Timezone","always_available":false}}],"support_escalation":{"escalation_wait_time":{"value":5,"type":"Type"},"response_wait_time":{"value":5,"type":"Type"},"contact":"Contact"},"support_type":"SupportType"},"media":[{"url":"URL","api_url":"APIURL","url_proxy":{"url":"URL","sha":"Sha"},"caption":"Caption","caption_i18n":{"mapKey":"Inner"},"type":"Type","thumbnail_url":"ThumbnailURL"}],"deprecate_pending":{"deprecate_date":"2019-01-01T12:00:00.000Z","deprecate_state":"DeprecateState","description":"Description"},"product_kind":"ProductKind","badges":[{"id":"ID","label":"Label","label_i18n":{"mapKey":"Inner"},"description":"Description","description_i18n":{"mapKey":"Inner"},"icon":"Icon","authority":"Authority","tag":"Tag","learn_more_links":{"first_party":"FirstParty","third_party":"ThirdParty"},"constraints":[{"type":"Type","rule":"anyValue"}]}],"plans":[{"id":"ID","_rev":"Rev","url":"URL","crn":"CRN","created":"2019-01-01T12:00:00.000Z","updated":"2019-01-01T12:00:00.000Z","offering_id":"OfferingID","catalog_id":"CatalogID","label":"Label","label_i18n":{"mapKey":"Inner"},"name":"Name","short_description":"ShortDescription","short_description_i18n":{"mapKey":"Inner"},"pricing_tags":["PricingTags"],"version_range":{"kinds":["Kinds"],"version":"Version","flavors":["Flavors"]},"features":[{"title":"Title","title_i18n":{"mapKey":"Inner"},"description":"Description","description_i18n":{"mapKey":"Inner"}}],"state":{"current":"Current","current_entered":"2019-01-01T12:00:00.000Z","pending":"Pending","pending_requested":"2019-01-01T12:00:00.000Z","previous":"Previous"},"deprecate_pending":{"deprecate_date":"2019-01-01T12:00:00.000Z","deprecate_state":"DeprecateState","description":"Description"},"metadata":{"anyKey":"anyValue"},"publish_approved":false}]}]}`)
					} else if requestNumber == 2 {
						fmt.Fprintf(res, "%s", `{"total_count":2,"limit":1,"resources":[{"id":"ID","_rev":"Rev","url":"URL","crn":"CRN","label":"Label","label_i18n":{"mapKey":"Inner"},"name":"Name","offering_icon_url":"OfferingIconURL","offering_docs_url":"OfferingDocsURL","offering_support_url":"OfferingSupportURL","tags":["Tags"],"keywords":["Keywords"],"rating":{"one_star_count":12,"two_star_count":12,"three_star_count":14,"four_star_count":13},"created":"2019-01-01T12:00:00.000Z","updated":"2019-01-01T12:00:00.000Z","short_description":"ShortDescription","short_description_i18n":{"mapKey":"Inner"},"long_description":"LongDescription","long_description_i18n":{"mapKey":"Inner"},"features":[{"title":"Title","title_i18n":{"mapKey":"Inner"},"description":"Description","description_i18n":{"mapKey":"Inner"}}],"kinds":[{"id":"ID","format_kind":"FormatKind","format_kind_label":"FormatKindLabel","install_kind":"InstallKind","install_kind_label":"InstallKindLabel","target_kind":"TargetKind","target_kind_label":"TargetKindLabel","metadata":{"anyKey":"anyValue"},"tags":["Tags"],"additional_features":[{"title":"Title","title_i18n":{"mapKey":"Inner"},"description":"Description","description_i18n":{"mapKey":"Inner"}}],"created":"2019-01-01T12:00:00.000Z","updated":"2019-01-01T12:00:00.000Z","versions":[{"id":"ID","_rev":"Rev","crn":"CRN","version":"Version","flavor":{"name":"Name","label":"Label","label_i18n":{"mapKey":"Inner"},"index":5},"sha":"Sha","created":"2019-01-01T12:00:00.000Z","updated":"2019-01-01T12:00:00.000Z","offering_id":"OfferingID","catalog_id":"CatalogID","kind_id":"KindID","tags":["Tags"],"repo_url":"RepoURL","source_url":"SourceURL","tgz_url":"TgzURL","configuration":[{"key":"Key","type":"Type","default_value":"anyValue","display_name":"DisplayName","value_constraint":"ValueConstraint","description":"Description","required":true,"options":["anyValue"],"hidden":true,"custom_config":{"type":"Type","grouping":"Grouping","original_grouping":"OriginalGrouping","grouping_index":13,"config_constraints":{"anyKey":"anyValue"},"associations":{"parameters":[{"name":"Name","optionsRefresh":true}]}},"type_metadata":"TypeMetadata"}],"outputs":[{"key":"Key","description":"Description"}],"iam_permissions":[{"service_name":"ServiceName","role_crns":["RoleCrns"],"resources":[{"name":"Name","description":"Description","role_crns":["RoleCrns"]}]}],"metadata":{"anyKey":"anyValue"},"validation":{"validated":"2019-01-01T12:00:00.000Z","requested":"2019-01-01T12:00:00.000Z","state":"State","last_operation":"LastOperation","target":{"anyKey":"anyValue"},"message":"Message"},"required_resources":[{"type":"mem","value":"anyValue"}],"single_instance":true,"schematics_env_values":{"value":"[{\"name\": \"TF_LOG\",\"value\": \"TRACE\",\"secure\": false,\"hidden\": false}]","sm_ref":"cmsm_v1:{\"name\": \"envVarSecret\",\"id\":\"1234567890\",\"service_id\":\"crn:v1:bluemix:public:secrets-manager:eu-gb:a/1234567890:1234567890::\",\"service_name\":\"My SM Instance\",\"group_id\":\"1234567890\",\"group_name\":\"My SM Group\",\"resource_group_id\":\"1234567890\",\"region\":\"eu-gb\",\"type\":\"arbitrary\"}"},"install":{"instructions":"Instructions","instructions_i18n":{"mapKey":"Inner"},"script":"Script","script_permission":"ScriptPermission","delete_script":"DeleteScript","scope":"Scope"},"pre_install":[{"instructions":"Instructions","instructions_i18n":{"mapKey":"Inner"},"script":"Script","script_permission":"ScriptPermission","delete_script":"DeleteScript","scope":"Scope"}],"scripts":{"mapKey":{"short_description":"ShortDescription","type":"ansible","path":"scripts/validate-post-ansible-playbook.yaml","stage":"pre","action":"validate"}},"entitlement":{"provider_name":"ProviderName","provider_id":"ProviderID","product_id":"ProductID","part_numbers":["PartNumbers"],"image_repo_name":"ImageRepoName"},"licenses":[{"id":"ID","name":"Name","type":"Type","url":"URL","description":"Description"}],"image_manifest_url":"ImageManifestURL","deprecated":true,"package_version":"PackageVersion","state":{"current":"Current","current_entered":"2019-01-01T12:00:00.000Z","pending":"Pending","pending_requested":"2019-01-01T12:00:00.000Z","previous":"Previous"},"version_locator":"VersionLocator","long_description":"LongDescription","long_description_i18n":{"mapKey":"Inner"},"whitelisted_accounts":["WhitelistedAccounts"],"image_pull_key_name":"ImagePullKeyName","deprecate_pending":{"deprecate_date":"2019-01-01T12:00:00.000Z","deprecate_state":"DeprecateState","description":"Description"},"solution_info":{"architecture_diagrams":[{"diagram":{"url":"URL","api_url":"APIURL","url_proxy":{"url":"URL","sha":"Sha"},"caption":"Caption","caption_i18n":{"mapKey":"Inner"},"type":"Type","thumbnail_url":"ThumbnailURL"},"description":"Description","description_i18n":{"mapKey":"Inner"}}],"features":[{"title":"Title","title_i18n":{"mapKey":"Inner"},"description":"Description","description_i18n":{"mapKey":"Inner"}}],"cost_estimate":{"version":"Version","currency":"Currency","projects":[{"name":"Name","metadata":{"anyKey":"anyValue"},"pastBreakdown":{"totalHourlyCost":"TotalHourlyCost","totalMonthlyCost":"TotalMonthlyCost","resources":[{"name":"Name","metadata":{"anyKey":"anyValue"},"hourlyCost":"HourlyCost","monthlyCost":"MonthlyCost","costComponents":[{"name":"Name","unit":"Unit","hourlyQuantity":"HourlyQuantity","monthlyQuantity":"MonthlyQuantity","price":"Price","hourlyCost":"HourlyCost","monthlyCost":"MonthlyCost"}]}]},"breakdown":{"totalHourlyCost":"TotalHourlyCost","totalMonthlyCost":"TotalMonthlyCost","resources":[{"name":"Name","metadata":{"anyKey":"anyValue"},"hourlyCost":"HourlyCost","monthlyCost":"MonthlyCost","costComponents":[{"name":"Name","unit":"Unit","hourlyQuantity":"HourlyQuantity","monthlyQuantity":"MonthlyQuantity","price":"Price","hourlyCost":"HourlyCost","monthlyCost":"MonthlyCost"}]}]},"diff":{"totalHourlyCost":"TotalHourlyCost","totalMonthlyCost":"TotalMonthlyCost","resources":[{"name":"Name","metadata":{"anyKey":"anyValue"},"hourlyCost":"HourlyCost","monthlyCost":"MonthlyCost","costComponents":[{"name":"Name","unit":"Unit","hourlyQuantity":"HourlyQuantity","monthlyQuantity":"MonthlyQuantity","price":"Price","hourlyCost":"HourlyCost","monthlyCost":"MonthlyCost"}]}]},"summary":{"totalDetectedResources":22,"totalSupportedResources":23,"totalUnsupportedResources":25,"totalUsageBasedResources":24,"totalNoPriceResources":21,"unsupportedResourceCounts":{"mapKey":5},"noPriceResourceCounts":{"mapKey":5}}}],"summary":{"totalDetectedResources":22,"totalSupportedResources":23,"totalUnsupportedResources":25,"totalUsageBasedResources":24,"totalNoPriceResources":21,"unsupportedResourceCounts":{"mapKey":5},"noPriceResourceCounts":{"mapKey":5}},"totalHourlyCost":"TotalHourlyCost","totalMonthlyCost":"TotalMonthlyCost","pastTotalHourlyCost":"PastTotalHourlyCost","pastTotalMonthlyCost":"PastTotalMonthlyCost","diffTotalHourlyCost":"DiffTotalHourlyCost","diffTotalMonthlyCost":"DiffTotalMonthlyCost","timeGenerated":"2019-01-01T12:00:00.000Z"},"dependencies":[{"catalog_id":"CatalogID","id":"ID","name":"Name","kind":"Kind","version":"Version","description":"Description","default_flavor":"DefaultFlavor","flavors":["Flavors"],"optional":true,"on_by_default":false}],"install_type":"InstallType"},"is_consumable":true,"compliance_v3":{"authority":"Authority","claims":{"profiles":[{"id":"ID","name":"Name","version":"Version","description":"Description","type":"Type","ui_href":"UIHref"}],"controls":[{"profile":{"id":"ID","name":"Name","version":"Version","description":"Description","type":"Type","ui_href":"UIHref"},"names":["Names"]}]},"evaluations":[{"scan_id":"ScanID","account_id":"AccountID","profile":{"id":"ID","name":"Name","version":"Version","description":"Description","type":"Type","ui_href":"UIHref"},"result":{"failure_count":12,"scan_time":"2019-01-01T12:00:00.000Z","error_message":"ErrorMessage","complete_scan":true,"unscanned_resources":["UnscannedResources"]},"controls":[{"id":"ID","name":"Name","description":"Description","specifications":[{"id":"ID","description":"Description","component_name":"ComponentName","assessments":[{"id":"ID","description":"Description","version":"Version","type":"Type","method":"Method","ui_href":"UIHref"}],"ui_href":"UIHref"}],"failure_count":12,"pass_count":9,"parent":{"id":"ID","name":"Name","version":"Version","description":"Description","profile":{"id":"ID","name":"Name","version":"Version","description":"Description","type":"Type","ui_href":"UIHref"},"parent_name":"ParentName","specifications":[{"id":"ID","description":"Description","component_name":"ComponentName","assessments":[{"id":"ID","description":"Description","version":"Version","type":"Type","method":"Method","ui_href":"UIHref"}],"ui_href":"UIHref"}],"ui_href":"UIHref"},"ui_href":"UIHref"}]}]},"change_notices":{"breaking":[{"title":"Title","title_i18n":{"mapKey":"Inner"},"description":"Description","description_i18n":{"mapKey":"Inner"}}],"new":[{"title":"Title","title_i18n":{"mapKey":"Inner"},"description":"Description","description_i18n":{"mapKey":"Inner"}}],"update":[{"title":"Title","title_i18n":{"mapKey":"Inner"},"description":"Description","description_i18n":{"mapKey":"Inner"}}]},"plan_ids":["PlanIds"],"stack":{"anyKey":"anyValue"},"minimum_compatible_version":"MinimumCompatibleVersion"}],"all_versions":{"first":{"href":"Href","start":"Start"},"next":{"href":"Href","start":"Start"}}}],"publish":{"pc_managed":false,"approval_type":"ApprovalType","publish_approved":false,"share_with_all":true,"share_with_ibm":true,"share_enabled":true,"original_crn":"OriginalCRN","public_crn":"PublicCRN","approval_record":{"anyKey":"anyValue"},"permit_ibm_public_publish":true,"ibm_approved":false,"public_approved":true},"pc_managed":false,"publish_approved":false,"share_with_all":true,"share_with_ibm":true,"share_enabled":true,"public_original_crn":"PublicOriginalCRN","publish_public_crn":"PublishPublicCRN","portal_approval_record":"PortalApprovalRecord","portal_ui_url":"PortalUIURL","catalog_id":"CatalogID","catalog_name":"CatalogName","metadata":{"anyKey":"anyValue"},"disclaimer":"Disclaimer","hidden":true,"provider":"Provider","provider_info":{"id":"ID","name":"Name"},"repo_info":{"token":"Token","type":"Type"},"image_pull_keys":[{"name":"Name","value":"Value","description":"Description"}],"support":{"url":"URL","process":"Process","process_i18n":{"mapKey":"Inner"},"locations":["Locations"],"support_details":[{"type":"Type","contact":"Contact","response_wait_time":{"value":5,"type":"Type"},"availability":{"times":[{"day":3,"start_time":"StartTime","end_time":"EndTime"}],"timezone":"Timezone","always_available":false}}],"support_escalation":{"escalation_wait_time":{"value":5,"type":"Type"},"response_wait_time":{"value":5,"type":"Type"},"contact":"Contact"},"support_type":"SupportType"},"media":[{"url":"URL","api_url":"APIURL","url_proxy":{"url":"URL","sha":"Sha"},"caption":"Caption","caption_i18n":{"mapKey":"Inner"},"type":"Type","thumbnail_url":"ThumbnailURL"}],"deprecate_pending":{"deprecate_date":"2019-01-01T12:00:00.000Z","deprecate_state":"DeprecateState","description":"Description"},"product_kind":"ProductKind","badges":[{"id":"ID","label":"Label","label_i18n":{"mapKey":"Inner"},"description":"Description","description_i18n":{"mapKey":"Inner"},"icon":"Icon","authority":"Authority","tag":"Tag","learn_more_links":{"first_party":"FirstParty","third_party":"ThirdParty"},"constraints":[{"type":"Type","rule":"anyValue"}]}],"plans":[{"id":"ID","_rev":"Rev","url":"URL","crn":"CRN","created":"2019-01-01T12:00:00.000Z","updated":"2019-01-01T12:00:00.000Z","offering_id":"OfferingID","catalog_id":"CatalogID","label":"Label","label_i18n":{"mapKey":"Inner"},"name":"Name","short_description":"ShortDescription","short_description_i18n":{"mapKey":"Inner"},"pricing_tags":["PricingTags"],"version_range":{"kinds":["Kinds"],"version":"Version","flavors":["Flavors"]},"features":[{"title":"Title","title_i18n":{"mapKey":"Inner"},"description":"Description","description_i18n":{"mapKey":"Inner"}}],"state":{"current":"Current","current_entered":"2019-01-01T12:00:00.000Z","pending":"Pending","pending_requested":"2019-01-01T12:00:00.000Z","previous":"Previous"},"deprecate_pending":{"deprecate_date":"2019-01-01T12:00:00.000Z","deprecate_state":"DeprecateState","description":"Description"},"metadata":{"anyKey":"anyValue"},"publish_approved":false}]}]}`)
					} else {
						res.WriteHeader(400)
					}
				}))
			})
			It(`Use GetConsumptionOfferingsPager.GetNext successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				getConsumptionOfferingsOptionsModel := &catalogmanagementv1.GetConsumptionOfferingsOptions{
					Digest:        core.BoolPtr(true),
					Catalog:       core.StringPtr("testString"),
					Select:        core.StringPtr("all"),
					IncludeHidden: core.BoolPtr(true),
					Limit:         core.Int64Ptr(int64(10)),
				}

				pager, err := catalogManagementService.NewGetConsumptionOfferingsPager(getConsumptionOfferingsOptionsModel)
				Expect(err).To(BeNil())
				Expect(pager).ToNot(BeNil())

				var allResults []catalogmanagementv1.Offering
				for pager.HasNext() {
					nextPage, err := pager.GetNext()
					Expect(err).To(BeNil())
					Expect(nextPage).ToNot(BeNil())
					allResults = append(allResults, nextPage...)
				}
				Expect(len(allResults)).To(Equal(2))
			})
			It(`Use GetConsumptionOfferingsPager.GetAll successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				getConsumptionOfferingsOptionsModel := &catalogmanagementv1.GetConsumptionOfferingsOptions{
					Digest:        core.BoolPtr(true),
					Catalog:       core.StringPtr("testString"),
					Select:        core.StringPtr("all"),
					IncludeHidden: core.BoolPtr(true),
					Limit:         core.Int64Ptr(int64(10)),
				}

				pager, err := catalogManagementService.NewGetConsumptionOfferingsPager(getConsumptionOfferingsOptionsModel)
				Expect(err).To(BeNil())
				Expect(pager).ToNot(BeNil())

				allResults, err := pager.GetAll()
				Expect(err).To(BeNil())
				Expect(allResults).ToNot(BeNil())
				Expect(len(allResults)).To(Equal(2))
			})
		})
	})
	Describe(`ListOfferings(listOfferingsOptions *ListOfferingsOptions) - Operation response error`, func() {
		listOfferingsPath := "/catalogs/testString/offerings"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listOfferingsPath))
					Expect(req.Method).To(Equal("GET"))
					// TODO: Add check for digest query parameter
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(10))}))
					Expect(req.URL.Query()["offset"]).To(Equal([]string{fmt.Sprint(int64(0))}))
					Expect(req.URL.Query()["name"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["sort"]).To(Equal([]string{"testString"}))
					// TODO: Add check for includeHidden query parameter
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ListOfferings with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ListOfferingsOptions model
				listOfferingsOptionsModel := new(catalogmanagementv1.ListOfferingsOptions)
				listOfferingsOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				listOfferingsOptionsModel.Digest = core.BoolPtr(true)
				listOfferingsOptionsModel.Limit = core.Int64Ptr(int64(10))
				listOfferingsOptionsModel.Offset = core.Int64Ptr(int64(0))
				listOfferingsOptionsModel.Name = core.StringPtr("testString")
				listOfferingsOptionsModel.Sort = core.StringPtr("testString")
				listOfferingsOptionsModel.IncludeHidden = core.BoolPtr(true)
				listOfferingsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.ListOfferings(listOfferingsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.ListOfferings(listOfferingsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListOfferings(listOfferingsOptions *ListOfferingsOptions)`, func() {
		listOfferingsPath := "/catalogs/testString/offerings"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listOfferingsPath))
					Expect(req.Method).To(Equal("GET"))

					// TODO: Add check for digest query parameter
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(10))}))
					Expect(req.URL.Query()["offset"]).To(Equal([]string{fmt.Sprint(int64(0))}))
					Expect(req.URL.Query()["name"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["sort"]).To(Equal([]string{"testString"}))
					// TODO: Add check for includeHidden query parameter
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"offset": 6, "limit": 5, "total_count": 10, "resource_count": 13, "first": "First", "last": "Last", "prev": "Prev", "next": "Next", "resources": [{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "name": "Name", "offering_icon_url": "OfferingIconURL", "offering_docs_url": "OfferingDocsURL", "offering_support_url": "OfferingSupportURL", "tags": ["Tags"], "keywords": ["Keywords"], "rating": {"one_star_count": 12, "two_star_count": 12, "three_star_count": 14, "four_star_count": 13}, "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "kinds": [{"id": "ID", "format_kind": "FormatKind", "format_kind_label": "FormatKindLabel", "install_kind": "InstallKind", "install_kind_label": "InstallKindLabel", "target_kind": "TargetKind", "target_kind_label": "TargetKindLabel", "metadata": {"anyKey": "anyValue"}, "tags": ["Tags"], "additional_features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "versions": [{"id": "ID", "_rev": "Rev", "crn": "CRN", "version": "Version", "flavor": {"name": "Name", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "index": 5}, "sha": "Sha", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "offering_id": "OfferingID", "catalog_id": "CatalogID", "kind_id": "KindID", "tags": ["Tags"], "repo_url": "RepoURL", "source_url": "SourceURL", "tgz_url": "TgzURL", "configuration": [{"key": "Key", "type": "Type", "default_value": "anyValue", "display_name": "DisplayName", "value_constraint": "ValueConstraint", "description": "Description", "required": true, "options": ["anyValue"], "hidden": true, "custom_config": {"type": "Type", "grouping": "Grouping", "original_grouping": "OriginalGrouping", "grouping_index": 13, "config_constraints": {"anyKey": "anyValue"}, "associations": {"parameters": [{"name": "Name", "optionsRefresh": true}]}}, "type_metadata": "TypeMetadata"}], "outputs": [{"key": "Key", "description": "Description"}], "iam_permissions": [{"service_name": "ServiceName", "role_crns": ["RoleCrns"], "resources": [{"name": "Name", "description": "Description", "role_crns": ["RoleCrns"]}]}], "metadata": {"anyKey": "anyValue"}, "validation": {"validated": "2019-01-01T12:00:00.000Z", "requested": "2019-01-01T12:00:00.000Z", "state": "State", "last_operation": "LastOperation", "target": {"anyKey": "anyValue"}, "message": "Message"}, "required_resources": [{"type": "mem", "value": "anyValue"}], "single_instance": true, "schematics_env_values": {"value": "[{\"name\": \"TF_LOG\",\"value\": \"TRACE\",\"secure\": false,\"hidden\": false}]", "sm_ref": "cmsm_v1:{\"name\": \"envVarSecret\",\"id\":\"1234567890\",\"service_id\":\"crn:v1:bluemix:public:secrets-manager:eu-gb:a/1234567890:1234567890::\",\"service_name\":\"My SM Instance\",\"group_id\":\"1234567890\",\"group_name\":\"My SM Group\",\"resource_group_id\":\"1234567890\",\"region\":\"eu-gb\",\"type\":\"arbitrary\"}"}, "install": {"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}, "pre_install": [{"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}], "scripts": {"mapKey": {"short_description": "ShortDescription", "type": "ansible", "path": "scripts/validate-post-ansible-playbook.yaml", "stage": "pre", "action": "validate"}}, "entitlement": {"provider_name": "ProviderName", "provider_id": "ProviderID", "product_id": "ProductID", "part_numbers": ["PartNumbers"], "image_repo_name": "ImageRepoName"}, "licenses": [{"id": "ID", "name": "Name", "type": "Type", "url": "URL", "description": "Description"}], "image_manifest_url": "ImageManifestURL", "deprecated": true, "package_version": "PackageVersion", "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "version_locator": "VersionLocator", "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "whitelisted_accounts": ["WhitelistedAccounts"], "image_pull_key_name": "ImagePullKeyName", "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "solution_info": {"architecture_diagrams": [{"diagram": {"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "cost_estimate": {"version": "Version", "currency": "Currency", "projects": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "pastBreakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "breakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "diff": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}}], "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}, "totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "pastTotalHourlyCost": "PastTotalHourlyCost", "pastTotalMonthlyCost": "PastTotalMonthlyCost", "diffTotalHourlyCost": "DiffTotalHourlyCost", "diffTotalMonthlyCost": "DiffTotalMonthlyCost", "timeGenerated": "2019-01-01T12:00:00.000Z"}, "dependencies": [{"catalog_id": "CatalogID", "id": "ID", "name": "Name", "kind": "Kind", "version": "Version", "description": "Description", "default_flavor": "DefaultFlavor", "flavors": ["Flavors"], "optional": true, "on_by_default": false}], "install_type": "InstallType"}, "is_consumable": true, "compliance_v3": {"authority": "Authority", "claims": {"profiles": [{"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}], "controls": [{"profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "names": ["Names"]}]}, "evaluations": [{"scan_id": "ScanID", "account_id": "AccountID", "profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "result": {"failure_count": 12, "scan_time": "2019-01-01T12:00:00.000Z", "error_message": "ErrorMessage", "complete_scan": true, "unscanned_resources": ["UnscannedResources"]}, "controls": [{"id": "ID", "name": "Name", "description": "Description", "specifications": [{"id": "ID", "description": "Description", "component_name": "ComponentName", "assessments": [{"id": "ID", "description": "Description", "version": "Version", "type": "Type", "method": "Method", "ui_href": "UIHref"}], "ui_href": "UIHref"}], "failure_count": 12, "pass_count": 9, "parent": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "parent_name": "ParentName", "specifications": [{"id": "ID", "description": "Description", "component_name": "ComponentName", "assessments": [{"id": "ID", "description": "Description", "version": "Version", "type": "Type", "method": "Method", "ui_href": "UIHref"}], "ui_href": "UIHref"}], "ui_href": "UIHref"}, "ui_href": "UIHref"}]}]}, "change_notices": {"breaking": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "new": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "update": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}]}, "plan_ids": ["PlanIds"], "stack": {"anyKey": "anyValue"}, "minimum_compatible_version": "MinimumCompatibleVersion"}], "all_versions": {"first": {"href": "Href", "start": "Start"}, "next": {"href": "Href", "start": "Start"}}}], "publish": {"pc_managed": false, "approval_type": "ApprovalType", "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "original_crn": "OriginalCRN", "public_crn": "PublicCRN", "approval_record": {"anyKey": "anyValue"}, "permit_ibm_public_publish": true, "ibm_approved": false, "public_approved": true}, "pc_managed": false, "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "public_original_crn": "PublicOriginalCRN", "publish_public_crn": "PublishPublicCRN", "portal_approval_record": "PortalApprovalRecord", "portal_ui_url": "PortalUIURL", "catalog_id": "CatalogID", "catalog_name": "CatalogName", "metadata": {"anyKey": "anyValue"}, "disclaimer": "Disclaimer", "hidden": true, "provider": "Provider", "provider_info": {"id": "ID", "name": "Name"}, "repo_info": {"token": "Token", "type": "Type"}, "image_pull_keys": [{"name": "Name", "value": "Value", "description": "Description"}], "support": {"url": "URL", "process": "Process", "process_i18n": {"mapKey": "Inner"}, "locations": ["Locations"], "support_details": [{"type": "Type", "contact": "Contact", "response_wait_time": {"value": 5, "type": "Type"}, "availability": {"times": [{"day": 3, "start_time": "StartTime", "end_time": "EndTime"}], "timezone": "Timezone", "always_available": false}}], "support_escalation": {"escalation_wait_time": {"value": 5, "type": "Type"}, "response_wait_time": {"value": 5, "type": "Type"}, "contact": "Contact"}, "support_type": "SupportType"}, "media": [{"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}], "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "product_kind": "ProductKind", "badges": [{"id": "ID", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}, "icon": "Icon", "authority": "Authority", "tag": "Tag", "learn_more_links": {"first_party": "FirstParty", "third_party": "ThirdParty"}, "constraints": [{"type": "Type", "rule": "anyValue"}]}], "plans": [{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "offering_id": "OfferingID", "catalog_id": "CatalogID", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "name": "Name", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "pricing_tags": ["PricingTags"], "version_range": {"kinds": ["Kinds"], "version": "Version", "flavors": ["Flavors"]}, "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "metadata": {"anyKey": "anyValue"}, "publish_approved": false}]}]}`)
				}))
			})
			It(`Invoke ListOfferings successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the ListOfferingsOptions model
				listOfferingsOptionsModel := new(catalogmanagementv1.ListOfferingsOptions)
				listOfferingsOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				listOfferingsOptionsModel.Digest = core.BoolPtr(true)
				listOfferingsOptionsModel.Limit = core.Int64Ptr(int64(10))
				listOfferingsOptionsModel.Offset = core.Int64Ptr(int64(0))
				listOfferingsOptionsModel.Name = core.StringPtr("testString")
				listOfferingsOptionsModel.Sort = core.StringPtr("testString")
				listOfferingsOptionsModel.IncludeHidden = core.BoolPtr(true)
				listOfferingsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.ListOfferingsWithContext(ctx, listOfferingsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.ListOfferings(listOfferingsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.ListOfferingsWithContext(ctx, listOfferingsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listOfferingsPath))
					Expect(req.Method).To(Equal("GET"))

					// TODO: Add check for digest query parameter
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(10))}))
					Expect(req.URL.Query()["offset"]).To(Equal([]string{fmt.Sprint(int64(0))}))
					Expect(req.URL.Query()["name"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["sort"]).To(Equal([]string{"testString"}))
					// TODO: Add check for includeHidden query parameter
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"offset": 6, "limit": 5, "total_count": 10, "resource_count": 13, "first": "First", "last": "Last", "prev": "Prev", "next": "Next", "resources": [{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "name": "Name", "offering_icon_url": "OfferingIconURL", "offering_docs_url": "OfferingDocsURL", "offering_support_url": "OfferingSupportURL", "tags": ["Tags"], "keywords": ["Keywords"], "rating": {"one_star_count": 12, "two_star_count": 12, "three_star_count": 14, "four_star_count": 13}, "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "kinds": [{"id": "ID", "format_kind": "FormatKind", "format_kind_label": "FormatKindLabel", "install_kind": "InstallKind", "install_kind_label": "InstallKindLabel", "target_kind": "TargetKind", "target_kind_label": "TargetKindLabel", "metadata": {"anyKey": "anyValue"}, "tags": ["Tags"], "additional_features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "versions": [{"id": "ID", "_rev": "Rev", "crn": "CRN", "version": "Version", "flavor": {"name": "Name", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "index": 5}, "sha": "Sha", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "offering_id": "OfferingID", "catalog_id": "CatalogID", "kind_id": "KindID", "tags": ["Tags"], "repo_url": "RepoURL", "source_url": "SourceURL", "tgz_url": "TgzURL", "configuration": [{"key": "Key", "type": "Type", "default_value": "anyValue", "display_name": "DisplayName", "value_constraint": "ValueConstraint", "description": "Description", "required": true, "options": ["anyValue"], "hidden": true, "custom_config": {"type": "Type", "grouping": "Grouping", "original_grouping": "OriginalGrouping", "grouping_index": 13, "config_constraints": {"anyKey": "anyValue"}, "associations": {"parameters": [{"name": "Name", "optionsRefresh": true}]}}, "type_metadata": "TypeMetadata"}], "outputs": [{"key": "Key", "description": "Description"}], "iam_permissions": [{"service_name": "ServiceName", "role_crns": ["RoleCrns"], "resources": [{"name": "Name", "description": "Description", "role_crns": ["RoleCrns"]}]}], "metadata": {"anyKey": "anyValue"}, "validation": {"validated": "2019-01-01T12:00:00.000Z", "requested": "2019-01-01T12:00:00.000Z", "state": "State", "last_operation": "LastOperation", "target": {"anyKey": "anyValue"}, "message": "Message"}, "required_resources": [{"type": "mem", "value": "anyValue"}], "single_instance": true, "schematics_env_values": {"value": "[{\"name\": \"TF_LOG\",\"value\": \"TRACE\",\"secure\": false,\"hidden\": false}]", "sm_ref": "cmsm_v1:{\"name\": \"envVarSecret\",\"id\":\"1234567890\",\"service_id\":\"crn:v1:bluemix:public:secrets-manager:eu-gb:a/1234567890:1234567890::\",\"service_name\":\"My SM Instance\",\"group_id\":\"1234567890\",\"group_name\":\"My SM Group\",\"resource_group_id\":\"1234567890\",\"region\":\"eu-gb\",\"type\":\"arbitrary\"}"}, "install": {"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}, "pre_install": [{"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}], "scripts": {"mapKey": {"short_description": "ShortDescription", "type": "ansible", "path": "scripts/validate-post-ansible-playbook.yaml", "stage": "pre", "action": "validate"}}, "entitlement": {"provider_name": "ProviderName", "provider_id": "ProviderID", "product_id": "ProductID", "part_numbers": ["PartNumbers"], "image_repo_name": "ImageRepoName"}, "licenses": [{"id": "ID", "name": "Name", "type": "Type", "url": "URL", "description": "Description"}], "image_manifest_url": "ImageManifestURL", "deprecated": true, "package_version": "PackageVersion", "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "version_locator": "VersionLocator", "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "whitelisted_accounts": ["WhitelistedAccounts"], "image_pull_key_name": "ImagePullKeyName", "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "solution_info": {"architecture_diagrams": [{"diagram": {"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "cost_estimate": {"version": "Version", "currency": "Currency", "projects": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "pastBreakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "breakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "diff": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}}], "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}, "totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "pastTotalHourlyCost": "PastTotalHourlyCost", "pastTotalMonthlyCost": "PastTotalMonthlyCost", "diffTotalHourlyCost": "DiffTotalHourlyCost", "diffTotalMonthlyCost": "DiffTotalMonthlyCost", "timeGenerated": "2019-01-01T12:00:00.000Z"}, "dependencies": [{"catalog_id": "CatalogID", "id": "ID", "name": "Name", "kind": "Kind", "version": "Version", "description": "Description", "default_flavor": "DefaultFlavor", "flavors": ["Flavors"], "optional": true, "on_by_default": false}], "install_type": "InstallType"}, "is_consumable": true, "compliance_v3": {"authority": "Authority", "claims": {"profiles": [{"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}], "controls": [{"profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "names": ["Names"]}]}, "evaluations": [{"scan_id": "ScanID", "account_id": "AccountID", "profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "result": {"failure_count": 12, "scan_time": "2019-01-01T12:00:00.000Z", "error_message": "ErrorMessage", "complete_scan": true, "unscanned_resources": ["UnscannedResources"]}, "controls": [{"id": "ID", "name": "Name", "description": "Description", "specifications": [{"id": "ID", "description": "Description", "component_name": "ComponentName", "assessments": [{"id": "ID", "description": "Description", "version": "Version", "type": "Type", "method": "Method", "ui_href": "UIHref"}], "ui_href": "UIHref"}], "failure_count": 12, "pass_count": 9, "parent": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "parent_name": "ParentName", "specifications": [{"id": "ID", "description": "Description", "component_name": "ComponentName", "assessments": [{"id": "ID", "description": "Description", "version": "Version", "type": "Type", "method": "Method", "ui_href": "UIHref"}], "ui_href": "UIHref"}], "ui_href": "UIHref"}, "ui_href": "UIHref"}]}]}, "change_notices": {"breaking": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "new": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "update": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}]}, "plan_ids": ["PlanIds"], "stack": {"anyKey": "anyValue"}, "minimum_compatible_version": "MinimumCompatibleVersion"}], "all_versions": {"first": {"href": "Href", "start": "Start"}, "next": {"href": "Href", "start": "Start"}}}], "publish": {"pc_managed": false, "approval_type": "ApprovalType", "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "original_crn": "OriginalCRN", "public_crn": "PublicCRN", "approval_record": {"anyKey": "anyValue"}, "permit_ibm_public_publish": true, "ibm_approved": false, "public_approved": true}, "pc_managed": false, "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "public_original_crn": "PublicOriginalCRN", "publish_public_crn": "PublishPublicCRN", "portal_approval_record": "PortalApprovalRecord", "portal_ui_url": "PortalUIURL", "catalog_id": "CatalogID", "catalog_name": "CatalogName", "metadata": {"anyKey": "anyValue"}, "disclaimer": "Disclaimer", "hidden": true, "provider": "Provider", "provider_info": {"id": "ID", "name": "Name"}, "repo_info": {"token": "Token", "type": "Type"}, "image_pull_keys": [{"name": "Name", "value": "Value", "description": "Description"}], "support": {"url": "URL", "process": "Process", "process_i18n": {"mapKey": "Inner"}, "locations": ["Locations"], "support_details": [{"type": "Type", "contact": "Contact", "response_wait_time": {"value": 5, "type": "Type"}, "availability": {"times": [{"day": 3, "start_time": "StartTime", "end_time": "EndTime"}], "timezone": "Timezone", "always_available": false}}], "support_escalation": {"escalation_wait_time": {"value": 5, "type": "Type"}, "response_wait_time": {"value": 5, "type": "Type"}, "contact": "Contact"}, "support_type": "SupportType"}, "media": [{"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}], "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "product_kind": "ProductKind", "badges": [{"id": "ID", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}, "icon": "Icon", "authority": "Authority", "tag": "Tag", "learn_more_links": {"first_party": "FirstParty", "third_party": "ThirdParty"}, "constraints": [{"type": "Type", "rule": "anyValue"}]}], "plans": [{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "offering_id": "OfferingID", "catalog_id": "CatalogID", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "name": "Name", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "pricing_tags": ["PricingTags"], "version_range": {"kinds": ["Kinds"], "version": "Version", "flavors": ["Flavors"]}, "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "metadata": {"anyKey": "anyValue"}, "publish_approved": false}]}]}`)
				}))
			})
			It(`Invoke ListOfferings successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.ListOfferings(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ListOfferingsOptions model
				listOfferingsOptionsModel := new(catalogmanagementv1.ListOfferingsOptions)
				listOfferingsOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				listOfferingsOptionsModel.Digest = core.BoolPtr(true)
				listOfferingsOptionsModel.Limit = core.Int64Ptr(int64(10))
				listOfferingsOptionsModel.Offset = core.Int64Ptr(int64(0))
				listOfferingsOptionsModel.Name = core.StringPtr("testString")
				listOfferingsOptionsModel.Sort = core.StringPtr("testString")
				listOfferingsOptionsModel.IncludeHidden = core.BoolPtr(true)
				listOfferingsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.ListOfferings(listOfferingsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ListOfferings with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ListOfferingsOptions model
				listOfferingsOptionsModel := new(catalogmanagementv1.ListOfferingsOptions)
				listOfferingsOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				listOfferingsOptionsModel.Digest = core.BoolPtr(true)
				listOfferingsOptionsModel.Limit = core.Int64Ptr(int64(10))
				listOfferingsOptionsModel.Offset = core.Int64Ptr(int64(0))
				listOfferingsOptionsModel.Name = core.StringPtr("testString")
				listOfferingsOptionsModel.Sort = core.StringPtr("testString")
				listOfferingsOptionsModel.IncludeHidden = core.BoolPtr(true)
				listOfferingsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.ListOfferings(listOfferingsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the ListOfferingsOptions model with no property values
				listOfferingsOptionsModelNew := new(catalogmanagementv1.ListOfferingsOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.ListOfferings(listOfferingsOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ListOfferings successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ListOfferingsOptions model
				listOfferingsOptionsModel := new(catalogmanagementv1.ListOfferingsOptions)
				listOfferingsOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				listOfferingsOptionsModel.Digest = core.BoolPtr(true)
				listOfferingsOptionsModel.Limit = core.Int64Ptr(int64(10))
				listOfferingsOptionsModel.Offset = core.Int64Ptr(int64(0))
				listOfferingsOptionsModel.Name = core.StringPtr("testString")
				listOfferingsOptionsModel.Sort = core.StringPtr("testString")
				listOfferingsOptionsModel.IncludeHidden = core.BoolPtr(true)
				listOfferingsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.ListOfferings(listOfferingsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Test pagination helper method on response`, func() {
			It(`Invoke GetNextOffset successfully`, func() {
				responseObject := new(catalogmanagementv1.OfferingSearchResult)
				responseObject.Next = core.StringPtr("ibm.com?offset=135")

				value, err := responseObject.GetNextOffset()
				Expect(err).To(BeNil())
				Expect(value).To(Equal(core.Int64Ptr(int64(135))))
			})
			It(`Invoke GetNextOffset without a "Next" property in the response`, func() {
				responseObject := new(catalogmanagementv1.OfferingSearchResult)

				value, err := responseObject.GetNextOffset()
				Expect(err).To(BeNil())
				Expect(value).To(BeNil())
			})
			It(`Invoke GetNextOffset without any query params in the "Next" URL`, func() {
				responseObject := new(catalogmanagementv1.OfferingSearchResult)
				responseObject.Next = core.StringPtr("ibm.com")

				value, err := responseObject.GetNextOffset()
				Expect(err).To(BeNil())
				Expect(value).To(BeNil())
			})
			It(`Invoke GetNextOffset with a non-integer query param in the "Next" URL`, func() {
				responseObject := new(catalogmanagementv1.OfferingSearchResult)
				responseObject.Next = core.StringPtr("ibm.com?offset=tiger")

				value, err := responseObject.GetNextOffset()
				Expect(err).NotTo(BeNil())
				Expect(value).To(BeNil())
			})
		})
		Context(`Using mock server endpoint - paginated response`, func() {
			BeforeEach(func() {
				var requestNumber int = 0
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listOfferingsPath))
					Expect(req.Method).To(Equal("GET"))

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					requestNumber++
					if requestNumber == 1 {
						fmt.Fprintf(res, "%s", `{"next":"https://myhost.com/somePath?offset=1","total_count":2,"limit":1,"resources":[{"id":"ID","_rev":"Rev","url":"URL","crn":"CRN","label":"Label","label_i18n":{"mapKey":"Inner"},"name":"Name","offering_icon_url":"OfferingIconURL","offering_docs_url":"OfferingDocsURL","offering_support_url":"OfferingSupportURL","tags":["Tags"],"keywords":["Keywords"],"rating":{"one_star_count":12,"two_star_count":12,"three_star_count":14,"four_star_count":13},"created":"2019-01-01T12:00:00.000Z","updated":"2019-01-01T12:00:00.000Z","short_description":"ShortDescription","short_description_i18n":{"mapKey":"Inner"},"long_description":"LongDescription","long_description_i18n":{"mapKey":"Inner"},"features":[{"title":"Title","title_i18n":{"mapKey":"Inner"},"description":"Description","description_i18n":{"mapKey":"Inner"}}],"kinds":[{"id":"ID","format_kind":"FormatKind","format_kind_label":"FormatKindLabel","install_kind":"InstallKind","install_kind_label":"InstallKindLabel","target_kind":"TargetKind","target_kind_label":"TargetKindLabel","metadata":{"anyKey":"anyValue"},"tags":["Tags"],"additional_features":[{"title":"Title","title_i18n":{"mapKey":"Inner"},"description":"Description","description_i18n":{"mapKey":"Inner"}}],"created":"2019-01-01T12:00:00.000Z","updated":"2019-01-01T12:00:00.000Z","versions":[{"id":"ID","_rev":"Rev","crn":"CRN","version":"Version","flavor":{"name":"Name","label":"Label","label_i18n":{"mapKey":"Inner"},"index":5},"sha":"Sha","created":"2019-01-01T12:00:00.000Z","updated":"2019-01-01T12:00:00.000Z","offering_id":"OfferingID","catalog_id":"CatalogID","kind_id":"KindID","tags":["Tags"],"repo_url":"RepoURL","source_url":"SourceURL","tgz_url":"TgzURL","configuration":[{"key":"Key","type":"Type","default_value":"anyValue","display_name":"DisplayName","value_constraint":"ValueConstraint","description":"Description","required":true,"options":["anyValue"],"hidden":true,"custom_config":{"type":"Type","grouping":"Grouping","original_grouping":"OriginalGrouping","grouping_index":13,"config_constraints":{"anyKey":"anyValue"},"associations":{"parameters":[{"name":"Name","optionsRefresh":true}]}},"type_metadata":"TypeMetadata"}],"outputs":[{"key":"Key","description":"Description"}],"iam_permissions":[{"service_name":"ServiceName","role_crns":["RoleCrns"],"resources":[{"name":"Name","description":"Description","role_crns":["RoleCrns"]}]}],"metadata":{"anyKey":"anyValue"},"validation":{"validated":"2019-01-01T12:00:00.000Z","requested":"2019-01-01T12:00:00.000Z","state":"State","last_operation":"LastOperation","target":{"anyKey":"anyValue"},"message":"Message"},"required_resources":[{"type":"mem","value":"anyValue"}],"single_instance":true,"schematics_env_values":{"value":"[{\"name\": \"TF_LOG\",\"value\": \"TRACE\",\"secure\": false,\"hidden\": false}]","sm_ref":"cmsm_v1:{\"name\": \"envVarSecret\",\"id\":\"1234567890\",\"service_id\":\"crn:v1:bluemix:public:secrets-manager:eu-gb:a/1234567890:1234567890::\",\"service_name\":\"My SM Instance\",\"group_id\":\"1234567890\",\"group_name\":\"My SM Group\",\"resource_group_id\":\"1234567890\",\"region\":\"eu-gb\",\"type\":\"arbitrary\"}"},"install":{"instructions":"Instructions","instructions_i18n":{"mapKey":"Inner"},"script":"Script","script_permission":"ScriptPermission","delete_script":"DeleteScript","scope":"Scope"},"pre_install":[{"instructions":"Instructions","instructions_i18n":{"mapKey":"Inner"},"script":"Script","script_permission":"ScriptPermission","delete_script":"DeleteScript","scope":"Scope"}],"scripts":{"mapKey":{"short_description":"ShortDescription","type":"ansible","path":"scripts/validate-post-ansible-playbook.yaml","stage":"pre","action":"validate"}},"entitlement":{"provider_name":"ProviderName","provider_id":"ProviderID","product_id":"ProductID","part_numbers":["PartNumbers"],"image_repo_name":"ImageRepoName"},"licenses":[{"id":"ID","name":"Name","type":"Type","url":"URL","description":"Description"}],"image_manifest_url":"ImageManifestURL","deprecated":true,"package_version":"PackageVersion","state":{"current":"Current","current_entered":"2019-01-01T12:00:00.000Z","pending":"Pending","pending_requested":"2019-01-01T12:00:00.000Z","previous":"Previous"},"version_locator":"VersionLocator","long_description":"LongDescription","long_description_i18n":{"mapKey":"Inner"},"whitelisted_accounts":["WhitelistedAccounts"],"image_pull_key_name":"ImagePullKeyName","deprecate_pending":{"deprecate_date":"2019-01-01T12:00:00.000Z","deprecate_state":"DeprecateState","description":"Description"},"solution_info":{"architecture_diagrams":[{"diagram":{"url":"URL","api_url":"APIURL","url_proxy":{"url":"URL","sha":"Sha"},"caption":"Caption","caption_i18n":{"mapKey":"Inner"},"type":"Type","thumbnail_url":"ThumbnailURL"},"description":"Description","description_i18n":{"mapKey":"Inner"}}],"features":[{"title":"Title","title_i18n":{"mapKey":"Inner"},"description":"Description","description_i18n":{"mapKey":"Inner"}}],"cost_estimate":{"version":"Version","currency":"Currency","projects":[{"name":"Name","metadata":{"anyKey":"anyValue"},"pastBreakdown":{"totalHourlyCost":"TotalHourlyCost","totalMonthlyCost":"TotalMonthlyCost","resources":[{"name":"Name","metadata":{"anyKey":"anyValue"},"hourlyCost":"HourlyCost","monthlyCost":"MonthlyCost","costComponents":[{"name":"Name","unit":"Unit","hourlyQuantity":"HourlyQuantity","monthlyQuantity":"MonthlyQuantity","price":"Price","hourlyCost":"HourlyCost","monthlyCost":"MonthlyCost"}]}]},"breakdown":{"totalHourlyCost":"TotalHourlyCost","totalMonthlyCost":"TotalMonthlyCost","resources":[{"name":"Name","metadata":{"anyKey":"anyValue"},"hourlyCost":"HourlyCost","monthlyCost":"MonthlyCost","costComponents":[{"name":"Name","unit":"Unit","hourlyQuantity":"HourlyQuantity","monthlyQuantity":"MonthlyQuantity","price":"Price","hourlyCost":"HourlyCost","monthlyCost":"MonthlyCost"}]}]},"diff":{"totalHourlyCost":"TotalHourlyCost","totalMonthlyCost":"TotalMonthlyCost","resources":[{"name":"Name","metadata":{"anyKey":"anyValue"},"hourlyCost":"HourlyCost","monthlyCost":"MonthlyCost","costComponents":[{"name":"Name","unit":"Unit","hourlyQuantity":"HourlyQuantity","monthlyQuantity":"MonthlyQuantity","price":"Price","hourlyCost":"HourlyCost","monthlyCost":"MonthlyCost"}]}]},"summary":{"totalDetectedResources":22,"totalSupportedResources":23,"totalUnsupportedResources":25,"totalUsageBasedResources":24,"totalNoPriceResources":21,"unsupportedResourceCounts":{"mapKey":5},"noPriceResourceCounts":{"mapKey":5}}}],"summary":{"totalDetectedResources":22,"totalSupportedResources":23,"totalUnsupportedResources":25,"totalUsageBasedResources":24,"totalNoPriceResources":21,"unsupportedResourceCounts":{"mapKey":5},"noPriceResourceCounts":{"mapKey":5}},"totalHourlyCost":"TotalHourlyCost","totalMonthlyCost":"TotalMonthlyCost","pastTotalHourlyCost":"PastTotalHourlyCost","pastTotalMonthlyCost":"PastTotalMonthlyCost","diffTotalHourlyCost":"DiffTotalHourlyCost","diffTotalMonthlyCost":"DiffTotalMonthlyCost","timeGenerated":"2019-01-01T12:00:00.000Z"},"dependencies":[{"catalog_id":"CatalogID","id":"ID","name":"Name","kind":"Kind","version":"Version","description":"Description","default_flavor":"DefaultFlavor","flavors":["Flavors"],"optional":true,"on_by_default":false}],"install_type":"InstallType"},"is_consumable":true,"compliance_v3":{"authority":"Authority","claims":{"profiles":[{"id":"ID","name":"Name","version":"Version","description":"Description","type":"Type","ui_href":"UIHref"}],"controls":[{"profile":{"id":"ID","name":"Name","version":"Version","description":"Description","type":"Type","ui_href":"UIHref"},"names":["Names"]}]},"evaluations":[{"scan_id":"ScanID","account_id":"AccountID","profile":{"id":"ID","name":"Name","version":"Version","description":"Description","type":"Type","ui_href":"UIHref"},"result":{"failure_count":12,"scan_time":"2019-01-01T12:00:00.000Z","error_message":"ErrorMessage","complete_scan":true,"unscanned_resources":["UnscannedResources"]},"controls":[{"id":"ID","name":"Name","description":"Description","specifications":[{"id":"ID","description":"Description","component_name":"ComponentName","assessments":[{"id":"ID","description":"Description","version":"Version","type":"Type","method":"Method","ui_href":"UIHref"}],"ui_href":"UIHref"}],"failure_count":12,"pass_count":9,"parent":{"id":"ID","name":"Name","version":"Version","description":"Description","profile":{"id":"ID","name":"Name","version":"Version","description":"Description","type":"Type","ui_href":"UIHref"},"parent_name":"ParentName","specifications":[{"id":"ID","description":"Description","component_name":"ComponentName","assessments":[{"id":"ID","description":"Description","version":"Version","type":"Type","method":"Method","ui_href":"UIHref"}],"ui_href":"UIHref"}],"ui_href":"UIHref"},"ui_href":"UIHref"}]}]},"change_notices":{"breaking":[{"title":"Title","title_i18n":{"mapKey":"Inner"},"description":"Description","description_i18n":{"mapKey":"Inner"}}],"new":[{"title":"Title","title_i18n":{"mapKey":"Inner"},"description":"Description","description_i18n":{"mapKey":"Inner"}}],"update":[{"title":"Title","title_i18n":{"mapKey":"Inner"},"description":"Description","description_i18n":{"mapKey":"Inner"}}]},"plan_ids":["PlanIds"],"stack":{"anyKey":"anyValue"},"minimum_compatible_version":"MinimumCompatibleVersion"}],"all_versions":{"first":{"href":"Href","start":"Start"},"next":{"href":"Href","start":"Start"}}}],"publish":{"pc_managed":false,"approval_type":"ApprovalType","publish_approved":false,"share_with_all":true,"share_with_ibm":true,"share_enabled":true,"original_crn":"OriginalCRN","public_crn":"PublicCRN","approval_record":{"anyKey":"anyValue"},"permit_ibm_public_publish":true,"ibm_approved":false,"public_approved":true},"pc_managed":false,"publish_approved":false,"share_with_all":true,"share_with_ibm":true,"share_enabled":true,"public_original_crn":"PublicOriginalCRN","publish_public_crn":"PublishPublicCRN","portal_approval_record":"PortalApprovalRecord","portal_ui_url":"PortalUIURL","catalog_id":"CatalogID","catalog_name":"CatalogName","metadata":{"anyKey":"anyValue"},"disclaimer":"Disclaimer","hidden":true,"provider":"Provider","provider_info":{"id":"ID","name":"Name"},"repo_info":{"token":"Token","type":"Type"},"image_pull_keys":[{"name":"Name","value":"Value","description":"Description"}],"support":{"url":"URL","process":"Process","process_i18n":{"mapKey":"Inner"},"locations":["Locations"],"support_details":[{"type":"Type","contact":"Contact","response_wait_time":{"value":5,"type":"Type"},"availability":{"times":[{"day":3,"start_time":"StartTime","end_time":"EndTime"}],"timezone":"Timezone","always_available":false}}],"support_escalation":{"escalation_wait_time":{"value":5,"type":"Type"},"response_wait_time":{"value":5,"type":"Type"},"contact":"Contact"},"support_type":"SupportType"},"media":[{"url":"URL","api_url":"APIURL","url_proxy":{"url":"URL","sha":"Sha"},"caption":"Caption","caption_i18n":{"mapKey":"Inner"},"type":"Type","thumbnail_url":"ThumbnailURL"}],"deprecate_pending":{"deprecate_date":"2019-01-01T12:00:00.000Z","deprecate_state":"DeprecateState","description":"Description"},"product_kind":"ProductKind","badges":[{"id":"ID","label":"Label","label_i18n":{"mapKey":"Inner"},"description":"Description","description_i18n":{"mapKey":"Inner"},"icon":"Icon","authority":"Authority","tag":"Tag","learn_more_links":{"first_party":"FirstParty","third_party":"ThirdParty"},"constraints":[{"type":"Type","rule":"anyValue"}]}],"plans":[{"id":"ID","_rev":"Rev","url":"URL","crn":"CRN","created":"2019-01-01T12:00:00.000Z","updated":"2019-01-01T12:00:00.000Z","offering_id":"OfferingID","catalog_id":"CatalogID","label":"Label","label_i18n":{"mapKey":"Inner"},"name":"Name","short_description":"ShortDescription","short_description_i18n":{"mapKey":"Inner"},"pricing_tags":["PricingTags"],"version_range":{"kinds":["Kinds"],"version":"Version","flavors":["Flavors"]},"features":[{"title":"Title","title_i18n":{"mapKey":"Inner"},"description":"Description","description_i18n":{"mapKey":"Inner"}}],"state":{"current":"Current","current_entered":"2019-01-01T12:00:00.000Z","pending":"Pending","pending_requested":"2019-01-01T12:00:00.000Z","previous":"Previous"},"deprecate_pending":{"deprecate_date":"2019-01-01T12:00:00.000Z","deprecate_state":"DeprecateState","description":"Description"},"metadata":{"anyKey":"anyValue"},"publish_approved":false}]}]}`)
					} else if requestNumber == 2 {
						fmt.Fprintf(res, "%s", `{"total_count":2,"limit":1,"resources":[{"id":"ID","_rev":"Rev","url":"URL","crn":"CRN","label":"Label","label_i18n":{"mapKey":"Inner"},"name":"Name","offering_icon_url":"OfferingIconURL","offering_docs_url":"OfferingDocsURL","offering_support_url":"OfferingSupportURL","tags":["Tags"],"keywords":["Keywords"],"rating":{"one_star_count":12,"two_star_count":12,"three_star_count":14,"four_star_count":13},"created":"2019-01-01T12:00:00.000Z","updated":"2019-01-01T12:00:00.000Z","short_description":"ShortDescription","short_description_i18n":{"mapKey":"Inner"},"long_description":"LongDescription","long_description_i18n":{"mapKey":"Inner"},"features":[{"title":"Title","title_i18n":{"mapKey":"Inner"},"description":"Description","description_i18n":{"mapKey":"Inner"}}],"kinds":[{"id":"ID","format_kind":"FormatKind","format_kind_label":"FormatKindLabel","install_kind":"InstallKind","install_kind_label":"InstallKindLabel","target_kind":"TargetKind","target_kind_label":"TargetKindLabel","metadata":{"anyKey":"anyValue"},"tags":["Tags"],"additional_features":[{"title":"Title","title_i18n":{"mapKey":"Inner"},"description":"Description","description_i18n":{"mapKey":"Inner"}}],"created":"2019-01-01T12:00:00.000Z","updated":"2019-01-01T12:00:00.000Z","versions":[{"id":"ID","_rev":"Rev","crn":"CRN","version":"Version","flavor":{"name":"Name","label":"Label","label_i18n":{"mapKey":"Inner"},"index":5},"sha":"Sha","created":"2019-01-01T12:00:00.000Z","updated":"2019-01-01T12:00:00.000Z","offering_id":"OfferingID","catalog_id":"CatalogID","kind_id":"KindID","tags":["Tags"],"repo_url":"RepoURL","source_url":"SourceURL","tgz_url":"TgzURL","configuration":[{"key":"Key","type":"Type","default_value":"anyValue","display_name":"DisplayName","value_constraint":"ValueConstraint","description":"Description","required":true,"options":["anyValue"],"hidden":true,"custom_config":{"type":"Type","grouping":"Grouping","original_grouping":"OriginalGrouping","grouping_index":13,"config_constraints":{"anyKey":"anyValue"},"associations":{"parameters":[{"name":"Name","optionsRefresh":true}]}},"type_metadata":"TypeMetadata"}],"outputs":[{"key":"Key","description":"Description"}],"iam_permissions":[{"service_name":"ServiceName","role_crns":["RoleCrns"],"resources":[{"name":"Name","description":"Description","role_crns":["RoleCrns"]}]}],"metadata":{"anyKey":"anyValue"},"validation":{"validated":"2019-01-01T12:00:00.000Z","requested":"2019-01-01T12:00:00.000Z","state":"State","last_operation":"LastOperation","target":{"anyKey":"anyValue"},"message":"Message"},"required_resources":[{"type":"mem","value":"anyValue"}],"single_instance":true,"schematics_env_values":{"value":"[{\"name\": \"TF_LOG\",\"value\": \"TRACE\",\"secure\": false,\"hidden\": false}]","sm_ref":"cmsm_v1:{\"name\": \"envVarSecret\",\"id\":\"1234567890\",\"service_id\":\"crn:v1:bluemix:public:secrets-manager:eu-gb:a/1234567890:1234567890::\",\"service_name\":\"My SM Instance\",\"group_id\":\"1234567890\",\"group_name\":\"My SM Group\",\"resource_group_id\":\"1234567890\",\"region\":\"eu-gb\",\"type\":\"arbitrary\"}"},"install":{"instructions":"Instructions","instructions_i18n":{"mapKey":"Inner"},"script":"Script","script_permission":"ScriptPermission","delete_script":"DeleteScript","scope":"Scope"},"pre_install":[{"instructions":"Instructions","instructions_i18n":{"mapKey":"Inner"},"script":"Script","script_permission":"ScriptPermission","delete_script":"DeleteScript","scope":"Scope"}],"scripts":{"mapKey":{"short_description":"ShortDescription","type":"ansible","path":"scripts/validate-post-ansible-playbook.yaml","stage":"pre","action":"validate"}},"entitlement":{"provider_name":"ProviderName","provider_id":"ProviderID","product_id":"ProductID","part_numbers":["PartNumbers"],"image_repo_name":"ImageRepoName"},"licenses":[{"id":"ID","name":"Name","type":"Type","url":"URL","description":"Description"}],"image_manifest_url":"ImageManifestURL","deprecated":true,"package_version":"PackageVersion","state":{"current":"Current","current_entered":"2019-01-01T12:00:00.000Z","pending":"Pending","pending_requested":"2019-01-01T12:00:00.000Z","previous":"Previous"},"version_locator":"VersionLocator","long_description":"LongDescription","long_description_i18n":{"mapKey":"Inner"},"whitelisted_accounts":["WhitelistedAccounts"],"image_pull_key_name":"ImagePullKeyName","deprecate_pending":{"deprecate_date":"2019-01-01T12:00:00.000Z","deprecate_state":"DeprecateState","description":"Description"},"solution_info":{"architecture_diagrams":[{"diagram":{"url":"URL","api_url":"APIURL","url_proxy":{"url":"URL","sha":"Sha"},"caption":"Caption","caption_i18n":{"mapKey":"Inner"},"type":"Type","thumbnail_url":"ThumbnailURL"},"description":"Description","description_i18n":{"mapKey":"Inner"}}],"features":[{"title":"Title","title_i18n":{"mapKey":"Inner"},"description":"Description","description_i18n":{"mapKey":"Inner"}}],"cost_estimate":{"version":"Version","currency":"Currency","projects":[{"name":"Name","metadata":{"anyKey":"anyValue"},"pastBreakdown":{"totalHourlyCost":"TotalHourlyCost","totalMonthlyCost":"TotalMonthlyCost","resources":[{"name":"Name","metadata":{"anyKey":"anyValue"},"hourlyCost":"HourlyCost","monthlyCost":"MonthlyCost","costComponents":[{"name":"Name","unit":"Unit","hourlyQuantity":"HourlyQuantity","monthlyQuantity":"MonthlyQuantity","price":"Price","hourlyCost":"HourlyCost","monthlyCost":"MonthlyCost"}]}]},"breakdown":{"totalHourlyCost":"TotalHourlyCost","totalMonthlyCost":"TotalMonthlyCost","resources":[{"name":"Name","metadata":{"anyKey":"anyValue"},"hourlyCost":"HourlyCost","monthlyCost":"MonthlyCost","costComponents":[{"name":"Name","unit":"Unit","hourlyQuantity":"HourlyQuantity","monthlyQuantity":"MonthlyQuantity","price":"Price","hourlyCost":"HourlyCost","monthlyCost":"MonthlyCost"}]}]},"diff":{"totalHourlyCost":"TotalHourlyCost","totalMonthlyCost":"TotalMonthlyCost","resources":[{"name":"Name","metadata":{"anyKey":"anyValue"},"hourlyCost":"HourlyCost","monthlyCost":"MonthlyCost","costComponents":[{"name":"Name","unit":"Unit","hourlyQuantity":"HourlyQuantity","monthlyQuantity":"MonthlyQuantity","price":"Price","hourlyCost":"HourlyCost","monthlyCost":"MonthlyCost"}]}]},"summary":{"totalDetectedResources":22,"totalSupportedResources":23,"totalUnsupportedResources":25,"totalUsageBasedResources":24,"totalNoPriceResources":21,"unsupportedResourceCounts":{"mapKey":5},"noPriceResourceCounts":{"mapKey":5}}}],"summary":{"totalDetectedResources":22,"totalSupportedResources":23,"totalUnsupportedResources":25,"totalUsageBasedResources":24,"totalNoPriceResources":21,"unsupportedResourceCounts":{"mapKey":5},"noPriceResourceCounts":{"mapKey":5}},"totalHourlyCost":"TotalHourlyCost","totalMonthlyCost":"TotalMonthlyCost","pastTotalHourlyCost":"PastTotalHourlyCost","pastTotalMonthlyCost":"PastTotalMonthlyCost","diffTotalHourlyCost":"DiffTotalHourlyCost","diffTotalMonthlyCost":"DiffTotalMonthlyCost","timeGenerated":"2019-01-01T12:00:00.000Z"},"dependencies":[{"catalog_id":"CatalogID","id":"ID","name":"Name","kind":"Kind","version":"Version","description":"Description","default_flavor":"DefaultFlavor","flavors":["Flavors"],"optional":true,"on_by_default":false}],"install_type":"InstallType"},"is_consumable":true,"compliance_v3":{"authority":"Authority","claims":{"profiles":[{"id":"ID","name":"Name","version":"Version","description":"Description","type":"Type","ui_href":"UIHref"}],"controls":[{"profile":{"id":"ID","name":"Name","version":"Version","description":"Description","type":"Type","ui_href":"UIHref"},"names":["Names"]}]},"evaluations":[{"scan_id":"ScanID","account_id":"AccountID","profile":{"id":"ID","name":"Name","version":"Version","description":"Description","type":"Type","ui_href":"UIHref"},"result":{"failure_count":12,"scan_time":"2019-01-01T12:00:00.000Z","error_message":"ErrorMessage","complete_scan":true,"unscanned_resources":["UnscannedResources"]},"controls":[{"id":"ID","name":"Name","description":"Description","specifications":[{"id":"ID","description":"Description","component_name":"ComponentName","assessments":[{"id":"ID","description":"Description","version":"Version","type":"Type","method":"Method","ui_href":"UIHref"}],"ui_href":"UIHref"}],"failure_count":12,"pass_count":9,"parent":{"id":"ID","name":"Name","version":"Version","description":"Description","profile":{"id":"ID","name":"Name","version":"Version","description":"Description","type":"Type","ui_href":"UIHref"},"parent_name":"ParentName","specifications":[{"id":"ID","description":"Description","component_name":"ComponentName","assessments":[{"id":"ID","description":"Description","version":"Version","type":"Type","method":"Method","ui_href":"UIHref"}],"ui_href":"UIHref"}],"ui_href":"UIHref"},"ui_href":"UIHref"}]}]},"change_notices":{"breaking":[{"title":"Title","title_i18n":{"mapKey":"Inner"},"description":"Description","description_i18n":{"mapKey":"Inner"}}],"new":[{"title":"Title","title_i18n":{"mapKey":"Inner"},"description":"Description","description_i18n":{"mapKey":"Inner"}}],"update":[{"title":"Title","title_i18n":{"mapKey":"Inner"},"description":"Description","description_i18n":{"mapKey":"Inner"}}]},"plan_ids":["PlanIds"],"stack":{"anyKey":"anyValue"},"minimum_compatible_version":"MinimumCompatibleVersion"}],"all_versions":{"first":{"href":"Href","start":"Start"},"next":{"href":"Href","start":"Start"}}}],"publish":{"pc_managed":false,"approval_type":"ApprovalType","publish_approved":false,"share_with_all":true,"share_with_ibm":true,"share_enabled":true,"original_crn":"OriginalCRN","public_crn":"PublicCRN","approval_record":{"anyKey":"anyValue"},"permit_ibm_public_publish":true,"ibm_approved":false,"public_approved":true},"pc_managed":false,"publish_approved":false,"share_with_all":true,"share_with_ibm":true,"share_enabled":true,"public_original_crn":"PublicOriginalCRN","publish_public_crn":"PublishPublicCRN","portal_approval_record":"PortalApprovalRecord","portal_ui_url":"PortalUIURL","catalog_id":"CatalogID","catalog_name":"CatalogName","metadata":{"anyKey":"anyValue"},"disclaimer":"Disclaimer","hidden":true,"provider":"Provider","provider_info":{"id":"ID","name":"Name"},"repo_info":{"token":"Token","type":"Type"},"image_pull_keys":[{"name":"Name","value":"Value","description":"Description"}],"support":{"url":"URL","process":"Process","process_i18n":{"mapKey":"Inner"},"locations":["Locations"],"support_details":[{"type":"Type","contact":"Contact","response_wait_time":{"value":5,"type":"Type"},"availability":{"times":[{"day":3,"start_time":"StartTime","end_time":"EndTime"}],"timezone":"Timezone","always_available":false}}],"support_escalation":{"escalation_wait_time":{"value":5,"type":"Type"},"response_wait_time":{"value":5,"type":"Type"},"contact":"Contact"},"support_type":"SupportType"},"media":[{"url":"URL","api_url":"APIURL","url_proxy":{"url":"URL","sha":"Sha"},"caption":"Caption","caption_i18n":{"mapKey":"Inner"},"type":"Type","thumbnail_url":"ThumbnailURL"}],"deprecate_pending":{"deprecate_date":"2019-01-01T12:00:00.000Z","deprecate_state":"DeprecateState","description":"Description"},"product_kind":"ProductKind","badges":[{"id":"ID","label":"Label","label_i18n":{"mapKey":"Inner"},"description":"Description","description_i18n":{"mapKey":"Inner"},"icon":"Icon","authority":"Authority","tag":"Tag","learn_more_links":{"first_party":"FirstParty","third_party":"ThirdParty"},"constraints":[{"type":"Type","rule":"anyValue"}]}],"plans":[{"id":"ID","_rev":"Rev","url":"URL","crn":"CRN","created":"2019-01-01T12:00:00.000Z","updated":"2019-01-01T12:00:00.000Z","offering_id":"OfferingID","catalog_id":"CatalogID","label":"Label","label_i18n":{"mapKey":"Inner"},"name":"Name","short_description":"ShortDescription","short_description_i18n":{"mapKey":"Inner"},"pricing_tags":["PricingTags"],"version_range":{"kinds":["Kinds"],"version":"Version","flavors":["Flavors"]},"features":[{"title":"Title","title_i18n":{"mapKey":"Inner"},"description":"Description","description_i18n":{"mapKey":"Inner"}}],"state":{"current":"Current","current_entered":"2019-01-01T12:00:00.000Z","pending":"Pending","pending_requested":"2019-01-01T12:00:00.000Z","previous":"Previous"},"deprecate_pending":{"deprecate_date":"2019-01-01T12:00:00.000Z","deprecate_state":"DeprecateState","description":"Description"},"metadata":{"anyKey":"anyValue"},"publish_approved":false}]}]}`)
					} else {
						res.WriteHeader(400)
					}
				}))
			})
			It(`Use OfferingsPager.GetNext successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				listOfferingsOptionsModel := &catalogmanagementv1.ListOfferingsOptions{
					CatalogIdentifier: core.StringPtr("testString"),
					Digest:            core.BoolPtr(true),
					Limit:             core.Int64Ptr(int64(10)),
					Name:              core.StringPtr("testString"),
					Sort:              core.StringPtr("testString"),
					IncludeHidden:     core.BoolPtr(true),
				}

				pager, err := catalogManagementService.NewOfferingsPager(listOfferingsOptionsModel)
				Expect(err).To(BeNil())
				Expect(pager).ToNot(BeNil())

				var allResults []catalogmanagementv1.Offering
				for pager.HasNext() {
					nextPage, err := pager.GetNext()
					Expect(err).To(BeNil())
					Expect(nextPage).ToNot(BeNil())
					allResults = append(allResults, nextPage...)
				}
				Expect(len(allResults)).To(Equal(2))
			})
			It(`Use OfferingsPager.GetAll successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				listOfferingsOptionsModel := &catalogmanagementv1.ListOfferingsOptions{
					CatalogIdentifier: core.StringPtr("testString"),
					Digest:            core.BoolPtr(true),
					Limit:             core.Int64Ptr(int64(10)),
					Name:              core.StringPtr("testString"),
					Sort:              core.StringPtr("testString"),
					IncludeHidden:     core.BoolPtr(true),
				}

				pager, err := catalogManagementService.NewOfferingsPager(listOfferingsOptionsModel)
				Expect(err).To(BeNil())
				Expect(pager).ToNot(BeNil())

				allResults, err := pager.GetAll()
				Expect(err).To(BeNil())
				Expect(allResults).ToNot(BeNil())
				Expect(len(allResults)).To(Equal(2))
			})
		})
	})
	Describe(`CreateOffering(createOfferingOptions *CreateOfferingOptions) - Operation response error`, func() {
		createOfferingPath := "/catalogs/testString/offerings"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createOfferingPath))
					Expect(req.Method).To(Equal("POST"))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke CreateOffering with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the Rating model
				ratingModel := new(catalogmanagementv1.Rating)
				ratingModel.OneStarCount = core.Int64Ptr(int64(38))
				ratingModel.TwoStarCount = core.Int64Ptr(int64(38))
				ratingModel.ThreeStarCount = core.Int64Ptr(int64(38))
				ratingModel.FourStarCount = core.Int64Ptr(int64(38))

				// Construct an instance of the Feature model
				featureModel := new(catalogmanagementv1.Feature)
				featureModel.Title = core.StringPtr("testString")
				featureModel.TitleI18n = map[string]string{"key1": "testString"}
				featureModel.Description = core.StringPtr("testString")
				featureModel.DescriptionI18n = map[string]string{"key1": "testString"}

				// Construct an instance of the Flavor model
				flavorModel := new(catalogmanagementv1.Flavor)
				flavorModel.Name = core.StringPtr("testString")
				flavorModel.Label = core.StringPtr("testString")
				flavorModel.LabelI18n = map[string]string{"key1": "testString"}
				flavorModel.Index = core.Int64Ptr(int64(38))

				// Construct an instance of the RenderTypeAssociationsParametersItem model
				renderTypeAssociationsParametersItemModel := new(catalogmanagementv1.RenderTypeAssociationsParametersItem)
				renderTypeAssociationsParametersItemModel.Name = core.StringPtr("testString")
				renderTypeAssociationsParametersItemModel.OptionsRefresh = core.BoolPtr(true)

				// Construct an instance of the RenderTypeAssociations model
				renderTypeAssociationsModel := new(catalogmanagementv1.RenderTypeAssociations)
				renderTypeAssociationsModel.Parameters = []catalogmanagementv1.RenderTypeAssociationsParametersItem{*renderTypeAssociationsParametersItemModel}

				// Construct an instance of the RenderType model
				renderTypeModel := new(catalogmanagementv1.RenderType)
				renderTypeModel.Type = core.StringPtr("testString")
				renderTypeModel.Grouping = core.StringPtr("testString")
				renderTypeModel.OriginalGrouping = core.StringPtr("testString")
				renderTypeModel.GroupingIndex = core.Int64Ptr(int64(38))
				renderTypeModel.ConfigConstraints = map[string]interface{}{"anyKey": "anyValue"}
				renderTypeModel.Associations = renderTypeAssociationsModel

				// Construct an instance of the Configuration model
				configurationModel := new(catalogmanagementv1.Configuration)
				configurationModel.Key = core.StringPtr("testString")
				configurationModel.Type = core.StringPtr("testString")
				configurationModel.DefaultValue = "testString"
				configurationModel.DisplayName = core.StringPtr("testString")
				configurationModel.ValueConstraint = core.StringPtr("testString")
				configurationModel.Description = core.StringPtr("testString")
				configurationModel.Required = core.BoolPtr(true)
				configurationModel.Options = []interface{}{"testString"}
				configurationModel.Hidden = core.BoolPtr(true)
				configurationModel.CustomConfig = renderTypeModel
				configurationModel.TypeMetadata = core.StringPtr("testString")

				// Construct an instance of the Output model
				outputModel := new(catalogmanagementv1.Output)
				outputModel.Key = core.StringPtr("testString")
				outputModel.Description = core.StringPtr("testString")

				// Construct an instance of the IamResource model
				iamResourceModel := new(catalogmanagementv1.IamResource)
				iamResourceModel.Name = core.StringPtr("testString")
				iamResourceModel.Description = core.StringPtr("testString")
				iamResourceModel.RoleCrns = []string{"testString"}

				// Construct an instance of the IamPermission model
				iamPermissionModel := new(catalogmanagementv1.IamPermission)
				iamPermissionModel.ServiceName = core.StringPtr("testString")
				iamPermissionModel.RoleCrns = []string{"testString"}
				iamPermissionModel.Resources = []catalogmanagementv1.IamResource{*iamResourceModel}

				// Construct an instance of the Validation model
				validationModel := new(catalogmanagementv1.Validation)
				validationModel.Validated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				validationModel.Requested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				validationModel.State = core.StringPtr("testString")
				validationModel.LastOperation = core.StringPtr("testString")
				validationModel.Target = map[string]interface{}{"anyKey": "anyValue"}
				validationModel.Message = core.StringPtr("testString")

				// Construct an instance of the Resource model
				resourceModel := new(catalogmanagementv1.Resource)
				resourceModel.Type = core.StringPtr("mem")
				resourceModel.Value = "testString"

				// Construct an instance of the SchematicsEnvValues model
				schematicsEnvValuesModel := new(catalogmanagementv1.SchematicsEnvValues)
				schematicsEnvValuesModel.Value = core.StringPtr("[{\"name\": \"TF_LOG\",\"value\": \"TRACE\",\"secure\": false,\"hidden\": false}]")
				schematicsEnvValuesModel.SmRef = core.StringPtr("cmsm_v1:{\"name\": \"envVarSecret\",\"id\":\"1234567890\",\"service_id\":\"crn:v1:bluemix:public:secrets-manager:eu-gb:a/1234567890:1234567890::\",\"service_name\":\"My SM Instance\",\"group_id\":\"1234567890\",\"group_name\":\"My SM Group\",\"resource_group_id\":\"1234567890\",\"region\":\"eu-gb\",\"type\":\"arbitrary\"}")

				// Construct an instance of the Script model
				scriptModel := new(catalogmanagementv1.Script)
				scriptModel.Instructions = core.StringPtr("testString")
				scriptModel.InstructionsI18n = map[string]string{"key1": "testString"}
				scriptModel.Script = core.StringPtr("testString")
				scriptModel.ScriptPermission = core.StringPtr("testString")
				scriptModel.DeleteScript = core.StringPtr("testString")
				scriptModel.Scope = core.StringPtr("testString")

				// Construct an instance of the ScriptRef model
				scriptRefModel := new(catalogmanagementv1.ScriptRef)
				scriptRefModel.ShortDescription = core.StringPtr("testString")
				scriptRefModel.Type = core.StringPtr("ansible")
				scriptRefModel.Path = core.StringPtr("scripts/validate-post-ansible-playbook.yaml")
				scriptRefModel.Stage = core.StringPtr("pre")
				scriptRefModel.Action = core.StringPtr("validate")

				// Construct an instance of the VersionEntitlement model
				versionEntitlementModel := new(catalogmanagementv1.VersionEntitlement)
				versionEntitlementModel.ProviderName = core.StringPtr("testString")
				versionEntitlementModel.ProviderID = core.StringPtr("testString")
				versionEntitlementModel.ProductID = core.StringPtr("testString")
				versionEntitlementModel.PartNumbers = []string{"testString"}
				versionEntitlementModel.ImageRepoName = core.StringPtr("testString")

				// Construct an instance of the License model
				licenseModel := new(catalogmanagementv1.License)
				licenseModel.ID = core.StringPtr("testString")
				licenseModel.Name = core.StringPtr("testString")
				licenseModel.Type = core.StringPtr("testString")
				licenseModel.URL = core.StringPtr("testString")
				licenseModel.Description = core.StringPtr("testString")

				// Construct an instance of the State model
				stateModel := new(catalogmanagementv1.State)
				stateModel.Current = core.StringPtr("testString")
				stateModel.CurrentEntered = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Pending = core.StringPtr("testString")
				stateModel.PendingRequested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Previous = core.StringPtr("testString")

				// Construct an instance of the DeprecatePending model
				deprecatePendingModel := new(catalogmanagementv1.DeprecatePending)
				deprecatePendingModel.DeprecateDate = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				deprecatePendingModel.DeprecateState = core.StringPtr("testString")
				deprecatePendingModel.Description = core.StringPtr("testString")

				// Construct an instance of the URLProxy model
				urlProxyModel := new(catalogmanagementv1.URLProxy)
				urlProxyModel.URL = core.StringPtr("testString")
				urlProxyModel.Sha = core.StringPtr("testString")

				// Construct an instance of the MediaItem model
				mediaItemModel := new(catalogmanagementv1.MediaItem)
				mediaItemModel.URL = core.StringPtr("testString")
				mediaItemModel.APIURL = core.StringPtr("testString")
				mediaItemModel.URLProxy = urlProxyModel
				mediaItemModel.Caption = core.StringPtr("testString")
				mediaItemModel.CaptionI18n = map[string]string{"key1": "testString"}
				mediaItemModel.Type = core.StringPtr("testString")
				mediaItemModel.ThumbnailURL = core.StringPtr("testString")

				// Construct an instance of the ArchitectureDiagram model
				architectureDiagramModel := new(catalogmanagementv1.ArchitectureDiagram)
				architectureDiagramModel.Diagram = mediaItemModel
				architectureDiagramModel.Description = core.StringPtr("testString")
				architectureDiagramModel.DescriptionI18n = map[string]string{"key1": "testString"}

				// Construct an instance of the CostComponent model
				costComponentModel := new(catalogmanagementv1.CostComponent)
				costComponentModel.Name = core.StringPtr("testString")
				costComponentModel.Unit = core.StringPtr("testString")
				costComponentModel.HourlyQuantity = core.StringPtr("testString")
				costComponentModel.MonthlyQuantity = core.StringPtr("testString")
				costComponentModel.Price = core.StringPtr("testString")
				costComponentModel.HourlyCost = core.StringPtr("testString")
				costComponentModel.MonthlyCost = core.StringPtr("testString")

				// Construct an instance of the CostResource model
				costResourceModel := new(catalogmanagementv1.CostResource)
				costResourceModel.Name = core.StringPtr("testString")
				costResourceModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				costResourceModel.HourlyCost = core.StringPtr("testString")
				costResourceModel.MonthlyCost = core.StringPtr("testString")
				costResourceModel.CostComponents = []catalogmanagementv1.CostComponent{*costComponentModel}

				// Construct an instance of the CostBreakdown model
				costBreakdownModel := new(catalogmanagementv1.CostBreakdown)
				costBreakdownModel.TotalHourlyCost = core.StringPtr("testString")
				costBreakdownModel.TotalMonthlyCost = core.StringPtr("testString")
				costBreakdownModel.Resources = []catalogmanagementv1.CostResource{*costResourceModel}

				// Construct an instance of the CostSummary model
				costSummaryModel := new(catalogmanagementv1.CostSummary)
				costSummaryModel.TotalDetectedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalSupportedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalUnsupportedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalUsageBasedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalNoPriceResources = core.Int64Ptr(int64(38))
				costSummaryModel.UnsupportedResourceCounts = map[string]int64{"key1": int64(38)}
				costSummaryModel.NoPriceResourceCounts = map[string]int64{"key1": int64(38)}

				// Construct an instance of the Project model
				projectModel := new(catalogmanagementv1.Project)
				projectModel.Name = core.StringPtr("testString")
				projectModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				projectModel.PastBreakdown = costBreakdownModel
				projectModel.Breakdown = costBreakdownModel
				projectModel.Diff = costBreakdownModel
				projectModel.Summary = costSummaryModel

				// Construct an instance of the CostEstimate model
				costEstimateModel := new(catalogmanagementv1.CostEstimate)
				costEstimateModel.Version = core.StringPtr("testString")
				costEstimateModel.Currency = core.StringPtr("testString")
				costEstimateModel.Projects = []catalogmanagementv1.Project{*projectModel}
				costEstimateModel.Summary = costSummaryModel
				costEstimateModel.TotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.TotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.PastTotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.PastTotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.DiffTotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.DiffTotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.TimeGenerated = CreateMockDateTime("2019-01-01T12:00:00.000Z")

				// Construct an instance of the OfferingReference model
				offeringReferenceModel := new(catalogmanagementv1.OfferingReference)
				offeringReferenceModel.CatalogID = core.StringPtr("testString")
				offeringReferenceModel.ID = core.StringPtr("testString")
				offeringReferenceModel.Name = core.StringPtr("testString")
				offeringReferenceModel.Kind = core.StringPtr("testString")
				offeringReferenceModel.Version = core.StringPtr("testString")
				offeringReferenceModel.Description = core.StringPtr("testString")
				offeringReferenceModel.DefaultFlavor = core.StringPtr("testString")
				offeringReferenceModel.Flavors = []string{"testString"}
				offeringReferenceModel.Optional = core.BoolPtr(true)
				offeringReferenceModel.OnByDefault = core.BoolPtr(true)

				// Construct an instance of the SolutionInfo model
				solutionInfoModel := new(catalogmanagementv1.SolutionInfo)
				solutionInfoModel.ArchitectureDiagrams = []catalogmanagementv1.ArchitectureDiagram{*architectureDiagramModel}
				solutionInfoModel.Features = []catalogmanagementv1.Feature{*featureModel}
				solutionInfoModel.CostEstimate = costEstimateModel
				solutionInfoModel.Dependencies = []catalogmanagementv1.OfferingReference{*offeringReferenceModel}
				solutionInfoModel.InstallType = core.StringPtr("testString")

				// Construct an instance of the SccProfile model
				sccProfileModel := new(catalogmanagementv1.SccProfile)
				sccProfileModel.ID = core.StringPtr("testString")
				sccProfileModel.Name = core.StringPtr("testString")
				sccProfileModel.Version = core.StringPtr("testString")
				sccProfileModel.Description = core.StringPtr("testString")
				sccProfileModel.Type = core.StringPtr("testString")
				sccProfileModel.UIHref = core.StringPtr("testString")

				// Construct an instance of the ClaimedControl model
				claimedControlModel := new(catalogmanagementv1.ClaimedControl)
				claimedControlModel.Profile = sccProfileModel
				claimedControlModel.Names = []string{"testString"}

				// Construct an instance of the Claims model
				claimsModel := new(catalogmanagementv1.Claims)
				claimsModel.Profiles = []catalogmanagementv1.SccProfile{*sccProfileModel}
				claimsModel.Controls = []catalogmanagementv1.ClaimedControl{*claimedControlModel}

				// Construct an instance of the Result model
				resultModel := new(catalogmanagementv1.Result)
				resultModel.FailureCount = core.Int64Ptr(int64(38))
				resultModel.ScanTime = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				resultModel.ErrorMessage = core.StringPtr("testString")
				resultModel.CompleteScan = core.BoolPtr(true)
				resultModel.UnscannedResources = []string{"testString"}

				// Construct an instance of the SccAssessment model
				sccAssessmentModel := new(catalogmanagementv1.SccAssessment)
				sccAssessmentModel.ID = core.StringPtr("testString")
				sccAssessmentModel.Description = core.StringPtr("testString")
				sccAssessmentModel.Version = core.StringPtr("testString")
				sccAssessmentModel.Type = core.StringPtr("testString")
				sccAssessmentModel.Method = core.StringPtr("testString")
				sccAssessmentModel.UIHref = core.StringPtr("testString")

				// Construct an instance of the SccSpecification model
				sccSpecificationModel := new(catalogmanagementv1.SccSpecification)
				sccSpecificationModel.ID = core.StringPtr("testString")
				sccSpecificationModel.Description = core.StringPtr("testString")
				sccSpecificationModel.ComponentName = core.StringPtr("testString")
				sccSpecificationModel.Assessments = []catalogmanagementv1.SccAssessment{*sccAssessmentModel}
				sccSpecificationModel.UIHref = core.StringPtr("testString")

				// Construct an instance of the SccControl model
				sccControlModel := new(catalogmanagementv1.SccControl)
				sccControlModel.ID = core.StringPtr("testString")
				sccControlModel.Name = core.StringPtr("testString")
				sccControlModel.Version = core.StringPtr("testString")
				sccControlModel.Description = core.StringPtr("testString")
				sccControlModel.Profile = sccProfileModel
				sccControlModel.ParentName = core.StringPtr("testString")
				sccControlModel.Specifications = []catalogmanagementv1.SccSpecification{*sccSpecificationModel}
				sccControlModel.UIHref = core.StringPtr("testString")

				// Construct an instance of the EvaluatedControl model
				evaluatedControlModel := new(catalogmanagementv1.EvaluatedControl)
				evaluatedControlModel.ID = core.StringPtr("testString")
				evaluatedControlModel.Name = core.StringPtr("testString")
				evaluatedControlModel.Description = core.StringPtr("testString")
				evaluatedControlModel.Specifications = []catalogmanagementv1.SccSpecification{*sccSpecificationModel}
				evaluatedControlModel.FailureCount = core.Int64Ptr(int64(38))
				evaluatedControlModel.PassCount = core.Int64Ptr(int64(38))
				evaluatedControlModel.Parent = sccControlModel
				evaluatedControlModel.UIHref = core.StringPtr("testString")

				// Construct an instance of the Evaluation model
				evaluationModel := new(catalogmanagementv1.Evaluation)
				evaluationModel.ScanID = core.StringPtr("testString")
				evaluationModel.AccountID = core.StringPtr("testString")
				evaluationModel.Profile = sccProfileModel
				evaluationModel.Result = resultModel
				evaluationModel.Controls = []catalogmanagementv1.EvaluatedControl{*evaluatedControlModel}

				// Construct an instance of the Compliance model
				complianceModel := new(catalogmanagementv1.Compliance)
				complianceModel.Authority = core.StringPtr("testString")
				complianceModel.Claims = claimsModel
				complianceModel.Evaluations = []catalogmanagementv1.Evaluation{*evaluationModel}

				// Construct an instance of the ChangeNotices model
				changeNoticesModel := new(catalogmanagementv1.ChangeNotices)
				changeNoticesModel.Breaking = []catalogmanagementv1.Feature{*featureModel}
				changeNoticesModel.New = []catalogmanagementv1.Feature{*featureModel}
				changeNoticesModel.Update = []catalogmanagementv1.Feature{*featureModel}

				// Construct an instance of the Version model
				versionModel := new(catalogmanagementv1.Version)
				versionModel.CRN = core.StringPtr("testString")
				versionModel.Version = core.StringPtr("testString")
				versionModel.Flavor = flavorModel
				versionModel.Sha = core.StringPtr("testString")
				versionModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				versionModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				versionModel.OfferingID = core.StringPtr("testString")
				versionModel.CatalogID = core.StringPtr("testString")
				versionModel.KindID = core.StringPtr("testString")
				versionModel.Tags = []string{"testString"}
				versionModel.RepoURL = core.StringPtr("testString")
				versionModel.SourceURL = core.StringPtr("testString")
				versionModel.TgzURL = core.StringPtr("testString")
				versionModel.Configuration = []catalogmanagementv1.Configuration{*configurationModel}
				versionModel.Outputs = []catalogmanagementv1.Output{*outputModel}
				versionModel.IamPermissions = []catalogmanagementv1.IamPermission{*iamPermissionModel}
				versionModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				versionModel.Validation = validationModel
				versionModel.RequiredResources = []catalogmanagementv1.Resource{*resourceModel}
				versionModel.SingleInstance = core.BoolPtr(true)
				versionModel.SchematicsEnvValues = schematicsEnvValuesModel
				versionModel.Install = scriptModel
				versionModel.PreInstall = []catalogmanagementv1.Script{*scriptModel}
				versionModel.Scripts = map[string]catalogmanagementv1.ScriptRef{"key1": *scriptRefModel}
				versionModel.Entitlement = versionEntitlementModel
				versionModel.Licenses = []catalogmanagementv1.License{*licenseModel}
				versionModel.ImageManifestURL = core.StringPtr("testString")
				versionModel.Deprecated = core.BoolPtr(true)
				versionModel.PackageVersion = core.StringPtr("testString")
				versionModel.State = stateModel
				versionModel.VersionLocator = core.StringPtr("testString")
				versionModel.LongDescription = core.StringPtr("testString")
				versionModel.LongDescriptionI18n = map[string]string{"key1": "testString"}
				versionModel.WhitelistedAccounts = []string{"testString"}
				versionModel.ImagePullKeyName = core.StringPtr("testString")
				versionModel.DeprecatePending = deprecatePendingModel
				versionModel.SolutionInfo = solutionInfoModel
				versionModel.IsConsumable = core.BoolPtr(true)
				versionModel.ComplianceV3 = complianceModel
				versionModel.ChangeNotices = changeNoticesModel
				versionModel.PlanIds = []string{"testString"}
				versionModel.Stack = map[string]interface{}{"anyKey": "anyValue"}
				versionModel.MinimumCompatibleVersion = core.StringPtr("testString")
				versionModel.Scripts["foo"] = *scriptRefModel

				// Construct an instance of the PaginationTokenLink model
				paginationTokenLinkModel := new(catalogmanagementv1.PaginationTokenLink)
				paginationTokenLinkModel.Href = core.StringPtr("testString")
				paginationTokenLinkModel.Start = core.StringPtr("testString")

				// Construct an instance of the KindAllVersions model
				kindAllVersionsModel := new(catalogmanagementv1.KindAllVersions)
				kindAllVersionsModel.First = paginationTokenLinkModel
				kindAllVersionsModel.Next = paginationTokenLinkModel

				// Construct an instance of the Kind model
				kindModel := new(catalogmanagementv1.Kind)
				kindModel.ID = core.StringPtr("testString")
				kindModel.FormatKind = core.StringPtr("testString")
				kindModel.FormatKindLabel = core.StringPtr("testString")
				kindModel.InstallKind = core.StringPtr("testString")
				kindModel.InstallKindLabel = core.StringPtr("testString")
				kindModel.TargetKind = core.StringPtr("testString")
				kindModel.TargetKindLabel = core.StringPtr("testString")
				kindModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				kindModel.Tags = []string{"testString"}
				kindModel.AdditionalFeatures = []catalogmanagementv1.Feature{*featureModel}
				kindModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				kindModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				kindModel.Versions = []catalogmanagementv1.Version{*versionModel}
				kindModel.AllVersions = kindAllVersionsModel

				// Construct an instance of the PublishObject model
				publishObjectModel := new(catalogmanagementv1.PublishObject)
				publishObjectModel.PcManaged = core.BoolPtr(true)
				publishObjectModel.ApprovalType = core.StringPtr("testString")
				publishObjectModel.PublishApproved = core.BoolPtr(true)
				publishObjectModel.ShareWithAll = core.BoolPtr(true)
				publishObjectModel.ShareWithIBM = core.BoolPtr(true)
				publishObjectModel.ShareEnabled = core.BoolPtr(true)
				publishObjectModel.OriginalCRN = core.StringPtr("testString")
				publishObjectModel.PublicCRN = core.StringPtr("testString")
				publishObjectModel.ApprovalRecord = map[string]interface{}{"anyKey": "anyValue"}
				publishObjectModel.PermitIBMPublicPublish = core.BoolPtr(true)
				publishObjectModel.IBMApproved = core.BoolPtr(true)
				publishObjectModel.PublicApproved = core.BoolPtr(true)

				// Construct an instance of the ProviderInfo model
				providerInfoModel := new(catalogmanagementv1.ProviderInfo)
				providerInfoModel.ID = core.StringPtr("testString")
				providerInfoModel.Name = core.StringPtr("testString")

				// Construct an instance of the RepoInfo model
				repoInfoModel := new(catalogmanagementv1.RepoInfo)
				repoInfoModel.Token = core.StringPtr("testString")
				repoInfoModel.Type = core.StringPtr("testString")

				// Construct an instance of the ImagePullKey model
				imagePullKeyModel := new(catalogmanagementv1.ImagePullKey)
				imagePullKeyModel.Name = core.StringPtr("testString")
				imagePullKeyModel.Value = core.StringPtr("testString")
				imagePullKeyModel.Description = core.StringPtr("testString")

				// Construct an instance of the SupportWaitTime model
				supportWaitTimeModel := new(catalogmanagementv1.SupportWaitTime)
				supportWaitTimeModel.Value = core.Int64Ptr(int64(38))
				supportWaitTimeModel.Type = core.StringPtr("testString")

				// Construct an instance of the SupportTime model
				supportTimeModel := new(catalogmanagementv1.SupportTime)
				supportTimeModel.Day = core.Int64Ptr(int64(38))
				supportTimeModel.StartTime = core.StringPtr("testString")
				supportTimeModel.EndTime = core.StringPtr("testString")

				// Construct an instance of the SupportAvailability model
				supportAvailabilityModel := new(catalogmanagementv1.SupportAvailability)
				supportAvailabilityModel.Times = []catalogmanagementv1.SupportTime{*supportTimeModel}
				supportAvailabilityModel.Timezone = core.StringPtr("testString")
				supportAvailabilityModel.AlwaysAvailable = core.BoolPtr(true)

				// Construct an instance of the SupportDetail model
				supportDetailModel := new(catalogmanagementv1.SupportDetail)
				supportDetailModel.Type = core.StringPtr("testString")
				supportDetailModel.Contact = core.StringPtr("testString")
				supportDetailModel.ResponseWaitTime = supportWaitTimeModel
				supportDetailModel.Availability = supportAvailabilityModel

				// Construct an instance of the SupportEscalation model
				supportEscalationModel := new(catalogmanagementv1.SupportEscalation)
				supportEscalationModel.EscalationWaitTime = supportWaitTimeModel
				supportEscalationModel.ResponseWaitTime = supportWaitTimeModel
				supportEscalationModel.Contact = core.StringPtr("testString")

				// Construct an instance of the Support model
				supportModel := new(catalogmanagementv1.Support)
				supportModel.URL = core.StringPtr("testString")
				supportModel.Process = core.StringPtr("testString")
				supportModel.ProcessI18n = map[string]string{"key1": "testString"}
				supportModel.Locations = []string{"testString"}
				supportModel.SupportDetails = []catalogmanagementv1.SupportDetail{*supportDetailModel}
				supportModel.SupportEscalation = supportEscalationModel
				supportModel.SupportType = core.StringPtr("testString")

				// Construct an instance of the LearnMoreLinks model
				learnMoreLinksModel := new(catalogmanagementv1.LearnMoreLinks)
				learnMoreLinksModel.FirstParty = core.StringPtr("testString")
				learnMoreLinksModel.ThirdParty = core.StringPtr("testString")

				// Construct an instance of the Constraint model
				constraintModel := new(catalogmanagementv1.Constraint)
				constraintModel.Type = core.StringPtr("testString")
				constraintModel.Rule = "testString"

				// Construct an instance of the Badge model
				badgeModel := new(catalogmanagementv1.Badge)
				badgeModel.ID = core.StringPtr("testString")
				badgeModel.Label = core.StringPtr("testString")
				badgeModel.LabelI18n = map[string]string{"key1": "testString"}
				badgeModel.Description = core.StringPtr("testString")
				badgeModel.DescriptionI18n = map[string]string{"key1": "testString"}
				badgeModel.Icon = core.StringPtr("testString")
				badgeModel.Authority = core.StringPtr("testString")
				badgeModel.Tag = core.StringPtr("testString")
				badgeModel.LearnMoreLinks = learnMoreLinksModel
				badgeModel.Constraints = []catalogmanagementv1.Constraint{*constraintModel}

				// Construct an instance of the VersionRange model
				versionRangeModel := new(catalogmanagementv1.VersionRange)
				versionRangeModel.Kinds = []string{"testString"}
				versionRangeModel.Version = core.StringPtr("testString")
				versionRangeModel.Flavors = []string{"testString"}

				// Construct an instance of the Plan model
				planModel := new(catalogmanagementv1.Plan)
				planModel.URL = core.StringPtr("testString")
				planModel.CRN = core.StringPtr("testString")
				planModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				planModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				planModel.OfferingID = core.StringPtr("testString")
				planModel.CatalogID = core.StringPtr("testString")
				planModel.Label = core.StringPtr("testString")
				planModel.LabelI18n = map[string]string{"key1": "testString"}
				planModel.Name = core.StringPtr("testString")
				planModel.ShortDescription = core.StringPtr("testString")
				planModel.ShortDescriptionI18n = map[string]string{"key1": "testString"}
				planModel.PricingTags = []string{"testString"}
				planModel.VersionRange = versionRangeModel
				planModel.Features = []catalogmanagementv1.Feature{*featureModel}
				planModel.State = stateModel
				planModel.DeprecatePending = deprecatePendingModel
				planModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				planModel.PublishApproved = core.BoolPtr(true)

				// Construct an instance of the CreateOfferingOptions model
				createOfferingOptionsModel := new(catalogmanagementv1.CreateOfferingOptions)
				createOfferingOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				createOfferingOptionsModel.URL = core.StringPtr("testString")
				createOfferingOptionsModel.CRN = core.StringPtr("testString")
				createOfferingOptionsModel.Label = core.StringPtr("testString")
				createOfferingOptionsModel.LabelI18n = map[string]string{"key1": "testString"}
				createOfferingOptionsModel.Name = core.StringPtr("testString")
				createOfferingOptionsModel.OfferingIconURL = core.StringPtr("testString")
				createOfferingOptionsModel.OfferingDocsURL = core.StringPtr("testString")
				createOfferingOptionsModel.OfferingSupportURL = core.StringPtr("testString")
				createOfferingOptionsModel.Tags = []string{"testString"}
				createOfferingOptionsModel.Keywords = []string{"testString"}
				createOfferingOptionsModel.Rating = ratingModel
				createOfferingOptionsModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				createOfferingOptionsModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				createOfferingOptionsModel.ShortDescription = core.StringPtr("testString")
				createOfferingOptionsModel.ShortDescriptionI18n = map[string]string{"key1": "testString"}
				createOfferingOptionsModel.LongDescription = core.StringPtr("testString")
				createOfferingOptionsModel.LongDescriptionI18n = map[string]string{"key1": "testString"}
				createOfferingOptionsModel.Features = []catalogmanagementv1.Feature{*featureModel}
				createOfferingOptionsModel.Kinds = []catalogmanagementv1.Kind{*kindModel}
				createOfferingOptionsModel.Publish = publishObjectModel
				createOfferingOptionsModel.PcManaged = core.BoolPtr(true)
				createOfferingOptionsModel.PublishApproved = core.BoolPtr(true)
				createOfferingOptionsModel.ShareWithAll = core.BoolPtr(true)
				createOfferingOptionsModel.ShareWithIBM = core.BoolPtr(true)
				createOfferingOptionsModel.ShareEnabled = core.BoolPtr(true)
				createOfferingOptionsModel.PublicOriginalCRN = core.StringPtr("testString")
				createOfferingOptionsModel.PublishPublicCRN = core.StringPtr("testString")
				createOfferingOptionsModel.PortalApprovalRecord = core.StringPtr("testString")
				createOfferingOptionsModel.PortalUIURL = core.StringPtr("testString")
				createOfferingOptionsModel.CatalogID = core.StringPtr("testString")
				createOfferingOptionsModel.CatalogName = core.StringPtr("testString")
				createOfferingOptionsModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				createOfferingOptionsModel.Disclaimer = core.StringPtr("testString")
				createOfferingOptionsModel.Hidden = core.BoolPtr(true)
				createOfferingOptionsModel.Provider = core.StringPtr("testString")
				createOfferingOptionsModel.ProviderInfo = providerInfoModel
				createOfferingOptionsModel.RepoInfo = repoInfoModel
				createOfferingOptionsModel.ImagePullKeys = []catalogmanagementv1.ImagePullKey{*imagePullKeyModel}
				createOfferingOptionsModel.Support = supportModel
				createOfferingOptionsModel.Media = []catalogmanagementv1.MediaItem{*mediaItemModel}
				createOfferingOptionsModel.DeprecatePending = deprecatePendingModel
				createOfferingOptionsModel.ProductKind = core.StringPtr("testString")
				createOfferingOptionsModel.Badges = []catalogmanagementv1.Badge{*badgeModel}
				createOfferingOptionsModel.Plans = []catalogmanagementv1.Plan{*planModel}
				createOfferingOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.CreateOffering(createOfferingOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.CreateOffering(createOfferingOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateOffering(createOfferingOptions *CreateOfferingOptions)`, func() {
		createOfferingPath := "/catalogs/testString/offerings"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createOfferingPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "name": "Name", "offering_icon_url": "OfferingIconURL", "offering_docs_url": "OfferingDocsURL", "offering_support_url": "OfferingSupportURL", "tags": ["Tags"], "keywords": ["Keywords"], "rating": {"one_star_count": 12, "two_star_count": 12, "three_star_count": 14, "four_star_count": 13}, "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "kinds": [{"id": "ID", "format_kind": "FormatKind", "format_kind_label": "FormatKindLabel", "install_kind": "InstallKind", "install_kind_label": "InstallKindLabel", "target_kind": "TargetKind", "target_kind_label": "TargetKindLabel", "metadata": {"anyKey": "anyValue"}, "tags": ["Tags"], "additional_features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "versions": [{"id": "ID", "_rev": "Rev", "crn": "CRN", "version": "Version", "flavor": {"name": "Name", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "index": 5}, "sha": "Sha", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "offering_id": "OfferingID", "catalog_id": "CatalogID", "kind_id": "KindID", "tags": ["Tags"], "repo_url": "RepoURL", "source_url": "SourceURL", "tgz_url": "TgzURL", "configuration": [{"key": "Key", "type": "Type", "default_value": "anyValue", "display_name": "DisplayName", "value_constraint": "ValueConstraint", "description": "Description", "required": true, "options": ["anyValue"], "hidden": true, "custom_config": {"type": "Type", "grouping": "Grouping", "original_grouping": "OriginalGrouping", "grouping_index": 13, "config_constraints": {"anyKey": "anyValue"}, "associations": {"parameters": [{"name": "Name", "optionsRefresh": true}]}}, "type_metadata": "TypeMetadata"}], "outputs": [{"key": "Key", "description": "Description"}], "iam_permissions": [{"service_name": "ServiceName", "role_crns": ["RoleCrns"], "resources": [{"name": "Name", "description": "Description", "role_crns": ["RoleCrns"]}]}], "metadata": {"anyKey": "anyValue"}, "validation": {"validated": "2019-01-01T12:00:00.000Z", "requested": "2019-01-01T12:00:00.000Z", "state": "State", "last_operation": "LastOperation", "target": {"anyKey": "anyValue"}, "message": "Message"}, "required_resources": [{"type": "mem", "value": "anyValue"}], "single_instance": true, "schematics_env_values": {"value": "[{\"name\": \"TF_LOG\",\"value\": \"TRACE\",\"secure\": false,\"hidden\": false}]", "sm_ref": "cmsm_v1:{\"name\": \"envVarSecret\",\"id\":\"1234567890\",\"service_id\":\"crn:v1:bluemix:public:secrets-manager:eu-gb:a/1234567890:1234567890::\",\"service_name\":\"My SM Instance\",\"group_id\":\"1234567890\",\"group_name\":\"My SM Group\",\"resource_group_id\":\"1234567890\",\"region\":\"eu-gb\",\"type\":\"arbitrary\"}"}, "install": {"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}, "pre_install": [{"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}], "scripts": {"mapKey": {"short_description": "ShortDescription", "type": "ansible", "path": "scripts/validate-post-ansible-playbook.yaml", "stage": "pre", "action": "validate"}}, "entitlement": {"provider_name": "ProviderName", "provider_id": "ProviderID", "product_id": "ProductID", "part_numbers": ["PartNumbers"], "image_repo_name": "ImageRepoName"}, "licenses": [{"id": "ID", "name": "Name", "type": "Type", "url": "URL", "description": "Description"}], "image_manifest_url": "ImageManifestURL", "deprecated": true, "package_version": "PackageVersion", "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "version_locator": "VersionLocator", "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "whitelisted_accounts": ["WhitelistedAccounts"], "image_pull_key_name": "ImagePullKeyName", "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "solution_info": {"architecture_diagrams": [{"diagram": {"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "cost_estimate": {"version": "Version", "currency": "Currency", "projects": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "pastBreakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "breakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "diff": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}}], "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}, "totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "pastTotalHourlyCost": "PastTotalHourlyCost", "pastTotalMonthlyCost": "PastTotalMonthlyCost", "diffTotalHourlyCost": "DiffTotalHourlyCost", "diffTotalMonthlyCost": "DiffTotalMonthlyCost", "timeGenerated": "2019-01-01T12:00:00.000Z"}, "dependencies": [{"catalog_id": "CatalogID", "id": "ID", "name": "Name", "kind": "Kind", "version": "Version", "description": "Description", "default_flavor": "DefaultFlavor", "flavors": ["Flavors"], "optional": true, "on_by_default": false}], "install_type": "InstallType"}, "is_consumable": true, "compliance_v3": {"authority": "Authority", "claims": {"profiles": [{"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}], "controls": [{"profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "names": ["Names"]}]}, "evaluations": [{"scan_id": "ScanID", "account_id": "AccountID", "profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "result": {"failure_count": 12, "scan_time": "2019-01-01T12:00:00.000Z", "error_message": "ErrorMessage", "complete_scan": true, "unscanned_resources": ["UnscannedResources"]}, "controls": [{"id": "ID", "name": "Name", "description": "Description", "specifications": [{"id": "ID", "description": "Description", "component_name": "ComponentName", "assessments": [{"id": "ID", "description": "Description", "version": "Version", "type": "Type", "method": "Method", "ui_href": "UIHref"}], "ui_href": "UIHref"}], "failure_count": 12, "pass_count": 9, "parent": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "parent_name": "ParentName", "specifications": [{"id": "ID", "description": "Description", "component_name": "ComponentName", "assessments": [{"id": "ID", "description": "Description", "version": "Version", "type": "Type", "method": "Method", "ui_href": "UIHref"}], "ui_href": "UIHref"}], "ui_href": "UIHref"}, "ui_href": "UIHref"}]}]}, "change_notices": {"breaking": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "new": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "update": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}]}, "plan_ids": ["PlanIds"], "stack": {"anyKey": "anyValue"}, "minimum_compatible_version": "MinimumCompatibleVersion"}], "all_versions": {"first": {"href": "Href", "start": "Start"}, "next": {"href": "Href", "start": "Start"}}}], "publish": {"pc_managed": false, "approval_type": "ApprovalType", "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "original_crn": "OriginalCRN", "public_crn": "PublicCRN", "approval_record": {"anyKey": "anyValue"}, "permit_ibm_public_publish": true, "ibm_approved": false, "public_approved": true}, "pc_managed": false, "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "public_original_crn": "PublicOriginalCRN", "publish_public_crn": "PublishPublicCRN", "portal_approval_record": "PortalApprovalRecord", "portal_ui_url": "PortalUIURL", "catalog_id": "CatalogID", "catalog_name": "CatalogName", "metadata": {"anyKey": "anyValue"}, "disclaimer": "Disclaimer", "hidden": true, "provider": "Provider", "provider_info": {"id": "ID", "name": "Name"}, "repo_info": {"token": "Token", "type": "Type"}, "image_pull_keys": [{"name": "Name", "value": "Value", "description": "Description"}], "support": {"url": "URL", "process": "Process", "process_i18n": {"mapKey": "Inner"}, "locations": ["Locations"], "support_details": [{"type": "Type", "contact": "Contact", "response_wait_time": {"value": 5, "type": "Type"}, "availability": {"times": [{"day": 3, "start_time": "StartTime", "end_time": "EndTime"}], "timezone": "Timezone", "always_available": false}}], "support_escalation": {"escalation_wait_time": {"value": 5, "type": "Type"}, "response_wait_time": {"value": 5, "type": "Type"}, "contact": "Contact"}, "support_type": "SupportType"}, "media": [{"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}], "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "product_kind": "ProductKind", "badges": [{"id": "ID", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}, "icon": "Icon", "authority": "Authority", "tag": "Tag", "learn_more_links": {"first_party": "FirstParty", "third_party": "ThirdParty"}, "constraints": [{"type": "Type", "rule": "anyValue"}]}], "plans": [{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "offering_id": "OfferingID", "catalog_id": "CatalogID", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "name": "Name", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "pricing_tags": ["PricingTags"], "version_range": {"kinds": ["Kinds"], "version": "Version", "flavors": ["Flavors"]}, "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "metadata": {"anyKey": "anyValue"}, "publish_approved": false}]}`)
				}))
			})
			It(`Invoke CreateOffering successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the Rating model
				ratingModel := new(catalogmanagementv1.Rating)
				ratingModel.OneStarCount = core.Int64Ptr(int64(38))
				ratingModel.TwoStarCount = core.Int64Ptr(int64(38))
				ratingModel.ThreeStarCount = core.Int64Ptr(int64(38))
				ratingModel.FourStarCount = core.Int64Ptr(int64(38))

				// Construct an instance of the Feature model
				featureModel := new(catalogmanagementv1.Feature)
				featureModel.Title = core.StringPtr("testString")
				featureModel.TitleI18n = map[string]string{"key1": "testString"}
				featureModel.Description = core.StringPtr("testString")
				featureModel.DescriptionI18n = map[string]string{"key1": "testString"}

				// Construct an instance of the Flavor model
				flavorModel := new(catalogmanagementv1.Flavor)
				flavorModel.Name = core.StringPtr("testString")
				flavorModel.Label = core.StringPtr("testString")
				flavorModel.LabelI18n = map[string]string{"key1": "testString"}
				flavorModel.Index = core.Int64Ptr(int64(38))

				// Construct an instance of the RenderTypeAssociationsParametersItem model
				renderTypeAssociationsParametersItemModel := new(catalogmanagementv1.RenderTypeAssociationsParametersItem)
				renderTypeAssociationsParametersItemModel.Name = core.StringPtr("testString")
				renderTypeAssociationsParametersItemModel.OptionsRefresh = core.BoolPtr(true)

				// Construct an instance of the RenderTypeAssociations model
				renderTypeAssociationsModel := new(catalogmanagementv1.RenderTypeAssociations)
				renderTypeAssociationsModel.Parameters = []catalogmanagementv1.RenderTypeAssociationsParametersItem{*renderTypeAssociationsParametersItemModel}

				// Construct an instance of the RenderType model
				renderTypeModel := new(catalogmanagementv1.RenderType)
				renderTypeModel.Type = core.StringPtr("testString")
				renderTypeModel.Grouping = core.StringPtr("testString")
				renderTypeModel.OriginalGrouping = core.StringPtr("testString")
				renderTypeModel.GroupingIndex = core.Int64Ptr(int64(38))
				renderTypeModel.ConfigConstraints = map[string]interface{}{"anyKey": "anyValue"}
				renderTypeModel.Associations = renderTypeAssociationsModel

				// Construct an instance of the Configuration model
				configurationModel := new(catalogmanagementv1.Configuration)
				configurationModel.Key = core.StringPtr("testString")
				configurationModel.Type = core.StringPtr("testString")
				configurationModel.DefaultValue = "testString"
				configurationModel.DisplayName = core.StringPtr("testString")
				configurationModel.ValueConstraint = core.StringPtr("testString")
				configurationModel.Description = core.StringPtr("testString")
				configurationModel.Required = core.BoolPtr(true)
				configurationModel.Options = []interface{}{"testString"}
				configurationModel.Hidden = core.BoolPtr(true)
				configurationModel.CustomConfig = renderTypeModel
				configurationModel.TypeMetadata = core.StringPtr("testString")

				// Construct an instance of the Output model
				outputModel := new(catalogmanagementv1.Output)
				outputModel.Key = core.StringPtr("testString")
				outputModel.Description = core.StringPtr("testString")

				// Construct an instance of the IamResource model
				iamResourceModel := new(catalogmanagementv1.IamResource)
				iamResourceModel.Name = core.StringPtr("testString")
				iamResourceModel.Description = core.StringPtr("testString")
				iamResourceModel.RoleCrns = []string{"testString"}

				// Construct an instance of the IamPermission model
				iamPermissionModel := new(catalogmanagementv1.IamPermission)
				iamPermissionModel.ServiceName = core.StringPtr("testString")
				iamPermissionModel.RoleCrns = []string{"testString"}
				iamPermissionModel.Resources = []catalogmanagementv1.IamResource{*iamResourceModel}

				// Construct an instance of the Validation model
				validationModel := new(catalogmanagementv1.Validation)
				validationModel.Validated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				validationModel.Requested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				validationModel.State = core.StringPtr("testString")
				validationModel.LastOperation = core.StringPtr("testString")
				validationModel.Target = map[string]interface{}{"anyKey": "anyValue"}
				validationModel.Message = core.StringPtr("testString")

				// Construct an instance of the Resource model
				resourceModel := new(catalogmanagementv1.Resource)
				resourceModel.Type = core.StringPtr("mem")
				resourceModel.Value = "testString"

				// Construct an instance of the SchematicsEnvValues model
				schematicsEnvValuesModel := new(catalogmanagementv1.SchematicsEnvValues)
				schematicsEnvValuesModel.Value = core.StringPtr("[{\"name\": \"TF_LOG\",\"value\": \"TRACE\",\"secure\": false,\"hidden\": false}]")
				schematicsEnvValuesModel.SmRef = core.StringPtr("cmsm_v1:{\"name\": \"envVarSecret\",\"id\":\"1234567890\",\"service_id\":\"crn:v1:bluemix:public:secrets-manager:eu-gb:a/1234567890:1234567890::\",\"service_name\":\"My SM Instance\",\"group_id\":\"1234567890\",\"group_name\":\"My SM Group\",\"resource_group_id\":\"1234567890\",\"region\":\"eu-gb\",\"type\":\"arbitrary\"}")

				// Construct an instance of the Script model
				scriptModel := new(catalogmanagementv1.Script)
				scriptModel.Instructions = core.StringPtr("testString")
				scriptModel.InstructionsI18n = map[string]string{"key1": "testString"}
				scriptModel.Script = core.StringPtr("testString")
				scriptModel.ScriptPermission = core.StringPtr("testString")
				scriptModel.DeleteScript = core.StringPtr("testString")
				scriptModel.Scope = core.StringPtr("testString")

				// Construct an instance of the ScriptRef model
				scriptRefModel := new(catalogmanagementv1.ScriptRef)
				scriptRefModel.ShortDescription = core.StringPtr("testString")
				scriptRefModel.Type = core.StringPtr("ansible")
				scriptRefModel.Path = core.StringPtr("scripts/validate-post-ansible-playbook.yaml")
				scriptRefModel.Stage = core.StringPtr("pre")
				scriptRefModel.Action = core.StringPtr("validate")

				// Construct an instance of the VersionEntitlement model
				versionEntitlementModel := new(catalogmanagementv1.VersionEntitlement)
				versionEntitlementModel.ProviderName = core.StringPtr("testString")
				versionEntitlementModel.ProviderID = core.StringPtr("testString")
				versionEntitlementModel.ProductID = core.StringPtr("testString")
				versionEntitlementModel.PartNumbers = []string{"testString"}
				versionEntitlementModel.ImageRepoName = core.StringPtr("testString")

				// Construct an instance of the License model
				licenseModel := new(catalogmanagementv1.License)
				licenseModel.ID = core.StringPtr("testString")
				licenseModel.Name = core.StringPtr("testString")
				licenseModel.Type = core.StringPtr("testString")
				licenseModel.URL = core.StringPtr("testString")
				licenseModel.Description = core.StringPtr("testString")

				// Construct an instance of the State model
				stateModel := new(catalogmanagementv1.State)
				stateModel.Current = core.StringPtr("testString")
				stateModel.CurrentEntered = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Pending = core.StringPtr("testString")
				stateModel.PendingRequested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Previous = core.StringPtr("testString")

				// Construct an instance of the DeprecatePending model
				deprecatePendingModel := new(catalogmanagementv1.DeprecatePending)
				deprecatePendingModel.DeprecateDate = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				deprecatePendingModel.DeprecateState = core.StringPtr("testString")
				deprecatePendingModel.Description = core.StringPtr("testString")

				// Construct an instance of the URLProxy model
				urlProxyModel := new(catalogmanagementv1.URLProxy)
				urlProxyModel.URL = core.StringPtr("testString")
				urlProxyModel.Sha = core.StringPtr("testString")

				// Construct an instance of the MediaItem model
				mediaItemModel := new(catalogmanagementv1.MediaItem)
				mediaItemModel.URL = core.StringPtr("testString")
				mediaItemModel.APIURL = core.StringPtr("testString")
				mediaItemModel.URLProxy = urlProxyModel
				mediaItemModel.Caption = core.StringPtr("testString")
				mediaItemModel.CaptionI18n = map[string]string{"key1": "testString"}
				mediaItemModel.Type = core.StringPtr("testString")
				mediaItemModel.ThumbnailURL = core.StringPtr("testString")

				// Construct an instance of the ArchitectureDiagram model
				architectureDiagramModel := new(catalogmanagementv1.ArchitectureDiagram)
				architectureDiagramModel.Diagram = mediaItemModel
				architectureDiagramModel.Description = core.StringPtr("testString")
				architectureDiagramModel.DescriptionI18n = map[string]string{"key1": "testString"}

				// Construct an instance of the CostComponent model
				costComponentModel := new(catalogmanagementv1.CostComponent)
				costComponentModel.Name = core.StringPtr("testString")
				costComponentModel.Unit = core.StringPtr("testString")
				costComponentModel.HourlyQuantity = core.StringPtr("testString")
				costComponentModel.MonthlyQuantity = core.StringPtr("testString")
				costComponentModel.Price = core.StringPtr("testString")
				costComponentModel.HourlyCost = core.StringPtr("testString")
				costComponentModel.MonthlyCost = core.StringPtr("testString")

				// Construct an instance of the CostResource model
				costResourceModel := new(catalogmanagementv1.CostResource)
				costResourceModel.Name = core.StringPtr("testString")
				costResourceModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				costResourceModel.HourlyCost = core.StringPtr("testString")
				costResourceModel.MonthlyCost = core.StringPtr("testString")
				costResourceModel.CostComponents = []catalogmanagementv1.CostComponent{*costComponentModel}

				// Construct an instance of the CostBreakdown model
				costBreakdownModel := new(catalogmanagementv1.CostBreakdown)
				costBreakdownModel.TotalHourlyCost = core.StringPtr("testString")
				costBreakdownModel.TotalMonthlyCost = core.StringPtr("testString")
				costBreakdownModel.Resources = []catalogmanagementv1.CostResource{*costResourceModel}

				// Construct an instance of the CostSummary model
				costSummaryModel := new(catalogmanagementv1.CostSummary)
				costSummaryModel.TotalDetectedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalSupportedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalUnsupportedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalUsageBasedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalNoPriceResources = core.Int64Ptr(int64(38))
				costSummaryModel.UnsupportedResourceCounts = map[string]int64{"key1": int64(38)}
				costSummaryModel.NoPriceResourceCounts = map[string]int64{"key1": int64(38)}

				// Construct an instance of the Project model
				projectModel := new(catalogmanagementv1.Project)
				projectModel.Name = core.StringPtr("testString")
				projectModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				projectModel.PastBreakdown = costBreakdownModel
				projectModel.Breakdown = costBreakdownModel
				projectModel.Diff = costBreakdownModel
				projectModel.Summary = costSummaryModel

				// Construct an instance of the CostEstimate model
				costEstimateModel := new(catalogmanagementv1.CostEstimate)
				costEstimateModel.Version = core.StringPtr("testString")
				costEstimateModel.Currency = core.StringPtr("testString")
				costEstimateModel.Projects = []catalogmanagementv1.Project{*projectModel}
				costEstimateModel.Summary = costSummaryModel
				costEstimateModel.TotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.TotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.PastTotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.PastTotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.DiffTotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.DiffTotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.TimeGenerated = CreateMockDateTime("2019-01-01T12:00:00.000Z")

				// Construct an instance of the OfferingReference model
				offeringReferenceModel := new(catalogmanagementv1.OfferingReference)
				offeringReferenceModel.CatalogID = core.StringPtr("testString")
				offeringReferenceModel.ID = core.StringPtr("testString")
				offeringReferenceModel.Name = core.StringPtr("testString")
				offeringReferenceModel.Kind = core.StringPtr("testString")
				offeringReferenceModel.Version = core.StringPtr("testString")
				offeringReferenceModel.Description = core.StringPtr("testString")
				offeringReferenceModel.DefaultFlavor = core.StringPtr("testString")
				offeringReferenceModel.Flavors = []string{"testString"}
				offeringReferenceModel.Optional = core.BoolPtr(true)
				offeringReferenceModel.OnByDefault = core.BoolPtr(true)

				// Construct an instance of the SolutionInfo model
				solutionInfoModel := new(catalogmanagementv1.SolutionInfo)
				solutionInfoModel.ArchitectureDiagrams = []catalogmanagementv1.ArchitectureDiagram{*architectureDiagramModel}
				solutionInfoModel.Features = []catalogmanagementv1.Feature{*featureModel}
				solutionInfoModel.CostEstimate = costEstimateModel
				solutionInfoModel.Dependencies = []catalogmanagementv1.OfferingReference{*offeringReferenceModel}
				solutionInfoModel.InstallType = core.StringPtr("testString")

				// Construct an instance of the SccProfile model
				sccProfileModel := new(catalogmanagementv1.SccProfile)
				sccProfileModel.ID = core.StringPtr("testString")
				sccProfileModel.Name = core.StringPtr("testString")
				sccProfileModel.Version = core.StringPtr("testString")
				sccProfileModel.Description = core.StringPtr("testString")
				sccProfileModel.Type = core.StringPtr("testString")
				sccProfileModel.UIHref = core.StringPtr("testString")

				// Construct an instance of the ClaimedControl model
				claimedControlModel := new(catalogmanagementv1.ClaimedControl)
				claimedControlModel.Profile = sccProfileModel
				claimedControlModel.Names = []string{"testString"}

				// Construct an instance of the Claims model
				claimsModel := new(catalogmanagementv1.Claims)
				claimsModel.Profiles = []catalogmanagementv1.SccProfile{*sccProfileModel}
				claimsModel.Controls = []catalogmanagementv1.ClaimedControl{*claimedControlModel}

				// Construct an instance of the Result model
				resultModel := new(catalogmanagementv1.Result)
				resultModel.FailureCount = core.Int64Ptr(int64(38))
				resultModel.ScanTime = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				resultModel.ErrorMessage = core.StringPtr("testString")
				resultModel.CompleteScan = core.BoolPtr(true)
				resultModel.UnscannedResources = []string{"testString"}

				// Construct an instance of the SccAssessment model
				sccAssessmentModel := new(catalogmanagementv1.SccAssessment)
				sccAssessmentModel.ID = core.StringPtr("testString")
				sccAssessmentModel.Description = core.StringPtr("testString")
				sccAssessmentModel.Version = core.StringPtr("testString")
				sccAssessmentModel.Type = core.StringPtr("testString")
				sccAssessmentModel.Method = core.StringPtr("testString")
				sccAssessmentModel.UIHref = core.StringPtr("testString")

				// Construct an instance of the SccSpecification model
				sccSpecificationModel := new(catalogmanagementv1.SccSpecification)
				sccSpecificationModel.ID = core.StringPtr("testString")
				sccSpecificationModel.Description = core.StringPtr("testString")
				sccSpecificationModel.ComponentName = core.StringPtr("testString")
				sccSpecificationModel.Assessments = []catalogmanagementv1.SccAssessment{*sccAssessmentModel}
				sccSpecificationModel.UIHref = core.StringPtr("testString")

				// Construct an instance of the SccControl model
				sccControlModel := new(catalogmanagementv1.SccControl)
				sccControlModel.ID = core.StringPtr("testString")
				sccControlModel.Name = core.StringPtr("testString")
				sccControlModel.Version = core.StringPtr("testString")
				sccControlModel.Description = core.StringPtr("testString")
				sccControlModel.Profile = sccProfileModel
				sccControlModel.ParentName = core.StringPtr("testString")
				sccControlModel.Specifications = []catalogmanagementv1.SccSpecification{*sccSpecificationModel}
				sccControlModel.UIHref = core.StringPtr("testString")

				// Construct an instance of the EvaluatedControl model
				evaluatedControlModel := new(catalogmanagementv1.EvaluatedControl)
				evaluatedControlModel.ID = core.StringPtr("testString")
				evaluatedControlModel.Name = core.StringPtr("testString")
				evaluatedControlModel.Description = core.StringPtr("testString")
				evaluatedControlModel.Specifications = []catalogmanagementv1.SccSpecification{*sccSpecificationModel}
				evaluatedControlModel.FailureCount = core.Int64Ptr(int64(38))
				evaluatedControlModel.PassCount = core.Int64Ptr(int64(38))
				evaluatedControlModel.Parent = sccControlModel
				evaluatedControlModel.UIHref = core.StringPtr("testString")

				// Construct an instance of the Evaluation model
				evaluationModel := new(catalogmanagementv1.Evaluation)
				evaluationModel.ScanID = core.StringPtr("testString")
				evaluationModel.AccountID = core.StringPtr("testString")
				evaluationModel.Profile = sccProfileModel
				evaluationModel.Result = resultModel
				evaluationModel.Controls = []catalogmanagementv1.EvaluatedControl{*evaluatedControlModel}

				// Construct an instance of the Compliance model
				complianceModel := new(catalogmanagementv1.Compliance)
				complianceModel.Authority = core.StringPtr("testString")
				complianceModel.Claims = claimsModel
				complianceModel.Evaluations = []catalogmanagementv1.Evaluation{*evaluationModel}

				// Construct an instance of the ChangeNotices model
				changeNoticesModel := new(catalogmanagementv1.ChangeNotices)
				changeNoticesModel.Breaking = []catalogmanagementv1.Feature{*featureModel}
				changeNoticesModel.New = []catalogmanagementv1.Feature{*featureModel}
				changeNoticesModel.Update = []catalogmanagementv1.Feature{*featureModel}

				// Construct an instance of the Version model
				versionModel := new(catalogmanagementv1.Version)
				versionModel.CRN = core.StringPtr("testString")
				versionModel.Version = core.StringPtr("testString")
				versionModel.Flavor = flavorModel
				versionModel.Sha = core.StringPtr("testString")
				versionModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				versionModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				versionModel.OfferingID = core.StringPtr("testString")
				versionModel.CatalogID = core.StringPtr("testString")
				versionModel.KindID = core.StringPtr("testString")
				versionModel.Tags = []string{"testString"}
				versionModel.RepoURL = core.StringPtr("testString")
				versionModel.SourceURL = core.StringPtr("testString")
				versionModel.TgzURL = core.StringPtr("testString")
				versionModel.Configuration = []catalogmanagementv1.Configuration{*configurationModel}
				versionModel.Outputs = []catalogmanagementv1.Output{*outputModel}
				versionModel.IamPermissions = []catalogmanagementv1.IamPermission{*iamPermissionModel}
				versionModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				versionModel.Validation = validationModel
				versionModel.RequiredResources = []catalogmanagementv1.Resource{*resourceModel}
				versionModel.SingleInstance = core.BoolPtr(true)
				versionModel.SchematicsEnvValues = schematicsEnvValuesModel
				versionModel.Install = scriptModel
				versionModel.PreInstall = []catalogmanagementv1.Script{*scriptModel}
				versionModel.Scripts = map[string]catalogmanagementv1.ScriptRef{"key1": *scriptRefModel}
				versionModel.Entitlement = versionEntitlementModel
				versionModel.Licenses = []catalogmanagementv1.License{*licenseModel}
				versionModel.ImageManifestURL = core.StringPtr("testString")
				versionModel.Deprecated = core.BoolPtr(true)
				versionModel.PackageVersion = core.StringPtr("testString")
				versionModel.State = stateModel
				versionModel.VersionLocator = core.StringPtr("testString")
				versionModel.LongDescription = core.StringPtr("testString")
				versionModel.LongDescriptionI18n = map[string]string{"key1": "testString"}
				versionModel.WhitelistedAccounts = []string{"testString"}
				versionModel.ImagePullKeyName = core.StringPtr("testString")
				versionModel.DeprecatePending = deprecatePendingModel
				versionModel.SolutionInfo = solutionInfoModel
				versionModel.IsConsumable = core.BoolPtr(true)
				versionModel.ComplianceV3 = complianceModel
				versionModel.ChangeNotices = changeNoticesModel
				versionModel.PlanIds = []string{"testString"}
				versionModel.Stack = map[string]interface{}{"anyKey": "anyValue"}
				versionModel.MinimumCompatibleVersion = core.StringPtr("testString")
				versionModel.Scripts["foo"] = *scriptRefModel

				// Construct an instance of the PaginationTokenLink model
				paginationTokenLinkModel := new(catalogmanagementv1.PaginationTokenLink)
				paginationTokenLinkModel.Href = core.StringPtr("testString")
				paginationTokenLinkModel.Start = core.StringPtr("testString")

				// Construct an instance of the KindAllVersions model
				kindAllVersionsModel := new(catalogmanagementv1.KindAllVersions)
				kindAllVersionsModel.First = paginationTokenLinkModel
				kindAllVersionsModel.Next = paginationTokenLinkModel

				// Construct an instance of the Kind model
				kindModel := new(catalogmanagementv1.Kind)
				kindModel.ID = core.StringPtr("testString")
				kindModel.FormatKind = core.StringPtr("testString")
				kindModel.FormatKindLabel = core.StringPtr("testString")
				kindModel.InstallKind = core.StringPtr("testString")
				kindModel.InstallKindLabel = core.StringPtr("testString")
				kindModel.TargetKind = core.StringPtr("testString")
				kindModel.TargetKindLabel = core.StringPtr("testString")
				kindModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				kindModel.Tags = []string{"testString"}
				kindModel.AdditionalFeatures = []catalogmanagementv1.Feature{*featureModel}
				kindModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				kindModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				kindModel.Versions = []catalogmanagementv1.Version{*versionModel}
				kindModel.AllVersions = kindAllVersionsModel

				// Construct an instance of the PublishObject model
				publishObjectModel := new(catalogmanagementv1.PublishObject)
				publishObjectModel.PcManaged = core.BoolPtr(true)
				publishObjectModel.ApprovalType = core.StringPtr("testString")
				publishObjectModel.PublishApproved = core.BoolPtr(true)
				publishObjectModel.ShareWithAll = core.BoolPtr(true)
				publishObjectModel.ShareWithIBM = core.BoolPtr(true)
				publishObjectModel.ShareEnabled = core.BoolPtr(true)
				publishObjectModel.OriginalCRN = core.StringPtr("testString")
				publishObjectModel.PublicCRN = core.StringPtr("testString")
				publishObjectModel.ApprovalRecord = map[string]interface{}{"anyKey": "anyValue"}
				publishObjectModel.PermitIBMPublicPublish = core.BoolPtr(true)
				publishObjectModel.IBMApproved = core.BoolPtr(true)
				publishObjectModel.PublicApproved = core.BoolPtr(true)

				// Construct an instance of the ProviderInfo model
				providerInfoModel := new(catalogmanagementv1.ProviderInfo)
				providerInfoModel.ID = core.StringPtr("testString")
				providerInfoModel.Name = core.StringPtr("testString")

				// Construct an instance of the RepoInfo model
				repoInfoModel := new(catalogmanagementv1.RepoInfo)
				repoInfoModel.Token = core.StringPtr("testString")
				repoInfoModel.Type = core.StringPtr("testString")

				// Construct an instance of the ImagePullKey model
				imagePullKeyModel := new(catalogmanagementv1.ImagePullKey)
				imagePullKeyModel.Name = core.StringPtr("testString")
				imagePullKeyModel.Value = core.StringPtr("testString")
				imagePullKeyModel.Description = core.StringPtr("testString")

				// Construct an instance of the SupportWaitTime model
				supportWaitTimeModel := new(catalogmanagementv1.SupportWaitTime)
				supportWaitTimeModel.Value = core.Int64Ptr(int64(38))
				supportWaitTimeModel.Type = core.StringPtr("testString")

				// Construct an instance of the SupportTime model
				supportTimeModel := new(catalogmanagementv1.SupportTime)
				supportTimeModel.Day = core.Int64Ptr(int64(38))
				supportTimeModel.StartTime = core.StringPtr("testString")
				supportTimeModel.EndTime = core.StringPtr("testString")

				// Construct an instance of the SupportAvailability model
				supportAvailabilityModel := new(catalogmanagementv1.SupportAvailability)
				supportAvailabilityModel.Times = []catalogmanagementv1.SupportTime{*supportTimeModel}
				supportAvailabilityModel.Timezone = core.StringPtr("testString")
				supportAvailabilityModel.AlwaysAvailable = core.BoolPtr(true)

				// Construct an instance of the SupportDetail model
				supportDetailModel := new(catalogmanagementv1.SupportDetail)
				supportDetailModel.Type = core.StringPtr("testString")
				supportDetailModel.Contact = core.StringPtr("testString")
				supportDetailModel.ResponseWaitTime = supportWaitTimeModel
				supportDetailModel.Availability = supportAvailabilityModel

				// Construct an instance of the SupportEscalation model
				supportEscalationModel := new(catalogmanagementv1.SupportEscalation)
				supportEscalationModel.EscalationWaitTime = supportWaitTimeModel
				supportEscalationModel.ResponseWaitTime = supportWaitTimeModel
				supportEscalationModel.Contact = core.StringPtr("testString")

				// Construct an instance of the Support model
				supportModel := new(catalogmanagementv1.Support)
				supportModel.URL = core.StringPtr("testString")
				supportModel.Process = core.StringPtr("testString")
				supportModel.ProcessI18n = map[string]string{"key1": "testString"}
				supportModel.Locations = []string{"testString"}
				supportModel.SupportDetails = []catalogmanagementv1.SupportDetail{*supportDetailModel}
				supportModel.SupportEscalation = supportEscalationModel
				supportModel.SupportType = core.StringPtr("testString")

				// Construct an instance of the LearnMoreLinks model
				learnMoreLinksModel := new(catalogmanagementv1.LearnMoreLinks)
				learnMoreLinksModel.FirstParty = core.StringPtr("testString")
				learnMoreLinksModel.ThirdParty = core.StringPtr("testString")

				// Construct an instance of the Constraint model
				constraintModel := new(catalogmanagementv1.Constraint)
				constraintModel.Type = core.StringPtr("testString")
				constraintModel.Rule = "testString"

				// Construct an instance of the Badge model
				badgeModel := new(catalogmanagementv1.Badge)
				badgeModel.ID = core.StringPtr("testString")
				badgeModel.Label = core.StringPtr("testString")
				badgeModel.LabelI18n = map[string]string{"key1": "testString"}
				badgeModel.Description = core.StringPtr("testString")
				badgeModel.DescriptionI18n = map[string]string{"key1": "testString"}
				badgeModel.Icon = core.StringPtr("testString")
				badgeModel.Authority = core.StringPtr("testString")
				badgeModel.Tag = core.StringPtr("testString")
				badgeModel.LearnMoreLinks = learnMoreLinksModel
				badgeModel.Constraints = []catalogmanagementv1.Constraint{*constraintModel}

				// Construct an instance of the VersionRange model
				versionRangeModel := new(catalogmanagementv1.VersionRange)
				versionRangeModel.Kinds = []string{"testString"}
				versionRangeModel.Version = core.StringPtr("testString")
				versionRangeModel.Flavors = []string{"testString"}

				// Construct an instance of the Plan model
				planModel := new(catalogmanagementv1.Plan)
				planModel.URL = core.StringPtr("testString")
				planModel.CRN = core.StringPtr("testString")
				planModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				planModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				planModel.OfferingID = core.StringPtr("testString")
				planModel.CatalogID = core.StringPtr("testString")
				planModel.Label = core.StringPtr("testString")
				planModel.LabelI18n = map[string]string{"key1": "testString"}
				planModel.Name = core.StringPtr("testString")
				planModel.ShortDescription = core.StringPtr("testString")
				planModel.ShortDescriptionI18n = map[string]string{"key1": "testString"}
				planModel.PricingTags = []string{"testString"}
				planModel.VersionRange = versionRangeModel
				planModel.Features = []catalogmanagementv1.Feature{*featureModel}
				planModel.State = stateModel
				planModel.DeprecatePending = deprecatePendingModel
				planModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				planModel.PublishApproved = core.BoolPtr(true)

				// Construct an instance of the CreateOfferingOptions model
				createOfferingOptionsModel := new(catalogmanagementv1.CreateOfferingOptions)
				createOfferingOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				createOfferingOptionsModel.URL = core.StringPtr("testString")
				createOfferingOptionsModel.CRN = core.StringPtr("testString")
				createOfferingOptionsModel.Label = core.StringPtr("testString")
				createOfferingOptionsModel.LabelI18n = map[string]string{"key1": "testString"}
				createOfferingOptionsModel.Name = core.StringPtr("testString")
				createOfferingOptionsModel.OfferingIconURL = core.StringPtr("testString")
				createOfferingOptionsModel.OfferingDocsURL = core.StringPtr("testString")
				createOfferingOptionsModel.OfferingSupportURL = core.StringPtr("testString")
				createOfferingOptionsModel.Tags = []string{"testString"}
				createOfferingOptionsModel.Keywords = []string{"testString"}
				createOfferingOptionsModel.Rating = ratingModel
				createOfferingOptionsModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				createOfferingOptionsModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				createOfferingOptionsModel.ShortDescription = core.StringPtr("testString")
				createOfferingOptionsModel.ShortDescriptionI18n = map[string]string{"key1": "testString"}
				createOfferingOptionsModel.LongDescription = core.StringPtr("testString")
				createOfferingOptionsModel.LongDescriptionI18n = map[string]string{"key1": "testString"}
				createOfferingOptionsModel.Features = []catalogmanagementv1.Feature{*featureModel}
				createOfferingOptionsModel.Kinds = []catalogmanagementv1.Kind{*kindModel}
				createOfferingOptionsModel.Publish = publishObjectModel
				createOfferingOptionsModel.PcManaged = core.BoolPtr(true)
				createOfferingOptionsModel.PublishApproved = core.BoolPtr(true)
				createOfferingOptionsModel.ShareWithAll = core.BoolPtr(true)
				createOfferingOptionsModel.ShareWithIBM = core.BoolPtr(true)
				createOfferingOptionsModel.ShareEnabled = core.BoolPtr(true)
				createOfferingOptionsModel.PublicOriginalCRN = core.StringPtr("testString")
				createOfferingOptionsModel.PublishPublicCRN = core.StringPtr("testString")
				createOfferingOptionsModel.PortalApprovalRecord = core.StringPtr("testString")
				createOfferingOptionsModel.PortalUIURL = core.StringPtr("testString")
				createOfferingOptionsModel.CatalogID = core.StringPtr("testString")
				createOfferingOptionsModel.CatalogName = core.StringPtr("testString")
				createOfferingOptionsModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				createOfferingOptionsModel.Disclaimer = core.StringPtr("testString")
				createOfferingOptionsModel.Hidden = core.BoolPtr(true)
				createOfferingOptionsModel.Provider = core.StringPtr("testString")
				createOfferingOptionsModel.ProviderInfo = providerInfoModel
				createOfferingOptionsModel.RepoInfo = repoInfoModel
				createOfferingOptionsModel.ImagePullKeys = []catalogmanagementv1.ImagePullKey{*imagePullKeyModel}
				createOfferingOptionsModel.Support = supportModel
				createOfferingOptionsModel.Media = []catalogmanagementv1.MediaItem{*mediaItemModel}
				createOfferingOptionsModel.DeprecatePending = deprecatePendingModel
				createOfferingOptionsModel.ProductKind = core.StringPtr("testString")
				createOfferingOptionsModel.Badges = []catalogmanagementv1.Badge{*badgeModel}
				createOfferingOptionsModel.Plans = []catalogmanagementv1.Plan{*planModel}
				createOfferingOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.CreateOfferingWithContext(ctx, createOfferingOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.CreateOffering(createOfferingOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.CreateOfferingWithContext(ctx, createOfferingOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createOfferingPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "name": "Name", "offering_icon_url": "OfferingIconURL", "offering_docs_url": "OfferingDocsURL", "offering_support_url": "OfferingSupportURL", "tags": ["Tags"], "keywords": ["Keywords"], "rating": {"one_star_count": 12, "two_star_count": 12, "three_star_count": 14, "four_star_count": 13}, "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "kinds": [{"id": "ID", "format_kind": "FormatKind", "format_kind_label": "FormatKindLabel", "install_kind": "InstallKind", "install_kind_label": "InstallKindLabel", "target_kind": "TargetKind", "target_kind_label": "TargetKindLabel", "metadata": {"anyKey": "anyValue"}, "tags": ["Tags"], "additional_features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "versions": [{"id": "ID", "_rev": "Rev", "crn": "CRN", "version": "Version", "flavor": {"name": "Name", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "index": 5}, "sha": "Sha", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "offering_id": "OfferingID", "catalog_id": "CatalogID", "kind_id": "KindID", "tags": ["Tags"], "repo_url": "RepoURL", "source_url": "SourceURL", "tgz_url": "TgzURL", "configuration": [{"key": "Key", "type": "Type", "default_value": "anyValue", "display_name": "DisplayName", "value_constraint": "ValueConstraint", "description": "Description", "required": true, "options": ["anyValue"], "hidden": true, "custom_config": {"type": "Type", "grouping": "Grouping", "original_grouping": "OriginalGrouping", "grouping_index": 13, "config_constraints": {"anyKey": "anyValue"}, "associations": {"parameters": [{"name": "Name", "optionsRefresh": true}]}}, "type_metadata": "TypeMetadata"}], "outputs": [{"key": "Key", "description": "Description"}], "iam_permissions": [{"service_name": "ServiceName", "role_crns": ["RoleCrns"], "resources": [{"name": "Name", "description": "Description", "role_crns": ["RoleCrns"]}]}], "metadata": {"anyKey": "anyValue"}, "validation": {"validated": "2019-01-01T12:00:00.000Z", "requested": "2019-01-01T12:00:00.000Z", "state": "State", "last_operation": "LastOperation", "target": {"anyKey": "anyValue"}, "message": "Message"}, "required_resources": [{"type": "mem", "value": "anyValue"}], "single_instance": true, "schematics_env_values": {"value": "[{\"name\": \"TF_LOG\",\"value\": \"TRACE\",\"secure\": false,\"hidden\": false}]", "sm_ref": "cmsm_v1:{\"name\": \"envVarSecret\",\"id\":\"1234567890\",\"service_id\":\"crn:v1:bluemix:public:secrets-manager:eu-gb:a/1234567890:1234567890::\",\"service_name\":\"My SM Instance\",\"group_id\":\"1234567890\",\"group_name\":\"My SM Group\",\"resource_group_id\":\"1234567890\",\"region\":\"eu-gb\",\"type\":\"arbitrary\"}"}, "install": {"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}, "pre_install": [{"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}], "scripts": {"mapKey": {"short_description": "ShortDescription", "type": "ansible", "path": "scripts/validate-post-ansible-playbook.yaml", "stage": "pre", "action": "validate"}}, "entitlement": {"provider_name": "ProviderName", "provider_id": "ProviderID", "product_id": "ProductID", "part_numbers": ["PartNumbers"], "image_repo_name": "ImageRepoName"}, "licenses": [{"id": "ID", "name": "Name", "type": "Type", "url": "URL", "description": "Description"}], "image_manifest_url": "ImageManifestURL", "deprecated": true, "package_version": "PackageVersion", "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "version_locator": "VersionLocator", "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "whitelisted_accounts": ["WhitelistedAccounts"], "image_pull_key_name": "ImagePullKeyName", "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "solution_info": {"architecture_diagrams": [{"diagram": {"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "cost_estimate": {"version": "Version", "currency": "Currency", "projects": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "pastBreakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "breakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "diff": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}}], "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}, "totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "pastTotalHourlyCost": "PastTotalHourlyCost", "pastTotalMonthlyCost": "PastTotalMonthlyCost", "diffTotalHourlyCost": "DiffTotalHourlyCost", "diffTotalMonthlyCost": "DiffTotalMonthlyCost", "timeGenerated": "2019-01-01T12:00:00.000Z"}, "dependencies": [{"catalog_id": "CatalogID", "id": "ID", "name": "Name", "kind": "Kind", "version": "Version", "description": "Description", "default_flavor": "DefaultFlavor", "flavors": ["Flavors"], "optional": true, "on_by_default": false}], "install_type": "InstallType"}, "is_consumable": true, "compliance_v3": {"authority": "Authority", "claims": {"profiles": [{"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}], "controls": [{"profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "names": ["Names"]}]}, "evaluations": [{"scan_id": "ScanID", "account_id": "AccountID", "profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "result": {"failure_count": 12, "scan_time": "2019-01-01T12:00:00.000Z", "error_message": "ErrorMessage", "complete_scan": true, "unscanned_resources": ["UnscannedResources"]}, "controls": [{"id": "ID", "name": "Name", "description": "Description", "specifications": [{"id": "ID", "description": "Description", "component_name": "ComponentName", "assessments": [{"id": "ID", "description": "Description", "version": "Version", "type": "Type", "method": "Method", "ui_href": "UIHref"}], "ui_href": "UIHref"}], "failure_count": 12, "pass_count": 9, "parent": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "parent_name": "ParentName", "specifications": [{"id": "ID", "description": "Description", "component_name": "ComponentName", "assessments": [{"id": "ID", "description": "Description", "version": "Version", "type": "Type", "method": "Method", "ui_href": "UIHref"}], "ui_href": "UIHref"}], "ui_href": "UIHref"}, "ui_href": "UIHref"}]}]}, "change_notices": {"breaking": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "new": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "update": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}]}, "plan_ids": ["PlanIds"], "stack": {"anyKey": "anyValue"}, "minimum_compatible_version": "MinimumCompatibleVersion"}], "all_versions": {"first": {"href": "Href", "start": "Start"}, "next": {"href": "Href", "start": "Start"}}}], "publish": {"pc_managed": false, "approval_type": "ApprovalType", "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "original_crn": "OriginalCRN", "public_crn": "PublicCRN", "approval_record": {"anyKey": "anyValue"}, "permit_ibm_public_publish": true, "ibm_approved": false, "public_approved": true}, "pc_managed": false, "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "public_original_crn": "PublicOriginalCRN", "publish_public_crn": "PublishPublicCRN", "portal_approval_record": "PortalApprovalRecord", "portal_ui_url": "PortalUIURL", "catalog_id": "CatalogID", "catalog_name": "CatalogName", "metadata": {"anyKey": "anyValue"}, "disclaimer": "Disclaimer", "hidden": true, "provider": "Provider", "provider_info": {"id": "ID", "name": "Name"}, "repo_info": {"token": "Token", "type": "Type"}, "image_pull_keys": [{"name": "Name", "value": "Value", "description": "Description"}], "support": {"url": "URL", "process": "Process", "process_i18n": {"mapKey": "Inner"}, "locations": ["Locations"], "support_details": [{"type": "Type", "contact": "Contact", "response_wait_time": {"value": 5, "type": "Type"}, "availability": {"times": [{"day": 3, "start_time": "StartTime", "end_time": "EndTime"}], "timezone": "Timezone", "always_available": false}}], "support_escalation": {"escalation_wait_time": {"value": 5, "type": "Type"}, "response_wait_time": {"value": 5, "type": "Type"}, "contact": "Contact"}, "support_type": "SupportType"}, "media": [{"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}], "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "product_kind": "ProductKind", "badges": [{"id": "ID", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}, "icon": "Icon", "authority": "Authority", "tag": "Tag", "learn_more_links": {"first_party": "FirstParty", "third_party": "ThirdParty"}, "constraints": [{"type": "Type", "rule": "anyValue"}]}], "plans": [{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "offering_id": "OfferingID", "catalog_id": "CatalogID", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "name": "Name", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "pricing_tags": ["PricingTags"], "version_range": {"kinds": ["Kinds"], "version": "Version", "flavors": ["Flavors"]}, "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "metadata": {"anyKey": "anyValue"}, "publish_approved": false}]}`)
				}))
			})
			It(`Invoke CreateOffering successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.CreateOffering(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the Rating model
				ratingModel := new(catalogmanagementv1.Rating)
				ratingModel.OneStarCount = core.Int64Ptr(int64(38))
				ratingModel.TwoStarCount = core.Int64Ptr(int64(38))
				ratingModel.ThreeStarCount = core.Int64Ptr(int64(38))
				ratingModel.FourStarCount = core.Int64Ptr(int64(38))

				// Construct an instance of the Feature model
				featureModel := new(catalogmanagementv1.Feature)
				featureModel.Title = core.StringPtr("testString")
				featureModel.TitleI18n = map[string]string{"key1": "testString"}
				featureModel.Description = core.StringPtr("testString")
				featureModel.DescriptionI18n = map[string]string{"key1": "testString"}

				// Construct an instance of the Flavor model
				flavorModel := new(catalogmanagementv1.Flavor)
				flavorModel.Name = core.StringPtr("testString")
				flavorModel.Label = core.StringPtr("testString")
				flavorModel.LabelI18n = map[string]string{"key1": "testString"}
				flavorModel.Index = core.Int64Ptr(int64(38))

				// Construct an instance of the RenderTypeAssociationsParametersItem model
				renderTypeAssociationsParametersItemModel := new(catalogmanagementv1.RenderTypeAssociationsParametersItem)
				renderTypeAssociationsParametersItemModel.Name = core.StringPtr("testString")
				renderTypeAssociationsParametersItemModel.OptionsRefresh = core.BoolPtr(true)

				// Construct an instance of the RenderTypeAssociations model
				renderTypeAssociationsModel := new(catalogmanagementv1.RenderTypeAssociations)
				renderTypeAssociationsModel.Parameters = []catalogmanagementv1.RenderTypeAssociationsParametersItem{*renderTypeAssociationsParametersItemModel}

				// Construct an instance of the RenderType model
				renderTypeModel := new(catalogmanagementv1.RenderType)
				renderTypeModel.Type = core.StringPtr("testString")
				renderTypeModel.Grouping = core.StringPtr("testString")
				renderTypeModel.OriginalGrouping = core.StringPtr("testString")
				renderTypeModel.GroupingIndex = core.Int64Ptr(int64(38))
				renderTypeModel.ConfigConstraints = map[string]interface{}{"anyKey": "anyValue"}
				renderTypeModel.Associations = renderTypeAssociationsModel

				// Construct an instance of the Configuration model
				configurationModel := new(catalogmanagementv1.Configuration)
				configurationModel.Key = core.StringPtr("testString")
				configurationModel.Type = core.StringPtr("testString")
				configurationModel.DefaultValue = "testString"
				configurationModel.DisplayName = core.StringPtr("testString")
				configurationModel.ValueConstraint = core.StringPtr("testString")
				configurationModel.Description = core.StringPtr("testString")
				configurationModel.Required = core.BoolPtr(true)
				configurationModel.Options = []interface{}{"testString"}
				configurationModel.Hidden = core.BoolPtr(true)
				configurationModel.CustomConfig = renderTypeModel
				configurationModel.TypeMetadata = core.StringPtr("testString")

				// Construct an instance of the Output model
				outputModel := new(catalogmanagementv1.Output)
				outputModel.Key = core.StringPtr("testString")
				outputModel.Description = core.StringPtr("testString")

				// Construct an instance of the IamResource model
				iamResourceModel := new(catalogmanagementv1.IamResource)
				iamResourceModel.Name = core.StringPtr("testString")
				iamResourceModel.Description = core.StringPtr("testString")
				iamResourceModel.RoleCrns = []string{"testString"}

				// Construct an instance of the IamPermission model
				iamPermissionModel := new(catalogmanagementv1.IamPermission)
				iamPermissionModel.ServiceName = core.StringPtr("testString")
				iamPermissionModel.RoleCrns = []string{"testString"}
				iamPermissionModel.Resources = []catalogmanagementv1.IamResource{*iamResourceModel}

				// Construct an instance of the Validation model
				validationModel := new(catalogmanagementv1.Validation)
				validationModel.Validated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				validationModel.Requested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				validationModel.State = core.StringPtr("testString")
				validationModel.LastOperation = core.StringPtr("testString")
				validationModel.Target = map[string]interface{}{"anyKey": "anyValue"}
				validationModel.Message = core.StringPtr("testString")

				// Construct an instance of the Resource model
				resourceModel := new(catalogmanagementv1.Resource)
				resourceModel.Type = core.StringPtr("mem")
				resourceModel.Value = "testString"

				// Construct an instance of the SchematicsEnvValues model
				schematicsEnvValuesModel := new(catalogmanagementv1.SchematicsEnvValues)
				schematicsEnvValuesModel.Value = core.StringPtr("[{\"name\": \"TF_LOG\",\"value\": \"TRACE\",\"secure\": false,\"hidden\": false}]")
				schematicsEnvValuesModel.SmRef = core.StringPtr("cmsm_v1:{\"name\": \"envVarSecret\",\"id\":\"1234567890\",\"service_id\":\"crn:v1:bluemix:public:secrets-manager:eu-gb:a/1234567890:1234567890::\",\"service_name\":\"My SM Instance\",\"group_id\":\"1234567890\",\"group_name\":\"My SM Group\",\"resource_group_id\":\"1234567890\",\"region\":\"eu-gb\",\"type\":\"arbitrary\"}")

				// Construct an instance of the Script model
				scriptModel := new(catalogmanagementv1.Script)
				scriptModel.Instructions = core.StringPtr("testString")
				scriptModel.InstructionsI18n = map[string]string{"key1": "testString"}
				scriptModel.Script = core.StringPtr("testString")
				scriptModel.ScriptPermission = core.StringPtr("testString")
				scriptModel.DeleteScript = core.StringPtr("testString")
				scriptModel.Scope = core.StringPtr("testString")

				// Construct an instance of the ScriptRef model
				scriptRefModel := new(catalogmanagementv1.ScriptRef)
				scriptRefModel.ShortDescription = core.StringPtr("testString")
				scriptRefModel.Type = core.StringPtr("ansible")
				scriptRefModel.Path = core.StringPtr("scripts/validate-post-ansible-playbook.yaml")
				scriptRefModel.Stage = core.StringPtr("pre")
				scriptRefModel.Action = core.StringPtr("validate")

				// Construct an instance of the VersionEntitlement model
				versionEntitlementModel := new(catalogmanagementv1.VersionEntitlement)
				versionEntitlementModel.ProviderName = core.StringPtr("testString")
				versionEntitlementModel.ProviderID = core.StringPtr("testString")
				versionEntitlementModel.ProductID = core.StringPtr("testString")
				versionEntitlementModel.PartNumbers = []string{"testString"}
				versionEntitlementModel.ImageRepoName = core.StringPtr("testString")

				// Construct an instance of the License model
				licenseModel := new(catalogmanagementv1.License)
				licenseModel.ID = core.StringPtr("testString")
				licenseModel.Name = core.StringPtr("testString")
				licenseModel.Type = core.StringPtr("testString")
				licenseModel.URL = core.StringPtr("testString")
				licenseModel.Description = core.StringPtr("testString")

				// Construct an instance of the State model
				stateModel := new(catalogmanagementv1.State)
				stateModel.Current = core.StringPtr("testString")
				stateModel.CurrentEntered = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Pending = core.StringPtr("testString")
				stateModel.PendingRequested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Previous = core.StringPtr("testString")

				// Construct an instance of the DeprecatePending model
				deprecatePendingModel := new(catalogmanagementv1.DeprecatePending)
				deprecatePendingModel.DeprecateDate = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				deprecatePendingModel.DeprecateState = core.StringPtr("testString")
				deprecatePendingModel.Description = core.StringPtr("testString")

				// Construct an instance of the URLProxy model
				urlProxyModel := new(catalogmanagementv1.URLProxy)
				urlProxyModel.URL = core.StringPtr("testString")
				urlProxyModel.Sha = core.StringPtr("testString")

				// Construct an instance of the MediaItem model
				mediaItemModel := new(catalogmanagementv1.MediaItem)
				mediaItemModel.URL = core.StringPtr("testString")
				mediaItemModel.APIURL = core.StringPtr("testString")
				mediaItemModel.URLProxy = urlProxyModel
				mediaItemModel.Caption = core.StringPtr("testString")
				mediaItemModel.CaptionI18n = map[string]string{"key1": "testString"}
				mediaItemModel.Type = core.StringPtr("testString")
				mediaItemModel.ThumbnailURL = core.StringPtr("testString")

				// Construct an instance of the ArchitectureDiagram model
				architectureDiagramModel := new(catalogmanagementv1.ArchitectureDiagram)
				architectureDiagramModel.Diagram = mediaItemModel
				architectureDiagramModel.Description = core.StringPtr("testString")
				architectureDiagramModel.DescriptionI18n = map[string]string{"key1": "testString"}

				// Construct an instance of the CostComponent model
				costComponentModel := new(catalogmanagementv1.CostComponent)
				costComponentModel.Name = core.StringPtr("testString")
				costComponentModel.Unit = core.StringPtr("testString")
				costComponentModel.HourlyQuantity = core.StringPtr("testString")
				costComponentModel.MonthlyQuantity = core.StringPtr("testString")
				costComponentModel.Price = core.StringPtr("testString")
				costComponentModel.HourlyCost = core.StringPtr("testString")
				costComponentModel.MonthlyCost = core.StringPtr("testString")

				// Construct an instance of the CostResource model
				costResourceModel := new(catalogmanagementv1.CostResource)
				costResourceModel.Name = core.StringPtr("testString")
				costResourceModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				costResourceModel.HourlyCost = core.StringPtr("testString")
				costResourceModel.MonthlyCost = core.StringPtr("testString")
				costResourceModel.CostComponents = []catalogmanagementv1.CostComponent{*costComponentModel}

				// Construct an instance of the CostBreakdown model
				costBreakdownModel := new(catalogmanagementv1.CostBreakdown)
				costBreakdownModel.TotalHourlyCost = core.StringPtr("testString")
				costBreakdownModel.TotalMonthlyCost = core.StringPtr("testString")
				costBreakdownModel.Resources = []catalogmanagementv1.CostResource{*costResourceModel}

				// Construct an instance of the CostSummary model
				costSummaryModel := new(catalogmanagementv1.CostSummary)
				costSummaryModel.TotalDetectedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalSupportedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalUnsupportedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalUsageBasedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalNoPriceResources = core.Int64Ptr(int64(38))
				costSummaryModel.UnsupportedResourceCounts = map[string]int64{"key1": int64(38)}
				costSummaryModel.NoPriceResourceCounts = map[string]int64{"key1": int64(38)}

				// Construct an instance of the Project model
				projectModel := new(catalogmanagementv1.Project)
				projectModel.Name = core.StringPtr("testString")
				projectModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				projectModel.PastBreakdown = costBreakdownModel
				projectModel.Breakdown = costBreakdownModel
				projectModel.Diff = costBreakdownModel
				projectModel.Summary = costSummaryModel

				// Construct an instance of the CostEstimate model
				costEstimateModel := new(catalogmanagementv1.CostEstimate)
				costEstimateModel.Version = core.StringPtr("testString")
				costEstimateModel.Currency = core.StringPtr("testString")
				costEstimateModel.Projects = []catalogmanagementv1.Project{*projectModel}
				costEstimateModel.Summary = costSummaryModel
				costEstimateModel.TotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.TotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.PastTotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.PastTotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.DiffTotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.DiffTotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.TimeGenerated = CreateMockDateTime("2019-01-01T12:00:00.000Z")

				// Construct an instance of the OfferingReference model
				offeringReferenceModel := new(catalogmanagementv1.OfferingReference)
				offeringReferenceModel.CatalogID = core.StringPtr("testString")
				offeringReferenceModel.ID = core.StringPtr("testString")
				offeringReferenceModel.Name = core.StringPtr("testString")
				offeringReferenceModel.Kind = core.StringPtr("testString")
				offeringReferenceModel.Version = core.StringPtr("testString")
				offeringReferenceModel.Description = core.StringPtr("testString")
				offeringReferenceModel.DefaultFlavor = core.StringPtr("testString")
				offeringReferenceModel.Flavors = []string{"testString"}
				offeringReferenceModel.Optional = core.BoolPtr(true)
				offeringReferenceModel.OnByDefault = core.BoolPtr(true)

				// Construct an instance of the SolutionInfo model
				solutionInfoModel := new(catalogmanagementv1.SolutionInfo)
				solutionInfoModel.ArchitectureDiagrams = []catalogmanagementv1.ArchitectureDiagram{*architectureDiagramModel}
				solutionInfoModel.Features = []catalogmanagementv1.Feature{*featureModel}
				solutionInfoModel.CostEstimate = costEstimateModel
				solutionInfoModel.Dependencies = []catalogmanagementv1.OfferingReference{*offeringReferenceModel}
				solutionInfoModel.InstallType = core.StringPtr("testString")

				// Construct an instance of the SccProfile model
				sccProfileModel := new(catalogmanagementv1.SccProfile)
				sccProfileModel.ID = core.StringPtr("testString")
				sccProfileModel.Name = core.StringPtr("testString")
				sccProfileModel.Version = core.StringPtr("testString")
				sccProfileModel.Description = core.StringPtr("testString")
				sccProfileModel.Type = core.StringPtr("testString")
				sccProfileModel.UIHref = core.StringPtr("testString")

				// Construct an instance of the ClaimedControl model
				claimedControlModel := new(catalogmanagementv1.ClaimedControl)
				claimedControlModel.Profile = sccProfileModel
				claimedControlModel.Names = []string{"testString"}

				// Construct an instance of the Claims model
				claimsModel := new(catalogmanagementv1.Claims)
				claimsModel.Profiles = []catalogmanagementv1.SccProfile{*sccProfileModel}
				claimsModel.Controls = []catalogmanagementv1.ClaimedControl{*claimedControlModel}

				// Construct an instance of the Result model
				resultModel := new(catalogmanagementv1.Result)
				resultModel.FailureCount = core.Int64Ptr(int64(38))
				resultModel.ScanTime = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				resultModel.ErrorMessage = core.StringPtr("testString")
				resultModel.CompleteScan = core.BoolPtr(true)
				resultModel.UnscannedResources = []string{"testString"}

				// Construct an instance of the SccAssessment model
				sccAssessmentModel := new(catalogmanagementv1.SccAssessment)
				sccAssessmentModel.ID = core.StringPtr("testString")
				sccAssessmentModel.Description = core.StringPtr("testString")
				sccAssessmentModel.Version = core.StringPtr("testString")
				sccAssessmentModel.Type = core.StringPtr("testString")
				sccAssessmentModel.Method = core.StringPtr("testString")
				sccAssessmentModel.UIHref = core.StringPtr("testString")

				// Construct an instance of the SccSpecification model
				sccSpecificationModel := new(catalogmanagementv1.SccSpecification)
				sccSpecificationModel.ID = core.StringPtr("testString")
				sccSpecificationModel.Description = core.StringPtr("testString")
				sccSpecificationModel.ComponentName = core.StringPtr("testString")
				sccSpecificationModel.Assessments = []catalogmanagementv1.SccAssessment{*sccAssessmentModel}
				sccSpecificationModel.UIHref = core.StringPtr("testString")

				// Construct an instance of the SccControl model
				sccControlModel := new(catalogmanagementv1.SccControl)
				sccControlModel.ID = core.StringPtr("testString")
				sccControlModel.Name = core.StringPtr("testString")
				sccControlModel.Version = core.StringPtr("testString")
				sccControlModel.Description = core.StringPtr("testString")
				sccControlModel.Profile = sccProfileModel
				sccControlModel.ParentName = core.StringPtr("testString")
				sccControlModel.Specifications = []catalogmanagementv1.SccSpecification{*sccSpecificationModel}
				sccControlModel.UIHref = core.StringPtr("testString")

				// Construct an instance of the EvaluatedControl model
				evaluatedControlModel := new(catalogmanagementv1.EvaluatedControl)
				evaluatedControlModel.ID = core.StringPtr("testString")
				evaluatedControlModel.Name = core.StringPtr("testString")
				evaluatedControlModel.Description = core.StringPtr("testString")
				evaluatedControlModel.Specifications = []catalogmanagementv1.SccSpecification{*sccSpecificationModel}
				evaluatedControlModel.FailureCount = core.Int64Ptr(int64(38))
				evaluatedControlModel.PassCount = core.Int64Ptr(int64(38))
				evaluatedControlModel.Parent = sccControlModel
				evaluatedControlModel.UIHref = core.StringPtr("testString")

				// Construct an instance of the Evaluation model
				evaluationModel := new(catalogmanagementv1.Evaluation)
				evaluationModel.ScanID = core.StringPtr("testString")
				evaluationModel.AccountID = core.StringPtr("testString")
				evaluationModel.Profile = sccProfileModel
				evaluationModel.Result = resultModel
				evaluationModel.Controls = []catalogmanagementv1.EvaluatedControl{*evaluatedControlModel}

				// Construct an instance of the Compliance model
				complianceModel := new(catalogmanagementv1.Compliance)
				complianceModel.Authority = core.StringPtr("testString")
				complianceModel.Claims = claimsModel
				complianceModel.Evaluations = []catalogmanagementv1.Evaluation{*evaluationModel}

				// Construct an instance of the ChangeNotices model
				changeNoticesModel := new(catalogmanagementv1.ChangeNotices)
				changeNoticesModel.Breaking = []catalogmanagementv1.Feature{*featureModel}
				changeNoticesModel.New = []catalogmanagementv1.Feature{*featureModel}
				changeNoticesModel.Update = []catalogmanagementv1.Feature{*featureModel}

				// Construct an instance of the Version model
				versionModel := new(catalogmanagementv1.Version)
				versionModel.CRN = core.StringPtr("testString")
				versionModel.Version = core.StringPtr("testString")
				versionModel.Flavor = flavorModel
				versionModel.Sha = core.StringPtr("testString")
				versionModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				versionModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				versionModel.OfferingID = core.StringPtr("testString")
				versionModel.CatalogID = core.StringPtr("testString")
				versionModel.KindID = core.StringPtr("testString")
				versionModel.Tags = []string{"testString"}
				versionModel.RepoURL = core.StringPtr("testString")
				versionModel.SourceURL = core.StringPtr("testString")
				versionModel.TgzURL = core.StringPtr("testString")
				versionModel.Configuration = []catalogmanagementv1.Configuration{*configurationModel}
				versionModel.Outputs = []catalogmanagementv1.Output{*outputModel}
				versionModel.IamPermissions = []catalogmanagementv1.IamPermission{*iamPermissionModel}
				versionModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				versionModel.Validation = validationModel
				versionModel.RequiredResources = []catalogmanagementv1.Resource{*resourceModel}
				versionModel.SingleInstance = core.BoolPtr(true)
				versionModel.SchematicsEnvValues = schematicsEnvValuesModel
				versionModel.Install = scriptModel
				versionModel.PreInstall = []catalogmanagementv1.Script{*scriptModel}
				versionModel.Scripts = map[string]catalogmanagementv1.ScriptRef{"key1": *scriptRefModel}
				versionModel.Entitlement = versionEntitlementModel
				versionModel.Licenses = []catalogmanagementv1.License{*licenseModel}
				versionModel.ImageManifestURL = core.StringPtr("testString")
				versionModel.Deprecated = core.BoolPtr(true)
				versionModel.PackageVersion = core.StringPtr("testString")
				versionModel.State = stateModel
				versionModel.VersionLocator = core.StringPtr("testString")
				versionModel.LongDescription = core.StringPtr("testString")
				versionModel.LongDescriptionI18n = map[string]string{"key1": "testString"}
				versionModel.WhitelistedAccounts = []string{"testString"}
				versionModel.ImagePullKeyName = core.StringPtr("testString")
				versionModel.DeprecatePending = deprecatePendingModel
				versionModel.SolutionInfo = solutionInfoModel
				versionModel.IsConsumable = core.BoolPtr(true)
				versionModel.ComplianceV3 = complianceModel
				versionModel.ChangeNotices = changeNoticesModel
				versionModel.PlanIds = []string{"testString"}
				versionModel.Stack = map[string]interface{}{"anyKey": "anyValue"}
				versionModel.MinimumCompatibleVersion = core.StringPtr("testString")
				versionModel.Scripts["foo"] = *scriptRefModel

				// Construct an instance of the PaginationTokenLink model
				paginationTokenLinkModel := new(catalogmanagementv1.PaginationTokenLink)
				paginationTokenLinkModel.Href = core.StringPtr("testString")
				paginationTokenLinkModel.Start = core.StringPtr("testString")

				// Construct an instance of the KindAllVersions model
				kindAllVersionsModel := new(catalogmanagementv1.KindAllVersions)
				kindAllVersionsModel.First = paginationTokenLinkModel
				kindAllVersionsModel.Next = paginationTokenLinkModel

				// Construct an instance of the Kind model
				kindModel := new(catalogmanagementv1.Kind)
				kindModel.ID = core.StringPtr("testString")
				kindModel.FormatKind = core.StringPtr("testString")
				kindModel.FormatKindLabel = core.StringPtr("testString")
				kindModel.InstallKind = core.StringPtr("testString")
				kindModel.InstallKindLabel = core.StringPtr("testString")
				kindModel.TargetKind = core.StringPtr("testString")
				kindModel.TargetKindLabel = core.StringPtr("testString")
				kindModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				kindModel.Tags = []string{"testString"}
				kindModel.AdditionalFeatures = []catalogmanagementv1.Feature{*featureModel}
				kindModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				kindModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				kindModel.Versions = []catalogmanagementv1.Version{*versionModel}
				kindModel.AllVersions = kindAllVersionsModel

				// Construct an instance of the PublishObject model
				publishObjectModel := new(catalogmanagementv1.PublishObject)
				publishObjectModel.PcManaged = core.BoolPtr(true)
				publishObjectModel.ApprovalType = core.StringPtr("testString")
				publishObjectModel.PublishApproved = core.BoolPtr(true)
				publishObjectModel.ShareWithAll = core.BoolPtr(true)
				publishObjectModel.ShareWithIBM = core.BoolPtr(true)
				publishObjectModel.ShareEnabled = core.BoolPtr(true)
				publishObjectModel.OriginalCRN = core.StringPtr("testString")
				publishObjectModel.PublicCRN = core.StringPtr("testString")
				publishObjectModel.ApprovalRecord = map[string]interface{}{"anyKey": "anyValue"}
				publishObjectModel.PermitIBMPublicPublish = core.BoolPtr(true)
				publishObjectModel.IBMApproved = core.BoolPtr(true)
				publishObjectModel.PublicApproved = core.BoolPtr(true)

				// Construct an instance of the ProviderInfo model
				providerInfoModel := new(catalogmanagementv1.ProviderInfo)
				providerInfoModel.ID = core.StringPtr("testString")
				providerInfoModel.Name = core.StringPtr("testString")

				// Construct an instance of the RepoInfo model
				repoInfoModel := new(catalogmanagementv1.RepoInfo)
				repoInfoModel.Token = core.StringPtr("testString")
				repoInfoModel.Type = core.StringPtr("testString")

				// Construct an instance of the ImagePullKey model
				imagePullKeyModel := new(catalogmanagementv1.ImagePullKey)
				imagePullKeyModel.Name = core.StringPtr("testString")
				imagePullKeyModel.Value = core.StringPtr("testString")
				imagePullKeyModel.Description = core.StringPtr("testString")

				// Construct an instance of the SupportWaitTime model
				supportWaitTimeModel := new(catalogmanagementv1.SupportWaitTime)
				supportWaitTimeModel.Value = core.Int64Ptr(int64(38))
				supportWaitTimeModel.Type = core.StringPtr("testString")

				// Construct an instance of the SupportTime model
				supportTimeModel := new(catalogmanagementv1.SupportTime)
				supportTimeModel.Day = core.Int64Ptr(int64(38))
				supportTimeModel.StartTime = core.StringPtr("testString")
				supportTimeModel.EndTime = core.StringPtr("testString")

				// Construct an instance of the SupportAvailability model
				supportAvailabilityModel := new(catalogmanagementv1.SupportAvailability)
				supportAvailabilityModel.Times = []catalogmanagementv1.SupportTime{*supportTimeModel}
				supportAvailabilityModel.Timezone = core.StringPtr("testString")
				supportAvailabilityModel.AlwaysAvailable = core.BoolPtr(true)

				// Construct an instance of the SupportDetail model
				supportDetailModel := new(catalogmanagementv1.SupportDetail)
				supportDetailModel.Type = core.StringPtr("testString")
				supportDetailModel.Contact = core.StringPtr("testString")
				supportDetailModel.ResponseWaitTime = supportWaitTimeModel
				supportDetailModel.Availability = supportAvailabilityModel

				// Construct an instance of the SupportEscalation model
				supportEscalationModel := new(catalogmanagementv1.SupportEscalation)
				supportEscalationModel.EscalationWaitTime = supportWaitTimeModel
				supportEscalationModel.ResponseWaitTime = supportWaitTimeModel
				supportEscalationModel.Contact = core.StringPtr("testString")

				// Construct an instance of the Support model
				supportModel := new(catalogmanagementv1.Support)
				supportModel.URL = core.StringPtr("testString")
				supportModel.Process = core.StringPtr("testString")
				supportModel.ProcessI18n = map[string]string{"key1": "testString"}
				supportModel.Locations = []string{"testString"}
				supportModel.SupportDetails = []catalogmanagementv1.SupportDetail{*supportDetailModel}
				supportModel.SupportEscalation = supportEscalationModel
				supportModel.SupportType = core.StringPtr("testString")

				// Construct an instance of the LearnMoreLinks model
				learnMoreLinksModel := new(catalogmanagementv1.LearnMoreLinks)
				learnMoreLinksModel.FirstParty = core.StringPtr("testString")
				learnMoreLinksModel.ThirdParty = core.StringPtr("testString")

				// Construct an instance of the Constraint model
				constraintModel := new(catalogmanagementv1.Constraint)
				constraintModel.Type = core.StringPtr("testString")
				constraintModel.Rule = "testString"

				// Construct an instance of the Badge model
				badgeModel := new(catalogmanagementv1.Badge)
				badgeModel.ID = core.StringPtr("testString")
				badgeModel.Label = core.StringPtr("testString")
				badgeModel.LabelI18n = map[string]string{"key1": "testString"}
				badgeModel.Description = core.StringPtr("testString")
				badgeModel.DescriptionI18n = map[string]string{"key1": "testString"}
				badgeModel.Icon = core.StringPtr("testString")
				badgeModel.Authority = core.StringPtr("testString")
				badgeModel.Tag = core.StringPtr("testString")
				badgeModel.LearnMoreLinks = learnMoreLinksModel
				badgeModel.Constraints = []catalogmanagementv1.Constraint{*constraintModel}

				// Construct an instance of the VersionRange model
				versionRangeModel := new(catalogmanagementv1.VersionRange)
				versionRangeModel.Kinds = []string{"testString"}
				versionRangeModel.Version = core.StringPtr("testString")
				versionRangeModel.Flavors = []string{"testString"}

				// Construct an instance of the Plan model
				planModel := new(catalogmanagementv1.Plan)
				planModel.URL = core.StringPtr("testString")
				planModel.CRN = core.StringPtr("testString")
				planModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				planModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				planModel.OfferingID = core.StringPtr("testString")
				planModel.CatalogID = core.StringPtr("testString")
				planModel.Label = core.StringPtr("testString")
				planModel.LabelI18n = map[string]string{"key1": "testString"}
				planModel.Name = core.StringPtr("testString")
				planModel.ShortDescription = core.StringPtr("testString")
				planModel.ShortDescriptionI18n = map[string]string{"key1": "testString"}
				planModel.PricingTags = []string{"testString"}
				planModel.VersionRange = versionRangeModel
				planModel.Features = []catalogmanagementv1.Feature{*featureModel}
				planModel.State = stateModel
				planModel.DeprecatePending = deprecatePendingModel
				planModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				planModel.PublishApproved = core.BoolPtr(true)

				// Construct an instance of the CreateOfferingOptions model
				createOfferingOptionsModel := new(catalogmanagementv1.CreateOfferingOptions)
				createOfferingOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				createOfferingOptionsModel.URL = core.StringPtr("testString")
				createOfferingOptionsModel.CRN = core.StringPtr("testString")
				createOfferingOptionsModel.Label = core.StringPtr("testString")
				createOfferingOptionsModel.LabelI18n = map[string]string{"key1": "testString"}
				createOfferingOptionsModel.Name = core.StringPtr("testString")
				createOfferingOptionsModel.OfferingIconURL = core.StringPtr("testString")
				createOfferingOptionsModel.OfferingDocsURL = core.StringPtr("testString")
				createOfferingOptionsModel.OfferingSupportURL = core.StringPtr("testString")
				createOfferingOptionsModel.Tags = []string{"testString"}
				createOfferingOptionsModel.Keywords = []string{"testString"}
				createOfferingOptionsModel.Rating = ratingModel
				createOfferingOptionsModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				createOfferingOptionsModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				createOfferingOptionsModel.ShortDescription = core.StringPtr("testString")
				createOfferingOptionsModel.ShortDescriptionI18n = map[string]string{"key1": "testString"}
				createOfferingOptionsModel.LongDescription = core.StringPtr("testString")
				createOfferingOptionsModel.LongDescriptionI18n = map[string]string{"key1": "testString"}
				createOfferingOptionsModel.Features = []catalogmanagementv1.Feature{*featureModel}
				createOfferingOptionsModel.Kinds = []catalogmanagementv1.Kind{*kindModel}
				createOfferingOptionsModel.Publish = publishObjectModel
				createOfferingOptionsModel.PcManaged = core.BoolPtr(true)
				createOfferingOptionsModel.PublishApproved = core.BoolPtr(true)
				createOfferingOptionsModel.ShareWithAll = core.BoolPtr(true)
				createOfferingOptionsModel.ShareWithIBM = core.BoolPtr(true)
				createOfferingOptionsModel.ShareEnabled = core.BoolPtr(true)
				createOfferingOptionsModel.PublicOriginalCRN = core.StringPtr("testString")
				createOfferingOptionsModel.PublishPublicCRN = core.StringPtr("testString")
				createOfferingOptionsModel.PortalApprovalRecord = core.StringPtr("testString")
				createOfferingOptionsModel.PortalUIURL = core.StringPtr("testString")
				createOfferingOptionsModel.CatalogID = core.StringPtr("testString")
				createOfferingOptionsModel.CatalogName = core.StringPtr("testString")
				createOfferingOptionsModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				createOfferingOptionsModel.Disclaimer = core.StringPtr("testString")
				createOfferingOptionsModel.Hidden = core.BoolPtr(true)
				createOfferingOptionsModel.Provider = core.StringPtr("testString")
				createOfferingOptionsModel.ProviderInfo = providerInfoModel
				createOfferingOptionsModel.RepoInfo = repoInfoModel
				createOfferingOptionsModel.ImagePullKeys = []catalogmanagementv1.ImagePullKey{*imagePullKeyModel}
				createOfferingOptionsModel.Support = supportModel
				createOfferingOptionsModel.Media = []catalogmanagementv1.MediaItem{*mediaItemModel}
				createOfferingOptionsModel.DeprecatePending = deprecatePendingModel
				createOfferingOptionsModel.ProductKind = core.StringPtr("testString")
				createOfferingOptionsModel.Badges = []catalogmanagementv1.Badge{*badgeModel}
				createOfferingOptionsModel.Plans = []catalogmanagementv1.Plan{*planModel}
				createOfferingOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.CreateOffering(createOfferingOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke CreateOffering with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the Rating model
				ratingModel := new(catalogmanagementv1.Rating)
				ratingModel.OneStarCount = core.Int64Ptr(int64(38))
				ratingModel.TwoStarCount = core.Int64Ptr(int64(38))
				ratingModel.ThreeStarCount = core.Int64Ptr(int64(38))
				ratingModel.FourStarCount = core.Int64Ptr(int64(38))

				// Construct an instance of the Feature model
				featureModel := new(catalogmanagementv1.Feature)
				featureModel.Title = core.StringPtr("testString")
				featureModel.TitleI18n = map[string]string{"key1": "testString"}
				featureModel.Description = core.StringPtr("testString")
				featureModel.DescriptionI18n = map[string]string{"key1": "testString"}

				// Construct an instance of the Flavor model
				flavorModel := new(catalogmanagementv1.Flavor)
				flavorModel.Name = core.StringPtr("testString")
				flavorModel.Label = core.StringPtr("testString")
				flavorModel.LabelI18n = map[string]string{"key1": "testString"}
				flavorModel.Index = core.Int64Ptr(int64(38))

				// Construct an instance of the RenderTypeAssociationsParametersItem model
				renderTypeAssociationsParametersItemModel := new(catalogmanagementv1.RenderTypeAssociationsParametersItem)
				renderTypeAssociationsParametersItemModel.Name = core.StringPtr("testString")
				renderTypeAssociationsParametersItemModel.OptionsRefresh = core.BoolPtr(true)

				// Construct an instance of the RenderTypeAssociations model
				renderTypeAssociationsModel := new(catalogmanagementv1.RenderTypeAssociations)
				renderTypeAssociationsModel.Parameters = []catalogmanagementv1.RenderTypeAssociationsParametersItem{*renderTypeAssociationsParametersItemModel}

				// Construct an instance of the RenderType model
				renderTypeModel := new(catalogmanagementv1.RenderType)
				renderTypeModel.Type = core.StringPtr("testString")
				renderTypeModel.Grouping = core.StringPtr("testString")
				renderTypeModel.OriginalGrouping = core.StringPtr("testString")
				renderTypeModel.GroupingIndex = core.Int64Ptr(int64(38))
				renderTypeModel.ConfigConstraints = map[string]interface{}{"anyKey": "anyValue"}
				renderTypeModel.Associations = renderTypeAssociationsModel

				// Construct an instance of the Configuration model
				configurationModel := new(catalogmanagementv1.Configuration)
				configurationModel.Key = core.StringPtr("testString")
				configurationModel.Type = core.StringPtr("testString")
				configurationModel.DefaultValue = "testString"
				configurationModel.DisplayName = core.StringPtr("testString")
				configurationModel.ValueConstraint = core.StringPtr("testString")
				configurationModel.Description = core.StringPtr("testString")
				configurationModel.Required = core.BoolPtr(true)
				configurationModel.Options = []interface{}{"testString"}
				configurationModel.Hidden = core.BoolPtr(true)
				configurationModel.CustomConfig = renderTypeModel
				configurationModel.TypeMetadata = core.StringPtr("testString")

				// Construct an instance of the Output model
				outputModel := new(catalogmanagementv1.Output)
				outputModel.Key = core.StringPtr("testString")
				outputModel.Description = core.StringPtr("testString")

				// Construct an instance of the IamResource model
				iamResourceModel := new(catalogmanagementv1.IamResource)
				iamResourceModel.Name = core.StringPtr("testString")
				iamResourceModel.Description = core.StringPtr("testString")
				iamResourceModel.RoleCrns = []string{"testString"}

				// Construct an instance of the IamPermission model
				iamPermissionModel := new(catalogmanagementv1.IamPermission)
				iamPermissionModel.ServiceName = core.StringPtr("testString")
				iamPermissionModel.RoleCrns = []string{"testString"}
				iamPermissionModel.Resources = []catalogmanagementv1.IamResource{*iamResourceModel}

				// Construct an instance of the Validation model
				validationModel := new(catalogmanagementv1.Validation)
				validationModel.Validated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				validationModel.Requested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				validationModel.State = core.StringPtr("testString")
				validationModel.LastOperation = core.StringPtr("testString")
				validationModel.Target = map[string]interface{}{"anyKey": "anyValue"}
				validationModel.Message = core.StringPtr("testString")

				// Construct an instance of the Resource model
				resourceModel := new(catalogmanagementv1.Resource)
				resourceModel.Type = core.StringPtr("mem")
				resourceModel.Value = "testString"

				// Construct an instance of the SchematicsEnvValues model
				schematicsEnvValuesModel := new(catalogmanagementv1.SchematicsEnvValues)
				schematicsEnvValuesModel.Value = core.StringPtr("[{\"name\": \"TF_LOG\",\"value\": \"TRACE\",\"secure\": false,\"hidden\": false}]")
				schematicsEnvValuesModel.SmRef = core.StringPtr("cmsm_v1:{\"name\": \"envVarSecret\",\"id\":\"1234567890\",\"service_id\":\"crn:v1:bluemix:public:secrets-manager:eu-gb:a/1234567890:1234567890::\",\"service_name\":\"My SM Instance\",\"group_id\":\"1234567890\",\"group_name\":\"My SM Group\",\"resource_group_id\":\"1234567890\",\"region\":\"eu-gb\",\"type\":\"arbitrary\"}")

				// Construct an instance of the Script model
				scriptModel := new(catalogmanagementv1.Script)
				scriptModel.Instructions = core.StringPtr("testString")
				scriptModel.InstructionsI18n = map[string]string{"key1": "testString"}
				scriptModel.Script = core.StringPtr("testString")
				scriptModel.ScriptPermission = core.StringPtr("testString")
				scriptModel.DeleteScript = core.StringPtr("testString")
				scriptModel.Scope = core.StringPtr("testString")

				// Construct an instance of the ScriptRef model
				scriptRefModel := new(catalogmanagementv1.ScriptRef)
				scriptRefModel.ShortDescription = core.StringPtr("testString")
				scriptRefModel.Type = core.StringPtr("ansible")
				scriptRefModel.Path = core.StringPtr("scripts/validate-post-ansible-playbook.yaml")
				scriptRefModel.Stage = core.StringPtr("pre")
				scriptRefModel.Action = core.StringPtr("validate")

				// Construct an instance of the VersionEntitlement model
				versionEntitlementModel := new(catalogmanagementv1.VersionEntitlement)
				versionEntitlementModel.ProviderName = core.StringPtr("testString")
				versionEntitlementModel.ProviderID = core.StringPtr("testString")
				versionEntitlementModel.ProductID = core.StringPtr("testString")
				versionEntitlementModel.PartNumbers = []string{"testString"}
				versionEntitlementModel.ImageRepoName = core.StringPtr("testString")

				// Construct an instance of the License model
				licenseModel := new(catalogmanagementv1.License)
				licenseModel.ID = core.StringPtr("testString")
				licenseModel.Name = core.StringPtr("testString")
				licenseModel.Type = core.StringPtr("testString")
				licenseModel.URL = core.StringPtr("testString")
				licenseModel.Description = core.StringPtr("testString")

				// Construct an instance of the State model
				stateModel := new(catalogmanagementv1.State)
				stateModel.Current = core.StringPtr("testString")
				stateModel.CurrentEntered = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Pending = core.StringPtr("testString")
				stateModel.PendingRequested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Previous = core.StringPtr("testString")

				// Construct an instance of the DeprecatePending model
				deprecatePendingModel := new(catalogmanagementv1.DeprecatePending)
				deprecatePendingModel.DeprecateDate = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				deprecatePendingModel.DeprecateState = core.StringPtr("testString")
				deprecatePendingModel.Description = core.StringPtr("testString")

				// Construct an instance of the URLProxy model
				urlProxyModel := new(catalogmanagementv1.URLProxy)
				urlProxyModel.URL = core.StringPtr("testString")
				urlProxyModel.Sha = core.StringPtr("testString")

				// Construct an instance of the MediaItem model
				mediaItemModel := new(catalogmanagementv1.MediaItem)
				mediaItemModel.URL = core.StringPtr("testString")
				mediaItemModel.APIURL = core.StringPtr("testString")
				mediaItemModel.URLProxy = urlProxyModel
				mediaItemModel.Caption = core.StringPtr("testString")
				mediaItemModel.CaptionI18n = map[string]string{"key1": "testString"}
				mediaItemModel.Type = core.StringPtr("testString")
				mediaItemModel.ThumbnailURL = core.StringPtr("testString")

				// Construct an instance of the ArchitectureDiagram model
				architectureDiagramModel := new(catalogmanagementv1.ArchitectureDiagram)
				architectureDiagramModel.Diagram = mediaItemModel
				architectureDiagramModel.Description = core.StringPtr("testString")
				architectureDiagramModel.DescriptionI18n = map[string]string{"key1": "testString"}

				// Construct an instance of the CostComponent model
				costComponentModel := new(catalogmanagementv1.CostComponent)
				costComponentModel.Name = core.StringPtr("testString")
				costComponentModel.Unit = core.StringPtr("testString")
				costComponentModel.HourlyQuantity = core.StringPtr("testString")
				costComponentModel.MonthlyQuantity = core.StringPtr("testString")
				costComponentModel.Price = core.StringPtr("testString")
				costComponentModel.HourlyCost = core.StringPtr("testString")
				costComponentModel.MonthlyCost = core.StringPtr("testString")

				// Construct an instance of the CostResource model
				costResourceModel := new(catalogmanagementv1.CostResource)
				costResourceModel.Name = core.StringPtr("testString")
				costResourceModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				costResourceModel.HourlyCost = core.StringPtr("testString")
				costResourceModel.MonthlyCost = core.StringPtr("testString")
				costResourceModel.CostComponents = []catalogmanagementv1.CostComponent{*costComponentModel}

				// Construct an instance of the CostBreakdown model
				costBreakdownModel := new(catalogmanagementv1.CostBreakdown)
				costBreakdownModel.TotalHourlyCost = core.StringPtr("testString")
				costBreakdownModel.TotalMonthlyCost = core.StringPtr("testString")
				costBreakdownModel.Resources = []catalogmanagementv1.CostResource{*costResourceModel}

				// Construct an instance of the CostSummary model
				costSummaryModel := new(catalogmanagementv1.CostSummary)
				costSummaryModel.TotalDetectedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalSupportedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalUnsupportedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalUsageBasedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalNoPriceResources = core.Int64Ptr(int64(38))
				costSummaryModel.UnsupportedResourceCounts = map[string]int64{"key1": int64(38)}
				costSummaryModel.NoPriceResourceCounts = map[string]int64{"key1": int64(38)}

				// Construct an instance of the Project model
				projectModel := new(catalogmanagementv1.Project)
				projectModel.Name = core.StringPtr("testString")
				projectModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				projectModel.PastBreakdown = costBreakdownModel
				projectModel.Breakdown = costBreakdownModel
				projectModel.Diff = costBreakdownModel
				projectModel.Summary = costSummaryModel

				// Construct an instance of the CostEstimate model
				costEstimateModel := new(catalogmanagementv1.CostEstimate)
				costEstimateModel.Version = core.StringPtr("testString")
				costEstimateModel.Currency = core.StringPtr("testString")
				costEstimateModel.Projects = []catalogmanagementv1.Project{*projectModel}
				costEstimateModel.Summary = costSummaryModel
				costEstimateModel.TotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.TotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.PastTotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.PastTotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.DiffTotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.DiffTotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.TimeGenerated = CreateMockDateTime("2019-01-01T12:00:00.000Z")

				// Construct an instance of the OfferingReference model
				offeringReferenceModel := new(catalogmanagementv1.OfferingReference)
				offeringReferenceModel.CatalogID = core.StringPtr("testString")
				offeringReferenceModel.ID = core.StringPtr("testString")
				offeringReferenceModel.Name = core.StringPtr("testString")
				offeringReferenceModel.Kind = core.StringPtr("testString")
				offeringReferenceModel.Version = core.StringPtr("testString")
				offeringReferenceModel.Description = core.StringPtr("testString")
				offeringReferenceModel.DefaultFlavor = core.StringPtr("testString")
				offeringReferenceModel.Flavors = []string{"testString"}
				offeringReferenceModel.Optional = core.BoolPtr(true)
				offeringReferenceModel.OnByDefault = core.BoolPtr(true)

				// Construct an instance of the SolutionInfo model
				solutionInfoModel := new(catalogmanagementv1.SolutionInfo)
				solutionInfoModel.ArchitectureDiagrams = []catalogmanagementv1.ArchitectureDiagram{*architectureDiagramModel}
				solutionInfoModel.Features = []catalogmanagementv1.Feature{*featureModel}
				solutionInfoModel.CostEstimate = costEstimateModel
				solutionInfoModel.Dependencies = []catalogmanagementv1.OfferingReference{*offeringReferenceModel}
				solutionInfoModel.InstallType = core.StringPtr("testString")

				// Construct an instance of the SccProfile model
				sccProfileModel := new(catalogmanagementv1.SccProfile)
				sccProfileModel.ID = core.StringPtr("testString")
				sccProfileModel.Name = core.StringPtr("testString")
				sccProfileModel.Version = core.StringPtr("testString")
				sccProfileModel.Description = core.StringPtr("testString")
				sccProfileModel.Type = core.StringPtr("testString")
				sccProfileModel.UIHref = core.StringPtr("testString")

				// Construct an instance of the ClaimedControl model
				claimedControlModel := new(catalogmanagementv1.ClaimedControl)
				claimedControlModel.Profile = sccProfileModel
				claimedControlModel.Names = []string{"testString"}

				// Construct an instance of the Claims model
				claimsModel := new(catalogmanagementv1.Claims)
				claimsModel.Profiles = []catalogmanagementv1.SccProfile{*sccProfileModel}
				claimsModel.Controls = []catalogmanagementv1.ClaimedControl{*claimedControlModel}

				// Construct an instance of the Result model
				resultModel := new(catalogmanagementv1.Result)
				resultModel.FailureCount = core.Int64Ptr(int64(38))
				resultModel.ScanTime = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				resultModel.ErrorMessage = core.StringPtr("testString")
				resultModel.CompleteScan = core.BoolPtr(true)
				resultModel.UnscannedResources = []string{"testString"}

				// Construct an instance of the SccAssessment model
				sccAssessmentModel := new(catalogmanagementv1.SccAssessment)
				sccAssessmentModel.ID = core.StringPtr("testString")
				sccAssessmentModel.Description = core.StringPtr("testString")
				sccAssessmentModel.Version = core.StringPtr("testString")
				sccAssessmentModel.Type = core.StringPtr("testString")
				sccAssessmentModel.Method = core.StringPtr("testString")
				sccAssessmentModel.UIHref = core.StringPtr("testString")

				// Construct an instance of the SccSpecification model
				sccSpecificationModel := new(catalogmanagementv1.SccSpecification)
				sccSpecificationModel.ID = core.StringPtr("testString")
				sccSpecificationModel.Description = core.StringPtr("testString")
				sccSpecificationModel.ComponentName = core.StringPtr("testString")
				sccSpecificationModel.Assessments = []catalogmanagementv1.SccAssessment{*sccAssessmentModel}
				sccSpecificationModel.UIHref = core.StringPtr("testString")

				// Construct an instance of the SccControl model
				sccControlModel := new(catalogmanagementv1.SccControl)
				sccControlModel.ID = core.StringPtr("testString")
				sccControlModel.Name = core.StringPtr("testString")
				sccControlModel.Version = core.StringPtr("testString")
				sccControlModel.Description = core.StringPtr("testString")
				sccControlModel.Profile = sccProfileModel
				sccControlModel.ParentName = core.StringPtr("testString")
				sccControlModel.Specifications = []catalogmanagementv1.SccSpecification{*sccSpecificationModel}
				sccControlModel.UIHref = core.StringPtr("testString")

				// Construct an instance of the EvaluatedControl model
				evaluatedControlModel := new(catalogmanagementv1.EvaluatedControl)
				evaluatedControlModel.ID = core.StringPtr("testString")
				evaluatedControlModel.Name = core.StringPtr("testString")
				evaluatedControlModel.Description = core.StringPtr("testString")
				evaluatedControlModel.Specifications = []catalogmanagementv1.SccSpecification{*sccSpecificationModel}
				evaluatedControlModel.FailureCount = core.Int64Ptr(int64(38))
				evaluatedControlModel.PassCount = core.Int64Ptr(int64(38))
				evaluatedControlModel.Parent = sccControlModel
				evaluatedControlModel.UIHref = core.StringPtr("testString")

				// Construct an instance of the Evaluation model
				evaluationModel := new(catalogmanagementv1.Evaluation)
				evaluationModel.ScanID = core.StringPtr("testString")
				evaluationModel.AccountID = core.StringPtr("testString")
				evaluationModel.Profile = sccProfileModel
				evaluationModel.Result = resultModel
				evaluationModel.Controls = []catalogmanagementv1.EvaluatedControl{*evaluatedControlModel}

				// Construct an instance of the Compliance model
				complianceModel := new(catalogmanagementv1.Compliance)
				complianceModel.Authority = core.StringPtr("testString")
				complianceModel.Claims = claimsModel
				complianceModel.Evaluations = []catalogmanagementv1.Evaluation{*evaluationModel}

				// Construct an instance of the ChangeNotices model
				changeNoticesModel := new(catalogmanagementv1.ChangeNotices)
				changeNoticesModel.Breaking = []catalogmanagementv1.Feature{*featureModel}
				changeNoticesModel.New = []catalogmanagementv1.Feature{*featureModel}
				changeNoticesModel.Update = []catalogmanagementv1.Feature{*featureModel}

				// Construct an instance of the Version model
				versionModel := new(catalogmanagementv1.Version)
				versionModel.CRN = core.StringPtr("testString")
				versionModel.Version = core.StringPtr("testString")
				versionModel.Flavor = flavorModel
				versionModel.Sha = core.StringPtr("testString")
				versionModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				versionModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				versionModel.OfferingID = core.StringPtr("testString")
				versionModel.CatalogID = core.StringPtr("testString")
				versionModel.KindID = core.StringPtr("testString")
				versionModel.Tags = []string{"testString"}
				versionModel.RepoURL = core.StringPtr("testString")
				versionModel.SourceURL = core.StringPtr("testString")
				versionModel.TgzURL = core.StringPtr("testString")
				versionModel.Configuration = []catalogmanagementv1.Configuration{*configurationModel}
				versionModel.Outputs = []catalogmanagementv1.Output{*outputModel}
				versionModel.IamPermissions = []catalogmanagementv1.IamPermission{*iamPermissionModel}
				versionModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				versionModel.Validation = validationModel
				versionModel.RequiredResources = []catalogmanagementv1.Resource{*resourceModel}
				versionModel.SingleInstance = core.BoolPtr(true)
				versionModel.SchematicsEnvValues = schematicsEnvValuesModel
				versionModel.Install = scriptModel
				versionModel.PreInstall = []catalogmanagementv1.Script{*scriptModel}
				versionModel.Scripts = map[string]catalogmanagementv1.ScriptRef{"key1": *scriptRefModel}
				versionModel.Entitlement = versionEntitlementModel
				versionModel.Licenses = []catalogmanagementv1.License{*licenseModel}
				versionModel.ImageManifestURL = core.StringPtr("testString")
				versionModel.Deprecated = core.BoolPtr(true)
				versionModel.PackageVersion = core.StringPtr("testString")
				versionModel.State = stateModel
				versionModel.VersionLocator = core.StringPtr("testString")
				versionModel.LongDescription = core.StringPtr("testString")
				versionModel.LongDescriptionI18n = map[string]string{"key1": "testString"}
				versionModel.WhitelistedAccounts = []string{"testString"}
				versionModel.ImagePullKeyName = core.StringPtr("testString")
				versionModel.DeprecatePending = deprecatePendingModel
				versionModel.SolutionInfo = solutionInfoModel
				versionModel.IsConsumable = core.BoolPtr(true)
				versionModel.ComplianceV3 = complianceModel
				versionModel.ChangeNotices = changeNoticesModel
				versionModel.PlanIds = []string{"testString"}
				versionModel.Stack = map[string]interface{}{"anyKey": "anyValue"}
				versionModel.MinimumCompatibleVersion = core.StringPtr("testString")
				versionModel.Scripts["foo"] = *scriptRefModel

				// Construct an instance of the PaginationTokenLink model
				paginationTokenLinkModel := new(catalogmanagementv1.PaginationTokenLink)
				paginationTokenLinkModel.Href = core.StringPtr("testString")
				paginationTokenLinkModel.Start = core.StringPtr("testString")

				// Construct an instance of the KindAllVersions model
				kindAllVersionsModel := new(catalogmanagementv1.KindAllVersions)
				kindAllVersionsModel.First = paginationTokenLinkModel
				kindAllVersionsModel.Next = paginationTokenLinkModel

				// Construct an instance of the Kind model
				kindModel := new(catalogmanagementv1.Kind)
				kindModel.ID = core.StringPtr("testString")
				kindModel.FormatKind = core.StringPtr("testString")
				kindModel.FormatKindLabel = core.StringPtr("testString")
				kindModel.InstallKind = core.StringPtr("testString")
				kindModel.InstallKindLabel = core.StringPtr("testString")
				kindModel.TargetKind = core.StringPtr("testString")
				kindModel.TargetKindLabel = core.StringPtr("testString")
				kindModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				kindModel.Tags = []string{"testString"}
				kindModel.AdditionalFeatures = []catalogmanagementv1.Feature{*featureModel}
				kindModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				kindModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				kindModel.Versions = []catalogmanagementv1.Version{*versionModel}
				kindModel.AllVersions = kindAllVersionsModel

				// Construct an instance of the PublishObject model
				publishObjectModel := new(catalogmanagementv1.PublishObject)
				publishObjectModel.PcManaged = core.BoolPtr(true)
				publishObjectModel.ApprovalType = core.StringPtr("testString")
				publishObjectModel.PublishApproved = core.BoolPtr(true)
				publishObjectModel.ShareWithAll = core.BoolPtr(true)
				publishObjectModel.ShareWithIBM = core.BoolPtr(true)
				publishObjectModel.ShareEnabled = core.BoolPtr(true)
				publishObjectModel.OriginalCRN = core.StringPtr("testString")
				publishObjectModel.PublicCRN = core.StringPtr("testString")
				publishObjectModel.ApprovalRecord = map[string]interface{}{"anyKey": "anyValue"}
				publishObjectModel.PermitIBMPublicPublish = core.BoolPtr(true)
				publishObjectModel.IBMApproved = core.BoolPtr(true)
				publishObjectModel.PublicApproved = core.BoolPtr(true)

				// Construct an instance of the ProviderInfo model
				providerInfoModel := new(catalogmanagementv1.ProviderInfo)
				providerInfoModel.ID = core.StringPtr("testString")
				providerInfoModel.Name = core.StringPtr("testString")

				// Construct an instance of the RepoInfo model
				repoInfoModel := new(catalogmanagementv1.RepoInfo)
				repoInfoModel.Token = core.StringPtr("testString")
				repoInfoModel.Type = core.StringPtr("testString")

				// Construct an instance of the ImagePullKey model
				imagePullKeyModel := new(catalogmanagementv1.ImagePullKey)
				imagePullKeyModel.Name = core.StringPtr("testString")
				imagePullKeyModel.Value = core.StringPtr("testString")
				imagePullKeyModel.Description = core.StringPtr("testString")

				// Construct an instance of the SupportWaitTime model
				supportWaitTimeModel := new(catalogmanagementv1.SupportWaitTime)
				supportWaitTimeModel.Value = core.Int64Ptr(int64(38))
				supportWaitTimeModel.Type = core.StringPtr("testString")

				// Construct an instance of the SupportTime model
				supportTimeModel := new(catalogmanagementv1.SupportTime)
				supportTimeModel.Day = core.Int64Ptr(int64(38))
				supportTimeModel.StartTime = core.StringPtr("testString")
				supportTimeModel.EndTime = core.StringPtr("testString")

				// Construct an instance of the SupportAvailability model
				supportAvailabilityModel := new(catalogmanagementv1.SupportAvailability)
				supportAvailabilityModel.Times = []catalogmanagementv1.SupportTime{*supportTimeModel}
				supportAvailabilityModel.Timezone = core.StringPtr("testString")
				supportAvailabilityModel.AlwaysAvailable = core.BoolPtr(true)

				// Construct an instance of the SupportDetail model
				supportDetailModel := new(catalogmanagementv1.SupportDetail)
				supportDetailModel.Type = core.StringPtr("testString")
				supportDetailModel.Contact = core.StringPtr("testString")
				supportDetailModel.ResponseWaitTime = supportWaitTimeModel
				supportDetailModel.Availability = supportAvailabilityModel

				// Construct an instance of the SupportEscalation model
				supportEscalationModel := new(catalogmanagementv1.SupportEscalation)
				supportEscalationModel.EscalationWaitTime = supportWaitTimeModel
				supportEscalationModel.ResponseWaitTime = supportWaitTimeModel
				supportEscalationModel.Contact = core.StringPtr("testString")

				// Construct an instance of the Support model
				supportModel := new(catalogmanagementv1.Support)
				supportModel.URL = core.StringPtr("testString")
				supportModel.Process = core.StringPtr("testString")
				supportModel.ProcessI18n = map[string]string{"key1": "testString"}
				supportModel.Locations = []string{"testString"}
				supportModel.SupportDetails = []catalogmanagementv1.SupportDetail{*supportDetailModel}
				supportModel.SupportEscalation = supportEscalationModel
				supportModel.SupportType = core.StringPtr("testString")

				// Construct an instance of the LearnMoreLinks model
				learnMoreLinksModel := new(catalogmanagementv1.LearnMoreLinks)
				learnMoreLinksModel.FirstParty = core.StringPtr("testString")
				learnMoreLinksModel.ThirdParty = core.StringPtr("testString")

				// Construct an instance of the Constraint model
				constraintModel := new(catalogmanagementv1.Constraint)
				constraintModel.Type = core.StringPtr("testString")
				constraintModel.Rule = "testString"

				// Construct an instance of the Badge model
				badgeModel := new(catalogmanagementv1.Badge)
				badgeModel.ID = core.StringPtr("testString")
				badgeModel.Label = core.StringPtr("testString")
				badgeModel.LabelI18n = map[string]string{"key1": "testString"}
				badgeModel.Description = core.StringPtr("testString")
				badgeModel.DescriptionI18n = map[string]string{"key1": "testString"}
				badgeModel.Icon = core.StringPtr("testString")
				badgeModel.Authority = core.StringPtr("testString")
				badgeModel.Tag = core.StringPtr("testString")
				badgeModel.LearnMoreLinks = learnMoreLinksModel
				badgeModel.Constraints = []catalogmanagementv1.Constraint{*constraintModel}

				// Construct an instance of the VersionRange model
				versionRangeModel := new(catalogmanagementv1.VersionRange)
				versionRangeModel.Kinds = []string{"testString"}
				versionRangeModel.Version = core.StringPtr("testString")
				versionRangeModel.Flavors = []string{"testString"}

				// Construct an instance of the Plan model
				planModel := new(catalogmanagementv1.Plan)
				planModel.URL = core.StringPtr("testString")
				planModel.CRN = core.StringPtr("testString")
				planModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				planModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				planModel.OfferingID = core.StringPtr("testString")
				planModel.CatalogID = core.StringPtr("testString")
				planModel.Label = core.StringPtr("testString")
				planModel.LabelI18n = map[string]string{"key1": "testString"}
				planModel.Name = core.StringPtr("testString")
				planModel.ShortDescription = core.StringPtr("testString")
				planModel.ShortDescriptionI18n = map[string]string{"key1": "testString"}
				planModel.PricingTags = []string{"testString"}
				planModel.VersionRange = versionRangeModel
				planModel.Features = []catalogmanagementv1.Feature{*featureModel}
				planModel.State = stateModel
				planModel.DeprecatePending = deprecatePendingModel
				planModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				planModel.PublishApproved = core.BoolPtr(true)

				// Construct an instance of the CreateOfferingOptions model
				createOfferingOptionsModel := new(catalogmanagementv1.CreateOfferingOptions)
				createOfferingOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				createOfferingOptionsModel.URL = core.StringPtr("testString")
				createOfferingOptionsModel.CRN = core.StringPtr("testString")
				createOfferingOptionsModel.Label = core.StringPtr("testString")
				createOfferingOptionsModel.LabelI18n = map[string]string{"key1": "testString"}
				createOfferingOptionsModel.Name = core.StringPtr("testString")
				createOfferingOptionsModel.OfferingIconURL = core.StringPtr("testString")
				createOfferingOptionsModel.OfferingDocsURL = core.StringPtr("testString")
				createOfferingOptionsModel.OfferingSupportURL = core.StringPtr("testString")
				createOfferingOptionsModel.Tags = []string{"testString"}
				createOfferingOptionsModel.Keywords = []string{"testString"}
				createOfferingOptionsModel.Rating = ratingModel
				createOfferingOptionsModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				createOfferingOptionsModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				createOfferingOptionsModel.ShortDescription = core.StringPtr("testString")
				createOfferingOptionsModel.ShortDescriptionI18n = map[string]string{"key1": "testString"}
				createOfferingOptionsModel.LongDescription = core.StringPtr("testString")
				createOfferingOptionsModel.LongDescriptionI18n = map[string]string{"key1": "testString"}
				createOfferingOptionsModel.Features = []catalogmanagementv1.Feature{*featureModel}
				createOfferingOptionsModel.Kinds = []catalogmanagementv1.Kind{*kindModel}
				createOfferingOptionsModel.Publish = publishObjectModel
				createOfferingOptionsModel.PcManaged = core.BoolPtr(true)
				createOfferingOptionsModel.PublishApproved = core.BoolPtr(true)
				createOfferingOptionsModel.ShareWithAll = core.BoolPtr(true)
				createOfferingOptionsModel.ShareWithIBM = core.BoolPtr(true)
				createOfferingOptionsModel.ShareEnabled = core.BoolPtr(true)
				createOfferingOptionsModel.PublicOriginalCRN = core.StringPtr("testString")
				createOfferingOptionsModel.PublishPublicCRN = core.StringPtr("testString")
				createOfferingOptionsModel.PortalApprovalRecord = core.StringPtr("testString")
				createOfferingOptionsModel.PortalUIURL = core.StringPtr("testString")
				createOfferingOptionsModel.CatalogID = core.StringPtr("testString")
				createOfferingOptionsModel.CatalogName = core.StringPtr("testString")
				createOfferingOptionsModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				createOfferingOptionsModel.Disclaimer = core.StringPtr("testString")
				createOfferingOptionsModel.Hidden = core.BoolPtr(true)
				createOfferingOptionsModel.Provider = core.StringPtr("testString")
				createOfferingOptionsModel.ProviderInfo = providerInfoModel
				createOfferingOptionsModel.RepoInfo = repoInfoModel
				createOfferingOptionsModel.ImagePullKeys = []catalogmanagementv1.ImagePullKey{*imagePullKeyModel}
				createOfferingOptionsModel.Support = supportModel
				createOfferingOptionsModel.Media = []catalogmanagementv1.MediaItem{*mediaItemModel}
				createOfferingOptionsModel.DeprecatePending = deprecatePendingModel
				createOfferingOptionsModel.ProductKind = core.StringPtr("testString")
				createOfferingOptionsModel.Badges = []catalogmanagementv1.Badge{*badgeModel}
				createOfferingOptionsModel.Plans = []catalogmanagementv1.Plan{*planModel}
				createOfferingOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.CreateOffering(createOfferingOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the CreateOfferingOptions model with no property values
				createOfferingOptionsModelNew := new(catalogmanagementv1.CreateOfferingOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.CreateOffering(createOfferingOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(201)
				}))
			})
			It(`Invoke CreateOffering successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the Rating model
				ratingModel := new(catalogmanagementv1.Rating)
				ratingModel.OneStarCount = core.Int64Ptr(int64(38))
				ratingModel.TwoStarCount = core.Int64Ptr(int64(38))
				ratingModel.ThreeStarCount = core.Int64Ptr(int64(38))
				ratingModel.FourStarCount = core.Int64Ptr(int64(38))

				// Construct an instance of the Feature model
				featureModel := new(catalogmanagementv1.Feature)
				featureModel.Title = core.StringPtr("testString")
				featureModel.TitleI18n = map[string]string{"key1": "testString"}
				featureModel.Description = core.StringPtr("testString")
				featureModel.DescriptionI18n = map[string]string{"key1": "testString"}

				// Construct an instance of the Flavor model
				flavorModel := new(catalogmanagementv1.Flavor)
				flavorModel.Name = core.StringPtr("testString")
				flavorModel.Label = core.StringPtr("testString")
				flavorModel.LabelI18n = map[string]string{"key1": "testString"}
				flavorModel.Index = core.Int64Ptr(int64(38))

				// Construct an instance of the RenderTypeAssociationsParametersItem model
				renderTypeAssociationsParametersItemModel := new(catalogmanagementv1.RenderTypeAssociationsParametersItem)
				renderTypeAssociationsParametersItemModel.Name = core.StringPtr("testString")
				renderTypeAssociationsParametersItemModel.OptionsRefresh = core.BoolPtr(true)

				// Construct an instance of the RenderTypeAssociations model
				renderTypeAssociationsModel := new(catalogmanagementv1.RenderTypeAssociations)
				renderTypeAssociationsModel.Parameters = []catalogmanagementv1.RenderTypeAssociationsParametersItem{*renderTypeAssociationsParametersItemModel}

				// Construct an instance of the RenderType model
				renderTypeModel := new(catalogmanagementv1.RenderType)
				renderTypeModel.Type = core.StringPtr("testString")
				renderTypeModel.Grouping = core.StringPtr("testString")
				renderTypeModel.OriginalGrouping = core.StringPtr("testString")
				renderTypeModel.GroupingIndex = core.Int64Ptr(int64(38))
				renderTypeModel.ConfigConstraints = map[string]interface{}{"anyKey": "anyValue"}
				renderTypeModel.Associations = renderTypeAssociationsModel

				// Construct an instance of the Configuration model
				configurationModel := new(catalogmanagementv1.Configuration)
				configurationModel.Key = core.StringPtr("testString")
				configurationModel.Type = core.StringPtr("testString")
				configurationModel.DefaultValue = "testString"
				configurationModel.DisplayName = core.StringPtr("testString")
				configurationModel.ValueConstraint = core.StringPtr("testString")
				configurationModel.Description = core.StringPtr("testString")
				configurationModel.Required = core.BoolPtr(true)
				configurationModel.Options = []interface{}{"testString"}
				configurationModel.Hidden = core.BoolPtr(true)
				configurationModel.CustomConfig = renderTypeModel
				configurationModel.TypeMetadata = core.StringPtr("testString")

				// Construct an instance of the Output model
				outputModel := new(catalogmanagementv1.Output)
				outputModel.Key = core.StringPtr("testString")
				outputModel.Description = core.StringPtr("testString")

				// Construct an instance of the IamResource model
				iamResourceModel := new(catalogmanagementv1.IamResource)
				iamResourceModel.Name = core.StringPtr("testString")
				iamResourceModel.Description = core.StringPtr("testString")
				iamResourceModel.RoleCrns = []string{"testString"}

				// Construct an instance of the IamPermission model
				iamPermissionModel := new(catalogmanagementv1.IamPermission)
				iamPermissionModel.ServiceName = core.StringPtr("testString")
				iamPermissionModel.RoleCrns = []string{"testString"}
				iamPermissionModel.Resources = []catalogmanagementv1.IamResource{*iamResourceModel}

				// Construct an instance of the Validation model
				validationModel := new(catalogmanagementv1.Validation)
				validationModel.Validated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				validationModel.Requested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				validationModel.State = core.StringPtr("testString")
				validationModel.LastOperation = core.StringPtr("testString")
				validationModel.Target = map[string]interface{}{"anyKey": "anyValue"}
				validationModel.Message = core.StringPtr("testString")

				// Construct an instance of the Resource model
				resourceModel := new(catalogmanagementv1.Resource)
				resourceModel.Type = core.StringPtr("mem")
				resourceModel.Value = "testString"

				// Construct an instance of the SchematicsEnvValues model
				schematicsEnvValuesModel := new(catalogmanagementv1.SchematicsEnvValues)
				schematicsEnvValuesModel.Value = core.StringPtr("[{\"name\": \"TF_LOG\",\"value\": \"TRACE\",\"secure\": false,\"hidden\": false}]")
				schematicsEnvValuesModel.SmRef = core.StringPtr("cmsm_v1:{\"name\": \"envVarSecret\",\"id\":\"1234567890\",\"service_id\":\"crn:v1:bluemix:public:secrets-manager:eu-gb:a/1234567890:1234567890::\",\"service_name\":\"My SM Instance\",\"group_id\":\"1234567890\",\"group_name\":\"My SM Group\",\"resource_group_id\":\"1234567890\",\"region\":\"eu-gb\",\"type\":\"arbitrary\"}")

				// Construct an instance of the Script model
				scriptModel := new(catalogmanagementv1.Script)
				scriptModel.Instructions = core.StringPtr("testString")
				scriptModel.InstructionsI18n = map[string]string{"key1": "testString"}
				scriptModel.Script = core.StringPtr("testString")
				scriptModel.ScriptPermission = core.StringPtr("testString")
				scriptModel.DeleteScript = core.StringPtr("testString")
				scriptModel.Scope = core.StringPtr("testString")

				// Construct an instance of the ScriptRef model
				scriptRefModel := new(catalogmanagementv1.ScriptRef)
				scriptRefModel.ShortDescription = core.StringPtr("testString")
				scriptRefModel.Type = core.StringPtr("ansible")
				scriptRefModel.Path = core.StringPtr("scripts/validate-post-ansible-playbook.yaml")
				scriptRefModel.Stage = core.StringPtr("pre")
				scriptRefModel.Action = core.StringPtr("validate")

				// Construct an instance of the VersionEntitlement model
				versionEntitlementModel := new(catalogmanagementv1.VersionEntitlement)
				versionEntitlementModel.ProviderName = core.StringPtr("testString")
				versionEntitlementModel.ProviderID = core.StringPtr("testString")
				versionEntitlementModel.ProductID = core.StringPtr("testString")
				versionEntitlementModel.PartNumbers = []string{"testString"}
				versionEntitlementModel.ImageRepoName = core.StringPtr("testString")

				// Construct an instance of the License model
				licenseModel := new(catalogmanagementv1.License)
				licenseModel.ID = core.StringPtr("testString")
				licenseModel.Name = core.StringPtr("testString")
				licenseModel.Type = core.StringPtr("testString")
				licenseModel.URL = core.StringPtr("testString")
				licenseModel.Description = core.StringPtr("testString")

				// Construct an instance of the State model
				stateModel := new(catalogmanagementv1.State)
				stateModel.Current = core.StringPtr("testString")
				stateModel.CurrentEntered = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Pending = core.StringPtr("testString")
				stateModel.PendingRequested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Previous = core.StringPtr("testString")

				// Construct an instance of the DeprecatePending model
				deprecatePendingModel := new(catalogmanagementv1.DeprecatePending)
				deprecatePendingModel.DeprecateDate = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				deprecatePendingModel.DeprecateState = core.StringPtr("testString")
				deprecatePendingModel.Description = core.StringPtr("testString")

				// Construct an instance of the URLProxy model
				urlProxyModel := new(catalogmanagementv1.URLProxy)
				urlProxyModel.URL = core.StringPtr("testString")
				urlProxyModel.Sha = core.StringPtr("testString")

				// Construct an instance of the MediaItem model
				mediaItemModel := new(catalogmanagementv1.MediaItem)
				mediaItemModel.URL = core.StringPtr("testString")
				mediaItemModel.APIURL = core.StringPtr("testString")
				mediaItemModel.URLProxy = urlProxyModel
				mediaItemModel.Caption = core.StringPtr("testString")
				mediaItemModel.CaptionI18n = map[string]string{"key1": "testString"}
				mediaItemModel.Type = core.StringPtr("testString")
				mediaItemModel.ThumbnailURL = core.StringPtr("testString")

				// Construct an instance of the ArchitectureDiagram model
				architectureDiagramModel := new(catalogmanagementv1.ArchitectureDiagram)
				architectureDiagramModel.Diagram = mediaItemModel
				architectureDiagramModel.Description = core.StringPtr("testString")
				architectureDiagramModel.DescriptionI18n = map[string]string{"key1": "testString"}

				// Construct an instance of the CostComponent model
				costComponentModel := new(catalogmanagementv1.CostComponent)
				costComponentModel.Name = core.StringPtr("testString")
				costComponentModel.Unit = core.StringPtr("testString")
				costComponentModel.HourlyQuantity = core.StringPtr("testString")
				costComponentModel.MonthlyQuantity = core.StringPtr("testString")
				costComponentModel.Price = core.StringPtr("testString")
				costComponentModel.HourlyCost = core.StringPtr("testString")
				costComponentModel.MonthlyCost = core.StringPtr("testString")

				// Construct an instance of the CostResource model
				costResourceModel := new(catalogmanagementv1.CostResource)
				costResourceModel.Name = core.StringPtr("testString")
				costResourceModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				costResourceModel.HourlyCost = core.StringPtr("testString")
				costResourceModel.MonthlyCost = core.StringPtr("testString")
				costResourceModel.CostComponents = []catalogmanagementv1.CostComponent{*costComponentModel}

				// Construct an instance of the CostBreakdown model
				costBreakdownModel := new(catalogmanagementv1.CostBreakdown)
				costBreakdownModel.TotalHourlyCost = core.StringPtr("testString")
				costBreakdownModel.TotalMonthlyCost = core.StringPtr("testString")
				costBreakdownModel.Resources = []catalogmanagementv1.CostResource{*costResourceModel}

				// Construct an instance of the CostSummary model
				costSummaryModel := new(catalogmanagementv1.CostSummary)
				costSummaryModel.TotalDetectedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalSupportedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalUnsupportedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalUsageBasedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalNoPriceResources = core.Int64Ptr(int64(38))
				costSummaryModel.UnsupportedResourceCounts = map[string]int64{"key1": int64(38)}
				costSummaryModel.NoPriceResourceCounts = map[string]int64{"key1": int64(38)}

				// Construct an instance of the Project model
				projectModel := new(catalogmanagementv1.Project)
				projectModel.Name = core.StringPtr("testString")
				projectModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				projectModel.PastBreakdown = costBreakdownModel
				projectModel.Breakdown = costBreakdownModel
				projectModel.Diff = costBreakdownModel
				projectModel.Summary = costSummaryModel

				// Construct an instance of the CostEstimate model
				costEstimateModel := new(catalogmanagementv1.CostEstimate)
				costEstimateModel.Version = core.StringPtr("testString")
				costEstimateModel.Currency = core.StringPtr("testString")
				costEstimateModel.Projects = []catalogmanagementv1.Project{*projectModel}
				costEstimateModel.Summary = costSummaryModel
				costEstimateModel.TotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.TotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.PastTotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.PastTotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.DiffTotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.DiffTotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.TimeGenerated = CreateMockDateTime("2019-01-01T12:00:00.000Z")

				// Construct an instance of the OfferingReference model
				offeringReferenceModel := new(catalogmanagementv1.OfferingReference)
				offeringReferenceModel.CatalogID = core.StringPtr("testString")
				offeringReferenceModel.ID = core.StringPtr("testString")
				offeringReferenceModel.Name = core.StringPtr("testString")
				offeringReferenceModel.Kind = core.StringPtr("testString")
				offeringReferenceModel.Version = core.StringPtr("testString")
				offeringReferenceModel.Description = core.StringPtr("testString")
				offeringReferenceModel.DefaultFlavor = core.StringPtr("testString")
				offeringReferenceModel.Flavors = []string{"testString"}
				offeringReferenceModel.Optional = core.BoolPtr(true)
				offeringReferenceModel.OnByDefault = core.BoolPtr(true)

				// Construct an instance of the SolutionInfo model
				solutionInfoModel := new(catalogmanagementv1.SolutionInfo)
				solutionInfoModel.ArchitectureDiagrams = []catalogmanagementv1.ArchitectureDiagram{*architectureDiagramModel}
				solutionInfoModel.Features = []catalogmanagementv1.Feature{*featureModel}
				solutionInfoModel.CostEstimate = costEstimateModel
				solutionInfoModel.Dependencies = []catalogmanagementv1.OfferingReference{*offeringReferenceModel}
				solutionInfoModel.InstallType = core.StringPtr("testString")

				// Construct an instance of the SccProfile model
				sccProfileModel := new(catalogmanagementv1.SccProfile)
				sccProfileModel.ID = core.StringPtr("testString")
				sccProfileModel.Name = core.StringPtr("testString")
				sccProfileModel.Version = core.StringPtr("testString")
				sccProfileModel.Description = core.StringPtr("testString")
				sccProfileModel.Type = core.StringPtr("testString")
				sccProfileModel.UIHref = core.StringPtr("testString")

				// Construct an instance of the ClaimedControl model
				claimedControlModel := new(catalogmanagementv1.ClaimedControl)
				claimedControlModel.Profile = sccProfileModel
				claimedControlModel.Names = []string{"testString"}

				// Construct an instance of the Claims model
				claimsModel := new(catalogmanagementv1.Claims)
				claimsModel.Profiles = []catalogmanagementv1.SccProfile{*sccProfileModel}
				claimsModel.Controls = []catalogmanagementv1.ClaimedControl{*claimedControlModel}

				// Construct an instance of the Result model
				resultModel := new(catalogmanagementv1.Result)
				resultModel.FailureCount = core.Int64Ptr(int64(38))
				resultModel.ScanTime = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				resultModel.ErrorMessage = core.StringPtr("testString")
				resultModel.CompleteScan = core.BoolPtr(true)
				resultModel.UnscannedResources = []string{"testString"}

				// Construct an instance of the SccAssessment model
				sccAssessmentModel := new(catalogmanagementv1.SccAssessment)
				sccAssessmentModel.ID = core.StringPtr("testString")
				sccAssessmentModel.Description = core.StringPtr("testString")
				sccAssessmentModel.Version = core.StringPtr("testString")
				sccAssessmentModel.Type = core.StringPtr("testString")
				sccAssessmentModel.Method = core.StringPtr("testString")
				sccAssessmentModel.UIHref = core.StringPtr("testString")

				// Construct an instance of the SccSpecification model
				sccSpecificationModel := new(catalogmanagementv1.SccSpecification)
				sccSpecificationModel.ID = core.StringPtr("testString")
				sccSpecificationModel.Description = core.StringPtr("testString")
				sccSpecificationModel.ComponentName = core.StringPtr("testString")
				sccSpecificationModel.Assessments = []catalogmanagementv1.SccAssessment{*sccAssessmentModel}
				sccSpecificationModel.UIHref = core.StringPtr("testString")

				// Construct an instance of the SccControl model
				sccControlModel := new(catalogmanagementv1.SccControl)
				sccControlModel.ID = core.StringPtr("testString")
				sccControlModel.Name = core.StringPtr("testString")
				sccControlModel.Version = core.StringPtr("testString")
				sccControlModel.Description = core.StringPtr("testString")
				sccControlModel.Profile = sccProfileModel
				sccControlModel.ParentName = core.StringPtr("testString")
				sccControlModel.Specifications = []catalogmanagementv1.SccSpecification{*sccSpecificationModel}
				sccControlModel.UIHref = core.StringPtr("testString")

				// Construct an instance of the EvaluatedControl model
				evaluatedControlModel := new(catalogmanagementv1.EvaluatedControl)
				evaluatedControlModel.ID = core.StringPtr("testString")
				evaluatedControlModel.Name = core.StringPtr("testString")
				evaluatedControlModel.Description = core.StringPtr("testString")
				evaluatedControlModel.Specifications = []catalogmanagementv1.SccSpecification{*sccSpecificationModel}
				evaluatedControlModel.FailureCount = core.Int64Ptr(int64(38))
				evaluatedControlModel.PassCount = core.Int64Ptr(int64(38))
				evaluatedControlModel.Parent = sccControlModel
				evaluatedControlModel.UIHref = core.StringPtr("testString")

				// Construct an instance of the Evaluation model
				evaluationModel := new(catalogmanagementv1.Evaluation)
				evaluationModel.ScanID = core.StringPtr("testString")
				evaluationModel.AccountID = core.StringPtr("testString")
				evaluationModel.Profile = sccProfileModel
				evaluationModel.Result = resultModel
				evaluationModel.Controls = []catalogmanagementv1.EvaluatedControl{*evaluatedControlModel}

				// Construct an instance of the Compliance model
				complianceModel := new(catalogmanagementv1.Compliance)
				complianceModel.Authority = core.StringPtr("testString")
				complianceModel.Claims = claimsModel
				complianceModel.Evaluations = []catalogmanagementv1.Evaluation{*evaluationModel}

				// Construct an instance of the ChangeNotices model
				changeNoticesModel := new(catalogmanagementv1.ChangeNotices)
				changeNoticesModel.Breaking = []catalogmanagementv1.Feature{*featureModel}
				changeNoticesModel.New = []catalogmanagementv1.Feature{*featureModel}
				changeNoticesModel.Update = []catalogmanagementv1.Feature{*featureModel}

				// Construct an instance of the Version model
				versionModel := new(catalogmanagementv1.Version)
				versionModel.CRN = core.StringPtr("testString")
				versionModel.Version = core.StringPtr("testString")
				versionModel.Flavor = flavorModel
				versionModel.Sha = core.StringPtr("testString")
				versionModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				versionModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				versionModel.OfferingID = core.StringPtr("testString")
				versionModel.CatalogID = core.StringPtr("testString")
				versionModel.KindID = core.StringPtr("testString")
				versionModel.Tags = []string{"testString"}
				versionModel.RepoURL = core.StringPtr("testString")
				versionModel.SourceURL = core.StringPtr("testString")
				versionModel.TgzURL = core.StringPtr("testString")
				versionModel.Configuration = []catalogmanagementv1.Configuration{*configurationModel}
				versionModel.Outputs = []catalogmanagementv1.Output{*outputModel}
				versionModel.IamPermissions = []catalogmanagementv1.IamPermission{*iamPermissionModel}
				versionModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				versionModel.Validation = validationModel
				versionModel.RequiredResources = []catalogmanagementv1.Resource{*resourceModel}
				versionModel.SingleInstance = core.BoolPtr(true)
				versionModel.SchematicsEnvValues = schematicsEnvValuesModel
				versionModel.Install = scriptModel
				versionModel.PreInstall = []catalogmanagementv1.Script{*scriptModel}
				versionModel.Scripts = map[string]catalogmanagementv1.ScriptRef{"key1": *scriptRefModel}
				versionModel.Entitlement = versionEntitlementModel
				versionModel.Licenses = []catalogmanagementv1.License{*licenseModel}
				versionModel.ImageManifestURL = core.StringPtr("testString")
				versionModel.Deprecated = core.BoolPtr(true)
				versionModel.PackageVersion = core.StringPtr("testString")
				versionModel.State = stateModel
				versionModel.VersionLocator = core.StringPtr("testString")
				versionModel.LongDescription = core.StringPtr("testString")
				versionModel.LongDescriptionI18n = map[string]string{"key1": "testString"}
				versionModel.WhitelistedAccounts = []string{"testString"}
				versionModel.ImagePullKeyName = core.StringPtr("testString")
				versionModel.DeprecatePending = deprecatePendingModel
				versionModel.SolutionInfo = solutionInfoModel
				versionModel.IsConsumable = core.BoolPtr(true)
				versionModel.ComplianceV3 = complianceModel
				versionModel.ChangeNotices = changeNoticesModel
				versionModel.PlanIds = []string{"testString"}
				versionModel.Stack = map[string]interface{}{"anyKey": "anyValue"}
				versionModel.MinimumCompatibleVersion = core.StringPtr("testString")
				versionModel.Scripts["foo"] = *scriptRefModel

				// Construct an instance of the PaginationTokenLink model
				paginationTokenLinkModel := new(catalogmanagementv1.PaginationTokenLink)
				paginationTokenLinkModel.Href = core.StringPtr("testString")
				paginationTokenLinkModel.Start = core.StringPtr("testString")

				// Construct an instance of the KindAllVersions model
				kindAllVersionsModel := new(catalogmanagementv1.KindAllVersions)
				kindAllVersionsModel.First = paginationTokenLinkModel
				kindAllVersionsModel.Next = paginationTokenLinkModel

				// Construct an instance of the Kind model
				kindModel := new(catalogmanagementv1.Kind)
				kindModel.ID = core.StringPtr("testString")
				kindModel.FormatKind = core.StringPtr("testString")
				kindModel.FormatKindLabel = core.StringPtr("testString")
				kindModel.InstallKind = core.StringPtr("testString")
				kindModel.InstallKindLabel = core.StringPtr("testString")
				kindModel.TargetKind = core.StringPtr("testString")
				kindModel.TargetKindLabel = core.StringPtr("testString")
				kindModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				kindModel.Tags = []string{"testString"}
				kindModel.AdditionalFeatures = []catalogmanagementv1.Feature{*featureModel}
				kindModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				kindModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				kindModel.Versions = []catalogmanagementv1.Version{*versionModel}
				kindModel.AllVersions = kindAllVersionsModel

				// Construct an instance of the PublishObject model
				publishObjectModel := new(catalogmanagementv1.PublishObject)
				publishObjectModel.PcManaged = core.BoolPtr(true)
				publishObjectModel.ApprovalType = core.StringPtr("testString")
				publishObjectModel.PublishApproved = core.BoolPtr(true)
				publishObjectModel.ShareWithAll = core.BoolPtr(true)
				publishObjectModel.ShareWithIBM = core.BoolPtr(true)
				publishObjectModel.ShareEnabled = core.BoolPtr(true)
				publishObjectModel.OriginalCRN = core.StringPtr("testString")
				publishObjectModel.PublicCRN = core.StringPtr("testString")
				publishObjectModel.ApprovalRecord = map[string]interface{}{"anyKey": "anyValue"}
				publishObjectModel.PermitIBMPublicPublish = core.BoolPtr(true)
				publishObjectModel.IBMApproved = core.BoolPtr(true)
				publishObjectModel.PublicApproved = core.BoolPtr(true)

				// Construct an instance of the ProviderInfo model
				providerInfoModel := new(catalogmanagementv1.ProviderInfo)
				providerInfoModel.ID = core.StringPtr("testString")
				providerInfoModel.Name = core.StringPtr("testString")

				// Construct an instance of the RepoInfo model
				repoInfoModel := new(catalogmanagementv1.RepoInfo)
				repoInfoModel.Token = core.StringPtr("testString")
				repoInfoModel.Type = core.StringPtr("testString")

				// Construct an instance of the ImagePullKey model
				imagePullKeyModel := new(catalogmanagementv1.ImagePullKey)
				imagePullKeyModel.Name = core.StringPtr("testString")
				imagePullKeyModel.Value = core.StringPtr("testString")
				imagePullKeyModel.Description = core.StringPtr("testString")

				// Construct an instance of the SupportWaitTime model
				supportWaitTimeModel := new(catalogmanagementv1.SupportWaitTime)
				supportWaitTimeModel.Value = core.Int64Ptr(int64(38))
				supportWaitTimeModel.Type = core.StringPtr("testString")

				// Construct an instance of the SupportTime model
				supportTimeModel := new(catalogmanagementv1.SupportTime)
				supportTimeModel.Day = core.Int64Ptr(int64(38))
				supportTimeModel.StartTime = core.StringPtr("testString")
				supportTimeModel.EndTime = core.StringPtr("testString")

				// Construct an instance of the SupportAvailability model
				supportAvailabilityModel := new(catalogmanagementv1.SupportAvailability)
				supportAvailabilityModel.Times = []catalogmanagementv1.SupportTime{*supportTimeModel}
				supportAvailabilityModel.Timezone = core.StringPtr("testString")
				supportAvailabilityModel.AlwaysAvailable = core.BoolPtr(true)

				// Construct an instance of the SupportDetail model
				supportDetailModel := new(catalogmanagementv1.SupportDetail)
				supportDetailModel.Type = core.StringPtr("testString")
				supportDetailModel.Contact = core.StringPtr("testString")
				supportDetailModel.ResponseWaitTime = supportWaitTimeModel
				supportDetailModel.Availability = supportAvailabilityModel

				// Construct an instance of the SupportEscalation model
				supportEscalationModel := new(catalogmanagementv1.SupportEscalation)
				supportEscalationModel.EscalationWaitTime = supportWaitTimeModel
				supportEscalationModel.ResponseWaitTime = supportWaitTimeModel
				supportEscalationModel.Contact = core.StringPtr("testString")

				// Construct an instance of the Support model
				supportModel := new(catalogmanagementv1.Support)
				supportModel.URL = core.StringPtr("testString")
				supportModel.Process = core.StringPtr("testString")
				supportModel.ProcessI18n = map[string]string{"key1": "testString"}
				supportModel.Locations = []string{"testString"}
				supportModel.SupportDetails = []catalogmanagementv1.SupportDetail{*supportDetailModel}
				supportModel.SupportEscalation = supportEscalationModel
				supportModel.SupportType = core.StringPtr("testString")

				// Construct an instance of the LearnMoreLinks model
				learnMoreLinksModel := new(catalogmanagementv1.LearnMoreLinks)
				learnMoreLinksModel.FirstParty = core.StringPtr("testString")
				learnMoreLinksModel.ThirdParty = core.StringPtr("testString")

				// Construct an instance of the Constraint model
				constraintModel := new(catalogmanagementv1.Constraint)
				constraintModel.Type = core.StringPtr("testString")
				constraintModel.Rule = "testString"

				// Construct an instance of the Badge model
				badgeModel := new(catalogmanagementv1.Badge)
				badgeModel.ID = core.StringPtr("testString")
				badgeModel.Label = core.StringPtr("testString")
				badgeModel.LabelI18n = map[string]string{"key1": "testString"}
				badgeModel.Description = core.StringPtr("testString")
				badgeModel.DescriptionI18n = map[string]string{"key1": "testString"}
				badgeModel.Icon = core.StringPtr("testString")
				badgeModel.Authority = core.StringPtr("testString")
				badgeModel.Tag = core.StringPtr("testString")
				badgeModel.LearnMoreLinks = learnMoreLinksModel
				badgeModel.Constraints = []catalogmanagementv1.Constraint{*constraintModel}

				// Construct an instance of the VersionRange model
				versionRangeModel := new(catalogmanagementv1.VersionRange)
				versionRangeModel.Kinds = []string{"testString"}
				versionRangeModel.Version = core.StringPtr("testString")
				versionRangeModel.Flavors = []string{"testString"}

				// Construct an instance of the Plan model
				planModel := new(catalogmanagementv1.Plan)
				planModel.URL = core.StringPtr("testString")
				planModel.CRN = core.StringPtr("testString")
				planModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				planModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				planModel.OfferingID = core.StringPtr("testString")
				planModel.CatalogID = core.StringPtr("testString")
				planModel.Label = core.StringPtr("testString")
				planModel.LabelI18n = map[string]string{"key1": "testString"}
				planModel.Name = core.StringPtr("testString")
				planModel.ShortDescription = core.StringPtr("testString")
				planModel.ShortDescriptionI18n = map[string]string{"key1": "testString"}
				planModel.PricingTags = []string{"testString"}
				planModel.VersionRange = versionRangeModel
				planModel.Features = []catalogmanagementv1.Feature{*featureModel}
				planModel.State = stateModel
				planModel.DeprecatePending = deprecatePendingModel
				planModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				planModel.PublishApproved = core.BoolPtr(true)

				// Construct an instance of the CreateOfferingOptions model
				createOfferingOptionsModel := new(catalogmanagementv1.CreateOfferingOptions)
				createOfferingOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				createOfferingOptionsModel.URL = core.StringPtr("testString")
				createOfferingOptionsModel.CRN = core.StringPtr("testString")
				createOfferingOptionsModel.Label = core.StringPtr("testString")
				createOfferingOptionsModel.LabelI18n = map[string]string{"key1": "testString"}
				createOfferingOptionsModel.Name = core.StringPtr("testString")
				createOfferingOptionsModel.OfferingIconURL = core.StringPtr("testString")
				createOfferingOptionsModel.OfferingDocsURL = core.StringPtr("testString")
				createOfferingOptionsModel.OfferingSupportURL = core.StringPtr("testString")
				createOfferingOptionsModel.Tags = []string{"testString"}
				createOfferingOptionsModel.Keywords = []string{"testString"}
				createOfferingOptionsModel.Rating = ratingModel
				createOfferingOptionsModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				createOfferingOptionsModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				createOfferingOptionsModel.ShortDescription = core.StringPtr("testString")
				createOfferingOptionsModel.ShortDescriptionI18n = map[string]string{"key1": "testString"}
				createOfferingOptionsModel.LongDescription = core.StringPtr("testString")
				createOfferingOptionsModel.LongDescriptionI18n = map[string]string{"key1": "testString"}
				createOfferingOptionsModel.Features = []catalogmanagementv1.Feature{*featureModel}
				createOfferingOptionsModel.Kinds = []catalogmanagementv1.Kind{*kindModel}
				createOfferingOptionsModel.Publish = publishObjectModel
				createOfferingOptionsModel.PcManaged = core.BoolPtr(true)
				createOfferingOptionsModel.PublishApproved = core.BoolPtr(true)
				createOfferingOptionsModel.ShareWithAll = core.BoolPtr(true)
				createOfferingOptionsModel.ShareWithIBM = core.BoolPtr(true)
				createOfferingOptionsModel.ShareEnabled = core.BoolPtr(true)
				createOfferingOptionsModel.PublicOriginalCRN = core.StringPtr("testString")
				createOfferingOptionsModel.PublishPublicCRN = core.StringPtr("testString")
				createOfferingOptionsModel.PortalApprovalRecord = core.StringPtr("testString")
				createOfferingOptionsModel.PortalUIURL = core.StringPtr("testString")
				createOfferingOptionsModel.CatalogID = core.StringPtr("testString")
				createOfferingOptionsModel.CatalogName = core.StringPtr("testString")
				createOfferingOptionsModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				createOfferingOptionsModel.Disclaimer = core.StringPtr("testString")
				createOfferingOptionsModel.Hidden = core.BoolPtr(true)
				createOfferingOptionsModel.Provider = core.StringPtr("testString")
				createOfferingOptionsModel.ProviderInfo = providerInfoModel
				createOfferingOptionsModel.RepoInfo = repoInfoModel
				createOfferingOptionsModel.ImagePullKeys = []catalogmanagementv1.ImagePullKey{*imagePullKeyModel}
				createOfferingOptionsModel.Support = supportModel
				createOfferingOptionsModel.Media = []catalogmanagementv1.MediaItem{*mediaItemModel}
				createOfferingOptionsModel.DeprecatePending = deprecatePendingModel
				createOfferingOptionsModel.ProductKind = core.StringPtr("testString")
				createOfferingOptionsModel.Badges = []catalogmanagementv1.Badge{*badgeModel}
				createOfferingOptionsModel.Plans = []catalogmanagementv1.Plan{*planModel}
				createOfferingOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.CreateOffering(createOfferingOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ImportOfferingVersion(importOfferingVersionOptions *ImportOfferingVersionOptions) - Operation response error`, func() {
		importOfferingVersionPath := "/catalogs/testString/offerings/testString/version"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(importOfferingVersionPath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["X-Auth-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["zipurl"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["targetVersion"]).To(Equal([]string{"testString"}))
					// TODO: Add check for includeConfig query parameter
					// TODO: Add check for isVSI query parameter
					Expect(req.URL.Query()["repotype"]).To(Equal([]string{"testString"}))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ImportOfferingVersion with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the Flavor model
				flavorModel := new(catalogmanagementv1.Flavor)
				flavorModel.Name = core.StringPtr("testString")
				flavorModel.Label = core.StringPtr("testString")
				flavorModel.LabelI18n = map[string]string{"key1": "testString"}
				flavorModel.Index = core.Int64Ptr(int64(38))

				// Construct an instance of the ImportOfferingBodyMetadataOperatingSystem model
				importOfferingBodyMetadataOperatingSystemModel := new(catalogmanagementv1.ImportOfferingBodyMetadataOperatingSystem)
				importOfferingBodyMetadataOperatingSystemModel.DedicatedHostOnly = core.BoolPtr(true)
				importOfferingBodyMetadataOperatingSystemModel.Vendor = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Name = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Href = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.DisplayName = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Family = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Version = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Architecture = core.StringPtr("testString")

				// Construct an instance of the ImportOfferingBodyMetadataFile model
				importOfferingBodyMetadataFileModel := new(catalogmanagementv1.ImportOfferingBodyMetadataFile)
				importOfferingBodyMetadataFileModel.Size = core.Int64Ptr(int64(38))

				// Construct an instance of the ImportOfferingBodyMetadataImagesItem model
				importOfferingBodyMetadataImagesItemModel := new(catalogmanagementv1.ImportOfferingBodyMetadataImagesItem)
				importOfferingBodyMetadataImagesItemModel.ID = core.StringPtr("testString")
				importOfferingBodyMetadataImagesItemModel.Name = core.StringPtr("testString")
				importOfferingBodyMetadataImagesItemModel.Region = core.StringPtr("testString")

				// Construct an instance of the ImportOfferingBodyMetadata model
				importOfferingBodyMetadataModel := new(catalogmanagementv1.ImportOfferingBodyMetadata)
				importOfferingBodyMetadataModel.OperatingSystem = importOfferingBodyMetadataOperatingSystemModel
				importOfferingBodyMetadataModel.File = importOfferingBodyMetadataFileModel
				importOfferingBodyMetadataModel.MinimumProvisionedSize = core.Int64Ptr(int64(38))
				importOfferingBodyMetadataModel.Images = []catalogmanagementv1.ImportOfferingBodyMetadataImagesItem{*importOfferingBodyMetadataImagesItemModel}

				// Construct an instance of the ImportOfferingVersionOptions model
				importOfferingVersionOptionsModel := new(catalogmanagementv1.ImportOfferingVersionOptions)
				importOfferingVersionOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				importOfferingVersionOptionsModel.OfferingID = core.StringPtr("testString")
				importOfferingVersionOptionsModel.Tags = []string{"testString"}
				importOfferingVersionOptionsModel.Keywords = []string{"testString"}
				importOfferingVersionOptionsModel.Content = CreateMockByteArray("VGhpcyBpcyBhIG1vY2sgYnl0ZSBhcnJheSB2YWx1ZS4=")
				importOfferingVersionOptionsModel.Name = core.StringPtr("testString")
				importOfferingVersionOptionsModel.Label = core.StringPtr("testString")
				importOfferingVersionOptionsModel.InstallKind = core.StringPtr("testString")
				importOfferingVersionOptionsModel.TargetKinds = []string{"testString"}
				importOfferingVersionOptionsModel.FormatKind = core.StringPtr("testString")
				importOfferingVersionOptionsModel.ProductKind = core.StringPtr("testString")
				importOfferingVersionOptionsModel.ProductKindLabel = core.StringPtr("testString")
				importOfferingVersionOptionsModel.Sha = core.StringPtr("testString")
				importOfferingVersionOptionsModel.Version = core.StringPtr("testString")
				importOfferingVersionOptionsModel.Flavor = flavorModel
				importOfferingVersionOptionsModel.Metadata = importOfferingBodyMetadataModel
				importOfferingVersionOptionsModel.WorkingDirectory = core.StringPtr("testString")
				importOfferingVersionOptionsModel.InstallType = core.StringPtr("testString")
				importOfferingVersionOptionsModel.Zipurl = core.StringPtr("testString")
				importOfferingVersionOptionsModel.TargetVersion = core.StringPtr("testString")
				importOfferingVersionOptionsModel.IncludeConfig = core.BoolPtr(true)
				importOfferingVersionOptionsModel.IsVsi = core.BoolPtr(true)
				importOfferingVersionOptionsModel.Repotype = core.StringPtr("testString")
				importOfferingVersionOptionsModel.XAuthToken = core.StringPtr("testString")
				importOfferingVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.ImportOfferingVersion(importOfferingVersionOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.ImportOfferingVersion(importOfferingVersionOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ImportOfferingVersion(importOfferingVersionOptions *ImportOfferingVersionOptions)`, func() {
		importOfferingVersionPath := "/catalogs/testString/offerings/testString/version"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(importOfferingVersionPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["X-Auth-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["zipurl"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["targetVersion"]).To(Equal([]string{"testString"}))
					// TODO: Add check for includeConfig query parameter
					// TODO: Add check for isVSI query parameter
					Expect(req.URL.Query()["repotype"]).To(Equal([]string{"testString"}))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "name": "Name", "offering_icon_url": "OfferingIconURL", "offering_docs_url": "OfferingDocsURL", "offering_support_url": "OfferingSupportURL", "tags": ["Tags"], "keywords": ["Keywords"], "rating": {"one_star_count": 12, "two_star_count": 12, "three_star_count": 14, "four_star_count": 13}, "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "kinds": [{"id": "ID", "format_kind": "FormatKind", "format_kind_label": "FormatKindLabel", "install_kind": "InstallKind", "install_kind_label": "InstallKindLabel", "target_kind": "TargetKind", "target_kind_label": "TargetKindLabel", "metadata": {"anyKey": "anyValue"}, "tags": ["Tags"], "additional_features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "versions": [{"id": "ID", "_rev": "Rev", "crn": "CRN", "version": "Version", "flavor": {"name": "Name", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "index": 5}, "sha": "Sha", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "offering_id": "OfferingID", "catalog_id": "CatalogID", "kind_id": "KindID", "tags": ["Tags"], "repo_url": "RepoURL", "source_url": "SourceURL", "tgz_url": "TgzURL", "configuration": [{"key": "Key", "type": "Type", "default_value": "anyValue", "display_name": "DisplayName", "value_constraint": "ValueConstraint", "description": "Description", "required": true, "options": ["anyValue"], "hidden": true, "custom_config": {"type": "Type", "grouping": "Grouping", "original_grouping": "OriginalGrouping", "grouping_index": 13, "config_constraints": {"anyKey": "anyValue"}, "associations": {"parameters": [{"name": "Name", "optionsRefresh": true}]}}, "type_metadata": "TypeMetadata"}], "outputs": [{"key": "Key", "description": "Description"}], "iam_permissions": [{"service_name": "ServiceName", "role_crns": ["RoleCrns"], "resources": [{"name": "Name", "description": "Description", "role_crns": ["RoleCrns"]}]}], "metadata": {"anyKey": "anyValue"}, "validation": {"validated": "2019-01-01T12:00:00.000Z", "requested": "2019-01-01T12:00:00.000Z", "state": "State", "last_operation": "LastOperation", "target": {"anyKey": "anyValue"}, "message": "Message"}, "required_resources": [{"type": "mem", "value": "anyValue"}], "single_instance": true, "schematics_env_values": {"value": "[{\"name\": \"TF_LOG\",\"value\": \"TRACE\",\"secure\": false,\"hidden\": false}]", "sm_ref": "cmsm_v1:{\"name\": \"envVarSecret\",\"id\":\"1234567890\",\"service_id\":\"crn:v1:bluemix:public:secrets-manager:eu-gb:a/1234567890:1234567890::\",\"service_name\":\"My SM Instance\",\"group_id\":\"1234567890\",\"group_name\":\"My SM Group\",\"resource_group_id\":\"1234567890\",\"region\":\"eu-gb\",\"type\":\"arbitrary\"}"}, "install": {"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}, "pre_install": [{"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}], "scripts": {"mapKey": {"short_description": "ShortDescription", "type": "ansible", "path": "scripts/validate-post-ansible-playbook.yaml", "stage": "pre", "action": "validate"}}, "entitlement": {"provider_name": "ProviderName", "provider_id": "ProviderID", "product_id": "ProductID", "part_numbers": ["PartNumbers"], "image_repo_name": "ImageRepoName"}, "licenses": [{"id": "ID", "name": "Name", "type": "Type", "url": "URL", "description": "Description"}], "image_manifest_url": "ImageManifestURL", "deprecated": true, "package_version": "PackageVersion", "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "version_locator": "VersionLocator", "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "whitelisted_accounts": ["WhitelistedAccounts"], "image_pull_key_name": "ImagePullKeyName", "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "solution_info": {"architecture_diagrams": [{"diagram": {"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "cost_estimate": {"version": "Version", "currency": "Currency", "projects": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "pastBreakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "breakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "diff": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}}], "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}, "totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "pastTotalHourlyCost": "PastTotalHourlyCost", "pastTotalMonthlyCost": "PastTotalMonthlyCost", "diffTotalHourlyCost": "DiffTotalHourlyCost", "diffTotalMonthlyCost": "DiffTotalMonthlyCost", "timeGenerated": "2019-01-01T12:00:00.000Z"}, "dependencies": [{"catalog_id": "CatalogID", "id": "ID", "name": "Name", "kind": "Kind", "version": "Version", "description": "Description", "default_flavor": "DefaultFlavor", "flavors": ["Flavors"], "optional": true, "on_by_default": false}], "install_type": "InstallType"}, "is_consumable": true, "compliance_v3": {"authority": "Authority", "claims": {"profiles": [{"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}], "controls": [{"profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "names": ["Names"]}]}, "evaluations": [{"scan_id": "ScanID", "account_id": "AccountID", "profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "result": {"failure_count": 12, "scan_time": "2019-01-01T12:00:00.000Z", "error_message": "ErrorMessage", "complete_scan": true, "unscanned_resources": ["UnscannedResources"]}, "controls": [{"id": "ID", "name": "Name", "description": "Description", "specifications": [{"id": "ID", "description": "Description", "component_name": "ComponentName", "assessments": [{"id": "ID", "description": "Description", "version": "Version", "type": "Type", "method": "Method", "ui_href": "UIHref"}], "ui_href": "UIHref"}], "failure_count": 12, "pass_count": 9, "parent": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "parent_name": "ParentName", "specifications": [{"id": "ID", "description": "Description", "component_name": "ComponentName", "assessments": [{"id": "ID", "description": "Description", "version": "Version", "type": "Type", "method": "Method", "ui_href": "UIHref"}], "ui_href": "UIHref"}], "ui_href": "UIHref"}, "ui_href": "UIHref"}]}]}, "change_notices": {"breaking": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "new": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "update": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}]}, "plan_ids": ["PlanIds"], "stack": {"anyKey": "anyValue"}, "minimum_compatible_version": "MinimumCompatibleVersion"}], "all_versions": {"first": {"href": "Href", "start": "Start"}, "next": {"href": "Href", "start": "Start"}}}], "publish": {"pc_managed": false, "approval_type": "ApprovalType", "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "original_crn": "OriginalCRN", "public_crn": "PublicCRN", "approval_record": {"anyKey": "anyValue"}, "permit_ibm_public_publish": true, "ibm_approved": false, "public_approved": true}, "pc_managed": false, "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "public_original_crn": "PublicOriginalCRN", "publish_public_crn": "PublishPublicCRN", "portal_approval_record": "PortalApprovalRecord", "portal_ui_url": "PortalUIURL", "catalog_id": "CatalogID", "catalog_name": "CatalogName", "metadata": {"anyKey": "anyValue"}, "disclaimer": "Disclaimer", "hidden": true, "provider": "Provider", "provider_info": {"id": "ID", "name": "Name"}, "repo_info": {"token": "Token", "type": "Type"}, "image_pull_keys": [{"name": "Name", "value": "Value", "description": "Description"}], "support": {"url": "URL", "process": "Process", "process_i18n": {"mapKey": "Inner"}, "locations": ["Locations"], "support_details": [{"type": "Type", "contact": "Contact", "response_wait_time": {"value": 5, "type": "Type"}, "availability": {"times": [{"day": 3, "start_time": "StartTime", "end_time": "EndTime"}], "timezone": "Timezone", "always_available": false}}], "support_escalation": {"escalation_wait_time": {"value": 5, "type": "Type"}, "response_wait_time": {"value": 5, "type": "Type"}, "contact": "Contact"}, "support_type": "SupportType"}, "media": [{"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}], "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "product_kind": "ProductKind", "badges": [{"id": "ID", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}, "icon": "Icon", "authority": "Authority", "tag": "Tag", "learn_more_links": {"first_party": "FirstParty", "third_party": "ThirdParty"}, "constraints": [{"type": "Type", "rule": "anyValue"}]}], "plans": [{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "offering_id": "OfferingID", "catalog_id": "CatalogID", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "name": "Name", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "pricing_tags": ["PricingTags"], "version_range": {"kinds": ["Kinds"], "version": "Version", "flavors": ["Flavors"]}, "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "metadata": {"anyKey": "anyValue"}, "publish_approved": false}]}`)
				}))
			})
			It(`Invoke ImportOfferingVersion successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the Flavor model
				flavorModel := new(catalogmanagementv1.Flavor)
				flavorModel.Name = core.StringPtr("testString")
				flavorModel.Label = core.StringPtr("testString")
				flavorModel.LabelI18n = map[string]string{"key1": "testString"}
				flavorModel.Index = core.Int64Ptr(int64(38))

				// Construct an instance of the ImportOfferingBodyMetadataOperatingSystem model
				importOfferingBodyMetadataOperatingSystemModel := new(catalogmanagementv1.ImportOfferingBodyMetadataOperatingSystem)
				importOfferingBodyMetadataOperatingSystemModel.DedicatedHostOnly = core.BoolPtr(true)
				importOfferingBodyMetadataOperatingSystemModel.Vendor = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Name = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Href = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.DisplayName = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Family = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Version = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Architecture = core.StringPtr("testString")

				// Construct an instance of the ImportOfferingBodyMetadataFile model
				importOfferingBodyMetadataFileModel := new(catalogmanagementv1.ImportOfferingBodyMetadataFile)
				importOfferingBodyMetadataFileModel.Size = core.Int64Ptr(int64(38))

				// Construct an instance of the ImportOfferingBodyMetadataImagesItem model
				importOfferingBodyMetadataImagesItemModel := new(catalogmanagementv1.ImportOfferingBodyMetadataImagesItem)
				importOfferingBodyMetadataImagesItemModel.ID = core.StringPtr("testString")
				importOfferingBodyMetadataImagesItemModel.Name = core.StringPtr("testString")
				importOfferingBodyMetadataImagesItemModel.Region = core.StringPtr("testString")

				// Construct an instance of the ImportOfferingBodyMetadata model
				importOfferingBodyMetadataModel := new(catalogmanagementv1.ImportOfferingBodyMetadata)
				importOfferingBodyMetadataModel.OperatingSystem = importOfferingBodyMetadataOperatingSystemModel
				importOfferingBodyMetadataModel.File = importOfferingBodyMetadataFileModel
				importOfferingBodyMetadataModel.MinimumProvisionedSize = core.Int64Ptr(int64(38))
				importOfferingBodyMetadataModel.Images = []catalogmanagementv1.ImportOfferingBodyMetadataImagesItem{*importOfferingBodyMetadataImagesItemModel}

				// Construct an instance of the ImportOfferingVersionOptions model
				importOfferingVersionOptionsModel := new(catalogmanagementv1.ImportOfferingVersionOptions)
				importOfferingVersionOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				importOfferingVersionOptionsModel.OfferingID = core.StringPtr("testString")
				importOfferingVersionOptionsModel.Tags = []string{"testString"}
				importOfferingVersionOptionsModel.Keywords = []string{"testString"}
				importOfferingVersionOptionsModel.Content = CreateMockByteArray("VGhpcyBpcyBhIG1vY2sgYnl0ZSBhcnJheSB2YWx1ZS4=")
				importOfferingVersionOptionsModel.Name = core.StringPtr("testString")
				importOfferingVersionOptionsModel.Label = core.StringPtr("testString")
				importOfferingVersionOptionsModel.InstallKind = core.StringPtr("testString")
				importOfferingVersionOptionsModel.TargetKinds = []string{"testString"}
				importOfferingVersionOptionsModel.FormatKind = core.StringPtr("testString")
				importOfferingVersionOptionsModel.ProductKind = core.StringPtr("testString")
				importOfferingVersionOptionsModel.ProductKindLabel = core.StringPtr("testString")
				importOfferingVersionOptionsModel.Sha = core.StringPtr("testString")
				importOfferingVersionOptionsModel.Version = core.StringPtr("testString")
				importOfferingVersionOptionsModel.Flavor = flavorModel
				importOfferingVersionOptionsModel.Metadata = importOfferingBodyMetadataModel
				importOfferingVersionOptionsModel.WorkingDirectory = core.StringPtr("testString")
				importOfferingVersionOptionsModel.InstallType = core.StringPtr("testString")
				importOfferingVersionOptionsModel.Zipurl = core.StringPtr("testString")
				importOfferingVersionOptionsModel.TargetVersion = core.StringPtr("testString")
				importOfferingVersionOptionsModel.IncludeConfig = core.BoolPtr(true)
				importOfferingVersionOptionsModel.IsVsi = core.BoolPtr(true)
				importOfferingVersionOptionsModel.Repotype = core.StringPtr("testString")
				importOfferingVersionOptionsModel.XAuthToken = core.StringPtr("testString")
				importOfferingVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.ImportOfferingVersionWithContext(ctx, importOfferingVersionOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.ImportOfferingVersion(importOfferingVersionOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.ImportOfferingVersionWithContext(ctx, importOfferingVersionOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(importOfferingVersionPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["X-Auth-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["zipurl"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["targetVersion"]).To(Equal([]string{"testString"}))
					// TODO: Add check for includeConfig query parameter
					// TODO: Add check for isVSI query parameter
					Expect(req.URL.Query()["repotype"]).To(Equal([]string{"testString"}))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "name": "Name", "offering_icon_url": "OfferingIconURL", "offering_docs_url": "OfferingDocsURL", "offering_support_url": "OfferingSupportURL", "tags": ["Tags"], "keywords": ["Keywords"], "rating": {"one_star_count": 12, "two_star_count": 12, "three_star_count": 14, "four_star_count": 13}, "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "kinds": [{"id": "ID", "format_kind": "FormatKind", "format_kind_label": "FormatKindLabel", "install_kind": "InstallKind", "install_kind_label": "InstallKindLabel", "target_kind": "TargetKind", "target_kind_label": "TargetKindLabel", "metadata": {"anyKey": "anyValue"}, "tags": ["Tags"], "additional_features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "versions": [{"id": "ID", "_rev": "Rev", "crn": "CRN", "version": "Version", "flavor": {"name": "Name", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "index": 5}, "sha": "Sha", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "offering_id": "OfferingID", "catalog_id": "CatalogID", "kind_id": "KindID", "tags": ["Tags"], "repo_url": "RepoURL", "source_url": "SourceURL", "tgz_url": "TgzURL", "configuration": [{"key": "Key", "type": "Type", "default_value": "anyValue", "display_name": "DisplayName", "value_constraint": "ValueConstraint", "description": "Description", "required": true, "options": ["anyValue"], "hidden": true, "custom_config": {"type": "Type", "grouping": "Grouping", "original_grouping": "OriginalGrouping", "grouping_index": 13, "config_constraints": {"anyKey": "anyValue"}, "associations": {"parameters": [{"name": "Name", "optionsRefresh": true}]}}, "type_metadata": "TypeMetadata"}], "outputs": [{"key": "Key", "description": "Description"}], "iam_permissions": [{"service_name": "ServiceName", "role_crns": ["RoleCrns"], "resources": [{"name": "Name", "description": "Description", "role_crns": ["RoleCrns"]}]}], "metadata": {"anyKey": "anyValue"}, "validation": {"validated": "2019-01-01T12:00:00.000Z", "requested": "2019-01-01T12:00:00.000Z", "state": "State", "last_operation": "LastOperation", "target": {"anyKey": "anyValue"}, "message": "Message"}, "required_resources": [{"type": "mem", "value": "anyValue"}], "single_instance": true, "schematics_env_values": {"value": "[{\"name\": \"TF_LOG\",\"value\": \"TRACE\",\"secure\": false,\"hidden\": false}]", "sm_ref": "cmsm_v1:{\"name\": \"envVarSecret\",\"id\":\"1234567890\",\"service_id\":\"crn:v1:bluemix:public:secrets-manager:eu-gb:a/1234567890:1234567890::\",\"service_name\":\"My SM Instance\",\"group_id\":\"1234567890\",\"group_name\":\"My SM Group\",\"resource_group_id\":\"1234567890\",\"region\":\"eu-gb\",\"type\":\"arbitrary\"}"}, "install": {"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}, "pre_install": [{"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}], "scripts": {"mapKey": {"short_description": "ShortDescription", "type": "ansible", "path": "scripts/validate-post-ansible-playbook.yaml", "stage": "pre", "action": "validate"}}, "entitlement": {"provider_name": "ProviderName", "provider_id": "ProviderID", "product_id": "ProductID", "part_numbers": ["PartNumbers"], "image_repo_name": "ImageRepoName"}, "licenses": [{"id": "ID", "name": "Name", "type": "Type", "url": "URL", "description": "Description"}], "image_manifest_url": "ImageManifestURL", "deprecated": true, "package_version": "PackageVersion", "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "version_locator": "VersionLocator", "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "whitelisted_accounts": ["WhitelistedAccounts"], "image_pull_key_name": "ImagePullKeyName", "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "solution_info": {"architecture_diagrams": [{"diagram": {"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "cost_estimate": {"version": "Version", "currency": "Currency", "projects": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "pastBreakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "breakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "diff": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}}], "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}, "totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "pastTotalHourlyCost": "PastTotalHourlyCost", "pastTotalMonthlyCost": "PastTotalMonthlyCost", "diffTotalHourlyCost": "DiffTotalHourlyCost", "diffTotalMonthlyCost": "DiffTotalMonthlyCost", "timeGenerated": "2019-01-01T12:00:00.000Z"}, "dependencies": [{"catalog_id": "CatalogID", "id": "ID", "name": "Name", "kind": "Kind", "version": "Version", "description": "Description", "default_flavor": "DefaultFlavor", "flavors": ["Flavors"], "optional": true, "on_by_default": false}], "install_type": "InstallType"}, "is_consumable": true, "compliance_v3": {"authority": "Authority", "claims": {"profiles": [{"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}], "controls": [{"profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "names": ["Names"]}]}, "evaluations": [{"scan_id": "ScanID", "account_id": "AccountID", "profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "result": {"failure_count": 12, "scan_time": "2019-01-01T12:00:00.000Z", "error_message": "ErrorMessage", "complete_scan": true, "unscanned_resources": ["UnscannedResources"]}, "controls": [{"id": "ID", "name": "Name", "description": "Description", "specifications": [{"id": "ID", "description": "Description", "component_name": "ComponentName", "assessments": [{"id": "ID", "description": "Description", "version": "Version", "type": "Type", "method": "Method", "ui_href": "UIHref"}], "ui_href": "UIHref"}], "failure_count": 12, "pass_count": 9, "parent": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "parent_name": "ParentName", "specifications": [{"id": "ID", "description": "Description", "component_name": "ComponentName", "assessments": [{"id": "ID", "description": "Description", "version": "Version", "type": "Type", "method": "Method", "ui_href": "UIHref"}], "ui_href": "UIHref"}], "ui_href": "UIHref"}, "ui_href": "UIHref"}]}]}, "change_notices": {"breaking": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "new": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "update": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}]}, "plan_ids": ["PlanIds"], "stack": {"anyKey": "anyValue"}, "minimum_compatible_version": "MinimumCompatibleVersion"}], "all_versions": {"first": {"href": "Href", "start": "Start"}, "next": {"href": "Href", "start": "Start"}}}], "publish": {"pc_managed": false, "approval_type": "ApprovalType", "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "original_crn": "OriginalCRN", "public_crn": "PublicCRN", "approval_record": {"anyKey": "anyValue"}, "permit_ibm_public_publish": true, "ibm_approved": false, "public_approved": true}, "pc_managed": false, "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "public_original_crn": "PublicOriginalCRN", "publish_public_crn": "PublishPublicCRN", "portal_approval_record": "PortalApprovalRecord", "portal_ui_url": "PortalUIURL", "catalog_id": "CatalogID", "catalog_name": "CatalogName", "metadata": {"anyKey": "anyValue"}, "disclaimer": "Disclaimer", "hidden": true, "provider": "Provider", "provider_info": {"id": "ID", "name": "Name"}, "repo_info": {"token": "Token", "type": "Type"}, "image_pull_keys": [{"name": "Name", "value": "Value", "description": "Description"}], "support": {"url": "URL", "process": "Process", "process_i18n": {"mapKey": "Inner"}, "locations": ["Locations"], "support_details": [{"type": "Type", "contact": "Contact", "response_wait_time": {"value": 5, "type": "Type"}, "availability": {"times": [{"day": 3, "start_time": "StartTime", "end_time": "EndTime"}], "timezone": "Timezone", "always_available": false}}], "support_escalation": {"escalation_wait_time": {"value": 5, "type": "Type"}, "response_wait_time": {"value": 5, "type": "Type"}, "contact": "Contact"}, "support_type": "SupportType"}, "media": [{"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}], "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "product_kind": "ProductKind", "badges": [{"id": "ID", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}, "icon": "Icon", "authority": "Authority", "tag": "Tag", "learn_more_links": {"first_party": "FirstParty", "third_party": "ThirdParty"}, "constraints": [{"type": "Type", "rule": "anyValue"}]}], "plans": [{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "offering_id": "OfferingID", "catalog_id": "CatalogID", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "name": "Name", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "pricing_tags": ["PricingTags"], "version_range": {"kinds": ["Kinds"], "version": "Version", "flavors": ["Flavors"]}, "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "metadata": {"anyKey": "anyValue"}, "publish_approved": false}]}`)
				}))
			})
			It(`Invoke ImportOfferingVersion successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.ImportOfferingVersion(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the Flavor model
				flavorModel := new(catalogmanagementv1.Flavor)
				flavorModel.Name = core.StringPtr("testString")
				flavorModel.Label = core.StringPtr("testString")
				flavorModel.LabelI18n = map[string]string{"key1": "testString"}
				flavorModel.Index = core.Int64Ptr(int64(38))

				// Construct an instance of the ImportOfferingBodyMetadataOperatingSystem model
				importOfferingBodyMetadataOperatingSystemModel := new(catalogmanagementv1.ImportOfferingBodyMetadataOperatingSystem)
				importOfferingBodyMetadataOperatingSystemModel.DedicatedHostOnly = core.BoolPtr(true)
				importOfferingBodyMetadataOperatingSystemModel.Vendor = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Name = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Href = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.DisplayName = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Family = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Version = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Architecture = core.StringPtr("testString")

				// Construct an instance of the ImportOfferingBodyMetadataFile model
				importOfferingBodyMetadataFileModel := new(catalogmanagementv1.ImportOfferingBodyMetadataFile)
				importOfferingBodyMetadataFileModel.Size = core.Int64Ptr(int64(38))

				// Construct an instance of the ImportOfferingBodyMetadataImagesItem model
				importOfferingBodyMetadataImagesItemModel := new(catalogmanagementv1.ImportOfferingBodyMetadataImagesItem)
				importOfferingBodyMetadataImagesItemModel.ID = core.StringPtr("testString")
				importOfferingBodyMetadataImagesItemModel.Name = core.StringPtr("testString")
				importOfferingBodyMetadataImagesItemModel.Region = core.StringPtr("testString")

				// Construct an instance of the ImportOfferingBodyMetadata model
				importOfferingBodyMetadataModel := new(catalogmanagementv1.ImportOfferingBodyMetadata)
				importOfferingBodyMetadataModel.OperatingSystem = importOfferingBodyMetadataOperatingSystemModel
				importOfferingBodyMetadataModel.File = importOfferingBodyMetadataFileModel
				importOfferingBodyMetadataModel.MinimumProvisionedSize = core.Int64Ptr(int64(38))
				importOfferingBodyMetadataModel.Images = []catalogmanagementv1.ImportOfferingBodyMetadataImagesItem{*importOfferingBodyMetadataImagesItemModel}

				// Construct an instance of the ImportOfferingVersionOptions model
				importOfferingVersionOptionsModel := new(catalogmanagementv1.ImportOfferingVersionOptions)
				importOfferingVersionOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				importOfferingVersionOptionsModel.OfferingID = core.StringPtr("testString")
				importOfferingVersionOptionsModel.Tags = []string{"testString"}
				importOfferingVersionOptionsModel.Keywords = []string{"testString"}
				importOfferingVersionOptionsModel.Content = CreateMockByteArray("VGhpcyBpcyBhIG1vY2sgYnl0ZSBhcnJheSB2YWx1ZS4=")
				importOfferingVersionOptionsModel.Name = core.StringPtr("testString")
				importOfferingVersionOptionsModel.Label = core.StringPtr("testString")
				importOfferingVersionOptionsModel.InstallKind = core.StringPtr("testString")
				importOfferingVersionOptionsModel.TargetKinds = []string{"testString"}
				importOfferingVersionOptionsModel.FormatKind = core.StringPtr("testString")
				importOfferingVersionOptionsModel.ProductKind = core.StringPtr("testString")
				importOfferingVersionOptionsModel.ProductKindLabel = core.StringPtr("testString")
				importOfferingVersionOptionsModel.Sha = core.StringPtr("testString")
				importOfferingVersionOptionsModel.Version = core.StringPtr("testString")
				importOfferingVersionOptionsModel.Flavor = flavorModel
				importOfferingVersionOptionsModel.Metadata = importOfferingBodyMetadataModel
				importOfferingVersionOptionsModel.WorkingDirectory = core.StringPtr("testString")
				importOfferingVersionOptionsModel.InstallType = core.StringPtr("testString")
				importOfferingVersionOptionsModel.Zipurl = core.StringPtr("testString")
				importOfferingVersionOptionsModel.TargetVersion = core.StringPtr("testString")
				importOfferingVersionOptionsModel.IncludeConfig = core.BoolPtr(true)
				importOfferingVersionOptionsModel.IsVsi = core.BoolPtr(true)
				importOfferingVersionOptionsModel.Repotype = core.StringPtr("testString")
				importOfferingVersionOptionsModel.XAuthToken = core.StringPtr("testString")
				importOfferingVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.ImportOfferingVersion(importOfferingVersionOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ImportOfferingVersion with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the Flavor model
				flavorModel := new(catalogmanagementv1.Flavor)
				flavorModel.Name = core.StringPtr("testString")
				flavorModel.Label = core.StringPtr("testString")
				flavorModel.LabelI18n = map[string]string{"key1": "testString"}
				flavorModel.Index = core.Int64Ptr(int64(38))

				// Construct an instance of the ImportOfferingBodyMetadataOperatingSystem model
				importOfferingBodyMetadataOperatingSystemModel := new(catalogmanagementv1.ImportOfferingBodyMetadataOperatingSystem)
				importOfferingBodyMetadataOperatingSystemModel.DedicatedHostOnly = core.BoolPtr(true)
				importOfferingBodyMetadataOperatingSystemModel.Vendor = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Name = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Href = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.DisplayName = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Family = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Version = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Architecture = core.StringPtr("testString")

				// Construct an instance of the ImportOfferingBodyMetadataFile model
				importOfferingBodyMetadataFileModel := new(catalogmanagementv1.ImportOfferingBodyMetadataFile)
				importOfferingBodyMetadataFileModel.Size = core.Int64Ptr(int64(38))

				// Construct an instance of the ImportOfferingBodyMetadataImagesItem model
				importOfferingBodyMetadataImagesItemModel := new(catalogmanagementv1.ImportOfferingBodyMetadataImagesItem)
				importOfferingBodyMetadataImagesItemModel.ID = core.StringPtr("testString")
				importOfferingBodyMetadataImagesItemModel.Name = core.StringPtr("testString")
				importOfferingBodyMetadataImagesItemModel.Region = core.StringPtr("testString")

				// Construct an instance of the ImportOfferingBodyMetadata model
				importOfferingBodyMetadataModel := new(catalogmanagementv1.ImportOfferingBodyMetadata)
				importOfferingBodyMetadataModel.OperatingSystem = importOfferingBodyMetadataOperatingSystemModel
				importOfferingBodyMetadataModel.File = importOfferingBodyMetadataFileModel
				importOfferingBodyMetadataModel.MinimumProvisionedSize = core.Int64Ptr(int64(38))
				importOfferingBodyMetadataModel.Images = []catalogmanagementv1.ImportOfferingBodyMetadataImagesItem{*importOfferingBodyMetadataImagesItemModel}

				// Construct an instance of the ImportOfferingVersionOptions model
				importOfferingVersionOptionsModel := new(catalogmanagementv1.ImportOfferingVersionOptions)
				importOfferingVersionOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				importOfferingVersionOptionsModel.OfferingID = core.StringPtr("testString")
				importOfferingVersionOptionsModel.Tags = []string{"testString"}
				importOfferingVersionOptionsModel.Keywords = []string{"testString"}
				importOfferingVersionOptionsModel.Content = CreateMockByteArray("VGhpcyBpcyBhIG1vY2sgYnl0ZSBhcnJheSB2YWx1ZS4=")
				importOfferingVersionOptionsModel.Name = core.StringPtr("testString")
				importOfferingVersionOptionsModel.Label = core.StringPtr("testString")
				importOfferingVersionOptionsModel.InstallKind = core.StringPtr("testString")
				importOfferingVersionOptionsModel.TargetKinds = []string{"testString"}
				importOfferingVersionOptionsModel.FormatKind = core.StringPtr("testString")
				importOfferingVersionOptionsModel.ProductKind = core.StringPtr("testString")
				importOfferingVersionOptionsModel.ProductKindLabel = core.StringPtr("testString")
				importOfferingVersionOptionsModel.Sha = core.StringPtr("testString")
				importOfferingVersionOptionsModel.Version = core.StringPtr("testString")
				importOfferingVersionOptionsModel.Flavor = flavorModel
				importOfferingVersionOptionsModel.Metadata = importOfferingBodyMetadataModel
				importOfferingVersionOptionsModel.WorkingDirectory = core.StringPtr("testString")
				importOfferingVersionOptionsModel.InstallType = core.StringPtr("testString")
				importOfferingVersionOptionsModel.Zipurl = core.StringPtr("testString")
				importOfferingVersionOptionsModel.TargetVersion = core.StringPtr("testString")
				importOfferingVersionOptionsModel.IncludeConfig = core.BoolPtr(true)
				importOfferingVersionOptionsModel.IsVsi = core.BoolPtr(true)
				importOfferingVersionOptionsModel.Repotype = core.StringPtr("testString")
				importOfferingVersionOptionsModel.XAuthToken = core.StringPtr("testString")
				importOfferingVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.ImportOfferingVersion(importOfferingVersionOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the ImportOfferingVersionOptions model with no property values
				importOfferingVersionOptionsModelNew := new(catalogmanagementv1.ImportOfferingVersionOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.ImportOfferingVersion(importOfferingVersionOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(201)
				}))
			})
			It(`Invoke ImportOfferingVersion successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the Flavor model
				flavorModel := new(catalogmanagementv1.Flavor)
				flavorModel.Name = core.StringPtr("testString")
				flavorModel.Label = core.StringPtr("testString")
				flavorModel.LabelI18n = map[string]string{"key1": "testString"}
				flavorModel.Index = core.Int64Ptr(int64(38))

				// Construct an instance of the ImportOfferingBodyMetadataOperatingSystem model
				importOfferingBodyMetadataOperatingSystemModel := new(catalogmanagementv1.ImportOfferingBodyMetadataOperatingSystem)
				importOfferingBodyMetadataOperatingSystemModel.DedicatedHostOnly = core.BoolPtr(true)
				importOfferingBodyMetadataOperatingSystemModel.Vendor = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Name = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Href = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.DisplayName = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Family = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Version = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Architecture = core.StringPtr("testString")

				// Construct an instance of the ImportOfferingBodyMetadataFile model
				importOfferingBodyMetadataFileModel := new(catalogmanagementv1.ImportOfferingBodyMetadataFile)
				importOfferingBodyMetadataFileModel.Size = core.Int64Ptr(int64(38))

				// Construct an instance of the ImportOfferingBodyMetadataImagesItem model
				importOfferingBodyMetadataImagesItemModel := new(catalogmanagementv1.ImportOfferingBodyMetadataImagesItem)
				importOfferingBodyMetadataImagesItemModel.ID = core.StringPtr("testString")
				importOfferingBodyMetadataImagesItemModel.Name = core.StringPtr("testString")
				importOfferingBodyMetadataImagesItemModel.Region = core.StringPtr("testString")

				// Construct an instance of the ImportOfferingBodyMetadata model
				importOfferingBodyMetadataModel := new(catalogmanagementv1.ImportOfferingBodyMetadata)
				importOfferingBodyMetadataModel.OperatingSystem = importOfferingBodyMetadataOperatingSystemModel
				importOfferingBodyMetadataModel.File = importOfferingBodyMetadataFileModel
				importOfferingBodyMetadataModel.MinimumProvisionedSize = core.Int64Ptr(int64(38))
				importOfferingBodyMetadataModel.Images = []catalogmanagementv1.ImportOfferingBodyMetadataImagesItem{*importOfferingBodyMetadataImagesItemModel}

				// Construct an instance of the ImportOfferingVersionOptions model
				importOfferingVersionOptionsModel := new(catalogmanagementv1.ImportOfferingVersionOptions)
				importOfferingVersionOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				importOfferingVersionOptionsModel.OfferingID = core.StringPtr("testString")
				importOfferingVersionOptionsModel.Tags = []string{"testString"}
				importOfferingVersionOptionsModel.Keywords = []string{"testString"}
				importOfferingVersionOptionsModel.Content = CreateMockByteArray("VGhpcyBpcyBhIG1vY2sgYnl0ZSBhcnJheSB2YWx1ZS4=")
				importOfferingVersionOptionsModel.Name = core.StringPtr("testString")
				importOfferingVersionOptionsModel.Label = core.StringPtr("testString")
				importOfferingVersionOptionsModel.InstallKind = core.StringPtr("testString")
				importOfferingVersionOptionsModel.TargetKinds = []string{"testString"}
				importOfferingVersionOptionsModel.FormatKind = core.StringPtr("testString")
				importOfferingVersionOptionsModel.ProductKind = core.StringPtr("testString")
				importOfferingVersionOptionsModel.ProductKindLabel = core.StringPtr("testString")
				importOfferingVersionOptionsModel.Sha = core.StringPtr("testString")
				importOfferingVersionOptionsModel.Version = core.StringPtr("testString")
				importOfferingVersionOptionsModel.Flavor = flavorModel
				importOfferingVersionOptionsModel.Metadata = importOfferingBodyMetadataModel
				importOfferingVersionOptionsModel.WorkingDirectory = core.StringPtr("testString")
				importOfferingVersionOptionsModel.InstallType = core.StringPtr("testString")
				importOfferingVersionOptionsModel.Zipurl = core.StringPtr("testString")
				importOfferingVersionOptionsModel.TargetVersion = core.StringPtr("testString")
				importOfferingVersionOptionsModel.IncludeConfig = core.BoolPtr(true)
				importOfferingVersionOptionsModel.IsVsi = core.BoolPtr(true)
				importOfferingVersionOptionsModel.Repotype = core.StringPtr("testString")
				importOfferingVersionOptionsModel.XAuthToken = core.StringPtr("testString")
				importOfferingVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.ImportOfferingVersion(importOfferingVersionOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ImportOffering(importOfferingOptions *ImportOfferingOptions) - Operation response error`, func() {
		importOfferingPath := "/catalogs/testString/import/offerings"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(importOfferingPath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["X-Auth-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["zipurl"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["offeringID"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["targetVersion"]).To(Equal([]string{"testString"}))
					// TODO: Add check for includeConfig query parameter
					// TODO: Add check for isVSI query parameter
					Expect(req.URL.Query()["repotype"]).To(Equal([]string{"testString"}))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ImportOffering with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the Flavor model
				flavorModel := new(catalogmanagementv1.Flavor)
				flavorModel.Name = core.StringPtr("testString")
				flavorModel.Label = core.StringPtr("testString")
				flavorModel.LabelI18n = map[string]string{"key1": "testString"}
				flavorModel.Index = core.Int64Ptr(int64(38))

				// Construct an instance of the ImportOfferingBodyMetadataOperatingSystem model
				importOfferingBodyMetadataOperatingSystemModel := new(catalogmanagementv1.ImportOfferingBodyMetadataOperatingSystem)
				importOfferingBodyMetadataOperatingSystemModel.DedicatedHostOnly = core.BoolPtr(true)
				importOfferingBodyMetadataOperatingSystemModel.Vendor = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Name = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Href = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.DisplayName = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Family = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Version = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Architecture = core.StringPtr("testString")

				// Construct an instance of the ImportOfferingBodyMetadataFile model
				importOfferingBodyMetadataFileModel := new(catalogmanagementv1.ImportOfferingBodyMetadataFile)
				importOfferingBodyMetadataFileModel.Size = core.Int64Ptr(int64(38))

				// Construct an instance of the ImportOfferingBodyMetadataImagesItem model
				importOfferingBodyMetadataImagesItemModel := new(catalogmanagementv1.ImportOfferingBodyMetadataImagesItem)
				importOfferingBodyMetadataImagesItemModel.ID = core.StringPtr("testString")
				importOfferingBodyMetadataImagesItemModel.Name = core.StringPtr("testString")
				importOfferingBodyMetadataImagesItemModel.Region = core.StringPtr("testString")

				// Construct an instance of the ImportOfferingBodyMetadata model
				importOfferingBodyMetadataModel := new(catalogmanagementv1.ImportOfferingBodyMetadata)
				importOfferingBodyMetadataModel.OperatingSystem = importOfferingBodyMetadataOperatingSystemModel
				importOfferingBodyMetadataModel.File = importOfferingBodyMetadataFileModel
				importOfferingBodyMetadataModel.MinimumProvisionedSize = core.Int64Ptr(int64(38))
				importOfferingBodyMetadataModel.Images = []catalogmanagementv1.ImportOfferingBodyMetadataImagesItem{*importOfferingBodyMetadataImagesItemModel}

				// Construct an instance of the ImportOfferingOptions model
				importOfferingOptionsModel := new(catalogmanagementv1.ImportOfferingOptions)
				importOfferingOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				importOfferingOptionsModel.Tags = []string{"testString"}
				importOfferingOptionsModel.Keywords = []string{"testString"}
				importOfferingOptionsModel.Content = CreateMockByteArray("VGhpcyBpcyBhIG1vY2sgYnl0ZSBhcnJheSB2YWx1ZS4=")
				importOfferingOptionsModel.Name = core.StringPtr("testString")
				importOfferingOptionsModel.Label = core.StringPtr("testString")
				importOfferingOptionsModel.InstallKind = core.StringPtr("testString")
				importOfferingOptionsModel.TargetKinds = []string{"testString"}
				importOfferingOptionsModel.FormatKind = core.StringPtr("testString")
				importOfferingOptionsModel.ProductKind = core.StringPtr("testString")
				importOfferingOptionsModel.ProductKindLabel = core.StringPtr("testString")
				importOfferingOptionsModel.Sha = core.StringPtr("testString")
				importOfferingOptionsModel.Version = core.StringPtr("testString")
				importOfferingOptionsModel.Flavor = flavorModel
				importOfferingOptionsModel.Metadata = importOfferingBodyMetadataModel
				importOfferingOptionsModel.WorkingDirectory = core.StringPtr("testString")
				importOfferingOptionsModel.InstallType = core.StringPtr("testString")
				importOfferingOptionsModel.Zipurl = core.StringPtr("testString")
				importOfferingOptionsModel.OfferingID = core.StringPtr("testString")
				importOfferingOptionsModel.TargetVersion = core.StringPtr("testString")
				importOfferingOptionsModel.IncludeConfig = core.BoolPtr(true)
				importOfferingOptionsModel.IsVsi = core.BoolPtr(true)
				importOfferingOptionsModel.Repotype = core.StringPtr("testString")
				importOfferingOptionsModel.XAuthToken = core.StringPtr("testString")
				importOfferingOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.ImportOffering(importOfferingOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.ImportOffering(importOfferingOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ImportOffering(importOfferingOptions *ImportOfferingOptions)`, func() {
		importOfferingPath := "/catalogs/testString/import/offerings"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(importOfferingPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["X-Auth-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["zipurl"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["offeringID"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["targetVersion"]).To(Equal([]string{"testString"}))
					// TODO: Add check for includeConfig query parameter
					// TODO: Add check for isVSI query parameter
					Expect(req.URL.Query()["repotype"]).To(Equal([]string{"testString"}))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "name": "Name", "offering_icon_url": "OfferingIconURL", "offering_docs_url": "OfferingDocsURL", "offering_support_url": "OfferingSupportURL", "tags": ["Tags"], "keywords": ["Keywords"], "rating": {"one_star_count": 12, "two_star_count": 12, "three_star_count": 14, "four_star_count": 13}, "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "kinds": [{"id": "ID", "format_kind": "FormatKind", "format_kind_label": "FormatKindLabel", "install_kind": "InstallKind", "install_kind_label": "InstallKindLabel", "target_kind": "TargetKind", "target_kind_label": "TargetKindLabel", "metadata": {"anyKey": "anyValue"}, "tags": ["Tags"], "additional_features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "versions": [{"id": "ID", "_rev": "Rev", "crn": "CRN", "version": "Version", "flavor": {"name": "Name", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "index": 5}, "sha": "Sha", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "offering_id": "OfferingID", "catalog_id": "CatalogID", "kind_id": "KindID", "tags": ["Tags"], "repo_url": "RepoURL", "source_url": "SourceURL", "tgz_url": "TgzURL", "configuration": [{"key": "Key", "type": "Type", "default_value": "anyValue", "display_name": "DisplayName", "value_constraint": "ValueConstraint", "description": "Description", "required": true, "options": ["anyValue"], "hidden": true, "custom_config": {"type": "Type", "grouping": "Grouping", "original_grouping": "OriginalGrouping", "grouping_index": 13, "config_constraints": {"anyKey": "anyValue"}, "associations": {"parameters": [{"name": "Name", "optionsRefresh": true}]}}, "type_metadata": "TypeMetadata"}], "outputs": [{"key": "Key", "description": "Description"}], "iam_permissions": [{"service_name": "ServiceName", "role_crns": ["RoleCrns"], "resources": [{"name": "Name", "description": "Description", "role_crns": ["RoleCrns"]}]}], "metadata": {"anyKey": "anyValue"}, "validation": {"validated": "2019-01-01T12:00:00.000Z", "requested": "2019-01-01T12:00:00.000Z", "state": "State", "last_operation": "LastOperation", "target": {"anyKey": "anyValue"}, "message": "Message"}, "required_resources": [{"type": "mem", "value": "anyValue"}], "single_instance": true, "schematics_env_values": {"value": "[{\"name\": \"TF_LOG\",\"value\": \"TRACE\",\"secure\": false,\"hidden\": false}]", "sm_ref": "cmsm_v1:{\"name\": \"envVarSecret\",\"id\":\"1234567890\",\"service_id\":\"crn:v1:bluemix:public:secrets-manager:eu-gb:a/1234567890:1234567890::\",\"service_name\":\"My SM Instance\",\"group_id\":\"1234567890\",\"group_name\":\"My SM Group\",\"resource_group_id\":\"1234567890\",\"region\":\"eu-gb\",\"type\":\"arbitrary\"}"}, "install": {"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}, "pre_install": [{"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}], "scripts": {"mapKey": {"short_description": "ShortDescription", "type": "ansible", "path": "scripts/validate-post-ansible-playbook.yaml", "stage": "pre", "action": "validate"}}, "entitlement": {"provider_name": "ProviderName", "provider_id": "ProviderID", "product_id": "ProductID", "part_numbers": ["PartNumbers"], "image_repo_name": "ImageRepoName"}, "licenses": [{"id": "ID", "name": "Name", "type": "Type", "url": "URL", "description": "Description"}], "image_manifest_url": "ImageManifestURL", "deprecated": true, "package_version": "PackageVersion", "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "version_locator": "VersionLocator", "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "whitelisted_accounts": ["WhitelistedAccounts"], "image_pull_key_name": "ImagePullKeyName", "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "solution_info": {"architecture_diagrams": [{"diagram": {"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "cost_estimate": {"version": "Version", "currency": "Currency", "projects": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "pastBreakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "breakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "diff": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}}], "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}, "totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "pastTotalHourlyCost": "PastTotalHourlyCost", "pastTotalMonthlyCost": "PastTotalMonthlyCost", "diffTotalHourlyCost": "DiffTotalHourlyCost", "diffTotalMonthlyCost": "DiffTotalMonthlyCost", "timeGenerated": "2019-01-01T12:00:00.000Z"}, "dependencies": [{"catalog_id": "CatalogID", "id": "ID", "name": "Name", "kind": "Kind", "version": "Version", "description": "Description", "default_flavor": "DefaultFlavor", "flavors": ["Flavors"], "optional": true, "on_by_default": false}], "install_type": "InstallType"}, "is_consumable": true, "compliance_v3": {"authority": "Authority", "claims": {"profiles": [{"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}], "controls": [{"profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "names": ["Names"]}]}, "evaluations": [{"scan_id": "ScanID", "account_id": "AccountID", "profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "result": {"failure_count": 12, "scan_time": "2019-01-01T12:00:00.000Z", "error_message": "ErrorMessage", "complete_scan": true, "unscanned_resources": ["UnscannedResources"]}, "controls": [{"id": "ID", "name": "Name", "description": "Description", "specifications": [{"id": "ID", "description": "Description", "component_name": "ComponentName", "assessments": [{"id": "ID", "description": "Description", "version": "Version", "type": "Type", "method": "Method", "ui_href": "UIHref"}], "ui_href": "UIHref"}], "failure_count": 12, "pass_count": 9, "parent": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "parent_name": "ParentName", "specifications": [{"id": "ID", "description": "Description", "component_name": "ComponentName", "assessments": [{"id": "ID", "description": "Description", "version": "Version", "type": "Type", "method": "Method", "ui_href": "UIHref"}], "ui_href": "UIHref"}], "ui_href": "UIHref"}, "ui_href": "UIHref"}]}]}, "change_notices": {"breaking": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "new": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "update": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}]}, "plan_ids": ["PlanIds"], "stack": {"anyKey": "anyValue"}, "minimum_compatible_version": "MinimumCompatibleVersion"}], "all_versions": {"first": {"href": "Href", "start": "Start"}, "next": {"href": "Href", "start": "Start"}}}], "publish": {"pc_managed": false, "approval_type": "ApprovalType", "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "original_crn": "OriginalCRN", "public_crn": "PublicCRN", "approval_record": {"anyKey": "anyValue"}, "permit_ibm_public_publish": true, "ibm_approved": false, "public_approved": true}, "pc_managed": false, "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "public_original_crn": "PublicOriginalCRN", "publish_public_crn": "PublishPublicCRN", "portal_approval_record": "PortalApprovalRecord", "portal_ui_url": "PortalUIURL", "catalog_id": "CatalogID", "catalog_name": "CatalogName", "metadata": {"anyKey": "anyValue"}, "disclaimer": "Disclaimer", "hidden": true, "provider": "Provider", "provider_info": {"id": "ID", "name": "Name"}, "repo_info": {"token": "Token", "type": "Type"}, "image_pull_keys": [{"name": "Name", "value": "Value", "description": "Description"}], "support": {"url": "URL", "process": "Process", "process_i18n": {"mapKey": "Inner"}, "locations": ["Locations"], "support_details": [{"type": "Type", "contact": "Contact", "response_wait_time": {"value": 5, "type": "Type"}, "availability": {"times": [{"day": 3, "start_time": "StartTime", "end_time": "EndTime"}], "timezone": "Timezone", "always_available": false}}], "support_escalation": {"escalation_wait_time": {"value": 5, "type": "Type"}, "response_wait_time": {"value": 5, "type": "Type"}, "contact": "Contact"}, "support_type": "SupportType"}, "media": [{"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}], "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "product_kind": "ProductKind", "badges": [{"id": "ID", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}, "icon": "Icon", "authority": "Authority", "tag": "Tag", "learn_more_links": {"first_party": "FirstParty", "third_party": "ThirdParty"}, "constraints": [{"type": "Type", "rule": "anyValue"}]}], "plans": [{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "offering_id": "OfferingID", "catalog_id": "CatalogID", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "name": "Name", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "pricing_tags": ["PricingTags"], "version_range": {"kinds": ["Kinds"], "version": "Version", "flavors": ["Flavors"]}, "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "metadata": {"anyKey": "anyValue"}, "publish_approved": false}]}`)
				}))
			})
			It(`Invoke ImportOffering successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the Flavor model
				flavorModel := new(catalogmanagementv1.Flavor)
				flavorModel.Name = core.StringPtr("testString")
				flavorModel.Label = core.StringPtr("testString")
				flavorModel.LabelI18n = map[string]string{"key1": "testString"}
				flavorModel.Index = core.Int64Ptr(int64(38))

				// Construct an instance of the ImportOfferingBodyMetadataOperatingSystem model
				importOfferingBodyMetadataOperatingSystemModel := new(catalogmanagementv1.ImportOfferingBodyMetadataOperatingSystem)
				importOfferingBodyMetadataOperatingSystemModel.DedicatedHostOnly = core.BoolPtr(true)
				importOfferingBodyMetadataOperatingSystemModel.Vendor = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Name = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Href = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.DisplayName = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Family = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Version = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Architecture = core.StringPtr("testString")

				// Construct an instance of the ImportOfferingBodyMetadataFile model
				importOfferingBodyMetadataFileModel := new(catalogmanagementv1.ImportOfferingBodyMetadataFile)
				importOfferingBodyMetadataFileModel.Size = core.Int64Ptr(int64(38))

				// Construct an instance of the ImportOfferingBodyMetadataImagesItem model
				importOfferingBodyMetadataImagesItemModel := new(catalogmanagementv1.ImportOfferingBodyMetadataImagesItem)
				importOfferingBodyMetadataImagesItemModel.ID = core.StringPtr("testString")
				importOfferingBodyMetadataImagesItemModel.Name = core.StringPtr("testString")
				importOfferingBodyMetadataImagesItemModel.Region = core.StringPtr("testString")

				// Construct an instance of the ImportOfferingBodyMetadata model
				importOfferingBodyMetadataModel := new(catalogmanagementv1.ImportOfferingBodyMetadata)
				importOfferingBodyMetadataModel.OperatingSystem = importOfferingBodyMetadataOperatingSystemModel
				importOfferingBodyMetadataModel.File = importOfferingBodyMetadataFileModel
				importOfferingBodyMetadataModel.MinimumProvisionedSize = core.Int64Ptr(int64(38))
				importOfferingBodyMetadataModel.Images = []catalogmanagementv1.ImportOfferingBodyMetadataImagesItem{*importOfferingBodyMetadataImagesItemModel}

				// Construct an instance of the ImportOfferingOptions model
				importOfferingOptionsModel := new(catalogmanagementv1.ImportOfferingOptions)
				importOfferingOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				importOfferingOptionsModel.Tags = []string{"testString"}
				importOfferingOptionsModel.Keywords = []string{"testString"}
				importOfferingOptionsModel.Content = CreateMockByteArray("VGhpcyBpcyBhIG1vY2sgYnl0ZSBhcnJheSB2YWx1ZS4=")
				importOfferingOptionsModel.Name = core.StringPtr("testString")
				importOfferingOptionsModel.Label = core.StringPtr("testString")
				importOfferingOptionsModel.InstallKind = core.StringPtr("testString")
				importOfferingOptionsModel.TargetKinds = []string{"testString"}
				importOfferingOptionsModel.FormatKind = core.StringPtr("testString")
				importOfferingOptionsModel.ProductKind = core.StringPtr("testString")
				importOfferingOptionsModel.ProductKindLabel = core.StringPtr("testString")
				importOfferingOptionsModel.Sha = core.StringPtr("testString")
				importOfferingOptionsModel.Version = core.StringPtr("testString")
				importOfferingOptionsModel.Flavor = flavorModel
				importOfferingOptionsModel.Metadata = importOfferingBodyMetadataModel
				importOfferingOptionsModel.WorkingDirectory = core.StringPtr("testString")
				importOfferingOptionsModel.InstallType = core.StringPtr("testString")
				importOfferingOptionsModel.Zipurl = core.StringPtr("testString")
				importOfferingOptionsModel.OfferingID = core.StringPtr("testString")
				importOfferingOptionsModel.TargetVersion = core.StringPtr("testString")
				importOfferingOptionsModel.IncludeConfig = core.BoolPtr(true)
				importOfferingOptionsModel.IsVsi = core.BoolPtr(true)
				importOfferingOptionsModel.Repotype = core.StringPtr("testString")
				importOfferingOptionsModel.XAuthToken = core.StringPtr("testString")
				importOfferingOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.ImportOfferingWithContext(ctx, importOfferingOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.ImportOffering(importOfferingOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.ImportOfferingWithContext(ctx, importOfferingOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(importOfferingPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["X-Auth-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["zipurl"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["offeringID"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["targetVersion"]).To(Equal([]string{"testString"}))
					// TODO: Add check for includeConfig query parameter
					// TODO: Add check for isVSI query parameter
					Expect(req.URL.Query()["repotype"]).To(Equal([]string{"testString"}))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "name": "Name", "offering_icon_url": "OfferingIconURL", "offering_docs_url": "OfferingDocsURL", "offering_support_url": "OfferingSupportURL", "tags": ["Tags"], "keywords": ["Keywords"], "rating": {"one_star_count": 12, "two_star_count": 12, "three_star_count": 14, "four_star_count": 13}, "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "kinds": [{"id": "ID", "format_kind": "FormatKind", "format_kind_label": "FormatKindLabel", "install_kind": "InstallKind", "install_kind_label": "InstallKindLabel", "target_kind": "TargetKind", "target_kind_label": "TargetKindLabel", "metadata": {"anyKey": "anyValue"}, "tags": ["Tags"], "additional_features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "versions": [{"id": "ID", "_rev": "Rev", "crn": "CRN", "version": "Version", "flavor": {"name": "Name", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "index": 5}, "sha": "Sha", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "offering_id": "OfferingID", "catalog_id": "CatalogID", "kind_id": "KindID", "tags": ["Tags"], "repo_url": "RepoURL", "source_url": "SourceURL", "tgz_url": "TgzURL", "configuration": [{"key": "Key", "type": "Type", "default_value": "anyValue", "display_name": "DisplayName", "value_constraint": "ValueConstraint", "description": "Description", "required": true, "options": ["anyValue"], "hidden": true, "custom_config": {"type": "Type", "grouping": "Grouping", "original_grouping": "OriginalGrouping", "grouping_index": 13, "config_constraints": {"anyKey": "anyValue"}, "associations": {"parameters": [{"name": "Name", "optionsRefresh": true}]}}, "type_metadata": "TypeMetadata"}], "outputs": [{"key": "Key", "description": "Description"}], "iam_permissions": [{"service_name": "ServiceName", "role_crns": ["RoleCrns"], "resources": [{"name": "Name", "description": "Description", "role_crns": ["RoleCrns"]}]}], "metadata": {"anyKey": "anyValue"}, "validation": {"validated": "2019-01-01T12:00:00.000Z", "requested": "2019-01-01T12:00:00.000Z", "state": "State", "last_operation": "LastOperation", "target": {"anyKey": "anyValue"}, "message": "Message"}, "required_resources": [{"type": "mem", "value": "anyValue"}], "single_instance": true, "schematics_env_values": {"value": "[{\"name\": \"TF_LOG\",\"value\": \"TRACE\",\"secure\": false,\"hidden\": false}]", "sm_ref": "cmsm_v1:{\"name\": \"envVarSecret\",\"id\":\"1234567890\",\"service_id\":\"crn:v1:bluemix:public:secrets-manager:eu-gb:a/1234567890:1234567890::\",\"service_name\":\"My SM Instance\",\"group_id\":\"1234567890\",\"group_name\":\"My SM Group\",\"resource_group_id\":\"1234567890\",\"region\":\"eu-gb\",\"type\":\"arbitrary\"}"}, "install": {"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}, "pre_install": [{"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}], "scripts": {"mapKey": {"short_description": "ShortDescription", "type": "ansible", "path": "scripts/validate-post-ansible-playbook.yaml", "stage": "pre", "action": "validate"}}, "entitlement": {"provider_name": "ProviderName", "provider_id": "ProviderID", "product_id": "ProductID", "part_numbers": ["PartNumbers"], "image_repo_name": "ImageRepoName"}, "licenses": [{"id": "ID", "name": "Name", "type": "Type", "url": "URL", "description": "Description"}], "image_manifest_url": "ImageManifestURL", "deprecated": true, "package_version": "PackageVersion", "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "version_locator": "VersionLocator", "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "whitelisted_accounts": ["WhitelistedAccounts"], "image_pull_key_name": "ImagePullKeyName", "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "solution_info": {"architecture_diagrams": [{"diagram": {"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "cost_estimate": {"version": "Version", "currency": "Currency", "projects": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "pastBreakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "breakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "diff": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}}], "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}, "totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "pastTotalHourlyCost": "PastTotalHourlyCost", "pastTotalMonthlyCost": "PastTotalMonthlyCost", "diffTotalHourlyCost": "DiffTotalHourlyCost", "diffTotalMonthlyCost": "DiffTotalMonthlyCost", "timeGenerated": "2019-01-01T12:00:00.000Z"}, "dependencies": [{"catalog_id": "CatalogID", "id": "ID", "name": "Name", "kind": "Kind", "version": "Version", "description": "Description", "default_flavor": "DefaultFlavor", "flavors": ["Flavors"], "optional": true, "on_by_default": false}], "install_type": "InstallType"}, "is_consumable": true, "compliance_v3": {"authority": "Authority", "claims": {"profiles": [{"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}], "controls": [{"profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "names": ["Names"]}]}, "evaluations": [{"scan_id": "ScanID", "account_id": "AccountID", "profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "result": {"failure_count": 12, "scan_time": "2019-01-01T12:00:00.000Z", "error_message": "ErrorMessage", "complete_scan": true, "unscanned_resources": ["UnscannedResources"]}, "controls": [{"id": "ID", "name": "Name", "description": "Description", "specifications": [{"id": "ID", "description": "Description", "component_name": "ComponentName", "assessments": [{"id": "ID", "description": "Description", "version": "Version", "type": "Type", "method": "Method", "ui_href": "UIHref"}], "ui_href": "UIHref"}], "failure_count": 12, "pass_count": 9, "parent": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "parent_name": "ParentName", "specifications": [{"id": "ID", "description": "Description", "component_name": "ComponentName", "assessments": [{"id": "ID", "description": "Description", "version": "Version", "type": "Type", "method": "Method", "ui_href": "UIHref"}], "ui_href": "UIHref"}], "ui_href": "UIHref"}, "ui_href": "UIHref"}]}]}, "change_notices": {"breaking": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "new": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "update": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}]}, "plan_ids": ["PlanIds"], "stack": {"anyKey": "anyValue"}, "minimum_compatible_version": "MinimumCompatibleVersion"}], "all_versions": {"first": {"href": "Href", "start": "Start"}, "next": {"href": "Href", "start": "Start"}}}], "publish": {"pc_managed": false, "approval_type": "ApprovalType", "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "original_crn": "OriginalCRN", "public_crn": "PublicCRN", "approval_record": {"anyKey": "anyValue"}, "permit_ibm_public_publish": true, "ibm_approved": false, "public_approved": true}, "pc_managed": false, "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "public_original_crn": "PublicOriginalCRN", "publish_public_crn": "PublishPublicCRN", "portal_approval_record": "PortalApprovalRecord", "portal_ui_url": "PortalUIURL", "catalog_id": "CatalogID", "catalog_name": "CatalogName", "metadata": {"anyKey": "anyValue"}, "disclaimer": "Disclaimer", "hidden": true, "provider": "Provider", "provider_info": {"id": "ID", "name": "Name"}, "repo_info": {"token": "Token", "type": "Type"}, "image_pull_keys": [{"name": "Name", "value": "Value", "description": "Description"}], "support": {"url": "URL", "process": "Process", "process_i18n": {"mapKey": "Inner"}, "locations": ["Locations"], "support_details": [{"type": "Type", "contact": "Contact", "response_wait_time": {"value": 5, "type": "Type"}, "availability": {"times": [{"day": 3, "start_time": "StartTime", "end_time": "EndTime"}], "timezone": "Timezone", "always_available": false}}], "support_escalation": {"escalation_wait_time": {"value": 5, "type": "Type"}, "response_wait_time": {"value": 5, "type": "Type"}, "contact": "Contact"}, "support_type": "SupportType"}, "media": [{"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}], "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "product_kind": "ProductKind", "badges": [{"id": "ID", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}, "icon": "Icon", "authority": "Authority", "tag": "Tag", "learn_more_links": {"first_party": "FirstParty", "third_party": "ThirdParty"}, "constraints": [{"type": "Type", "rule": "anyValue"}]}], "plans": [{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "offering_id": "OfferingID", "catalog_id": "CatalogID", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "name": "Name", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "pricing_tags": ["PricingTags"], "version_range": {"kinds": ["Kinds"], "version": "Version", "flavors": ["Flavors"]}, "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "metadata": {"anyKey": "anyValue"}, "publish_approved": false}]}`)
				}))
			})
			It(`Invoke ImportOffering successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.ImportOffering(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the Flavor model
				flavorModel := new(catalogmanagementv1.Flavor)
				flavorModel.Name = core.StringPtr("testString")
				flavorModel.Label = core.StringPtr("testString")
				flavorModel.LabelI18n = map[string]string{"key1": "testString"}
				flavorModel.Index = core.Int64Ptr(int64(38))

				// Construct an instance of the ImportOfferingBodyMetadataOperatingSystem model
				importOfferingBodyMetadataOperatingSystemModel := new(catalogmanagementv1.ImportOfferingBodyMetadataOperatingSystem)
				importOfferingBodyMetadataOperatingSystemModel.DedicatedHostOnly = core.BoolPtr(true)
				importOfferingBodyMetadataOperatingSystemModel.Vendor = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Name = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Href = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.DisplayName = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Family = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Version = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Architecture = core.StringPtr("testString")

				// Construct an instance of the ImportOfferingBodyMetadataFile model
				importOfferingBodyMetadataFileModel := new(catalogmanagementv1.ImportOfferingBodyMetadataFile)
				importOfferingBodyMetadataFileModel.Size = core.Int64Ptr(int64(38))

				// Construct an instance of the ImportOfferingBodyMetadataImagesItem model
				importOfferingBodyMetadataImagesItemModel := new(catalogmanagementv1.ImportOfferingBodyMetadataImagesItem)
				importOfferingBodyMetadataImagesItemModel.ID = core.StringPtr("testString")
				importOfferingBodyMetadataImagesItemModel.Name = core.StringPtr("testString")
				importOfferingBodyMetadataImagesItemModel.Region = core.StringPtr("testString")

				// Construct an instance of the ImportOfferingBodyMetadata model
				importOfferingBodyMetadataModel := new(catalogmanagementv1.ImportOfferingBodyMetadata)
				importOfferingBodyMetadataModel.OperatingSystem = importOfferingBodyMetadataOperatingSystemModel
				importOfferingBodyMetadataModel.File = importOfferingBodyMetadataFileModel
				importOfferingBodyMetadataModel.MinimumProvisionedSize = core.Int64Ptr(int64(38))
				importOfferingBodyMetadataModel.Images = []catalogmanagementv1.ImportOfferingBodyMetadataImagesItem{*importOfferingBodyMetadataImagesItemModel}

				// Construct an instance of the ImportOfferingOptions model
				importOfferingOptionsModel := new(catalogmanagementv1.ImportOfferingOptions)
				importOfferingOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				importOfferingOptionsModel.Tags = []string{"testString"}
				importOfferingOptionsModel.Keywords = []string{"testString"}
				importOfferingOptionsModel.Content = CreateMockByteArray("VGhpcyBpcyBhIG1vY2sgYnl0ZSBhcnJheSB2YWx1ZS4=")
				importOfferingOptionsModel.Name = core.StringPtr("testString")
				importOfferingOptionsModel.Label = core.StringPtr("testString")
				importOfferingOptionsModel.InstallKind = core.StringPtr("testString")
				importOfferingOptionsModel.TargetKinds = []string{"testString"}
				importOfferingOptionsModel.FormatKind = core.StringPtr("testString")
				importOfferingOptionsModel.ProductKind = core.StringPtr("testString")
				importOfferingOptionsModel.ProductKindLabel = core.StringPtr("testString")
				importOfferingOptionsModel.Sha = core.StringPtr("testString")
				importOfferingOptionsModel.Version = core.StringPtr("testString")
				importOfferingOptionsModel.Flavor = flavorModel
				importOfferingOptionsModel.Metadata = importOfferingBodyMetadataModel
				importOfferingOptionsModel.WorkingDirectory = core.StringPtr("testString")
				importOfferingOptionsModel.InstallType = core.StringPtr("testString")
				importOfferingOptionsModel.Zipurl = core.StringPtr("testString")
				importOfferingOptionsModel.OfferingID = core.StringPtr("testString")
				importOfferingOptionsModel.TargetVersion = core.StringPtr("testString")
				importOfferingOptionsModel.IncludeConfig = core.BoolPtr(true)
				importOfferingOptionsModel.IsVsi = core.BoolPtr(true)
				importOfferingOptionsModel.Repotype = core.StringPtr("testString")
				importOfferingOptionsModel.XAuthToken = core.StringPtr("testString")
				importOfferingOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.ImportOffering(importOfferingOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ImportOffering with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the Flavor model
				flavorModel := new(catalogmanagementv1.Flavor)
				flavorModel.Name = core.StringPtr("testString")
				flavorModel.Label = core.StringPtr("testString")
				flavorModel.LabelI18n = map[string]string{"key1": "testString"}
				flavorModel.Index = core.Int64Ptr(int64(38))

				// Construct an instance of the ImportOfferingBodyMetadataOperatingSystem model
				importOfferingBodyMetadataOperatingSystemModel := new(catalogmanagementv1.ImportOfferingBodyMetadataOperatingSystem)
				importOfferingBodyMetadataOperatingSystemModel.DedicatedHostOnly = core.BoolPtr(true)
				importOfferingBodyMetadataOperatingSystemModel.Vendor = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Name = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Href = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.DisplayName = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Family = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Version = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Architecture = core.StringPtr("testString")

				// Construct an instance of the ImportOfferingBodyMetadataFile model
				importOfferingBodyMetadataFileModel := new(catalogmanagementv1.ImportOfferingBodyMetadataFile)
				importOfferingBodyMetadataFileModel.Size = core.Int64Ptr(int64(38))

				// Construct an instance of the ImportOfferingBodyMetadataImagesItem model
				importOfferingBodyMetadataImagesItemModel := new(catalogmanagementv1.ImportOfferingBodyMetadataImagesItem)
				importOfferingBodyMetadataImagesItemModel.ID = core.StringPtr("testString")
				importOfferingBodyMetadataImagesItemModel.Name = core.StringPtr("testString")
				importOfferingBodyMetadataImagesItemModel.Region = core.StringPtr("testString")

				// Construct an instance of the ImportOfferingBodyMetadata model
				importOfferingBodyMetadataModel := new(catalogmanagementv1.ImportOfferingBodyMetadata)
				importOfferingBodyMetadataModel.OperatingSystem = importOfferingBodyMetadataOperatingSystemModel
				importOfferingBodyMetadataModel.File = importOfferingBodyMetadataFileModel
				importOfferingBodyMetadataModel.MinimumProvisionedSize = core.Int64Ptr(int64(38))
				importOfferingBodyMetadataModel.Images = []catalogmanagementv1.ImportOfferingBodyMetadataImagesItem{*importOfferingBodyMetadataImagesItemModel}

				// Construct an instance of the ImportOfferingOptions model
				importOfferingOptionsModel := new(catalogmanagementv1.ImportOfferingOptions)
				importOfferingOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				importOfferingOptionsModel.Tags = []string{"testString"}
				importOfferingOptionsModel.Keywords = []string{"testString"}
				importOfferingOptionsModel.Content = CreateMockByteArray("VGhpcyBpcyBhIG1vY2sgYnl0ZSBhcnJheSB2YWx1ZS4=")
				importOfferingOptionsModel.Name = core.StringPtr("testString")
				importOfferingOptionsModel.Label = core.StringPtr("testString")
				importOfferingOptionsModel.InstallKind = core.StringPtr("testString")
				importOfferingOptionsModel.TargetKinds = []string{"testString"}
				importOfferingOptionsModel.FormatKind = core.StringPtr("testString")
				importOfferingOptionsModel.ProductKind = core.StringPtr("testString")
				importOfferingOptionsModel.ProductKindLabel = core.StringPtr("testString")
				importOfferingOptionsModel.Sha = core.StringPtr("testString")
				importOfferingOptionsModel.Version = core.StringPtr("testString")
				importOfferingOptionsModel.Flavor = flavorModel
				importOfferingOptionsModel.Metadata = importOfferingBodyMetadataModel
				importOfferingOptionsModel.WorkingDirectory = core.StringPtr("testString")
				importOfferingOptionsModel.InstallType = core.StringPtr("testString")
				importOfferingOptionsModel.Zipurl = core.StringPtr("testString")
				importOfferingOptionsModel.OfferingID = core.StringPtr("testString")
				importOfferingOptionsModel.TargetVersion = core.StringPtr("testString")
				importOfferingOptionsModel.IncludeConfig = core.BoolPtr(true)
				importOfferingOptionsModel.IsVsi = core.BoolPtr(true)
				importOfferingOptionsModel.Repotype = core.StringPtr("testString")
				importOfferingOptionsModel.XAuthToken = core.StringPtr("testString")
				importOfferingOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.ImportOffering(importOfferingOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the ImportOfferingOptions model with no property values
				importOfferingOptionsModelNew := new(catalogmanagementv1.ImportOfferingOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.ImportOffering(importOfferingOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(201)
				}))
			})
			It(`Invoke ImportOffering successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the Flavor model
				flavorModel := new(catalogmanagementv1.Flavor)
				flavorModel.Name = core.StringPtr("testString")
				flavorModel.Label = core.StringPtr("testString")
				flavorModel.LabelI18n = map[string]string{"key1": "testString"}
				flavorModel.Index = core.Int64Ptr(int64(38))

				// Construct an instance of the ImportOfferingBodyMetadataOperatingSystem model
				importOfferingBodyMetadataOperatingSystemModel := new(catalogmanagementv1.ImportOfferingBodyMetadataOperatingSystem)
				importOfferingBodyMetadataOperatingSystemModel.DedicatedHostOnly = core.BoolPtr(true)
				importOfferingBodyMetadataOperatingSystemModel.Vendor = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Name = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Href = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.DisplayName = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Family = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Version = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Architecture = core.StringPtr("testString")

				// Construct an instance of the ImportOfferingBodyMetadataFile model
				importOfferingBodyMetadataFileModel := new(catalogmanagementv1.ImportOfferingBodyMetadataFile)
				importOfferingBodyMetadataFileModel.Size = core.Int64Ptr(int64(38))

				// Construct an instance of the ImportOfferingBodyMetadataImagesItem model
				importOfferingBodyMetadataImagesItemModel := new(catalogmanagementv1.ImportOfferingBodyMetadataImagesItem)
				importOfferingBodyMetadataImagesItemModel.ID = core.StringPtr("testString")
				importOfferingBodyMetadataImagesItemModel.Name = core.StringPtr("testString")
				importOfferingBodyMetadataImagesItemModel.Region = core.StringPtr("testString")

				// Construct an instance of the ImportOfferingBodyMetadata model
				importOfferingBodyMetadataModel := new(catalogmanagementv1.ImportOfferingBodyMetadata)
				importOfferingBodyMetadataModel.OperatingSystem = importOfferingBodyMetadataOperatingSystemModel
				importOfferingBodyMetadataModel.File = importOfferingBodyMetadataFileModel
				importOfferingBodyMetadataModel.MinimumProvisionedSize = core.Int64Ptr(int64(38))
				importOfferingBodyMetadataModel.Images = []catalogmanagementv1.ImportOfferingBodyMetadataImagesItem{*importOfferingBodyMetadataImagesItemModel}

				// Construct an instance of the ImportOfferingOptions model
				importOfferingOptionsModel := new(catalogmanagementv1.ImportOfferingOptions)
				importOfferingOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				importOfferingOptionsModel.Tags = []string{"testString"}
				importOfferingOptionsModel.Keywords = []string{"testString"}
				importOfferingOptionsModel.Content = CreateMockByteArray("VGhpcyBpcyBhIG1vY2sgYnl0ZSBhcnJheSB2YWx1ZS4=")
				importOfferingOptionsModel.Name = core.StringPtr("testString")
				importOfferingOptionsModel.Label = core.StringPtr("testString")
				importOfferingOptionsModel.InstallKind = core.StringPtr("testString")
				importOfferingOptionsModel.TargetKinds = []string{"testString"}
				importOfferingOptionsModel.FormatKind = core.StringPtr("testString")
				importOfferingOptionsModel.ProductKind = core.StringPtr("testString")
				importOfferingOptionsModel.ProductKindLabel = core.StringPtr("testString")
				importOfferingOptionsModel.Sha = core.StringPtr("testString")
				importOfferingOptionsModel.Version = core.StringPtr("testString")
				importOfferingOptionsModel.Flavor = flavorModel
				importOfferingOptionsModel.Metadata = importOfferingBodyMetadataModel
				importOfferingOptionsModel.WorkingDirectory = core.StringPtr("testString")
				importOfferingOptionsModel.InstallType = core.StringPtr("testString")
				importOfferingOptionsModel.Zipurl = core.StringPtr("testString")
				importOfferingOptionsModel.OfferingID = core.StringPtr("testString")
				importOfferingOptionsModel.TargetVersion = core.StringPtr("testString")
				importOfferingOptionsModel.IncludeConfig = core.BoolPtr(true)
				importOfferingOptionsModel.IsVsi = core.BoolPtr(true)
				importOfferingOptionsModel.Repotype = core.StringPtr("testString")
				importOfferingOptionsModel.XAuthToken = core.StringPtr("testString")
				importOfferingOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.ImportOffering(importOfferingOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ReloadOffering(reloadOfferingOptions *ReloadOfferingOptions) - Operation response error`, func() {
		reloadOfferingPath := "/catalogs/testString/offerings/testString/reload"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(reloadOfferingPath))
					Expect(req.Method).To(Equal("PUT"))
					Expect(req.URL.Query()["targetVersion"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["zipurl"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["repoType"]).To(Equal([]string{"testString"}))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ReloadOffering with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the Flavor model
				flavorModel := new(catalogmanagementv1.Flavor)
				flavorModel.Name = core.StringPtr("testString")
				flavorModel.Label = core.StringPtr("testString")
				flavorModel.LabelI18n = map[string]string{"key1": "testString"}
				flavorModel.Index = core.Int64Ptr(int64(38))

				// Construct an instance of the ReloadOfferingOptions model
				reloadOfferingOptionsModel := new(catalogmanagementv1.ReloadOfferingOptions)
				reloadOfferingOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				reloadOfferingOptionsModel.OfferingID = core.StringPtr("testString")
				reloadOfferingOptionsModel.TargetVersion = core.StringPtr("testString")
				reloadOfferingOptionsModel.Tags = []string{"testString"}
				reloadOfferingOptionsModel.Content = CreateMockByteArray("VGhpcyBpcyBhIG1vY2sgYnl0ZSBhcnJheSB2YWx1ZS4=")
				reloadOfferingOptionsModel.TargetKinds = []string{"testString"}
				reloadOfferingOptionsModel.FormatKind = core.StringPtr("testString")
				reloadOfferingOptionsModel.Flavor = flavorModel
				reloadOfferingOptionsModel.WorkingDirectory = core.StringPtr("testString")
				reloadOfferingOptionsModel.InstallType = core.StringPtr("testString")
				reloadOfferingOptionsModel.Zipurl = core.StringPtr("testString")
				reloadOfferingOptionsModel.RepoType = core.StringPtr("testString")
				reloadOfferingOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.ReloadOffering(reloadOfferingOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.ReloadOffering(reloadOfferingOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ReloadOffering(reloadOfferingOptions *ReloadOfferingOptions)`, func() {
		reloadOfferingPath := "/catalogs/testString/offerings/testString/reload"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(reloadOfferingPath))
					Expect(req.Method).To(Equal("PUT"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.URL.Query()["targetVersion"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["zipurl"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["repoType"]).To(Equal([]string{"testString"}))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "name": "Name", "offering_icon_url": "OfferingIconURL", "offering_docs_url": "OfferingDocsURL", "offering_support_url": "OfferingSupportURL", "tags": ["Tags"], "keywords": ["Keywords"], "rating": {"one_star_count": 12, "two_star_count": 12, "three_star_count": 14, "four_star_count": 13}, "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "kinds": [{"id": "ID", "format_kind": "FormatKind", "format_kind_label": "FormatKindLabel", "install_kind": "InstallKind", "install_kind_label": "InstallKindLabel", "target_kind": "TargetKind", "target_kind_label": "TargetKindLabel", "metadata": {"anyKey": "anyValue"}, "tags": ["Tags"], "additional_features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "versions": [{"id": "ID", "_rev": "Rev", "crn": "CRN", "version": "Version", "flavor": {"name": "Name", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "index": 5}, "sha": "Sha", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "offering_id": "OfferingID", "catalog_id": "CatalogID", "kind_id": "KindID", "tags": ["Tags"], "repo_url": "RepoURL", "source_url": "SourceURL", "tgz_url": "TgzURL", "configuration": [{"key": "Key", "type": "Type", "default_value": "anyValue", "display_name": "DisplayName", "value_constraint": "ValueConstraint", "description": "Description", "required": true, "options": ["anyValue"], "hidden": true, "custom_config": {"type": "Type", "grouping": "Grouping", "original_grouping": "OriginalGrouping", "grouping_index": 13, "config_constraints": {"anyKey": "anyValue"}, "associations": {"parameters": [{"name": "Name", "optionsRefresh": true}]}}, "type_metadata": "TypeMetadata"}], "outputs": [{"key": "Key", "description": "Description"}], "iam_permissions": [{"service_name": "ServiceName", "role_crns": ["RoleCrns"], "resources": [{"name": "Name", "description": "Description", "role_crns": ["RoleCrns"]}]}], "metadata": {"anyKey": "anyValue"}, "validation": {"validated": "2019-01-01T12:00:00.000Z", "requested": "2019-01-01T12:00:00.000Z", "state": "State", "last_operation": "LastOperation", "target": {"anyKey": "anyValue"}, "message": "Message"}, "required_resources": [{"type": "mem", "value": "anyValue"}], "single_instance": true, "schematics_env_values": {"value": "[{\"name\": \"TF_LOG\",\"value\": \"TRACE\",\"secure\": false,\"hidden\": false}]", "sm_ref": "cmsm_v1:{\"name\": \"envVarSecret\",\"id\":\"1234567890\",\"service_id\":\"crn:v1:bluemix:public:secrets-manager:eu-gb:a/1234567890:1234567890::\",\"service_name\":\"My SM Instance\",\"group_id\":\"1234567890\",\"group_name\":\"My SM Group\",\"resource_group_id\":\"1234567890\",\"region\":\"eu-gb\",\"type\":\"arbitrary\"}"}, "install": {"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}, "pre_install": [{"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}], "scripts": {"mapKey": {"short_description": "ShortDescription", "type": "ansible", "path": "scripts/validate-post-ansible-playbook.yaml", "stage": "pre", "action": "validate"}}, "entitlement": {"provider_name": "ProviderName", "provider_id": "ProviderID", "product_id": "ProductID", "part_numbers": ["PartNumbers"], "image_repo_name": "ImageRepoName"}, "licenses": [{"id": "ID", "name": "Name", "type": "Type", "url": "URL", "description": "Description"}], "image_manifest_url": "ImageManifestURL", "deprecated": true, "package_version": "PackageVersion", "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "version_locator": "VersionLocator", "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "whitelisted_accounts": ["WhitelistedAccounts"], "image_pull_key_name": "ImagePullKeyName", "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "solution_info": {"architecture_diagrams": [{"diagram": {"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "cost_estimate": {"version": "Version", "currency": "Currency", "projects": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "pastBreakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "breakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "diff": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}}], "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}, "totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "pastTotalHourlyCost": "PastTotalHourlyCost", "pastTotalMonthlyCost": "PastTotalMonthlyCost", "diffTotalHourlyCost": "DiffTotalHourlyCost", "diffTotalMonthlyCost": "DiffTotalMonthlyCost", "timeGenerated": "2019-01-01T12:00:00.000Z"}, "dependencies": [{"catalog_id": "CatalogID", "id": "ID", "name": "Name", "kind": "Kind", "version": "Version", "description": "Description", "default_flavor": "DefaultFlavor", "flavors": ["Flavors"], "optional": true, "on_by_default": false}], "install_type": "InstallType"}, "is_consumable": true, "compliance_v3": {"authority": "Authority", "claims": {"profiles": [{"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}], "controls": [{"profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "names": ["Names"]}]}, "evaluations": [{"scan_id": "ScanID", "account_id": "AccountID", "profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "result": {"failure_count": 12, "scan_time": "2019-01-01T12:00:00.000Z", "error_message": "ErrorMessage", "complete_scan": true, "unscanned_resources": ["UnscannedResources"]}, "controls": [{"id": "ID", "name": "Name", "description": "Description", "specifications": [{"id": "ID", "description": "Description", "component_name": "ComponentName", "assessments": [{"id": "ID", "description": "Description", "version": "Version", "type": "Type", "method": "Method", "ui_href": "UIHref"}], "ui_href": "UIHref"}], "failure_count": 12, "pass_count": 9, "parent": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "parent_name": "ParentName", "specifications": [{"id": "ID", "description": "Description", "component_name": "ComponentName", "assessments": [{"id": "ID", "description": "Description", "version": "Version", "type": "Type", "method": "Method", "ui_href": "UIHref"}], "ui_href": "UIHref"}], "ui_href": "UIHref"}, "ui_href": "UIHref"}]}]}, "change_notices": {"breaking": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "new": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "update": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}]}, "plan_ids": ["PlanIds"], "stack": {"anyKey": "anyValue"}, "minimum_compatible_version": "MinimumCompatibleVersion"}], "all_versions": {"first": {"href": "Href", "start": "Start"}, "next": {"href": "Href", "start": "Start"}}}], "publish": {"pc_managed": false, "approval_type": "ApprovalType", "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "original_crn": "OriginalCRN", "public_crn": "PublicCRN", "approval_record": {"anyKey": "anyValue"}, "permit_ibm_public_publish": true, "ibm_approved": false, "public_approved": true}, "pc_managed": false, "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "public_original_crn": "PublicOriginalCRN", "publish_public_crn": "PublishPublicCRN", "portal_approval_record": "PortalApprovalRecord", "portal_ui_url": "PortalUIURL", "catalog_id": "CatalogID", "catalog_name": "CatalogName", "metadata": {"anyKey": "anyValue"}, "disclaimer": "Disclaimer", "hidden": true, "provider": "Provider", "provider_info": {"id": "ID", "name": "Name"}, "repo_info": {"token": "Token", "type": "Type"}, "image_pull_keys": [{"name": "Name", "value": "Value", "description": "Description"}], "support": {"url": "URL", "process": "Process", "process_i18n": {"mapKey": "Inner"}, "locations": ["Locations"], "support_details": [{"type": "Type", "contact": "Contact", "response_wait_time": {"value": 5, "type": "Type"}, "availability": {"times": [{"day": 3, "start_time": "StartTime", "end_time": "EndTime"}], "timezone": "Timezone", "always_available": false}}], "support_escalation": {"escalation_wait_time": {"value": 5, "type": "Type"}, "response_wait_time": {"value": 5, "type": "Type"}, "contact": "Contact"}, "support_type": "SupportType"}, "media": [{"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}], "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "product_kind": "ProductKind", "badges": [{"id": "ID", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}, "icon": "Icon", "authority": "Authority", "tag": "Tag", "learn_more_links": {"first_party": "FirstParty", "third_party": "ThirdParty"}, "constraints": [{"type": "Type", "rule": "anyValue"}]}], "plans": [{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "offering_id": "OfferingID", "catalog_id": "CatalogID", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "name": "Name", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "pricing_tags": ["PricingTags"], "version_range": {"kinds": ["Kinds"], "version": "Version", "flavors": ["Flavors"]}, "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "metadata": {"anyKey": "anyValue"}, "publish_approved": false}]}`)
				}))
			})
			It(`Invoke ReloadOffering successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the Flavor model
				flavorModel := new(catalogmanagementv1.Flavor)
				flavorModel.Name = core.StringPtr("testString")
				flavorModel.Label = core.StringPtr("testString")
				flavorModel.LabelI18n = map[string]string{"key1": "testString"}
				flavorModel.Index = core.Int64Ptr(int64(38))

				// Construct an instance of the ReloadOfferingOptions model
				reloadOfferingOptionsModel := new(catalogmanagementv1.ReloadOfferingOptions)
				reloadOfferingOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				reloadOfferingOptionsModel.OfferingID = core.StringPtr("testString")
				reloadOfferingOptionsModel.TargetVersion = core.StringPtr("testString")
				reloadOfferingOptionsModel.Tags = []string{"testString"}
				reloadOfferingOptionsModel.Content = CreateMockByteArray("VGhpcyBpcyBhIG1vY2sgYnl0ZSBhcnJheSB2YWx1ZS4=")
				reloadOfferingOptionsModel.TargetKinds = []string{"testString"}
				reloadOfferingOptionsModel.FormatKind = core.StringPtr("testString")
				reloadOfferingOptionsModel.Flavor = flavorModel
				reloadOfferingOptionsModel.WorkingDirectory = core.StringPtr("testString")
				reloadOfferingOptionsModel.InstallType = core.StringPtr("testString")
				reloadOfferingOptionsModel.Zipurl = core.StringPtr("testString")
				reloadOfferingOptionsModel.RepoType = core.StringPtr("testString")
				reloadOfferingOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.ReloadOfferingWithContext(ctx, reloadOfferingOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.ReloadOffering(reloadOfferingOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.ReloadOfferingWithContext(ctx, reloadOfferingOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(reloadOfferingPath))
					Expect(req.Method).To(Equal("PUT"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.URL.Query()["targetVersion"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["zipurl"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["repoType"]).To(Equal([]string{"testString"}))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "name": "Name", "offering_icon_url": "OfferingIconURL", "offering_docs_url": "OfferingDocsURL", "offering_support_url": "OfferingSupportURL", "tags": ["Tags"], "keywords": ["Keywords"], "rating": {"one_star_count": 12, "two_star_count": 12, "three_star_count": 14, "four_star_count": 13}, "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "kinds": [{"id": "ID", "format_kind": "FormatKind", "format_kind_label": "FormatKindLabel", "install_kind": "InstallKind", "install_kind_label": "InstallKindLabel", "target_kind": "TargetKind", "target_kind_label": "TargetKindLabel", "metadata": {"anyKey": "anyValue"}, "tags": ["Tags"], "additional_features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "versions": [{"id": "ID", "_rev": "Rev", "crn": "CRN", "version": "Version", "flavor": {"name": "Name", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "index": 5}, "sha": "Sha", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "offering_id": "OfferingID", "catalog_id": "CatalogID", "kind_id": "KindID", "tags": ["Tags"], "repo_url": "RepoURL", "source_url": "SourceURL", "tgz_url": "TgzURL", "configuration": [{"key": "Key", "type": "Type", "default_value": "anyValue", "display_name": "DisplayName", "value_constraint": "ValueConstraint", "description": "Description", "required": true, "options": ["anyValue"], "hidden": true, "custom_config": {"type": "Type", "grouping": "Grouping", "original_grouping": "OriginalGrouping", "grouping_index": 13, "config_constraints": {"anyKey": "anyValue"}, "associations": {"parameters": [{"name": "Name", "optionsRefresh": true}]}}, "type_metadata": "TypeMetadata"}], "outputs": [{"key": "Key", "description": "Description"}], "iam_permissions": [{"service_name": "ServiceName", "role_crns": ["RoleCrns"], "resources": [{"name": "Name", "description": "Description", "role_crns": ["RoleCrns"]}]}], "metadata": {"anyKey": "anyValue"}, "validation": {"validated": "2019-01-01T12:00:00.000Z", "requested": "2019-01-01T12:00:00.000Z", "state": "State", "last_operation": "LastOperation", "target": {"anyKey": "anyValue"}, "message": "Message"}, "required_resources": [{"type": "mem", "value": "anyValue"}], "single_instance": true, "schematics_env_values": {"value": "[{\"name\": \"TF_LOG\",\"value\": \"TRACE\",\"secure\": false,\"hidden\": false}]", "sm_ref": "cmsm_v1:{\"name\": \"envVarSecret\",\"id\":\"1234567890\",\"service_id\":\"crn:v1:bluemix:public:secrets-manager:eu-gb:a/1234567890:1234567890::\",\"service_name\":\"My SM Instance\",\"group_id\":\"1234567890\",\"group_name\":\"My SM Group\",\"resource_group_id\":\"1234567890\",\"region\":\"eu-gb\",\"type\":\"arbitrary\"}"}, "install": {"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}, "pre_install": [{"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}], "scripts": {"mapKey": {"short_description": "ShortDescription", "type": "ansible", "path": "scripts/validate-post-ansible-playbook.yaml", "stage": "pre", "action": "validate"}}, "entitlement": {"provider_name": "ProviderName", "provider_id": "ProviderID", "product_id": "ProductID", "part_numbers": ["PartNumbers"], "image_repo_name": "ImageRepoName"}, "licenses": [{"id": "ID", "name": "Name", "type": "Type", "url": "URL", "description": "Description"}], "image_manifest_url": "ImageManifestURL", "deprecated": true, "package_version": "PackageVersion", "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "version_locator": "VersionLocator", "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "whitelisted_accounts": ["WhitelistedAccounts"], "image_pull_key_name": "ImagePullKeyName", "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "solution_info": {"architecture_diagrams": [{"diagram": {"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "cost_estimate": {"version": "Version", "currency": "Currency", "projects": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "pastBreakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "breakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "diff": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}}], "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}, "totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "pastTotalHourlyCost": "PastTotalHourlyCost", "pastTotalMonthlyCost": "PastTotalMonthlyCost", "diffTotalHourlyCost": "DiffTotalHourlyCost", "diffTotalMonthlyCost": "DiffTotalMonthlyCost", "timeGenerated": "2019-01-01T12:00:00.000Z"}, "dependencies": [{"catalog_id": "CatalogID", "id": "ID", "name": "Name", "kind": "Kind", "version": "Version", "description": "Description", "default_flavor": "DefaultFlavor", "flavors": ["Flavors"], "optional": true, "on_by_default": false}], "install_type": "InstallType"}, "is_consumable": true, "compliance_v3": {"authority": "Authority", "claims": {"profiles": [{"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}], "controls": [{"profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "names": ["Names"]}]}, "evaluations": [{"scan_id": "ScanID", "account_id": "AccountID", "profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "result": {"failure_count": 12, "scan_time": "2019-01-01T12:00:00.000Z", "error_message": "ErrorMessage", "complete_scan": true, "unscanned_resources": ["UnscannedResources"]}, "controls": [{"id": "ID", "name": "Name", "description": "Description", "specifications": [{"id": "ID", "description": "Description", "component_name": "ComponentName", "assessments": [{"id": "ID", "description": "Description", "version": "Version", "type": "Type", "method": "Method", "ui_href": "UIHref"}], "ui_href": "UIHref"}], "failure_count": 12, "pass_count": 9, "parent": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "parent_name": "ParentName", "specifications": [{"id": "ID", "description": "Description", "component_name": "ComponentName", "assessments": [{"id": "ID", "description": "Description", "version": "Version", "type": "Type", "method": "Method", "ui_href": "UIHref"}], "ui_href": "UIHref"}], "ui_href": "UIHref"}, "ui_href": "UIHref"}]}]}, "change_notices": {"breaking": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "new": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "update": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}]}, "plan_ids": ["PlanIds"], "stack": {"anyKey": "anyValue"}, "minimum_compatible_version": "MinimumCompatibleVersion"}], "all_versions": {"first": {"href": "Href", "start": "Start"}, "next": {"href": "Href", "start": "Start"}}}], "publish": {"pc_managed": false, "approval_type": "ApprovalType", "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "original_crn": "OriginalCRN", "public_crn": "PublicCRN", "approval_record": {"anyKey": "anyValue"}, "permit_ibm_public_publish": true, "ibm_approved": false, "public_approved": true}, "pc_managed": false, "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "public_original_crn": "PublicOriginalCRN", "publish_public_crn": "PublishPublicCRN", "portal_approval_record": "PortalApprovalRecord", "portal_ui_url": "PortalUIURL", "catalog_id": "CatalogID", "catalog_name": "CatalogName", "metadata": {"anyKey": "anyValue"}, "disclaimer": "Disclaimer", "hidden": true, "provider": "Provider", "provider_info": {"id": "ID", "name": "Name"}, "repo_info": {"token": "Token", "type": "Type"}, "image_pull_keys": [{"name": "Name", "value": "Value", "description": "Description"}], "support": {"url": "URL", "process": "Process", "process_i18n": {"mapKey": "Inner"}, "locations": ["Locations"], "support_details": [{"type": "Type", "contact": "Contact", "response_wait_time": {"value": 5, "type": "Type"}, "availability": {"times": [{"day": 3, "start_time": "StartTime", "end_time": "EndTime"}], "timezone": "Timezone", "always_available": false}}], "support_escalation": {"escalation_wait_time": {"value": 5, "type": "Type"}, "response_wait_time": {"value": 5, "type": "Type"}, "contact": "Contact"}, "support_type": "SupportType"}, "media": [{"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}], "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "product_kind": "ProductKind", "badges": [{"id": "ID", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}, "icon": "Icon", "authority": "Authority", "tag": "Tag", "learn_more_links": {"first_party": "FirstParty", "third_party": "ThirdParty"}, "constraints": [{"type": "Type", "rule": "anyValue"}]}], "plans": [{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "offering_id": "OfferingID", "catalog_id": "CatalogID", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "name": "Name", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "pricing_tags": ["PricingTags"], "version_range": {"kinds": ["Kinds"], "version": "Version", "flavors": ["Flavors"]}, "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "metadata": {"anyKey": "anyValue"}, "publish_approved": false}]}`)
				}))
			})
			It(`Invoke ReloadOffering successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.ReloadOffering(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the Flavor model
				flavorModel := new(catalogmanagementv1.Flavor)
				flavorModel.Name = core.StringPtr("testString")
				flavorModel.Label = core.StringPtr("testString")
				flavorModel.LabelI18n = map[string]string{"key1": "testString"}
				flavorModel.Index = core.Int64Ptr(int64(38))

				// Construct an instance of the ReloadOfferingOptions model
				reloadOfferingOptionsModel := new(catalogmanagementv1.ReloadOfferingOptions)
				reloadOfferingOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				reloadOfferingOptionsModel.OfferingID = core.StringPtr("testString")
				reloadOfferingOptionsModel.TargetVersion = core.StringPtr("testString")
				reloadOfferingOptionsModel.Tags = []string{"testString"}
				reloadOfferingOptionsModel.Content = CreateMockByteArray("VGhpcyBpcyBhIG1vY2sgYnl0ZSBhcnJheSB2YWx1ZS4=")
				reloadOfferingOptionsModel.TargetKinds = []string{"testString"}
				reloadOfferingOptionsModel.FormatKind = core.StringPtr("testString")
				reloadOfferingOptionsModel.Flavor = flavorModel
				reloadOfferingOptionsModel.WorkingDirectory = core.StringPtr("testString")
				reloadOfferingOptionsModel.InstallType = core.StringPtr("testString")
				reloadOfferingOptionsModel.Zipurl = core.StringPtr("testString")
				reloadOfferingOptionsModel.RepoType = core.StringPtr("testString")
				reloadOfferingOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.ReloadOffering(reloadOfferingOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ReloadOffering with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the Flavor model
				flavorModel := new(catalogmanagementv1.Flavor)
				flavorModel.Name = core.StringPtr("testString")
				flavorModel.Label = core.StringPtr("testString")
				flavorModel.LabelI18n = map[string]string{"key1": "testString"}
				flavorModel.Index = core.Int64Ptr(int64(38))

				// Construct an instance of the ReloadOfferingOptions model
				reloadOfferingOptionsModel := new(catalogmanagementv1.ReloadOfferingOptions)
				reloadOfferingOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				reloadOfferingOptionsModel.OfferingID = core.StringPtr("testString")
				reloadOfferingOptionsModel.TargetVersion = core.StringPtr("testString")
				reloadOfferingOptionsModel.Tags = []string{"testString"}
				reloadOfferingOptionsModel.Content = CreateMockByteArray("VGhpcyBpcyBhIG1vY2sgYnl0ZSBhcnJheSB2YWx1ZS4=")
				reloadOfferingOptionsModel.TargetKinds = []string{"testString"}
				reloadOfferingOptionsModel.FormatKind = core.StringPtr("testString")
				reloadOfferingOptionsModel.Flavor = flavorModel
				reloadOfferingOptionsModel.WorkingDirectory = core.StringPtr("testString")
				reloadOfferingOptionsModel.InstallType = core.StringPtr("testString")
				reloadOfferingOptionsModel.Zipurl = core.StringPtr("testString")
				reloadOfferingOptionsModel.RepoType = core.StringPtr("testString")
				reloadOfferingOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.ReloadOffering(reloadOfferingOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the ReloadOfferingOptions model with no property values
				reloadOfferingOptionsModelNew := new(catalogmanagementv1.ReloadOfferingOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.ReloadOffering(reloadOfferingOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ReloadOffering successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the Flavor model
				flavorModel := new(catalogmanagementv1.Flavor)
				flavorModel.Name = core.StringPtr("testString")
				flavorModel.Label = core.StringPtr("testString")
				flavorModel.LabelI18n = map[string]string{"key1": "testString"}
				flavorModel.Index = core.Int64Ptr(int64(38))

				// Construct an instance of the ReloadOfferingOptions model
				reloadOfferingOptionsModel := new(catalogmanagementv1.ReloadOfferingOptions)
				reloadOfferingOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				reloadOfferingOptionsModel.OfferingID = core.StringPtr("testString")
				reloadOfferingOptionsModel.TargetVersion = core.StringPtr("testString")
				reloadOfferingOptionsModel.Tags = []string{"testString"}
				reloadOfferingOptionsModel.Content = CreateMockByteArray("VGhpcyBpcyBhIG1vY2sgYnl0ZSBhcnJheSB2YWx1ZS4=")
				reloadOfferingOptionsModel.TargetKinds = []string{"testString"}
				reloadOfferingOptionsModel.FormatKind = core.StringPtr("testString")
				reloadOfferingOptionsModel.Flavor = flavorModel
				reloadOfferingOptionsModel.WorkingDirectory = core.StringPtr("testString")
				reloadOfferingOptionsModel.InstallType = core.StringPtr("testString")
				reloadOfferingOptionsModel.Zipurl = core.StringPtr("testString")
				reloadOfferingOptionsModel.RepoType = core.StringPtr("testString")
				reloadOfferingOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.ReloadOffering(reloadOfferingOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetOffering(getOfferingOptions *GetOfferingOptions) - Operation response error`, func() {
		getOfferingPath := "/catalogs/testString/offerings/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.URL.Query()["type"]).To(Equal([]string{"testString"}))
					// TODO: Add check for digest query parameter
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetOffering with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOfferingOptions model
				getOfferingOptionsModel := new(catalogmanagementv1.GetOfferingOptions)
				getOfferingOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getOfferingOptionsModel.OfferingID = core.StringPtr("testString")
				getOfferingOptionsModel.Type = core.StringPtr("testString")
				getOfferingOptionsModel.Digest = core.BoolPtr(true)
				getOfferingOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.GetOffering(getOfferingOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.GetOffering(getOfferingOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetOffering(getOfferingOptions *GetOfferingOptions)`, func() {
		getOfferingPath := "/catalogs/testString/offerings/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.URL.Query()["type"]).To(Equal([]string{"testString"}))
					// TODO: Add check for digest query parameter
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "name": "Name", "offering_icon_url": "OfferingIconURL", "offering_docs_url": "OfferingDocsURL", "offering_support_url": "OfferingSupportURL", "tags": ["Tags"], "keywords": ["Keywords"], "rating": {"one_star_count": 12, "two_star_count": 12, "three_star_count": 14, "four_star_count": 13}, "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "kinds": [{"id": "ID", "format_kind": "FormatKind", "format_kind_label": "FormatKindLabel", "install_kind": "InstallKind", "install_kind_label": "InstallKindLabel", "target_kind": "TargetKind", "target_kind_label": "TargetKindLabel", "metadata": {"anyKey": "anyValue"}, "tags": ["Tags"], "additional_features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "versions": [{"id": "ID", "_rev": "Rev", "crn": "CRN", "version": "Version", "flavor": {"name": "Name", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "index": 5}, "sha": "Sha", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "offering_id": "OfferingID", "catalog_id": "CatalogID", "kind_id": "KindID", "tags": ["Tags"], "repo_url": "RepoURL", "source_url": "SourceURL", "tgz_url": "TgzURL", "configuration": [{"key": "Key", "type": "Type", "default_value": "anyValue", "display_name": "DisplayName", "value_constraint": "ValueConstraint", "description": "Description", "required": true, "options": ["anyValue"], "hidden": true, "custom_config": {"type": "Type", "grouping": "Grouping", "original_grouping": "OriginalGrouping", "grouping_index": 13, "config_constraints": {"anyKey": "anyValue"}, "associations": {"parameters": [{"name": "Name", "optionsRefresh": true}]}}, "type_metadata": "TypeMetadata"}], "outputs": [{"key": "Key", "description": "Description"}], "iam_permissions": [{"service_name": "ServiceName", "role_crns": ["RoleCrns"], "resources": [{"name": "Name", "description": "Description", "role_crns": ["RoleCrns"]}]}], "metadata": {"anyKey": "anyValue"}, "validation": {"validated": "2019-01-01T12:00:00.000Z", "requested": "2019-01-01T12:00:00.000Z", "state": "State", "last_operation": "LastOperation", "target": {"anyKey": "anyValue"}, "message": "Message"}, "required_resources": [{"type": "mem", "value": "anyValue"}], "single_instance": true, "schematics_env_values": {"value": "[{\"name\": \"TF_LOG\",\"value\": \"TRACE\",\"secure\": false,\"hidden\": false}]", "sm_ref": "cmsm_v1:{\"name\": \"envVarSecret\",\"id\":\"1234567890\",\"service_id\":\"crn:v1:bluemix:public:secrets-manager:eu-gb:a/1234567890:1234567890::\",\"service_name\":\"My SM Instance\",\"group_id\":\"1234567890\",\"group_name\":\"My SM Group\",\"resource_group_id\":\"1234567890\",\"region\":\"eu-gb\",\"type\":\"arbitrary\"}"}, "install": {"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}, "pre_install": [{"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}], "scripts": {"mapKey": {"short_description": "ShortDescription", "type": "ansible", "path": "scripts/validate-post-ansible-playbook.yaml", "stage": "pre", "action": "validate"}}, "entitlement": {"provider_name": "ProviderName", "provider_id": "ProviderID", "product_id": "ProductID", "part_numbers": ["PartNumbers"], "image_repo_name": "ImageRepoName"}, "licenses": [{"id": "ID", "name": "Name", "type": "Type", "url": "URL", "description": "Description"}], "image_manifest_url": "ImageManifestURL", "deprecated": true, "package_version": "PackageVersion", "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "version_locator": "VersionLocator", "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "whitelisted_accounts": ["WhitelistedAccounts"], "image_pull_key_name": "ImagePullKeyName", "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "solution_info": {"architecture_diagrams": [{"diagram": {"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "cost_estimate": {"version": "Version", "currency": "Currency", "projects": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "pastBreakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "breakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "diff": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}}], "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}, "totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "pastTotalHourlyCost": "PastTotalHourlyCost", "pastTotalMonthlyCost": "PastTotalMonthlyCost", "diffTotalHourlyCost": "DiffTotalHourlyCost", "diffTotalMonthlyCost": "DiffTotalMonthlyCost", "timeGenerated": "2019-01-01T12:00:00.000Z"}, "dependencies": [{"catalog_id": "CatalogID", "id": "ID", "name": "Name", "kind": "Kind", "version": "Version", "description": "Description", "default_flavor": "DefaultFlavor", "flavors": ["Flavors"], "optional": true, "on_by_default": false}], "install_type": "InstallType"}, "is_consumable": true, "compliance_v3": {"authority": "Authority", "claims": {"profiles": [{"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}], "controls": [{"profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "names": ["Names"]}]}, "evaluations": [{"scan_id": "ScanID", "account_id": "AccountID", "profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "result": {"failure_count": 12, "scan_time": "2019-01-01T12:00:00.000Z", "error_message": "ErrorMessage", "complete_scan": true, "unscanned_resources": ["UnscannedResources"]}, "controls": [{"id": "ID", "name": "Name", "description": "Description", "specifications": [{"id": "ID", "description": "Description", "component_name": "ComponentName", "assessments": [{"id": "ID", "description": "Description", "version": "Version", "type": "Type", "method": "Method", "ui_href": "UIHref"}], "ui_href": "UIHref"}], "failure_count": 12, "pass_count": 9, "parent": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "parent_name": "ParentName", "specifications": [{"id": "ID", "description": "Description", "component_name": "ComponentName", "assessments": [{"id": "ID", "description": "Description", "version": "Version", "type": "Type", "method": "Method", "ui_href": "UIHref"}], "ui_href": "UIHref"}], "ui_href": "UIHref"}, "ui_href": "UIHref"}]}]}, "change_notices": {"breaking": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "new": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "update": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}]}, "plan_ids": ["PlanIds"], "stack": {"anyKey": "anyValue"}, "minimum_compatible_version": "MinimumCompatibleVersion"}], "all_versions": {"first": {"href": "Href", "start": "Start"}, "next": {"href": "Href", "start": "Start"}}}], "publish": {"pc_managed": false, "approval_type": "ApprovalType", "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "original_crn": "OriginalCRN", "public_crn": "PublicCRN", "approval_record": {"anyKey": "anyValue"}, "permit_ibm_public_publish": true, "ibm_approved": false, "public_approved": true}, "pc_managed": false, "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "public_original_crn": "PublicOriginalCRN", "publish_public_crn": "PublishPublicCRN", "portal_approval_record": "PortalApprovalRecord", "portal_ui_url": "PortalUIURL", "catalog_id": "CatalogID", "catalog_name": "CatalogName", "metadata": {"anyKey": "anyValue"}, "disclaimer": "Disclaimer", "hidden": true, "provider": "Provider", "provider_info": {"id": "ID", "name": "Name"}, "repo_info": {"token": "Token", "type": "Type"}, "image_pull_keys": [{"name": "Name", "value": "Value", "description": "Description"}], "support": {"url": "URL", "process": "Process", "process_i18n": {"mapKey": "Inner"}, "locations": ["Locations"], "support_details": [{"type": "Type", "contact": "Contact", "response_wait_time": {"value": 5, "type": "Type"}, "availability": {"times": [{"day": 3, "start_time": "StartTime", "end_time": "EndTime"}], "timezone": "Timezone", "always_available": false}}], "support_escalation": {"escalation_wait_time": {"value": 5, "type": "Type"}, "response_wait_time": {"value": 5, "type": "Type"}, "contact": "Contact"}, "support_type": "SupportType"}, "media": [{"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}], "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "product_kind": "ProductKind", "badges": [{"id": "ID", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}, "icon": "Icon", "authority": "Authority", "tag": "Tag", "learn_more_links": {"first_party": "FirstParty", "third_party": "ThirdParty"}, "constraints": [{"type": "Type", "rule": "anyValue"}]}], "plans": [{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "offering_id": "OfferingID", "catalog_id": "CatalogID", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "name": "Name", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "pricing_tags": ["PricingTags"], "version_range": {"kinds": ["Kinds"], "version": "Version", "flavors": ["Flavors"]}, "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "metadata": {"anyKey": "anyValue"}, "publish_approved": false}]}`)
				}))
			})
			It(`Invoke GetOffering successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the GetOfferingOptions model
				getOfferingOptionsModel := new(catalogmanagementv1.GetOfferingOptions)
				getOfferingOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getOfferingOptionsModel.OfferingID = core.StringPtr("testString")
				getOfferingOptionsModel.Type = core.StringPtr("testString")
				getOfferingOptionsModel.Digest = core.BoolPtr(true)
				getOfferingOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.GetOfferingWithContext(ctx, getOfferingOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.GetOffering(getOfferingOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.GetOfferingWithContext(ctx, getOfferingOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.URL.Query()["type"]).To(Equal([]string{"testString"}))
					// TODO: Add check for digest query parameter
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "name": "Name", "offering_icon_url": "OfferingIconURL", "offering_docs_url": "OfferingDocsURL", "offering_support_url": "OfferingSupportURL", "tags": ["Tags"], "keywords": ["Keywords"], "rating": {"one_star_count": 12, "two_star_count": 12, "three_star_count": 14, "four_star_count": 13}, "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "kinds": [{"id": "ID", "format_kind": "FormatKind", "format_kind_label": "FormatKindLabel", "install_kind": "InstallKind", "install_kind_label": "InstallKindLabel", "target_kind": "TargetKind", "target_kind_label": "TargetKindLabel", "metadata": {"anyKey": "anyValue"}, "tags": ["Tags"], "additional_features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "versions": [{"id": "ID", "_rev": "Rev", "crn": "CRN", "version": "Version", "flavor": {"name": "Name", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "index": 5}, "sha": "Sha", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "offering_id": "OfferingID", "catalog_id": "CatalogID", "kind_id": "KindID", "tags": ["Tags"], "repo_url": "RepoURL", "source_url": "SourceURL", "tgz_url": "TgzURL", "configuration": [{"key": "Key", "type": "Type", "default_value": "anyValue", "display_name": "DisplayName", "value_constraint": "ValueConstraint", "description": "Description", "required": true, "options": ["anyValue"], "hidden": true, "custom_config": {"type": "Type", "grouping": "Grouping", "original_grouping": "OriginalGrouping", "grouping_index": 13, "config_constraints": {"anyKey": "anyValue"}, "associations": {"parameters": [{"name": "Name", "optionsRefresh": true}]}}, "type_metadata": "TypeMetadata"}], "outputs": [{"key": "Key", "description": "Description"}], "iam_permissions": [{"service_name": "ServiceName", "role_crns": ["RoleCrns"], "resources": [{"name": "Name", "description": "Description", "role_crns": ["RoleCrns"]}]}], "metadata": {"anyKey": "anyValue"}, "validation": {"validated": "2019-01-01T12:00:00.000Z", "requested": "2019-01-01T12:00:00.000Z", "state": "State", "last_operation": "LastOperation", "target": {"anyKey": "anyValue"}, "message": "Message"}, "required_resources": [{"type": "mem", "value": "anyValue"}], "single_instance": true, "schematics_env_values": {"value": "[{\"name\": \"TF_LOG\",\"value\": \"TRACE\",\"secure\": false,\"hidden\": false}]", "sm_ref": "cmsm_v1:{\"name\": \"envVarSecret\",\"id\":\"1234567890\",\"service_id\":\"crn:v1:bluemix:public:secrets-manager:eu-gb:a/1234567890:1234567890::\",\"service_name\":\"My SM Instance\",\"group_id\":\"1234567890\",\"group_name\":\"My SM Group\",\"resource_group_id\":\"1234567890\",\"region\":\"eu-gb\",\"type\":\"arbitrary\"}"}, "install": {"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}, "pre_install": [{"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}], "scripts": {"mapKey": {"short_description": "ShortDescription", "type": "ansible", "path": "scripts/validate-post-ansible-playbook.yaml", "stage": "pre", "action": "validate"}}, "entitlement": {"provider_name": "ProviderName", "provider_id": "ProviderID", "product_id": "ProductID", "part_numbers": ["PartNumbers"], "image_repo_name": "ImageRepoName"}, "licenses": [{"id": "ID", "name": "Name", "type": "Type", "url": "URL", "description": "Description"}], "image_manifest_url": "ImageManifestURL", "deprecated": true, "package_version": "PackageVersion", "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "version_locator": "VersionLocator", "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "whitelisted_accounts": ["WhitelistedAccounts"], "image_pull_key_name": "ImagePullKeyName", "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "solution_info": {"architecture_diagrams": [{"diagram": {"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "cost_estimate": {"version": "Version", "currency": "Currency", "projects": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "pastBreakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "breakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "diff": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}}], "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}, "totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "pastTotalHourlyCost": "PastTotalHourlyCost", "pastTotalMonthlyCost": "PastTotalMonthlyCost", "diffTotalHourlyCost": "DiffTotalHourlyCost", "diffTotalMonthlyCost": "DiffTotalMonthlyCost", "timeGenerated": "2019-01-01T12:00:00.000Z"}, "dependencies": [{"catalog_id": "CatalogID", "id": "ID", "name": "Name", "kind": "Kind", "version": "Version", "description": "Description", "default_flavor": "DefaultFlavor", "flavors": ["Flavors"], "optional": true, "on_by_default": false}], "install_type": "InstallType"}, "is_consumable": true, "compliance_v3": {"authority": "Authority", "claims": {"profiles": [{"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}], "controls": [{"profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "names": ["Names"]}]}, "evaluations": [{"scan_id": "ScanID", "account_id": "AccountID", "profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "result": {"failure_count": 12, "scan_time": "2019-01-01T12:00:00.000Z", "error_message": "ErrorMessage", "complete_scan": true, "unscanned_resources": ["UnscannedResources"]}, "controls": [{"id": "ID", "name": "Name", "description": "Description", "specifications": [{"id": "ID", "description": "Description", "component_name": "ComponentName", "assessments": [{"id": "ID", "description": "Description", "version": "Version", "type": "Type", "method": "Method", "ui_href": "UIHref"}], "ui_href": "UIHref"}], "failure_count": 12, "pass_count": 9, "parent": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "parent_name": "ParentName", "specifications": [{"id": "ID", "description": "Description", "component_name": "ComponentName", "assessments": [{"id": "ID", "description": "Description", "version": "Version", "type": "Type", "method": "Method", "ui_href": "UIHref"}], "ui_href": "UIHref"}], "ui_href": "UIHref"}, "ui_href": "UIHref"}]}]}, "change_notices": {"breaking": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "new": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "update": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}]}, "plan_ids": ["PlanIds"], "stack": {"anyKey": "anyValue"}, "minimum_compatible_version": "MinimumCompatibleVersion"}], "all_versions": {"first": {"href": "Href", "start": "Start"}, "next": {"href": "Href", "start": "Start"}}}], "publish": {"pc_managed": false, "approval_type": "ApprovalType", "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "original_crn": "OriginalCRN", "public_crn": "PublicCRN", "approval_record": {"anyKey": "anyValue"}, "permit_ibm_public_publish": true, "ibm_approved": false, "public_approved": true}, "pc_managed": false, "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "public_original_crn": "PublicOriginalCRN", "publish_public_crn": "PublishPublicCRN", "portal_approval_record": "PortalApprovalRecord", "portal_ui_url": "PortalUIURL", "catalog_id": "CatalogID", "catalog_name": "CatalogName", "metadata": {"anyKey": "anyValue"}, "disclaimer": "Disclaimer", "hidden": true, "provider": "Provider", "provider_info": {"id": "ID", "name": "Name"}, "repo_info": {"token": "Token", "type": "Type"}, "image_pull_keys": [{"name": "Name", "value": "Value", "description": "Description"}], "support": {"url": "URL", "process": "Process", "process_i18n": {"mapKey": "Inner"}, "locations": ["Locations"], "support_details": [{"type": "Type", "contact": "Contact", "response_wait_time": {"value": 5, "type": "Type"}, "availability": {"times": [{"day": 3, "start_time": "StartTime", "end_time": "EndTime"}], "timezone": "Timezone", "always_available": false}}], "support_escalation": {"escalation_wait_time": {"value": 5, "type": "Type"}, "response_wait_time": {"value": 5, "type": "Type"}, "contact": "Contact"}, "support_type": "SupportType"}, "media": [{"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}], "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "product_kind": "ProductKind", "badges": [{"id": "ID", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}, "icon": "Icon", "authority": "Authority", "tag": "Tag", "learn_more_links": {"first_party": "FirstParty", "third_party": "ThirdParty"}, "constraints": [{"type": "Type", "rule": "anyValue"}]}], "plans": [{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "offering_id": "OfferingID", "catalog_id": "CatalogID", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "name": "Name", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "pricing_tags": ["PricingTags"], "version_range": {"kinds": ["Kinds"], "version": "Version", "flavors": ["Flavors"]}, "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "metadata": {"anyKey": "anyValue"}, "publish_approved": false}]}`)
				}))
			})
			It(`Invoke GetOffering successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.GetOffering(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetOfferingOptions model
				getOfferingOptionsModel := new(catalogmanagementv1.GetOfferingOptions)
				getOfferingOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getOfferingOptionsModel.OfferingID = core.StringPtr("testString")
				getOfferingOptionsModel.Type = core.StringPtr("testString")
				getOfferingOptionsModel.Digest = core.BoolPtr(true)
				getOfferingOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.GetOffering(getOfferingOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetOffering with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOfferingOptions model
				getOfferingOptionsModel := new(catalogmanagementv1.GetOfferingOptions)
				getOfferingOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getOfferingOptionsModel.OfferingID = core.StringPtr("testString")
				getOfferingOptionsModel.Type = core.StringPtr("testString")
				getOfferingOptionsModel.Digest = core.BoolPtr(true)
				getOfferingOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.GetOffering(getOfferingOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetOfferingOptions model with no property values
				getOfferingOptionsModelNew := new(catalogmanagementv1.GetOfferingOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.GetOffering(getOfferingOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetOffering successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOfferingOptions model
				getOfferingOptionsModel := new(catalogmanagementv1.GetOfferingOptions)
				getOfferingOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getOfferingOptionsModel.OfferingID = core.StringPtr("testString")
				getOfferingOptionsModel.Type = core.StringPtr("testString")
				getOfferingOptionsModel.Digest = core.BoolPtr(true)
				getOfferingOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.GetOffering(getOfferingOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ReplaceOffering(replaceOfferingOptions *ReplaceOfferingOptions) - Operation response error`, func() {
		replaceOfferingPath := "/catalogs/testString/offerings/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(replaceOfferingPath))
					Expect(req.Method).To(Equal("PUT"))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ReplaceOffering with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the Rating model
				ratingModel := new(catalogmanagementv1.Rating)
				ratingModel.OneStarCount = core.Int64Ptr(int64(38))
				ratingModel.TwoStarCount = core.Int64Ptr(int64(38))
				ratingModel.ThreeStarCount = core.Int64Ptr(int64(38))
				ratingModel.FourStarCount = core.Int64Ptr(int64(38))

				// Construct an instance of the Feature model
				featureModel := new(catalogmanagementv1.Feature)
				featureModel.Title = core.StringPtr("testString")
				featureModel.TitleI18n = map[string]string{"key1": "testString"}
				featureModel.Description = core.StringPtr("testString")
				featureModel.DescriptionI18n = map[string]string{"key1": "testString"}

				// Construct an instance of the Flavor model
				flavorModel := new(catalogmanagementv1.Flavor)
				flavorModel.Name = core.StringPtr("testString")
				flavorModel.Label = core.StringPtr("testString")
				flavorModel.LabelI18n = map[string]string{"key1": "testString"}
				flavorModel.Index = core.Int64Ptr(int64(38))

				// Construct an instance of the RenderTypeAssociationsParametersItem model
				renderTypeAssociationsParametersItemModel := new(catalogmanagementv1.RenderTypeAssociationsParametersItem)
				renderTypeAssociationsParametersItemModel.Name = core.StringPtr("testString")
				renderTypeAssociationsParametersItemModel.OptionsRefresh = core.BoolPtr(true)

				// Construct an instance of the RenderTypeAssociations model
				renderTypeAssociationsModel := new(catalogmanagementv1.RenderTypeAssociations)
				renderTypeAssociationsModel.Parameters = []catalogmanagementv1.RenderTypeAssociationsParametersItem{*renderTypeAssociationsParametersItemModel}

				// Construct an instance of the RenderType model
				renderTypeModel := new(catalogmanagementv1.RenderType)
				renderTypeModel.Type = core.StringPtr("testString")
				renderTypeModel.Grouping = core.StringPtr("testString")
				renderTypeModel.OriginalGrouping = core.StringPtr("testString")
				renderTypeModel.GroupingIndex = core.Int64Ptr(int64(38))
				renderTypeModel.ConfigConstraints = map[string]interface{}{"anyKey": "anyValue"}
				renderTypeModel.Associations = renderTypeAssociationsModel

				// Construct an instance of the Configuration model
				configurationModel := new(catalogmanagementv1.Configuration)
				configurationModel.Key = core.StringPtr("testString")
				configurationModel.Type = core.StringPtr("testString")
				configurationModel.DefaultValue = "testString"
				configurationModel.DisplayName = core.StringPtr("testString")
				configurationModel.ValueConstraint = core.StringPtr("testString")
				configurationModel.Description = core.StringPtr("testString")
				configurationModel.Required = core.BoolPtr(true)
				configurationModel.Options = []interface{}{"testString"}
				configurationModel.Hidden = core.BoolPtr(true)
				configurationModel.CustomConfig = renderTypeModel
				configurationModel.TypeMetadata = core.StringPtr("testString")

				// Construct an instance of the Output model
				outputModel := new(catalogmanagementv1.Output)
				outputModel.Key = core.StringPtr("testString")
				outputModel.Description = core.StringPtr("testString")

				// Construct an instance of the IamResource model
				iamResourceModel := new(catalogmanagementv1.IamResource)
				iamResourceModel.Name = core.StringPtr("testString")
				iamResourceModel.Description = core.StringPtr("testString")
				iamResourceModel.RoleCrns = []string{"testString"}

				// Construct an instance of the IamPermission model
				iamPermissionModel := new(catalogmanagementv1.IamPermission)
				iamPermissionModel.ServiceName = core.StringPtr("testString")
				iamPermissionModel.RoleCrns = []string{"testString"}
				iamPermissionModel.Resources = []catalogmanagementv1.IamResource{*iamResourceModel}

				// Construct an instance of the Validation model
				validationModel := new(catalogmanagementv1.Validation)
				validationModel.Validated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				validationModel.Requested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				validationModel.State = core.StringPtr("testString")
				validationModel.LastOperation = core.StringPtr("testString")
				validationModel.Target = map[string]interface{}{"anyKey": "anyValue"}
				validationModel.Message = core.StringPtr("testString")

				// Construct an instance of the Resource model
				resourceModel := new(catalogmanagementv1.Resource)
				resourceModel.Type = core.StringPtr("mem")
				resourceModel.Value = "testString"

				// Construct an instance of the SchematicsEnvValues model
				schematicsEnvValuesModel := new(catalogmanagementv1.SchematicsEnvValues)
				schematicsEnvValuesModel.Value = core.StringPtr("[{\"name\": \"TF_LOG\",\"value\": \"TRACE\",\"secure\": false,\"hidden\": false}]")
				schematicsEnvValuesModel.SmRef = core.StringPtr("cmsm_v1:{\"name\": \"envVarSecret\",\"id\":\"1234567890\",\"service_id\":\"crn:v1:bluemix:public:secrets-manager:eu-gb:a/1234567890:1234567890::\",\"service_name\":\"My SM Instance\",\"group_id\":\"1234567890\",\"group_name\":\"My SM Group\",\"resource_group_id\":\"1234567890\",\"region\":\"eu-gb\",\"type\":\"arbitrary\"}")

				// Construct an instance of the Script model
				scriptModel := new(catalogmanagementv1.Script)
				scriptModel.Instructions = core.StringPtr("testString")
				scriptModel.InstructionsI18n = map[string]string{"key1": "testString"}
				scriptModel.Script = core.StringPtr("testString")
				scriptModel.ScriptPermission = core.StringPtr("testString")
				scriptModel.DeleteScript = core.StringPtr("testString")
				scriptModel.Scope = core.StringPtr("testString")

				// Construct an instance of the ScriptRef model
				scriptRefModel := new(catalogmanagementv1.ScriptRef)
				scriptRefModel.ShortDescription = core.StringPtr("testString")
				scriptRefModel.Type = core.StringPtr("ansible")
				scriptRefModel.Path = core.StringPtr("scripts/validate-post-ansible-playbook.yaml")
				scriptRefModel.Stage = core.StringPtr("pre")
				scriptRefModel.Action = core.StringPtr("validate")

				// Construct an instance of the VersionEntitlement model
				versionEntitlementModel := new(catalogmanagementv1.VersionEntitlement)
				versionEntitlementModel.ProviderName = core.StringPtr("testString")
				versionEntitlementModel.ProviderID = core.StringPtr("testString")
				versionEntitlementModel.ProductID = core.StringPtr("testString")
				versionEntitlementModel.PartNumbers = []string{"testString"}
				versionEntitlementModel.ImageRepoName = core.StringPtr("testString")

				// Construct an instance of the License model
				licenseModel := new(catalogmanagementv1.License)
				licenseModel.ID = core.StringPtr("testString")
				licenseModel.Name = core.StringPtr("testString")
				licenseModel.Type = core.StringPtr("testString")
				licenseModel.URL = core.StringPtr("testString")
				licenseModel.Description = core.StringPtr("testString")

				// Construct an instance of the State model
				stateModel := new(catalogmanagementv1.State)
				stateModel.Current = core.StringPtr("testString")
				stateModel.CurrentEntered = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Pending = core.StringPtr("testString")
				stateModel.PendingRequested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Previous = core.StringPtr("testString")

				// Construct an instance of the DeprecatePending model
				deprecatePendingModel := new(catalogmanagementv1.DeprecatePending)
				deprecatePendingModel.DeprecateDate = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				deprecatePendingModel.DeprecateState = core.StringPtr("testString")
				deprecatePendingModel.Description = core.StringPtr("testString")

				// Construct an instance of the URLProxy model
				urlProxyModel := new(catalogmanagementv1.URLProxy)
				urlProxyModel.URL = core.StringPtr("testString")
				urlProxyModel.Sha = core.StringPtr("testString")

				// Construct an instance of the MediaItem model
				mediaItemModel := new(catalogmanagementv1.MediaItem)
				mediaItemModel.URL = core.StringPtr("testString")
				mediaItemModel.APIURL = core.StringPtr("testString")
				mediaItemModel.URLProxy = urlProxyModel
				mediaItemModel.Caption = core.StringPtr("testString")
				mediaItemModel.CaptionI18n = map[string]string{"key1": "testString"}
				mediaItemModel.Type = core.StringPtr("testString")
				mediaItemModel.ThumbnailURL = core.StringPtr("testString")

				// Construct an instance of the ArchitectureDiagram model
				architectureDiagramModel := new(catalogmanagementv1.ArchitectureDiagram)
				architectureDiagramModel.Diagram = mediaItemModel
				architectureDiagramModel.Description = core.StringPtr("testString")
				architectureDiagramModel.DescriptionI18n = map[string]string{"key1": "testString"}

				// Construct an instance of the CostComponent model
				costComponentModel := new(catalogmanagementv1.CostComponent)
				costComponentModel.Name = core.StringPtr("testString")
				costComponentModel.Unit = core.StringPtr("testString")
				costComponentModel.HourlyQuantity = core.StringPtr("testString")
				costComponentModel.MonthlyQuantity = core.StringPtr("testString")
				costComponentModel.Price = core.StringPtr("testString")
				costComponentModel.HourlyCost = core.StringPtr("testString")
				costComponentModel.MonthlyCost = core.StringPtr("testString")

				// Construct an instance of the CostResource model
				costResourceModel := new(catalogmanagementv1.CostResource)
				costResourceModel.Name = core.StringPtr("testString")
				costResourceModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				costResourceModel.HourlyCost = core.StringPtr("testString")
				costResourceModel.MonthlyCost = core.StringPtr("testString")
				costResourceModel.CostComponents = []catalogmanagementv1.CostComponent{*costComponentModel}

				// Construct an instance of the CostBreakdown model
				costBreakdownModel := new(catalogmanagementv1.CostBreakdown)
				costBreakdownModel.TotalHourlyCost = core.StringPtr("testString")
				costBreakdownModel.TotalMonthlyCost = core.StringPtr("testString")
				costBreakdownModel.Resources = []catalogmanagementv1.CostResource{*costResourceModel}

				// Construct an instance of the CostSummary model
				costSummaryModel := new(catalogmanagementv1.CostSummary)
				costSummaryModel.TotalDetectedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalSupportedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalUnsupportedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalUsageBasedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalNoPriceResources = core.Int64Ptr(int64(38))
				costSummaryModel.UnsupportedResourceCounts = map[string]int64{"key1": int64(38)}
				costSummaryModel.NoPriceResourceCounts = map[string]int64{"key1": int64(38)}

				// Construct an instance of the Project model
				projectModel := new(catalogmanagementv1.Project)
				projectModel.Name = core.StringPtr("testString")
				projectModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				projectModel.PastBreakdown = costBreakdownModel
				projectModel.Breakdown = costBreakdownModel
				projectModel.Diff = costBreakdownModel
				projectModel.Summary = costSummaryModel

				// Construct an instance of the CostEstimate model
				costEstimateModel := new(catalogmanagementv1.CostEstimate)
				costEstimateModel.Version = core.StringPtr("testString")
				costEstimateModel.Currency = core.StringPtr("testString")
				costEstimateModel.Projects = []catalogmanagementv1.Project{*projectModel}
				costEstimateModel.Summary = costSummaryModel
				costEstimateModel.TotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.TotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.PastTotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.PastTotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.DiffTotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.DiffTotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.TimeGenerated = CreateMockDateTime("2019-01-01T12:00:00.000Z")

				// Construct an instance of the OfferingReference model
				offeringReferenceModel := new(catalogmanagementv1.OfferingReference)
				offeringReferenceModel.CatalogID = core.StringPtr("testString")
				offeringReferenceModel.ID = core.StringPtr("testString")
				offeringReferenceModel.Name = core.StringPtr("testString")
				offeringReferenceModel.Kind = core.StringPtr("testString")
				offeringReferenceModel.Version = core.StringPtr("testString")
				offeringReferenceModel.Description = core.StringPtr("testString")
				offeringReferenceModel.DefaultFlavor = core.StringPtr("testString")
				offeringReferenceModel.Flavors = []string{"testString"}
				offeringReferenceModel.Optional = core.BoolPtr(true)
				offeringReferenceModel.OnByDefault = core.BoolPtr(true)

				// Construct an instance of the SolutionInfo model
				solutionInfoModel := new(catalogmanagementv1.SolutionInfo)
				solutionInfoModel.ArchitectureDiagrams = []catalogmanagementv1.ArchitectureDiagram{*architectureDiagramModel}
				solutionInfoModel.Features = []catalogmanagementv1.Feature{*featureModel}
				solutionInfoModel.CostEstimate = costEstimateModel
				solutionInfoModel.Dependencies = []catalogmanagementv1.OfferingReference{*offeringReferenceModel}
				solutionInfoModel.InstallType = core.StringPtr("testString")

				// Construct an instance of the SccProfile model
				sccProfileModel := new(catalogmanagementv1.SccProfile)
				sccProfileModel.ID = core.StringPtr("testString")
				sccProfileModel.Name = core.StringPtr("testString")
				sccProfileModel.Version = core.StringPtr("testString")
				sccProfileModel.Description = core.StringPtr("testString")
				sccProfileModel.Type = core.StringPtr("testString")
				sccProfileModel.UIHref = core.StringPtr("testString")

				// Construct an instance of the ClaimedControl model
				claimedControlModel := new(catalogmanagementv1.ClaimedControl)
				claimedControlModel.Profile = sccProfileModel
				claimedControlModel.Names = []string{"testString"}

				// Construct an instance of the Claims model
				claimsModel := new(catalogmanagementv1.Claims)
				claimsModel.Profiles = []catalogmanagementv1.SccProfile{*sccProfileModel}
				claimsModel.Controls = []catalogmanagementv1.ClaimedControl{*claimedControlModel}

				// Construct an instance of the Result model
				resultModel := new(catalogmanagementv1.Result)
				resultModel.FailureCount = core.Int64Ptr(int64(38))
				resultModel.ScanTime = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				resultModel.ErrorMessage = core.StringPtr("testString")
				resultModel.CompleteScan = core.BoolPtr(true)
				resultModel.UnscannedResources = []string{"testString"}

				// Construct an instance of the SccAssessment model
				sccAssessmentModel := new(catalogmanagementv1.SccAssessment)
				sccAssessmentModel.ID = core.StringPtr("testString")
				sccAssessmentModel.Description = core.StringPtr("testString")
				sccAssessmentModel.Version = core.StringPtr("testString")
				sccAssessmentModel.Type = core.StringPtr("testString")
				sccAssessmentModel.Method = core.StringPtr("testString")
				sccAssessmentModel.UIHref = core.StringPtr("testString")

				// Construct an instance of the SccSpecification model
				sccSpecificationModel := new(catalogmanagementv1.SccSpecification)
				sccSpecificationModel.ID = core.StringPtr("testString")
				sccSpecificationModel.Description = core.StringPtr("testString")
				sccSpecificationModel.ComponentName = core.StringPtr("testString")
				sccSpecificationModel.Assessments = []catalogmanagementv1.SccAssessment{*sccAssessmentModel}
				sccSpecificationModel.UIHref = core.StringPtr("testString")

				// Construct an instance of the SccControl model
				sccControlModel := new(catalogmanagementv1.SccControl)
				sccControlModel.ID = core.StringPtr("testString")
				sccControlModel.Name = core.StringPtr("testString")
				sccControlModel.Version = core.StringPtr("testString")
				sccControlModel.Description = core.StringPtr("testString")
				sccControlModel.Profile = sccProfileModel
				sccControlModel.ParentName = core.StringPtr("testString")
				sccControlModel.Specifications = []catalogmanagementv1.SccSpecification{*sccSpecificationModel}
				sccControlModel.UIHref = core.StringPtr("testString")

				// Construct an instance of the EvaluatedControl model
				evaluatedControlModel := new(catalogmanagementv1.EvaluatedControl)
				evaluatedControlModel.ID = core.StringPtr("testString")
				evaluatedControlModel.Name = core.StringPtr("testString")
				evaluatedControlModel.Description = core.StringPtr("testString")
				evaluatedControlModel.Specifications = []catalogmanagementv1.SccSpecification{*sccSpecificationModel}
				evaluatedControlModel.FailureCount = core.Int64Ptr(int64(38))
				evaluatedControlModel.PassCount = core.Int64Ptr(int64(38))
				evaluatedControlModel.Parent = sccControlModel
				evaluatedControlModel.UIHref = core.StringPtr("testString")

				// Construct an instance of the Evaluation model
				evaluationModel := new(catalogmanagementv1.Evaluation)
				evaluationModel.ScanID = core.StringPtr("testString")
				evaluationModel.AccountID = core.StringPtr("testString")
				evaluationModel.Profile = sccProfileModel
				evaluationModel.Result = resultModel
				evaluationModel.Controls = []catalogmanagementv1.EvaluatedControl{*evaluatedControlModel}

				// Construct an instance of the Compliance model
				complianceModel := new(catalogmanagementv1.Compliance)
				complianceModel.Authority = core.StringPtr("testString")
				complianceModel.Claims = claimsModel
				complianceModel.Evaluations = []catalogmanagementv1.Evaluation{*evaluationModel}

				// Construct an instance of the ChangeNotices model
				changeNoticesModel := new(catalogmanagementv1.ChangeNotices)
				changeNoticesModel.Breaking = []catalogmanagementv1.Feature{*featureModel}
				changeNoticesModel.New = []catalogmanagementv1.Feature{*featureModel}
				changeNoticesModel.Update = []catalogmanagementv1.Feature{*featureModel}

				// Construct an instance of the Version model
				versionModel := new(catalogmanagementv1.Version)
				versionModel.CRN = core.StringPtr("testString")
				versionModel.Version = core.StringPtr("testString")
				versionModel.Flavor = flavorModel
				versionModel.Sha = core.StringPtr("testString")
				versionModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				versionModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				versionModel.OfferingID = core.StringPtr("testString")
				versionModel.CatalogID = core.StringPtr("testString")
				versionModel.KindID = core.StringPtr("testString")
				versionModel.Tags = []string{"testString"}
				versionModel.RepoURL = core.StringPtr("testString")
				versionModel.SourceURL = core.StringPtr("testString")
				versionModel.TgzURL = core.StringPtr("testString")
				versionModel.Configuration = []catalogmanagementv1.Configuration{*configurationModel}
				versionModel.Outputs = []catalogmanagementv1.Output{*outputModel}
				versionModel.IamPermissions = []catalogmanagementv1.IamPermission{*iamPermissionModel}
				versionModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				versionModel.Validation = validationModel
				versionModel.RequiredResources = []catalogmanagementv1.Resource{*resourceModel}
				versionModel.SingleInstance = core.BoolPtr(true)
				versionModel.SchematicsEnvValues = schematicsEnvValuesModel
				versionModel.Install = scriptModel
				versionModel.PreInstall = []catalogmanagementv1.Script{*scriptModel}
				versionModel.Scripts = map[string]catalogmanagementv1.ScriptRef{"key1": *scriptRefModel}
				versionModel.Entitlement = versionEntitlementModel
				versionModel.Licenses = []catalogmanagementv1.License{*licenseModel}
				versionModel.ImageManifestURL = core.StringPtr("testString")
				versionModel.Deprecated = core.BoolPtr(true)
				versionModel.PackageVersion = core.StringPtr("testString")
				versionModel.State = stateModel
				versionModel.VersionLocator = core.StringPtr("testString")
				versionModel.LongDescription = core.StringPtr("testString")
				versionModel.LongDescriptionI18n = map[string]string{"key1": "testString"}
				versionModel.WhitelistedAccounts = []string{"testString"}
				versionModel.ImagePullKeyName = core.StringPtr("testString")
				versionModel.DeprecatePending = deprecatePendingModel
				versionModel.SolutionInfo = solutionInfoModel
				versionModel.IsConsumable = core.BoolPtr(true)
				versionModel.ComplianceV3 = complianceModel
				versionModel.ChangeNotices = changeNoticesModel
				versionModel.PlanIds = []string{"testString"}
				versionModel.Stack = map[string]interface{}{"anyKey": "anyValue"}
				versionModel.MinimumCompatibleVersion = core.StringPtr("testString")
				versionModel.Scripts["foo"] = *scriptRefModel

				// Construct an instance of the PaginationTokenLink model
				paginationTokenLinkModel := new(catalogmanagementv1.PaginationTokenLink)
				paginationTokenLinkModel.Href = core.StringPtr("testString")
				paginationTokenLinkModel.Start = core.StringPtr("testString")

				// Construct an instance of the KindAllVersions model
				kindAllVersionsModel := new(catalogmanagementv1.KindAllVersions)
				kindAllVersionsModel.First = paginationTokenLinkModel
				kindAllVersionsModel.Next = paginationTokenLinkModel

				// Construct an instance of the Kind model
				kindModel := new(catalogmanagementv1.Kind)
				kindModel.ID = core.StringPtr("testString")
				kindModel.FormatKind = core.StringPtr("testString")
				kindModel.FormatKindLabel = core.StringPtr("testString")
				kindModel.InstallKind = core.StringPtr("testString")
				kindModel.InstallKindLabel = core.StringPtr("testString")
				kindModel.TargetKind = core.StringPtr("testString")
				kindModel.TargetKindLabel = core.StringPtr("testString")
				kindModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				kindModel.Tags = []string{"testString"}
				kindModel.AdditionalFeatures = []catalogmanagementv1.Feature{*featureModel}
				kindModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				kindModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				kindModel.Versions = []catalogmanagementv1.Version{*versionModel}
				kindModel.AllVersions = kindAllVersionsModel

				// Construct an instance of the PublishObject model
				publishObjectModel := new(catalogmanagementv1.PublishObject)
				publishObjectModel.PcManaged = core.BoolPtr(true)
				publishObjectModel.ApprovalType = core.StringPtr("testString")
				publishObjectModel.PublishApproved = core.BoolPtr(true)
				publishObjectModel.ShareWithAll = core.BoolPtr(true)
				publishObjectModel.ShareWithIBM = core.BoolPtr(true)
				publishObjectModel.ShareEnabled = core.BoolPtr(true)
				publishObjectModel.OriginalCRN = core.StringPtr("testString")
				publishObjectModel.PublicCRN = core.StringPtr("testString")
				publishObjectModel.ApprovalRecord = map[string]interface{}{"anyKey": "anyValue"}
				publishObjectModel.PermitIBMPublicPublish = core.BoolPtr(true)
				publishObjectModel.IBMApproved = core.BoolPtr(true)
				publishObjectModel.PublicApproved = core.BoolPtr(true)

				// Construct an instance of the ProviderInfo model
				providerInfoModel := new(catalogmanagementv1.ProviderInfo)
				providerInfoModel.ID = core.StringPtr("testString")
				providerInfoModel.Name = core.StringPtr("testString")

				// Construct an instance of the RepoInfo model
				repoInfoModel := new(catalogmanagementv1.RepoInfo)
				repoInfoModel.Token = core.StringPtr("testString")
				repoInfoModel.Type = core.StringPtr("testString")

				// Construct an instance of the ImagePullKey model
				imagePullKeyModel := new(catalogmanagementv1.ImagePullKey)
				imagePullKeyModel.Name = core.StringPtr("testString")
				imagePullKeyModel.Value = core.StringPtr("testString")
				imagePullKeyModel.Description = core.StringPtr("testString")

				// Construct an instance of the SupportWaitTime model
				supportWaitTimeModel := new(catalogmanagementv1.SupportWaitTime)
				supportWaitTimeModel.Value = core.Int64Ptr(int64(38))
				supportWaitTimeModel.Type = core.StringPtr("testString")

				// Construct an instance of the SupportTime model
				supportTimeModel := new(catalogmanagementv1.SupportTime)
				supportTimeModel.Day = core.Int64Ptr(int64(38))
				supportTimeModel.StartTime = core.StringPtr("testString")
				supportTimeModel.EndTime = core.StringPtr("testString")

				// Construct an instance of the SupportAvailability model
				supportAvailabilityModel := new(catalogmanagementv1.SupportAvailability)
				supportAvailabilityModel.Times = []catalogmanagementv1.SupportTime{*supportTimeModel}
				supportAvailabilityModel.Timezone = core.StringPtr("testString")
				supportAvailabilityModel.AlwaysAvailable = core.BoolPtr(true)

				// Construct an instance of the SupportDetail model
				supportDetailModel := new(catalogmanagementv1.SupportDetail)
				supportDetailModel.Type = core.StringPtr("testString")
				supportDetailModel.Contact = core.StringPtr("testString")
				supportDetailModel.ResponseWaitTime = supportWaitTimeModel
				supportDetailModel.Availability = supportAvailabilityModel

				// Construct an instance of the SupportEscalation model
				supportEscalationModel := new(catalogmanagementv1.SupportEscalation)
				supportEscalationModel.EscalationWaitTime = supportWaitTimeModel
				supportEscalationModel.ResponseWaitTime = supportWaitTimeModel
				supportEscalationModel.Contact = core.StringPtr("testString")

				// Construct an instance of the Support model
				supportModel := new(catalogmanagementv1.Support)
				supportModel.URL = core.StringPtr("testString")
				supportModel.Process = core.StringPtr("testString")
				supportModel.ProcessI18n = map[string]string{"key1": "testString"}
				supportModel.Locations = []string{"testString"}
				supportModel.SupportDetails = []catalogmanagementv1.SupportDetail{*supportDetailModel}
				supportModel.SupportEscalation = supportEscalationModel
				supportModel.SupportType = core.StringPtr("testString")

				// Construct an instance of the LearnMoreLinks model
				learnMoreLinksModel := new(catalogmanagementv1.LearnMoreLinks)
				learnMoreLinksModel.FirstParty = core.StringPtr("testString")
				learnMoreLinksModel.ThirdParty = core.StringPtr("testString")

				// Construct an instance of the Constraint model
				constraintModel := new(catalogmanagementv1.Constraint)
				constraintModel.Type = core.StringPtr("testString")
				constraintModel.Rule = "testString"

				// Construct an instance of the Badge model
				badgeModel := new(catalogmanagementv1.Badge)
				badgeModel.ID = core.StringPtr("testString")
				badgeModel.Label = core.StringPtr("testString")
				badgeModel.LabelI18n = map[string]string{"key1": "testString"}
				badgeModel.Description = core.StringPtr("testString")
				badgeModel.DescriptionI18n = map[string]string{"key1": "testString"}
				badgeModel.Icon = core.StringPtr("testString")
				badgeModel.Authority = core.StringPtr("testString")
				badgeModel.Tag = core.StringPtr("testString")
				badgeModel.LearnMoreLinks = learnMoreLinksModel
				badgeModel.Constraints = []catalogmanagementv1.Constraint{*constraintModel}

				// Construct an instance of the VersionRange model
				versionRangeModel := new(catalogmanagementv1.VersionRange)
				versionRangeModel.Kinds = []string{"testString"}
				versionRangeModel.Version = core.StringPtr("testString")
				versionRangeModel.Flavors = []string{"testString"}

				// Construct an instance of the Plan model
				planModel := new(catalogmanagementv1.Plan)
				planModel.URL = core.StringPtr("testString")
				planModel.CRN = core.StringPtr("testString")
				planModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				planModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				planModel.OfferingID = core.StringPtr("testString")
				planModel.CatalogID = core.StringPtr("testString")
				planModel.Label = core.StringPtr("testString")
				planModel.LabelI18n = map[string]string{"key1": "testString"}
				planModel.Name = core.StringPtr("testString")
				planModel.ShortDescription = core.StringPtr("testString")
				planModel.ShortDescriptionI18n = map[string]string{"key1": "testString"}
				planModel.PricingTags = []string{"testString"}
				planModel.VersionRange = versionRangeModel
				planModel.Features = []catalogmanagementv1.Feature{*featureModel}
				planModel.State = stateModel
				planModel.DeprecatePending = deprecatePendingModel
				planModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				planModel.PublishApproved = core.BoolPtr(true)

				// Construct an instance of the ReplaceOfferingOptions model
				replaceOfferingOptionsModel := new(catalogmanagementv1.ReplaceOfferingOptions)
				replaceOfferingOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				replaceOfferingOptionsModel.OfferingID = core.StringPtr("testString")
				replaceOfferingOptionsModel.ID = core.StringPtr("testString")
				replaceOfferingOptionsModel.Rev = core.StringPtr("testString")
				replaceOfferingOptionsModel.URL = core.StringPtr("testString")
				replaceOfferingOptionsModel.CRN = core.StringPtr("testString")
				replaceOfferingOptionsModel.Label = core.StringPtr("testString")
				replaceOfferingOptionsModel.LabelI18n = map[string]string{"key1": "testString"}
				replaceOfferingOptionsModel.Name = core.StringPtr("testString")
				replaceOfferingOptionsModel.OfferingIconURL = core.StringPtr("testString")
				replaceOfferingOptionsModel.OfferingDocsURL = core.StringPtr("testString")
				replaceOfferingOptionsModel.OfferingSupportURL = core.StringPtr("testString")
				replaceOfferingOptionsModel.Tags = []string{"testString"}
				replaceOfferingOptionsModel.Keywords = []string{"testString"}
				replaceOfferingOptionsModel.Rating = ratingModel
				replaceOfferingOptionsModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				replaceOfferingOptionsModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				replaceOfferingOptionsModel.ShortDescription = core.StringPtr("testString")
				replaceOfferingOptionsModel.ShortDescriptionI18n = map[string]string{"key1": "testString"}
				replaceOfferingOptionsModel.LongDescription = core.StringPtr("testString")
				replaceOfferingOptionsModel.LongDescriptionI18n = map[string]string{"key1": "testString"}
				replaceOfferingOptionsModel.Features = []catalogmanagementv1.Feature{*featureModel}
				replaceOfferingOptionsModel.Kinds = []catalogmanagementv1.Kind{*kindModel}
				replaceOfferingOptionsModel.Publish = publishObjectModel
				replaceOfferingOptionsModel.PcManaged = core.BoolPtr(true)
				replaceOfferingOptionsModel.PublishApproved = core.BoolPtr(true)
				replaceOfferingOptionsModel.ShareWithAll = core.BoolPtr(true)
				replaceOfferingOptionsModel.ShareWithIBM = core.BoolPtr(true)
				replaceOfferingOptionsModel.ShareEnabled = core.BoolPtr(true)
				replaceOfferingOptionsModel.PublicOriginalCRN = core.StringPtr("testString")
				replaceOfferingOptionsModel.PublishPublicCRN = core.StringPtr("testString")
				replaceOfferingOptionsModel.PortalApprovalRecord = core.StringPtr("testString")
				replaceOfferingOptionsModel.PortalUIURL = core.StringPtr("testString")
				replaceOfferingOptionsModel.CatalogID = core.StringPtr("testString")
				replaceOfferingOptionsModel.CatalogName = core.StringPtr("testString")
				replaceOfferingOptionsModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				replaceOfferingOptionsModel.Disclaimer = core.StringPtr("testString")
				replaceOfferingOptionsModel.Hidden = core.BoolPtr(true)
				replaceOfferingOptionsModel.Provider = core.StringPtr("testString")
				replaceOfferingOptionsModel.ProviderInfo = providerInfoModel
				replaceOfferingOptionsModel.RepoInfo = repoInfoModel
				replaceOfferingOptionsModel.ImagePullKeys = []catalogmanagementv1.ImagePullKey{*imagePullKeyModel}
				replaceOfferingOptionsModel.Support = supportModel
				replaceOfferingOptionsModel.Media = []catalogmanagementv1.MediaItem{*mediaItemModel}
				replaceOfferingOptionsModel.DeprecatePending = deprecatePendingModel
				replaceOfferingOptionsModel.ProductKind = core.StringPtr("testString")
				replaceOfferingOptionsModel.Badges = []catalogmanagementv1.Badge{*badgeModel}
				replaceOfferingOptionsModel.Plans = []catalogmanagementv1.Plan{*planModel}
				replaceOfferingOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.ReplaceOffering(replaceOfferingOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.ReplaceOffering(replaceOfferingOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ReplaceOffering(replaceOfferingOptions *ReplaceOfferingOptions)`, func() {
		replaceOfferingPath := "/catalogs/testString/offerings/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(replaceOfferingPath))
					Expect(req.Method).To(Equal("PUT"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "name": "Name", "offering_icon_url": "OfferingIconURL", "offering_docs_url": "OfferingDocsURL", "offering_support_url": "OfferingSupportURL", "tags": ["Tags"], "keywords": ["Keywords"], "rating": {"one_star_count": 12, "two_star_count": 12, "three_star_count": 14, "four_star_count": 13}, "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "kinds": [{"id": "ID", "format_kind": "FormatKind", "format_kind_label": "FormatKindLabel", "install_kind": "InstallKind", "install_kind_label": "InstallKindLabel", "target_kind": "TargetKind", "target_kind_label": "TargetKindLabel", "metadata": {"anyKey": "anyValue"}, "tags": ["Tags"], "additional_features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "versions": [{"id": "ID", "_rev": "Rev", "crn": "CRN", "version": "Version", "flavor": {"name": "Name", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "index": 5}, "sha": "Sha", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "offering_id": "OfferingID", "catalog_id": "CatalogID", "kind_id": "KindID", "tags": ["Tags"], "repo_url": "RepoURL", "source_url": "SourceURL", "tgz_url": "TgzURL", "configuration": [{"key": "Key", "type": "Type", "default_value": "anyValue", "display_name": "DisplayName", "value_constraint": "ValueConstraint", "description": "Description", "required": true, "options": ["anyValue"], "hidden": true, "custom_config": {"type": "Type", "grouping": "Grouping", "original_grouping": "OriginalGrouping", "grouping_index": 13, "config_constraints": {"anyKey": "anyValue"}, "associations": {"parameters": [{"name": "Name", "optionsRefresh": true}]}}, "type_metadata": "TypeMetadata"}], "outputs": [{"key": "Key", "description": "Description"}], "iam_permissions": [{"service_name": "ServiceName", "role_crns": ["RoleCrns"], "resources": [{"name": "Name", "description": "Description", "role_crns": ["RoleCrns"]}]}], "metadata": {"anyKey": "anyValue"}, "validation": {"validated": "2019-01-01T12:00:00.000Z", "requested": "2019-01-01T12:00:00.000Z", "state": "State", "last_operation": "LastOperation", "target": {"anyKey": "anyValue"}, "message": "Message"}, "required_resources": [{"type": "mem", "value": "anyValue"}], "single_instance": true, "schematics_env_values": {"value": "[{\"name\": \"TF_LOG\",\"value\": \"TRACE\",\"secure\": false,\"hidden\": false}]", "sm_ref": "cmsm_v1:{\"name\": \"envVarSecret\",\"id\":\"1234567890\",\"service_id\":\"crn:v1:bluemix:public:secrets-manager:eu-gb:a/1234567890:1234567890::\",\"service_name\":\"My SM Instance\",\"group_id\":\"1234567890\",\"group_name\":\"My SM Group\",\"resource_group_id\":\"1234567890\",\"region\":\"eu-gb\",\"type\":\"arbitrary\"}"}, "install": {"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}, "pre_install": [{"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}], "scripts": {"mapKey": {"short_description": "ShortDescription", "type": "ansible", "path": "scripts/validate-post-ansible-playbook.yaml", "stage": "pre", "action": "validate"}}, "entitlement": {"provider_name": "ProviderName", "provider_id": "ProviderID", "product_id": "ProductID", "part_numbers": ["PartNumbers"], "image_repo_name": "ImageRepoName"}, "licenses": [{"id": "ID", "name": "Name", "type": "Type", "url": "URL", "description": "Description"}], "image_manifest_url": "ImageManifestURL", "deprecated": true, "package_version": "PackageVersion", "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "version_locator": "VersionLocator", "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "whitelisted_accounts": ["WhitelistedAccounts"], "image_pull_key_name": "ImagePullKeyName", "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "solution_info": {"architecture_diagrams": [{"diagram": {"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "cost_estimate": {"version": "Version", "currency": "Currency", "projects": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "pastBreakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "breakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "diff": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}}], "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}, "totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "pastTotalHourlyCost": "PastTotalHourlyCost", "pastTotalMonthlyCost": "PastTotalMonthlyCost", "diffTotalHourlyCost": "DiffTotalHourlyCost", "diffTotalMonthlyCost": "DiffTotalMonthlyCost", "timeGenerated": "2019-01-01T12:00:00.000Z"}, "dependencies": [{"catalog_id": "CatalogID", "id": "ID", "name": "Name", "kind": "Kind", "version": "Version", "description": "Description", "default_flavor": "DefaultFlavor", "flavors": ["Flavors"], "optional": true, "on_by_default": false}], "install_type": "InstallType"}, "is_consumable": true, "compliance_v3": {"authority": "Authority", "claims": {"profiles": [{"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}], "controls": [{"profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "names": ["Names"]}]}, "evaluations": [{"scan_id": "ScanID", "account_id": "AccountID", "profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "result": {"failure_count": 12, "scan_time": "2019-01-01T12:00:00.000Z", "error_message": "ErrorMessage", "complete_scan": true, "unscanned_resources": ["UnscannedResources"]}, "controls": [{"id": "ID", "name": "Name", "description": "Description", "specifications": [{"id": "ID", "description": "Description", "component_name": "ComponentName", "assessments": [{"id": "ID", "description": "Description", "version": "Version", "type": "Type", "method": "Method", "ui_href": "UIHref"}], "ui_href": "UIHref"}], "failure_count": 12, "pass_count": 9, "parent": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "parent_name": "ParentName", "specifications": [{"id": "ID", "description": "Description", "component_name": "ComponentName", "assessments": [{"id": "ID", "description": "Description", "version": "Version", "type": "Type", "method": "Method", "ui_href": "UIHref"}], "ui_href": "UIHref"}], "ui_href": "UIHref"}, "ui_href": "UIHref"}]}]}, "change_notices": {"breaking": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "new": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "update": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}]}, "plan_ids": ["PlanIds"], "stack": {"anyKey": "anyValue"}, "minimum_compatible_version": "MinimumCompatibleVersion"}], "all_versions": {"first": {"href": "Href", "start": "Start"}, "next": {"href": "Href", "start": "Start"}}}], "publish": {"pc_managed": false, "approval_type": "ApprovalType", "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "original_crn": "OriginalCRN", "public_crn": "PublicCRN", "approval_record": {"anyKey": "anyValue"}, "permit_ibm_public_publish": true, "ibm_approved": false, "public_approved": true}, "pc_managed": false, "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "public_original_crn": "PublicOriginalCRN", "publish_public_crn": "PublishPublicCRN", "portal_approval_record": "PortalApprovalRecord", "portal_ui_url": "PortalUIURL", "catalog_id": "CatalogID", "catalog_name": "CatalogName", "metadata": {"anyKey": "anyValue"}, "disclaimer": "Disclaimer", "hidden": true, "provider": "Provider", "provider_info": {"id": "ID", "name": "Name"}, "repo_info": {"token": "Token", "type": "Type"}, "image_pull_keys": [{"name": "Name", "value": "Value", "description": "Description"}], "support": {"url": "URL", "process": "Process", "process_i18n": {"mapKey": "Inner"}, "locations": ["Locations"], "support_details": [{"type": "Type", "contact": "Contact", "response_wait_time": {"value": 5, "type": "Type"}, "availability": {"times": [{"day": 3, "start_time": "StartTime", "end_time": "EndTime"}], "timezone": "Timezone", "always_available": false}}], "support_escalation": {"escalation_wait_time": {"value": 5, "type": "Type"}, "response_wait_time": {"value": 5, "type": "Type"}, "contact": "Contact"}, "support_type": "SupportType"}, "media": [{"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}], "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "product_kind": "ProductKind", "badges": [{"id": "ID", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}, "icon": "Icon", "authority": "Authority", "tag": "Tag", "learn_more_links": {"first_party": "FirstParty", "third_party": "ThirdParty"}, "constraints": [{"type": "Type", "rule": "anyValue"}]}], "plans": [{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "offering_id": "OfferingID", "catalog_id": "CatalogID", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "name": "Name", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "pricing_tags": ["PricingTags"], "version_range": {"kinds": ["Kinds"], "version": "Version", "flavors": ["Flavors"]}, "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "metadata": {"anyKey": "anyValue"}, "publish_approved": false}]}`)
				}))
			})
			It(`Invoke ReplaceOffering successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the Rating model
				ratingModel := new(catalogmanagementv1.Rating)
				ratingModel.OneStarCount = core.Int64Ptr(int64(38))
				ratingModel.TwoStarCount = core.Int64Ptr(int64(38))
				ratingModel.ThreeStarCount = core.Int64Ptr(int64(38))
				ratingModel.FourStarCount = core.Int64Ptr(int64(38))

				// Construct an instance of the Feature model
				featureModel := new(catalogmanagementv1.Feature)
				featureModel.Title = core.StringPtr("testString")
				featureModel.TitleI18n = map[string]string{"key1": "testString"}
				featureModel.Description = core.StringPtr("testString")
				featureModel.DescriptionI18n = map[string]string{"key1": "testString"}

				// Construct an instance of the Flavor model
				flavorModel := new(catalogmanagementv1.Flavor)
				flavorModel.Name = core.StringPtr("testString")
				flavorModel.Label = core.StringPtr("testString")
				flavorModel.LabelI18n = map[string]string{"key1": "testString"}
				flavorModel.Index = core.Int64Ptr(int64(38))

				// Construct an instance of the RenderTypeAssociationsParametersItem model
				renderTypeAssociationsParametersItemModel := new(catalogmanagementv1.RenderTypeAssociationsParametersItem)
				renderTypeAssociationsParametersItemModel.Name = core.StringPtr("testString")
				renderTypeAssociationsParametersItemModel.OptionsRefresh = core.BoolPtr(true)

				// Construct an instance of the RenderTypeAssociations model
				renderTypeAssociationsModel := new(catalogmanagementv1.RenderTypeAssociations)
				renderTypeAssociationsModel.Parameters = []catalogmanagementv1.RenderTypeAssociationsParametersItem{*renderTypeAssociationsParametersItemModel}

				// Construct an instance of the RenderType model
				renderTypeModel := new(catalogmanagementv1.RenderType)
				renderTypeModel.Type = core.StringPtr("testString")
				renderTypeModel.Grouping = core.StringPtr("testString")
				renderTypeModel.OriginalGrouping = core.StringPtr("testString")
				renderTypeModel.GroupingIndex = core.Int64Ptr(int64(38))
				renderTypeModel.ConfigConstraints = map[string]interface{}{"anyKey": "anyValue"}
				renderTypeModel.Associations = renderTypeAssociationsModel

				// Construct an instance of the Configuration model
				configurationModel := new(catalogmanagementv1.Configuration)
				configurationModel.Key = core.StringPtr("testString")
				configurationModel.Type = core.StringPtr("testString")
				configurationModel.DefaultValue = "testString"
				configurationModel.DisplayName = core.StringPtr("testString")
				configurationModel.ValueConstraint = core.StringPtr("testString")
				configurationModel.Description = core.StringPtr("testString")
				configurationModel.Required = core.BoolPtr(true)
				configurationModel.Options = []interface{}{"testString"}
				configurationModel.Hidden = core.BoolPtr(true)
				configurationModel.CustomConfig = renderTypeModel
				configurationModel.TypeMetadata = core.StringPtr("testString")

				// Construct an instance of the Output model
				outputModel := new(catalogmanagementv1.Output)
				outputModel.Key = core.StringPtr("testString")
				outputModel.Description = core.StringPtr("testString")

				// Construct an instance of the IamResource model
				iamResourceModel := new(catalogmanagementv1.IamResource)
				iamResourceModel.Name = core.StringPtr("testString")
				iamResourceModel.Description = core.StringPtr("testString")
				iamResourceModel.RoleCrns = []string{"testString"}

				// Construct an instance of the IamPermission model
				iamPermissionModel := new(catalogmanagementv1.IamPermission)
				iamPermissionModel.ServiceName = core.StringPtr("testString")
				iamPermissionModel.RoleCrns = []string{"testString"}
				iamPermissionModel.Resources = []catalogmanagementv1.IamResource{*iamResourceModel}

				// Construct an instance of the Validation model
				validationModel := new(catalogmanagementv1.Validation)
				validationModel.Validated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				validationModel.Requested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				validationModel.State = core.StringPtr("testString")
				validationModel.LastOperation = core.StringPtr("testString")
				validationModel.Target = map[string]interface{}{"anyKey": "anyValue"}
				validationModel.Message = core.StringPtr("testString")

				// Construct an instance of the Resource model
				resourceModel := new(catalogmanagementv1.Resource)
				resourceModel.Type = core.StringPtr("mem")
				resourceModel.Value = "testString"

				// Construct an instance of the SchematicsEnvValues model
				schematicsEnvValuesModel := new(catalogmanagementv1.SchematicsEnvValues)
				schematicsEnvValuesModel.Value = core.StringPtr("[{\"name\": \"TF_LOG\",\"value\": \"TRACE\",\"secure\": false,\"hidden\": false}]")
				schematicsEnvValuesModel.SmRef = core.StringPtr("cmsm_v1:{\"name\": \"envVarSecret\",\"id\":\"1234567890\",\"service_id\":\"crn:v1:bluemix:public:secrets-manager:eu-gb:a/1234567890:1234567890::\",\"service_name\":\"My SM Instance\",\"group_id\":\"1234567890\",\"group_name\":\"My SM Group\",\"resource_group_id\":\"1234567890\",\"region\":\"eu-gb\",\"type\":\"arbitrary\"}")

				// Construct an instance of the Script model
				scriptModel := new(catalogmanagementv1.Script)
				scriptModel.Instructions = core.StringPtr("testString")
				scriptModel.InstructionsI18n = map[string]string{"key1": "testString"}
				scriptModel.Script = core.StringPtr("testString")
				scriptModel.ScriptPermission = core.StringPtr("testString")
				scriptModel.DeleteScript = core.StringPtr("testString")
				scriptModel.Scope = core.StringPtr("testString")

				// Construct an instance of the ScriptRef model
				scriptRefModel := new(catalogmanagementv1.ScriptRef)
				scriptRefModel.ShortDescription = core.StringPtr("testString")
				scriptRefModel.Type = core.StringPtr("ansible")
				scriptRefModel.Path = core.StringPtr("scripts/validate-post-ansible-playbook.yaml")
				scriptRefModel.Stage = core.StringPtr("pre")
				scriptRefModel.Action = core.StringPtr("validate")

				// Construct an instance of the VersionEntitlement model
				versionEntitlementModel := new(catalogmanagementv1.VersionEntitlement)
				versionEntitlementModel.ProviderName = core.StringPtr("testString")
				versionEntitlementModel.ProviderID = core.StringPtr("testString")
				versionEntitlementModel.ProductID = core.StringPtr("testString")
				versionEntitlementModel.PartNumbers = []string{"testString"}
				versionEntitlementModel.ImageRepoName = core.StringPtr("testString")

				// Construct an instance of the License model
				licenseModel := new(catalogmanagementv1.License)
				licenseModel.ID = core.StringPtr("testString")
				licenseModel.Name = core.StringPtr("testString")
				licenseModel.Type = core.StringPtr("testString")
				licenseModel.URL = core.StringPtr("testString")
				licenseModel.Description = core.StringPtr("testString")

				// Construct an instance of the State model
				stateModel := new(catalogmanagementv1.State)
				stateModel.Current = core.StringPtr("testString")
				stateModel.CurrentEntered = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Pending = core.StringPtr("testString")
				stateModel.PendingRequested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Previous = core.StringPtr("testString")

				// Construct an instance of the DeprecatePending model
				deprecatePendingModel := new(catalogmanagementv1.DeprecatePending)
				deprecatePendingModel.DeprecateDate = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				deprecatePendingModel.DeprecateState = core.StringPtr("testString")
				deprecatePendingModel.Description = core.StringPtr("testString")

				// Construct an instance of the URLProxy model
				urlProxyModel := new(catalogmanagementv1.URLProxy)
				urlProxyModel.URL = core.StringPtr("testString")
				urlProxyModel.Sha = core.StringPtr("testString")

				// Construct an instance of the MediaItem model
				mediaItemModel := new(catalogmanagementv1.MediaItem)
				mediaItemModel.URL = core.StringPtr("testString")
				mediaItemModel.APIURL = core.StringPtr("testString")
				mediaItemModel.URLProxy = urlProxyModel
				mediaItemModel.Caption = core.StringPtr("testString")
				mediaItemModel.CaptionI18n = map[string]string{"key1": "testString"}
				mediaItemModel.Type = core.StringPtr("testString")
				mediaItemModel.ThumbnailURL = core.StringPtr("testString")

				// Construct an instance of the ArchitectureDiagram model
				architectureDiagramModel := new(catalogmanagementv1.ArchitectureDiagram)
				architectureDiagramModel.Diagram = mediaItemModel
				architectureDiagramModel.Description = core.StringPtr("testString")
				architectureDiagramModel.DescriptionI18n = map[string]string{"key1": "testString"}

				// Construct an instance of the CostComponent model
				costComponentModel := new(catalogmanagementv1.CostComponent)
				costComponentModel.Name = core.StringPtr("testString")
				costComponentModel.Unit = core.StringPtr("testString")
				costComponentModel.HourlyQuantity = core.StringPtr("testString")
				costComponentModel.MonthlyQuantity = core.StringPtr("testString")
				costComponentModel.Price = core.StringPtr("testString")
				costComponentModel.HourlyCost = core.StringPtr("testString")
				costComponentModel.MonthlyCost = core.StringPtr("testString")

				// Construct an instance of the CostResource model
				costResourceModel := new(catalogmanagementv1.CostResource)
				costResourceModel.Name = core.StringPtr("testString")
				costResourceModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				costResourceModel.HourlyCost = core.StringPtr("testString")
				costResourceModel.MonthlyCost = core.StringPtr("testString")
				costResourceModel.CostComponents = []catalogmanagementv1.CostComponent{*costComponentModel}

				// Construct an instance of the CostBreakdown model
				costBreakdownModel := new(catalogmanagementv1.CostBreakdown)
				costBreakdownModel.TotalHourlyCost = core.StringPtr("testString")
				costBreakdownModel.TotalMonthlyCost = core.StringPtr("testString")
				costBreakdownModel.Resources = []catalogmanagementv1.CostResource{*costResourceModel}

				// Construct an instance of the CostSummary model
				costSummaryModel := new(catalogmanagementv1.CostSummary)
				costSummaryModel.TotalDetectedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalSupportedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalUnsupportedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalUsageBasedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalNoPriceResources = core.Int64Ptr(int64(38))
				costSummaryModel.UnsupportedResourceCounts = map[string]int64{"key1": int64(38)}
				costSummaryModel.NoPriceResourceCounts = map[string]int64{"key1": int64(38)}

				// Construct an instance of the Project model
				projectModel := new(catalogmanagementv1.Project)
				projectModel.Name = core.StringPtr("testString")
				projectModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				projectModel.PastBreakdown = costBreakdownModel
				projectModel.Breakdown = costBreakdownModel
				projectModel.Diff = costBreakdownModel
				projectModel.Summary = costSummaryModel

				// Construct an instance of the CostEstimate model
				costEstimateModel := new(catalogmanagementv1.CostEstimate)
				costEstimateModel.Version = core.StringPtr("testString")
				costEstimateModel.Currency = core.StringPtr("testString")
				costEstimateModel.Projects = []catalogmanagementv1.Project{*projectModel}
				costEstimateModel.Summary = costSummaryModel
				costEstimateModel.TotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.TotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.PastTotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.PastTotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.DiffTotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.DiffTotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.TimeGenerated = CreateMockDateTime("2019-01-01T12:00:00.000Z")

				// Construct an instance of the OfferingReference model
				offeringReferenceModel := new(catalogmanagementv1.OfferingReference)
				offeringReferenceModel.CatalogID = core.StringPtr("testString")
				offeringReferenceModel.ID = core.StringPtr("testString")
				offeringReferenceModel.Name = core.StringPtr("testString")
				offeringReferenceModel.Kind = core.StringPtr("testString")
				offeringReferenceModel.Version = core.StringPtr("testString")
				offeringReferenceModel.Description = core.StringPtr("testString")
				offeringReferenceModel.DefaultFlavor = core.StringPtr("testString")
				offeringReferenceModel.Flavors = []string{"testString"}
				offeringReferenceModel.Optional = core.BoolPtr(true)
				offeringReferenceModel.OnByDefault = core.BoolPtr(true)

				// Construct an instance of the SolutionInfo model
				solutionInfoModel := new(catalogmanagementv1.SolutionInfo)
				solutionInfoModel.ArchitectureDiagrams = []catalogmanagementv1.ArchitectureDiagram{*architectureDiagramModel}
				solutionInfoModel.Features = []catalogmanagementv1.Feature{*featureModel}
				solutionInfoModel.CostEstimate = costEstimateModel
				solutionInfoModel.Dependencies = []catalogmanagementv1.OfferingReference{*offeringReferenceModel}
				solutionInfoModel.InstallType = core.StringPtr("testString")

				// Construct an instance of the SccProfile model
				sccProfileModel := new(catalogmanagementv1.SccProfile)
				sccProfileModel.ID = core.StringPtr("testString")
				sccProfileModel.Name = core.StringPtr("testString")
				sccProfileModel.Version = core.StringPtr("testString")
				sccProfileModel.Description = core.StringPtr("testString")
				sccProfileModel.Type = core.StringPtr("testString")
				sccProfileModel.UIHref = core.StringPtr("testString")

				// Construct an instance of the ClaimedControl model
				claimedControlModel := new(catalogmanagementv1.ClaimedControl)
				claimedControlModel.Profile = sccProfileModel
				claimedControlModel.Names = []string{"testString"}

				// Construct an instance of the Claims model
				claimsModel := new(catalogmanagementv1.Claims)
				claimsModel.Profiles = []catalogmanagementv1.SccProfile{*sccProfileModel}
				claimsModel.Controls = []catalogmanagementv1.ClaimedControl{*claimedControlModel}

				// Construct an instance of the Result model
				resultModel := new(catalogmanagementv1.Result)
				resultModel.FailureCount = core.Int64Ptr(int64(38))
				resultModel.ScanTime = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				resultModel.ErrorMessage = core.StringPtr("testString")
				resultModel.CompleteScan = core.BoolPtr(true)
				resultModel.UnscannedResources = []string{"testString"}

				// Construct an instance of the SccAssessment model
				sccAssessmentModel := new(catalogmanagementv1.SccAssessment)
				sccAssessmentModel.ID = core.StringPtr("testString")
				sccAssessmentModel.Description = core.StringPtr("testString")
				sccAssessmentModel.Version = core.StringPtr("testString")
				sccAssessmentModel.Type = core.StringPtr("testString")
				sccAssessmentModel.Method = core.StringPtr("testString")
				sccAssessmentModel.UIHref = core.StringPtr("testString")

				// Construct an instance of the SccSpecification model
				sccSpecificationModel := new(catalogmanagementv1.SccSpecification)
				sccSpecificationModel.ID = core.StringPtr("testString")
				sccSpecificationModel.Description = core.StringPtr("testString")
				sccSpecificationModel.ComponentName = core.StringPtr("testString")
				sccSpecificationModel.Assessments = []catalogmanagementv1.SccAssessment{*sccAssessmentModel}
				sccSpecificationModel.UIHref = core.StringPtr("testString")

				// Construct an instance of the SccControl model
				sccControlModel := new(catalogmanagementv1.SccControl)
				sccControlModel.ID = core.StringPtr("testString")
				sccControlModel.Name = core.StringPtr("testString")
				sccControlModel.Version = core.StringPtr("testString")
				sccControlModel.Description = core.StringPtr("testString")
				sccControlModel.Profile = sccProfileModel
				sccControlModel.ParentName = core.StringPtr("testString")
				sccControlModel.Specifications = []catalogmanagementv1.SccSpecification{*sccSpecificationModel}
				sccControlModel.UIHref = core.StringPtr("testString")

				// Construct an instance of the EvaluatedControl model
				evaluatedControlModel := new(catalogmanagementv1.EvaluatedControl)
				evaluatedControlModel.ID = core.StringPtr("testString")
				evaluatedControlModel.Name = core.StringPtr("testString")
				evaluatedControlModel.Description = core.StringPtr("testString")
				evaluatedControlModel.Specifications = []catalogmanagementv1.SccSpecification{*sccSpecificationModel}
				evaluatedControlModel.FailureCount = core.Int64Ptr(int64(38))
				evaluatedControlModel.PassCount = core.Int64Ptr(int64(38))
				evaluatedControlModel.Parent = sccControlModel
				evaluatedControlModel.UIHref = core.StringPtr("testString")

				// Construct an instance of the Evaluation model
				evaluationModel := new(catalogmanagementv1.Evaluation)
				evaluationModel.ScanID = core.StringPtr("testString")
				evaluationModel.AccountID = core.StringPtr("testString")
				evaluationModel.Profile = sccProfileModel
				evaluationModel.Result = resultModel
				evaluationModel.Controls = []catalogmanagementv1.EvaluatedControl{*evaluatedControlModel}

				// Construct an instance of the Compliance model
				complianceModel := new(catalogmanagementv1.Compliance)
				complianceModel.Authority = core.StringPtr("testString")
				complianceModel.Claims = claimsModel
				complianceModel.Evaluations = []catalogmanagementv1.Evaluation{*evaluationModel}

				// Construct an instance of the ChangeNotices model
				changeNoticesModel := new(catalogmanagementv1.ChangeNotices)
				changeNoticesModel.Breaking = []catalogmanagementv1.Feature{*featureModel}
				changeNoticesModel.New = []catalogmanagementv1.Feature{*featureModel}
				changeNoticesModel.Update = []catalogmanagementv1.Feature{*featureModel}

				// Construct an instance of the Version model
				versionModel := new(catalogmanagementv1.Version)
				versionModel.CRN = core.StringPtr("testString")
				versionModel.Version = core.StringPtr("testString")
				versionModel.Flavor = flavorModel
				versionModel.Sha = core.StringPtr("testString")
				versionModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				versionModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				versionModel.OfferingID = core.StringPtr("testString")
				versionModel.CatalogID = core.StringPtr("testString")
				versionModel.KindID = core.StringPtr("testString")
				versionModel.Tags = []string{"testString"}
				versionModel.RepoURL = core.StringPtr("testString")
				versionModel.SourceURL = core.StringPtr("testString")
				versionModel.TgzURL = core.StringPtr("testString")
				versionModel.Configuration = []catalogmanagementv1.Configuration{*configurationModel}
				versionModel.Outputs = []catalogmanagementv1.Output{*outputModel}
				versionModel.IamPermissions = []catalogmanagementv1.IamPermission{*iamPermissionModel}
				versionModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				versionModel.Validation = validationModel
				versionModel.RequiredResources = []catalogmanagementv1.Resource{*resourceModel}
				versionModel.SingleInstance = core.BoolPtr(true)
				versionModel.SchematicsEnvValues = schematicsEnvValuesModel
				versionModel.Install = scriptModel
				versionModel.PreInstall = []catalogmanagementv1.Script{*scriptModel}
				versionModel.Scripts = map[string]catalogmanagementv1.ScriptRef{"key1": *scriptRefModel}
				versionModel.Entitlement = versionEntitlementModel
				versionModel.Licenses = []catalogmanagementv1.License{*licenseModel}
				versionModel.ImageManifestURL = core.StringPtr("testString")
				versionModel.Deprecated = core.BoolPtr(true)
				versionModel.PackageVersion = core.StringPtr("testString")
				versionModel.State = stateModel
				versionModel.VersionLocator = core.StringPtr("testString")
				versionModel.LongDescription = core.StringPtr("testString")
				versionModel.LongDescriptionI18n = map[string]string{"key1": "testString"}
				versionModel.WhitelistedAccounts = []string{"testString"}
				versionModel.ImagePullKeyName = core.StringPtr("testString")
				versionModel.DeprecatePending = deprecatePendingModel
				versionModel.SolutionInfo = solutionInfoModel
				versionModel.IsConsumable = core.BoolPtr(true)
				versionModel.ComplianceV3 = complianceModel
				versionModel.ChangeNotices = changeNoticesModel
				versionModel.PlanIds = []string{"testString"}
				versionModel.Stack = map[string]interface{}{"anyKey": "anyValue"}
				versionModel.MinimumCompatibleVersion = core.StringPtr("testString")
				versionModel.Scripts["foo"] = *scriptRefModel

				// Construct an instance of the PaginationTokenLink model
				paginationTokenLinkModel := new(catalogmanagementv1.PaginationTokenLink)
				paginationTokenLinkModel.Href = core.StringPtr("testString")
				paginationTokenLinkModel.Start = core.StringPtr("testString")

				// Construct an instance of the KindAllVersions model
				kindAllVersionsModel := new(catalogmanagementv1.KindAllVersions)
				kindAllVersionsModel.First = paginationTokenLinkModel
				kindAllVersionsModel.Next = paginationTokenLinkModel

				// Construct an instance of the Kind model
				kindModel := new(catalogmanagementv1.Kind)
				kindModel.ID = core.StringPtr("testString")
				kindModel.FormatKind = core.StringPtr("testString")
				kindModel.FormatKindLabel = core.StringPtr("testString")
				kindModel.InstallKind = core.StringPtr("testString")
				kindModel.InstallKindLabel = core.StringPtr("testString")
				kindModel.TargetKind = core.StringPtr("testString")
				kindModel.TargetKindLabel = core.StringPtr("testString")
				kindModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				kindModel.Tags = []string{"testString"}
				kindModel.AdditionalFeatures = []catalogmanagementv1.Feature{*featureModel}
				kindModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				kindModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				kindModel.Versions = []catalogmanagementv1.Version{*versionModel}
				kindModel.AllVersions = kindAllVersionsModel

				// Construct an instance of the PublishObject model
				publishObjectModel := new(catalogmanagementv1.PublishObject)
				publishObjectModel.PcManaged = core.BoolPtr(true)
				publishObjectModel.ApprovalType = core.StringPtr("testString")
				publishObjectModel.PublishApproved = core.BoolPtr(true)
				publishObjectModel.ShareWithAll = core.BoolPtr(true)
				publishObjectModel.ShareWithIBM = core.BoolPtr(true)
				publishObjectModel.ShareEnabled = core.BoolPtr(true)
				publishObjectModel.OriginalCRN = core.StringPtr("testString")
				publishObjectModel.PublicCRN = core.StringPtr("testString")
				publishObjectModel.ApprovalRecord = map[string]interface{}{"anyKey": "anyValue"}
				publishObjectModel.PermitIBMPublicPublish = core.BoolPtr(true)
				publishObjectModel.IBMApproved = core.BoolPtr(true)
				publishObjectModel.PublicApproved = core.BoolPtr(true)

				// Construct an instance of the ProviderInfo model
				providerInfoModel := new(catalogmanagementv1.ProviderInfo)
				providerInfoModel.ID = core.StringPtr("testString")
				providerInfoModel.Name = core.StringPtr("testString")

				// Construct an instance of the RepoInfo model
				repoInfoModel := new(catalogmanagementv1.RepoInfo)
				repoInfoModel.Token = core.StringPtr("testString")
				repoInfoModel.Type = core.StringPtr("testString")

				// Construct an instance of the ImagePullKey model
				imagePullKeyModel := new(catalogmanagementv1.ImagePullKey)
				imagePullKeyModel.Name = core.StringPtr("testString")
				imagePullKeyModel.Value = core.StringPtr("testString")
				imagePullKeyModel.Description = core.StringPtr("testString")

				// Construct an instance of the SupportWaitTime model
				supportWaitTimeModel := new(catalogmanagementv1.SupportWaitTime)
				supportWaitTimeModel.Value = core.Int64Ptr(int64(38))
				supportWaitTimeModel.Type = core.StringPtr("testString")

				// Construct an instance of the SupportTime model
				supportTimeModel := new(catalogmanagementv1.SupportTime)
				supportTimeModel.Day = core.Int64Ptr(int64(38))
				supportTimeModel.StartTime = core.StringPtr("testString")
				supportTimeModel.EndTime = core.StringPtr("testString")

				// Construct an instance of the SupportAvailability model
				supportAvailabilityModel := new(catalogmanagementv1.SupportAvailability)
				supportAvailabilityModel.Times = []catalogmanagementv1.SupportTime{*supportTimeModel}
				supportAvailabilityModel.Timezone = core.StringPtr("testString")
				supportAvailabilityModel.AlwaysAvailable = core.BoolPtr(true)

				// Construct an instance of the SupportDetail model
				supportDetailModel := new(catalogmanagementv1.SupportDetail)
				supportDetailModel.Type = core.StringPtr("testString")
				supportDetailModel.Contact = core.StringPtr("testString")
				supportDetailModel.ResponseWaitTime = supportWaitTimeModel
				supportDetailModel.Availability = supportAvailabilityModel

				// Construct an instance of the SupportEscalation model
				supportEscalationModel := new(catalogmanagementv1.SupportEscalation)
				supportEscalationModel.EscalationWaitTime = supportWaitTimeModel
				supportEscalationModel.ResponseWaitTime = supportWaitTimeModel
				supportEscalationModel.Contact = core.StringPtr("testString")

				// Construct an instance of the Support model
				supportModel := new(catalogmanagementv1.Support)
				supportModel.URL = core.StringPtr("testString")
				supportModel.Process = core.StringPtr("testString")
				supportModel.ProcessI18n = map[string]string{"key1": "testString"}
				supportModel.Locations = []string{"testString"}
				supportModel.SupportDetails = []catalogmanagementv1.SupportDetail{*supportDetailModel}
				supportModel.SupportEscalation = supportEscalationModel
				supportModel.SupportType = core.StringPtr("testString")

				// Construct an instance of the LearnMoreLinks model
				learnMoreLinksModel := new(catalogmanagementv1.LearnMoreLinks)
				learnMoreLinksModel.FirstParty = core.StringPtr("testString")
				learnMoreLinksModel.ThirdParty = core.StringPtr("testString")

				// Construct an instance of the Constraint model
				constraintModel := new(catalogmanagementv1.Constraint)
				constraintModel.Type = core.StringPtr("testString")
				constraintModel.Rule = "testString"

				// Construct an instance of the Badge model
				badgeModel := new(catalogmanagementv1.Badge)
				badgeModel.ID = core.StringPtr("testString")
				badgeModel.Label = core.StringPtr("testString")
				badgeModel.LabelI18n = map[string]string{"key1": "testString"}
				badgeModel.Description = core.StringPtr("testString")
				badgeModel.DescriptionI18n = map[string]string{"key1": "testString"}
				badgeModel.Icon = core.StringPtr("testString")
				badgeModel.Authority = core.StringPtr("testString")
				badgeModel.Tag = core.StringPtr("testString")
				badgeModel.LearnMoreLinks = learnMoreLinksModel
				badgeModel.Constraints = []catalogmanagementv1.Constraint{*constraintModel}

				// Construct an instance of the VersionRange model
				versionRangeModel := new(catalogmanagementv1.VersionRange)
				versionRangeModel.Kinds = []string{"testString"}
				versionRangeModel.Version = core.StringPtr("testString")
				versionRangeModel.Flavors = []string{"testString"}

				// Construct an instance of the Plan model
				planModel := new(catalogmanagementv1.Plan)
				planModel.URL = core.StringPtr("testString")
				planModel.CRN = core.StringPtr("testString")
				planModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				planModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				planModel.OfferingID = core.StringPtr("testString")
				planModel.CatalogID = core.StringPtr("testString")
				planModel.Label = core.StringPtr("testString")
				planModel.LabelI18n = map[string]string{"key1": "testString"}
				planModel.Name = core.StringPtr("testString")
				planModel.ShortDescription = core.StringPtr("testString")
				planModel.ShortDescriptionI18n = map[string]string{"key1": "testString"}
				planModel.PricingTags = []string{"testString"}
				planModel.VersionRange = versionRangeModel
				planModel.Features = []catalogmanagementv1.Feature{*featureModel}
				planModel.State = stateModel
				planModel.DeprecatePending = deprecatePendingModel
				planModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				planModel.PublishApproved = core.BoolPtr(true)

				// Construct an instance of the ReplaceOfferingOptions model
				replaceOfferingOptionsModel := new(catalogmanagementv1.ReplaceOfferingOptions)
				replaceOfferingOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				replaceOfferingOptionsModel.OfferingID = core.StringPtr("testString")
				replaceOfferingOptionsModel.ID = core.StringPtr("testString")
				replaceOfferingOptionsModel.Rev = core.StringPtr("testString")
				replaceOfferingOptionsModel.URL = core.StringPtr("testString")
				replaceOfferingOptionsModel.CRN = core.StringPtr("testString")
				replaceOfferingOptionsModel.Label = core.StringPtr("testString")
				replaceOfferingOptionsModel.LabelI18n = map[string]string{"key1": "testString"}
				replaceOfferingOptionsModel.Name = core.StringPtr("testString")
				replaceOfferingOptionsModel.OfferingIconURL = core.StringPtr("testString")
				replaceOfferingOptionsModel.OfferingDocsURL = core.StringPtr("testString")
				replaceOfferingOptionsModel.OfferingSupportURL = core.StringPtr("testString")
				replaceOfferingOptionsModel.Tags = []string{"testString"}
				replaceOfferingOptionsModel.Keywords = []string{"testString"}
				replaceOfferingOptionsModel.Rating = ratingModel
				replaceOfferingOptionsModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				replaceOfferingOptionsModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				replaceOfferingOptionsModel.ShortDescription = core.StringPtr("testString")
				replaceOfferingOptionsModel.ShortDescriptionI18n = map[string]string{"key1": "testString"}
				replaceOfferingOptionsModel.LongDescription = core.StringPtr("testString")
				replaceOfferingOptionsModel.LongDescriptionI18n = map[string]string{"key1": "testString"}
				replaceOfferingOptionsModel.Features = []catalogmanagementv1.Feature{*featureModel}
				replaceOfferingOptionsModel.Kinds = []catalogmanagementv1.Kind{*kindModel}
				replaceOfferingOptionsModel.Publish = publishObjectModel
				replaceOfferingOptionsModel.PcManaged = core.BoolPtr(true)
				replaceOfferingOptionsModel.PublishApproved = core.BoolPtr(true)
				replaceOfferingOptionsModel.ShareWithAll = core.BoolPtr(true)
				replaceOfferingOptionsModel.ShareWithIBM = core.BoolPtr(true)
				replaceOfferingOptionsModel.ShareEnabled = core.BoolPtr(true)
				replaceOfferingOptionsModel.PublicOriginalCRN = core.StringPtr("testString")
				replaceOfferingOptionsModel.PublishPublicCRN = core.StringPtr("testString")
				replaceOfferingOptionsModel.PortalApprovalRecord = core.StringPtr("testString")
				replaceOfferingOptionsModel.PortalUIURL = core.StringPtr("testString")
				replaceOfferingOptionsModel.CatalogID = core.StringPtr("testString")
				replaceOfferingOptionsModel.CatalogName = core.StringPtr("testString")
				replaceOfferingOptionsModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				replaceOfferingOptionsModel.Disclaimer = core.StringPtr("testString")
				replaceOfferingOptionsModel.Hidden = core.BoolPtr(true)
				replaceOfferingOptionsModel.Provider = core.StringPtr("testString")
				replaceOfferingOptionsModel.ProviderInfo = providerInfoModel
				replaceOfferingOptionsModel.RepoInfo = repoInfoModel
				replaceOfferingOptionsModel.ImagePullKeys = []catalogmanagementv1.ImagePullKey{*imagePullKeyModel}
				replaceOfferingOptionsModel.Support = supportModel
				replaceOfferingOptionsModel.Media = []catalogmanagementv1.MediaItem{*mediaItemModel}
				replaceOfferingOptionsModel.DeprecatePending = deprecatePendingModel
				replaceOfferingOptionsModel.ProductKind = core.StringPtr("testString")
				replaceOfferingOptionsModel.Badges = []catalogmanagementv1.Badge{*badgeModel}
				replaceOfferingOptionsModel.Plans = []catalogmanagementv1.Plan{*planModel}
				replaceOfferingOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.ReplaceOfferingWithContext(ctx, replaceOfferingOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.ReplaceOffering(replaceOfferingOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.ReplaceOfferingWithContext(ctx, replaceOfferingOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(replaceOfferingPath))
					Expect(req.Method).To(Equal("PUT"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "name": "Name", "offering_icon_url": "OfferingIconURL", "offering_docs_url": "OfferingDocsURL", "offering_support_url": "OfferingSupportURL", "tags": ["Tags"], "keywords": ["Keywords"], "rating": {"one_star_count": 12, "two_star_count": 12, "three_star_count": 14, "four_star_count": 13}, "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "kinds": [{"id": "ID", "format_kind": "FormatKind", "format_kind_label": "FormatKindLabel", "install_kind": "InstallKind", "install_kind_label": "InstallKindLabel", "target_kind": "TargetKind", "target_kind_label": "TargetKindLabel", "metadata": {"anyKey": "anyValue"}, "tags": ["Tags"], "additional_features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "versions": [{"id": "ID", "_rev": "Rev", "crn": "CRN", "version": "Version", "flavor": {"name": "Name", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "index": 5}, "sha": "Sha", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "offering_id": "OfferingID", "catalog_id": "CatalogID", "kind_id": "KindID", "tags": ["Tags"], "repo_url": "RepoURL", "source_url": "SourceURL", "tgz_url": "TgzURL", "configuration": [{"key": "Key", "type": "Type", "default_value": "anyValue", "display_name": "DisplayName", "value_constraint": "ValueConstraint", "description": "Description", "required": true, "options": ["anyValue"], "hidden": true, "custom_config": {"type": "Type", "grouping": "Grouping", "original_grouping": "OriginalGrouping", "grouping_index": 13, "config_constraints": {"anyKey": "anyValue"}, "associations": {"parameters": [{"name": "Name", "optionsRefresh": true}]}}, "type_metadata": "TypeMetadata"}], "outputs": [{"key": "Key", "description": "Description"}], "iam_permissions": [{"service_name": "ServiceName", "role_crns": ["RoleCrns"], "resources": [{"name": "Name", "description": "Description", "role_crns": ["RoleCrns"]}]}], "metadata": {"anyKey": "anyValue"}, "validation": {"validated": "2019-01-01T12:00:00.000Z", "requested": "2019-01-01T12:00:00.000Z", "state": "State", "last_operation": "LastOperation", "target": {"anyKey": "anyValue"}, "message": "Message"}, "required_resources": [{"type": "mem", "value": "anyValue"}], "single_instance": true, "schematics_env_values": {"value": "[{\"name\": \"TF_LOG\",\"value\": \"TRACE\",\"secure\": false,\"hidden\": false}]", "sm_ref": "cmsm_v1:{\"name\": \"envVarSecret\",\"id\":\"1234567890\",\"service_id\":\"crn:v1:bluemix:public:secrets-manager:eu-gb:a/1234567890:1234567890::\",\"service_name\":\"My SM Instance\",\"group_id\":\"1234567890\",\"group_name\":\"My SM Group\",\"resource_group_id\":\"1234567890\",\"region\":\"eu-gb\",\"type\":\"arbitrary\"}"}, "install": {"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}, "pre_install": [{"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}], "scripts": {"mapKey": {"short_description": "ShortDescription", "type": "ansible", "path": "scripts/validate-post-ansible-playbook.yaml", "stage": "pre", "action": "validate"}}, "entitlement": {"provider_name": "ProviderName", "provider_id": "ProviderID", "product_id": "ProductID", "part_numbers": ["PartNumbers"], "image_repo_name": "ImageRepoName"}, "licenses": [{"id": "ID", "name": "Name", "type": "Type", "url": "URL", "description": "Description"}], "image_manifest_url": "ImageManifestURL", "deprecated": true, "package_version": "PackageVersion", "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "version_locator": "VersionLocator", "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "whitelisted_accounts": ["WhitelistedAccounts"], "image_pull_key_name": "ImagePullKeyName", "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "solution_info": {"architecture_diagrams": [{"diagram": {"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "cost_estimate": {"version": "Version", "currency": "Currency", "projects": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "pastBreakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "breakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "diff": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}}], "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}, "totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "pastTotalHourlyCost": "PastTotalHourlyCost", "pastTotalMonthlyCost": "PastTotalMonthlyCost", "diffTotalHourlyCost": "DiffTotalHourlyCost", "diffTotalMonthlyCost": "DiffTotalMonthlyCost", "timeGenerated": "2019-01-01T12:00:00.000Z"}, "dependencies": [{"catalog_id": "CatalogID", "id": "ID", "name": "Name", "kind": "Kind", "version": "Version", "description": "Description", "default_flavor": "DefaultFlavor", "flavors": ["Flavors"], "optional": true, "on_by_default": false}], "install_type": "InstallType"}, "is_consumable": true, "compliance_v3": {"authority": "Authority", "claims": {"profiles": [{"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}], "controls": [{"profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "names": ["Names"]}]}, "evaluations": [{"scan_id": "ScanID", "account_id": "AccountID", "profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "result": {"failure_count": 12, "scan_time": "2019-01-01T12:00:00.000Z", "error_message": "ErrorMessage", "complete_scan": true, "unscanned_resources": ["UnscannedResources"]}, "controls": [{"id": "ID", "name": "Name", "description": "Description", "specifications": [{"id": "ID", "description": "Description", "component_name": "ComponentName", "assessments": [{"id": "ID", "description": "Description", "version": "Version", "type": "Type", "method": "Method", "ui_href": "UIHref"}], "ui_href": "UIHref"}], "failure_count": 12, "pass_count": 9, "parent": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "parent_name": "ParentName", "specifications": [{"id": "ID", "description": "Description", "component_name": "ComponentName", "assessments": [{"id": "ID", "description": "Description", "version": "Version", "type": "Type", "method": "Method", "ui_href": "UIHref"}], "ui_href": "UIHref"}], "ui_href": "UIHref"}, "ui_href": "UIHref"}]}]}, "change_notices": {"breaking": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "new": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "update": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}]}, "plan_ids": ["PlanIds"], "stack": {"anyKey": "anyValue"}, "minimum_compatible_version": "MinimumCompatibleVersion"}], "all_versions": {"first": {"href": "Href", "start": "Start"}, "next": {"href": "Href", "start": "Start"}}}], "publish": {"pc_managed": false, "approval_type": "ApprovalType", "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "original_crn": "OriginalCRN", "public_crn": "PublicCRN", "approval_record": {"anyKey": "anyValue"}, "permit_ibm_public_publish": true, "ibm_approved": false, "public_approved": true}, "pc_managed": false, "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "public_original_crn": "PublicOriginalCRN", "publish_public_crn": "PublishPublicCRN", "portal_approval_record": "PortalApprovalRecord", "portal_ui_url": "PortalUIURL", "catalog_id": "CatalogID", "catalog_name": "CatalogName", "metadata": {"anyKey": "anyValue"}, "disclaimer": "Disclaimer", "hidden": true, "provider": "Provider", "provider_info": {"id": "ID", "name": "Name"}, "repo_info": {"token": "Token", "type": "Type"}, "image_pull_keys": [{"name": "Name", "value": "Value", "description": "Description"}], "support": {"url": "URL", "process": "Process", "process_i18n": {"mapKey": "Inner"}, "locations": ["Locations"], "support_details": [{"type": "Type", "contact": "Contact", "response_wait_time": {"value": 5, "type": "Type"}, "availability": {"times": [{"day": 3, "start_time": "StartTime", "end_time": "EndTime"}], "timezone": "Timezone", "always_available": false}}], "support_escalation": {"escalation_wait_time": {"value": 5, "type": "Type"}, "response_wait_time": {"value": 5, "type": "Type"}, "contact": "Contact"}, "support_type": "SupportType"}, "media": [{"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}], "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "product_kind": "ProductKind", "badges": [{"id": "ID", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}, "icon": "Icon", "authority": "Authority", "tag": "Tag", "learn_more_links": {"first_party": "FirstParty", "third_party": "ThirdParty"}, "constraints": [{"type": "Type", "rule": "anyValue"}]}], "plans": [{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "offering_id": "OfferingID", "catalog_id": "CatalogID", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "name": "Name", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "pricing_tags": ["PricingTags"], "version_range": {"kinds": ["Kinds"], "version": "Version", "flavors": ["Flavors"]}, "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "metadata": {"anyKey": "anyValue"}, "publish_approved": false}]}`)
				}))
			})
			It(`Invoke ReplaceOffering successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.ReplaceOffering(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the Rating model
				ratingModel := new(catalogmanagementv1.Rating)
				ratingModel.OneStarCount = core.Int64Ptr(int64(38))
				ratingModel.TwoStarCount = core.Int64Ptr(int64(38))
				ratingModel.ThreeStarCount = core.Int64Ptr(int64(38))
				ratingModel.FourStarCount = core.Int64Ptr(int64(38))

				// Construct an instance of the Feature model
				featureModel := new(catalogmanagementv1.Feature)
				featureModel.Title = core.StringPtr("testString")
				featureModel.TitleI18n = map[string]string{"key1": "testString"}
				featureModel.Description = core.StringPtr("testString")
				featureModel.DescriptionI18n = map[string]string{"key1": "testString"}

				// Construct an instance of the Flavor model
				flavorModel := new(catalogmanagementv1.Flavor)
				flavorModel.Name = core.StringPtr("testString")
				flavorModel.Label = core.StringPtr("testString")
				flavorModel.LabelI18n = map[string]string{"key1": "testString"}
				flavorModel.Index = core.Int64Ptr(int64(38))

				// Construct an instance of the RenderTypeAssociationsParametersItem model
				renderTypeAssociationsParametersItemModel := new(catalogmanagementv1.RenderTypeAssociationsParametersItem)
				renderTypeAssociationsParametersItemModel.Name = core.StringPtr("testString")
				renderTypeAssociationsParametersItemModel.OptionsRefresh = core.BoolPtr(true)

				// Construct an instance of the RenderTypeAssociations model
				renderTypeAssociationsModel := new(catalogmanagementv1.RenderTypeAssociations)
				renderTypeAssociationsModel.Parameters = []catalogmanagementv1.RenderTypeAssociationsParametersItem{*renderTypeAssociationsParametersItemModel}

				// Construct an instance of the RenderType model
				renderTypeModel := new(catalogmanagementv1.RenderType)
				renderTypeModel.Type = core.StringPtr("testString")
				renderTypeModel.Grouping = core.StringPtr("testString")
				renderTypeModel.OriginalGrouping = core.StringPtr("testString")
				renderTypeModel.GroupingIndex = core.Int64Ptr(int64(38))
				renderTypeModel.ConfigConstraints = map[string]interface{}{"anyKey": "anyValue"}
				renderTypeModel.Associations = renderTypeAssociationsModel

				// Construct an instance of the Configuration model
				configurationModel := new(catalogmanagementv1.Configuration)
				configurationModel.Key = core.StringPtr("testString")
				configurationModel.Type = core.StringPtr("testString")
				configurationModel.DefaultValue = "testString"
				configurationModel.DisplayName = core.StringPtr("testString")
				configurationModel.ValueConstraint = core.StringPtr("testString")
				configurationModel.Description = core.StringPtr("testString")
				configurationModel.Required = core.BoolPtr(true)
				configurationModel.Options = []interface{}{"testString"}
				configurationModel.Hidden = core.BoolPtr(true)
				configurationModel.CustomConfig = renderTypeModel
				configurationModel.TypeMetadata = core.StringPtr("testString")

				// Construct an instance of the Output model
				outputModel := new(catalogmanagementv1.Output)
				outputModel.Key = core.StringPtr("testString")
				outputModel.Description = core.StringPtr("testString")

				// Construct an instance of the IamResource model
				iamResourceModel := new(catalogmanagementv1.IamResource)
				iamResourceModel.Name = core.StringPtr("testString")
				iamResourceModel.Description = core.StringPtr("testString")
				iamResourceModel.RoleCrns = []string{"testString"}

				// Construct an instance of the IamPermission model
				iamPermissionModel := new(catalogmanagementv1.IamPermission)
				iamPermissionModel.ServiceName = core.StringPtr("testString")
				iamPermissionModel.RoleCrns = []string{"testString"}
				iamPermissionModel.Resources = []catalogmanagementv1.IamResource{*iamResourceModel}

				// Construct an instance of the Validation model
				validationModel := new(catalogmanagementv1.Validation)
				validationModel.Validated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				validationModel.Requested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				validationModel.State = core.StringPtr("testString")
				validationModel.LastOperation = core.StringPtr("testString")
				validationModel.Target = map[string]interface{}{"anyKey": "anyValue"}
				validationModel.Message = core.StringPtr("testString")

				// Construct an instance of the Resource model
				resourceModel := new(catalogmanagementv1.Resource)
				resourceModel.Type = core.StringPtr("mem")
				resourceModel.Value = "testString"

				// Construct an instance of the SchematicsEnvValues model
				schematicsEnvValuesModel := new(catalogmanagementv1.SchematicsEnvValues)
				schematicsEnvValuesModel.Value = core.StringPtr("[{\"name\": \"TF_LOG\",\"value\": \"TRACE\",\"secure\": false,\"hidden\": false}]")
				schematicsEnvValuesModel.SmRef = core.StringPtr("cmsm_v1:{\"name\": \"envVarSecret\",\"id\":\"1234567890\",\"service_id\":\"crn:v1:bluemix:public:secrets-manager:eu-gb:a/1234567890:1234567890::\",\"service_name\":\"My SM Instance\",\"group_id\":\"1234567890\",\"group_name\":\"My SM Group\",\"resource_group_id\":\"1234567890\",\"region\":\"eu-gb\",\"type\":\"arbitrary\"}")

				// Construct an instance of the Script model
				scriptModel := new(catalogmanagementv1.Script)
				scriptModel.Instructions = core.StringPtr("testString")
				scriptModel.InstructionsI18n = map[string]string{"key1": "testString"}
				scriptModel.Script = core.StringPtr("testString")
				scriptModel.ScriptPermission = core.StringPtr("testString")
				scriptModel.DeleteScript = core.StringPtr("testString")
				scriptModel.Scope = core.StringPtr("testString")

				// Construct an instance of the ScriptRef model
				scriptRefModel := new(catalogmanagementv1.ScriptRef)
				scriptRefModel.ShortDescription = core.StringPtr("testString")
				scriptRefModel.Type = core.StringPtr("ansible")
				scriptRefModel.Path = core.StringPtr("scripts/validate-post-ansible-playbook.yaml")
				scriptRefModel.Stage = core.StringPtr("pre")
				scriptRefModel.Action = core.StringPtr("validate")

				// Construct an instance of the VersionEntitlement model
				versionEntitlementModel := new(catalogmanagementv1.VersionEntitlement)
				versionEntitlementModel.ProviderName = core.StringPtr("testString")
				versionEntitlementModel.ProviderID = core.StringPtr("testString")
				versionEntitlementModel.ProductID = core.StringPtr("testString")
				versionEntitlementModel.PartNumbers = []string{"testString"}
				versionEntitlementModel.ImageRepoName = core.StringPtr("testString")

				// Construct an instance of the License model
				licenseModel := new(catalogmanagementv1.License)
				licenseModel.ID = core.StringPtr("testString")
				licenseModel.Name = core.StringPtr("testString")
				licenseModel.Type = core.StringPtr("testString")
				licenseModel.URL = core.StringPtr("testString")
				licenseModel.Description = core.StringPtr("testString")

				// Construct an instance of the State model
				stateModel := new(catalogmanagementv1.State)
				stateModel.Current = core.StringPtr("testString")
				stateModel.CurrentEntered = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Pending = core.StringPtr("testString")
				stateModel.PendingRequested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Previous = core.StringPtr("testString")

				// Construct an instance of the DeprecatePending model
				deprecatePendingModel := new(catalogmanagementv1.DeprecatePending)
				deprecatePendingModel.DeprecateDate = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				deprecatePendingModel.DeprecateState = core.StringPtr("testString")
				deprecatePendingModel.Description = core.StringPtr("testString")

				// Construct an instance of the URLProxy model
				urlProxyModel := new(catalogmanagementv1.URLProxy)
				urlProxyModel.URL = core.StringPtr("testString")
				urlProxyModel.Sha = core.StringPtr("testString")

				// Construct an instance of the MediaItem model
				mediaItemModel := new(catalogmanagementv1.MediaItem)
				mediaItemModel.URL = core.StringPtr("testString")
				mediaItemModel.APIURL = core.StringPtr("testString")
				mediaItemModel.URLProxy = urlProxyModel
				mediaItemModel.Caption = core.StringPtr("testString")
				mediaItemModel.CaptionI18n = map[string]string{"key1": "testString"}
				mediaItemModel.Type = core.StringPtr("testString")
				mediaItemModel.ThumbnailURL = core.StringPtr("testString")

				// Construct an instance of the ArchitectureDiagram model
				architectureDiagramModel := new(catalogmanagementv1.ArchitectureDiagram)
				architectureDiagramModel.Diagram = mediaItemModel
				architectureDiagramModel.Description = core.StringPtr("testString")
				architectureDiagramModel.DescriptionI18n = map[string]string{"key1": "testString"}

				// Construct an instance of the CostComponent model
				costComponentModel := new(catalogmanagementv1.CostComponent)
				costComponentModel.Name = core.StringPtr("testString")
				costComponentModel.Unit = core.StringPtr("testString")
				costComponentModel.HourlyQuantity = core.StringPtr("testString")
				costComponentModel.MonthlyQuantity = core.StringPtr("testString")
				costComponentModel.Price = core.StringPtr("testString")
				costComponentModel.HourlyCost = core.StringPtr("testString")
				costComponentModel.MonthlyCost = core.StringPtr("testString")

				// Construct an instance of the CostResource model
				costResourceModel := new(catalogmanagementv1.CostResource)
				costResourceModel.Name = core.StringPtr("testString")
				costResourceModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				costResourceModel.HourlyCost = core.StringPtr("testString")
				costResourceModel.MonthlyCost = core.StringPtr("testString")
				costResourceModel.CostComponents = []catalogmanagementv1.CostComponent{*costComponentModel}

				// Construct an instance of the CostBreakdown model
				costBreakdownModel := new(catalogmanagementv1.CostBreakdown)
				costBreakdownModel.TotalHourlyCost = core.StringPtr("testString")
				costBreakdownModel.TotalMonthlyCost = core.StringPtr("testString")
				costBreakdownModel.Resources = []catalogmanagementv1.CostResource{*costResourceModel}

				// Construct an instance of the CostSummary model
				costSummaryModel := new(catalogmanagementv1.CostSummary)
				costSummaryModel.TotalDetectedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalSupportedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalUnsupportedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalUsageBasedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalNoPriceResources = core.Int64Ptr(int64(38))
				costSummaryModel.UnsupportedResourceCounts = map[string]int64{"key1": int64(38)}
				costSummaryModel.NoPriceResourceCounts = map[string]int64{"key1": int64(38)}

				// Construct an instance of the Project model
				projectModel := new(catalogmanagementv1.Project)
				projectModel.Name = core.StringPtr("testString")
				projectModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				projectModel.PastBreakdown = costBreakdownModel
				projectModel.Breakdown = costBreakdownModel
				projectModel.Diff = costBreakdownModel
				projectModel.Summary = costSummaryModel

				// Construct an instance of the CostEstimate model
				costEstimateModel := new(catalogmanagementv1.CostEstimate)
				costEstimateModel.Version = core.StringPtr("testString")
				costEstimateModel.Currency = core.StringPtr("testString")
				costEstimateModel.Projects = []catalogmanagementv1.Project{*projectModel}
				costEstimateModel.Summary = costSummaryModel
				costEstimateModel.TotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.TotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.PastTotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.PastTotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.DiffTotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.DiffTotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.TimeGenerated = CreateMockDateTime("2019-01-01T12:00:00.000Z")

				// Construct an instance of the OfferingReference model
				offeringReferenceModel := new(catalogmanagementv1.OfferingReference)
				offeringReferenceModel.CatalogID = core.StringPtr("testString")
				offeringReferenceModel.ID = core.StringPtr("testString")
				offeringReferenceModel.Name = core.StringPtr("testString")
				offeringReferenceModel.Kind = core.StringPtr("testString")
				offeringReferenceModel.Version = core.StringPtr("testString")
				offeringReferenceModel.Description = core.StringPtr("testString")
				offeringReferenceModel.DefaultFlavor = core.StringPtr("testString")
				offeringReferenceModel.Flavors = []string{"testString"}
				offeringReferenceModel.Optional = core.BoolPtr(true)
				offeringReferenceModel.OnByDefault = core.BoolPtr(true)

				// Construct an instance of the SolutionInfo model
				solutionInfoModel := new(catalogmanagementv1.SolutionInfo)
				solutionInfoModel.ArchitectureDiagrams = []catalogmanagementv1.ArchitectureDiagram{*architectureDiagramModel}
				solutionInfoModel.Features = []catalogmanagementv1.Feature{*featureModel}
				solutionInfoModel.CostEstimate = costEstimateModel
				solutionInfoModel.Dependencies = []catalogmanagementv1.OfferingReference{*offeringReferenceModel}
				solutionInfoModel.InstallType = core.StringPtr("testString")

				// Construct an instance of the SccProfile model
				sccProfileModel := new(catalogmanagementv1.SccProfile)
				sccProfileModel.ID = core.StringPtr("testString")
				sccProfileModel.Name = core.StringPtr("testString")
				sccProfileModel.Version = core.StringPtr("testString")
				sccProfileModel.Description = core.StringPtr("testString")
				sccProfileModel.Type = core.StringPtr("testString")
				sccProfileModel.UIHref = core.StringPtr("testString")

				// Construct an instance of the ClaimedControl model
				claimedControlModel := new(catalogmanagementv1.ClaimedControl)
				claimedControlModel.Profile = sccProfileModel
				claimedControlModel.Names = []string{"testString"}

				// Construct an instance of the Claims model
				claimsModel := new(catalogmanagementv1.Claims)
				claimsModel.Profiles = []catalogmanagementv1.SccProfile{*sccProfileModel}
				claimsModel.Controls = []catalogmanagementv1.ClaimedControl{*claimedControlModel}

				// Construct an instance of the Result model
				resultModel := new(catalogmanagementv1.Result)
				resultModel.FailureCount = core.Int64Ptr(int64(38))
				resultModel.ScanTime = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				resultModel.ErrorMessage = core.StringPtr("testString")
				resultModel.CompleteScan = core.BoolPtr(true)
				resultModel.UnscannedResources = []string{"testString"}

				// Construct an instance of the SccAssessment model
				sccAssessmentModel := new(catalogmanagementv1.SccAssessment)
				sccAssessmentModel.ID = core.StringPtr("testString")
				sccAssessmentModel.Description = core.StringPtr("testString")
				sccAssessmentModel.Version = core.StringPtr("testString")
				sccAssessmentModel.Type = core.StringPtr("testString")
				sccAssessmentModel.Method = core.StringPtr("testString")
				sccAssessmentModel.UIHref = core.StringPtr("testString")

				// Construct an instance of the SccSpecification model
				sccSpecificationModel := new(catalogmanagementv1.SccSpecification)
				sccSpecificationModel.ID = core.StringPtr("testString")
				sccSpecificationModel.Description = core.StringPtr("testString")
				sccSpecificationModel.ComponentName = core.StringPtr("testString")
				sccSpecificationModel.Assessments = []catalogmanagementv1.SccAssessment{*sccAssessmentModel}
				sccSpecificationModel.UIHref = core.StringPtr("testString")

				// Construct an instance of the SccControl model
				sccControlModel := new(catalogmanagementv1.SccControl)
				sccControlModel.ID = core.StringPtr("testString")
				sccControlModel.Name = core.StringPtr("testString")
				sccControlModel.Version = core.StringPtr("testString")
				sccControlModel.Description = core.StringPtr("testString")
				sccControlModel.Profile = sccProfileModel
				sccControlModel.ParentName = core.StringPtr("testString")
				sccControlModel.Specifications = []catalogmanagementv1.SccSpecification{*sccSpecificationModel}
				sccControlModel.UIHref = core.StringPtr("testString")

				// Construct an instance of the EvaluatedControl model
				evaluatedControlModel := new(catalogmanagementv1.EvaluatedControl)
				evaluatedControlModel.ID = core.StringPtr("testString")
				evaluatedControlModel.Name = core.StringPtr("testString")
				evaluatedControlModel.Description = core.StringPtr("testString")
				evaluatedControlModel.Specifications = []catalogmanagementv1.SccSpecification{*sccSpecificationModel}
				evaluatedControlModel.FailureCount = core.Int64Ptr(int64(38))
				evaluatedControlModel.PassCount = core.Int64Ptr(int64(38))
				evaluatedControlModel.Parent = sccControlModel
				evaluatedControlModel.UIHref = core.StringPtr("testString")

				// Construct an instance of the Evaluation model
				evaluationModel := new(catalogmanagementv1.Evaluation)
				evaluationModel.ScanID = core.StringPtr("testString")
				evaluationModel.AccountID = core.StringPtr("testString")
				evaluationModel.Profile = sccProfileModel
				evaluationModel.Result = resultModel
				evaluationModel.Controls = []catalogmanagementv1.EvaluatedControl{*evaluatedControlModel}

				// Construct an instance of the Compliance model
				complianceModel := new(catalogmanagementv1.Compliance)
				complianceModel.Authority = core.StringPtr("testString")
				complianceModel.Claims = claimsModel
				complianceModel.Evaluations = []catalogmanagementv1.Evaluation{*evaluationModel}

				// Construct an instance of the ChangeNotices model
				changeNoticesModel := new(catalogmanagementv1.ChangeNotices)
				changeNoticesModel.Breaking = []catalogmanagementv1.Feature{*featureModel}
				changeNoticesModel.New = []catalogmanagementv1.Feature{*featureModel}
				changeNoticesModel.Update = []catalogmanagementv1.Feature{*featureModel}

				// Construct an instance of the Version model
				versionModel := new(catalogmanagementv1.Version)
				versionModel.CRN = core.StringPtr("testString")
				versionModel.Version = core.StringPtr("testString")
				versionModel.Flavor = flavorModel
				versionModel.Sha = core.StringPtr("testString")
				versionModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				versionModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				versionModel.OfferingID = core.StringPtr("testString")
				versionModel.CatalogID = core.StringPtr("testString")
				versionModel.KindID = core.StringPtr("testString")
				versionModel.Tags = []string{"testString"}
				versionModel.RepoURL = core.StringPtr("testString")
				versionModel.SourceURL = core.StringPtr("testString")
				versionModel.TgzURL = core.StringPtr("testString")
				versionModel.Configuration = []catalogmanagementv1.Configuration{*configurationModel}
				versionModel.Outputs = []catalogmanagementv1.Output{*outputModel}
				versionModel.IamPermissions = []catalogmanagementv1.IamPermission{*iamPermissionModel}
				versionModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				versionModel.Validation = validationModel
				versionModel.RequiredResources = []catalogmanagementv1.Resource{*resourceModel}
				versionModel.SingleInstance = core.BoolPtr(true)
				versionModel.SchematicsEnvValues = schematicsEnvValuesModel
				versionModel.Install = scriptModel
				versionModel.PreInstall = []catalogmanagementv1.Script{*scriptModel}
				versionModel.Scripts = map[string]catalogmanagementv1.ScriptRef{"key1": *scriptRefModel}
				versionModel.Entitlement = versionEntitlementModel
				versionModel.Licenses = []catalogmanagementv1.License{*licenseModel}
				versionModel.ImageManifestURL = core.StringPtr("testString")
				versionModel.Deprecated = core.BoolPtr(true)
				versionModel.PackageVersion = core.StringPtr("testString")
				versionModel.State = stateModel
				versionModel.VersionLocator = core.StringPtr("testString")
				versionModel.LongDescription = core.StringPtr("testString")
				versionModel.LongDescriptionI18n = map[string]string{"key1": "testString"}
				versionModel.WhitelistedAccounts = []string{"testString"}
				versionModel.ImagePullKeyName = core.StringPtr("testString")
				versionModel.DeprecatePending = deprecatePendingModel
				versionModel.SolutionInfo = solutionInfoModel
				versionModel.IsConsumable = core.BoolPtr(true)
				versionModel.ComplianceV3 = complianceModel
				versionModel.ChangeNotices = changeNoticesModel
				versionModel.PlanIds = []string{"testString"}
				versionModel.Stack = map[string]interface{}{"anyKey": "anyValue"}
				versionModel.MinimumCompatibleVersion = core.StringPtr("testString")
				versionModel.Scripts["foo"] = *scriptRefModel

				// Construct an instance of the PaginationTokenLink model
				paginationTokenLinkModel := new(catalogmanagementv1.PaginationTokenLink)
				paginationTokenLinkModel.Href = core.StringPtr("testString")
				paginationTokenLinkModel.Start = core.StringPtr("testString")

				// Construct an instance of the KindAllVersions model
				kindAllVersionsModel := new(catalogmanagementv1.KindAllVersions)
				kindAllVersionsModel.First = paginationTokenLinkModel
				kindAllVersionsModel.Next = paginationTokenLinkModel

				// Construct an instance of the Kind model
				kindModel := new(catalogmanagementv1.Kind)
				kindModel.ID = core.StringPtr("testString")
				kindModel.FormatKind = core.StringPtr("testString")
				kindModel.FormatKindLabel = core.StringPtr("testString")
				kindModel.InstallKind = core.StringPtr("testString")
				kindModel.InstallKindLabel = core.StringPtr("testString")
				kindModel.TargetKind = core.StringPtr("testString")
				kindModel.TargetKindLabel = core.StringPtr("testString")
				kindModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				kindModel.Tags = []string{"testString"}
				kindModel.AdditionalFeatures = []catalogmanagementv1.Feature{*featureModel}
				kindModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				kindModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				kindModel.Versions = []catalogmanagementv1.Version{*versionModel}
				kindModel.AllVersions = kindAllVersionsModel

				// Construct an instance of the PublishObject model
				publishObjectModel := new(catalogmanagementv1.PublishObject)
				publishObjectModel.PcManaged = core.BoolPtr(true)
				publishObjectModel.ApprovalType = core.StringPtr("testString")
				publishObjectModel.PublishApproved = core.BoolPtr(true)
				publishObjectModel.ShareWithAll = core.BoolPtr(true)
				publishObjectModel.ShareWithIBM = core.BoolPtr(true)
				publishObjectModel.ShareEnabled = core.BoolPtr(true)
				publishObjectModel.OriginalCRN = core.StringPtr("testString")
				publishObjectModel.PublicCRN = core.StringPtr("testString")
				publishObjectModel.ApprovalRecord = map[string]interface{}{"anyKey": "anyValue"}
				publishObjectModel.PermitIBMPublicPublish = core.BoolPtr(true)
				publishObjectModel.IBMApproved = core.BoolPtr(true)
				publishObjectModel.PublicApproved = core.BoolPtr(true)

				// Construct an instance of the ProviderInfo model
				providerInfoModel := new(catalogmanagementv1.ProviderInfo)
				providerInfoModel.ID = core.StringPtr("testString")
				providerInfoModel.Name = core.StringPtr("testString")

				// Construct an instance of the RepoInfo model
				repoInfoModel := new(catalogmanagementv1.RepoInfo)
				repoInfoModel.Token = core.StringPtr("testString")
				repoInfoModel.Type = core.StringPtr("testString")

				// Construct an instance of the ImagePullKey model
				imagePullKeyModel := new(catalogmanagementv1.ImagePullKey)
				imagePullKeyModel.Name = core.StringPtr("testString")
				imagePullKeyModel.Value = core.StringPtr("testString")
				imagePullKeyModel.Description = core.StringPtr("testString")

				// Construct an instance of the SupportWaitTime model
				supportWaitTimeModel := new(catalogmanagementv1.SupportWaitTime)
				supportWaitTimeModel.Value = core.Int64Ptr(int64(38))
				supportWaitTimeModel.Type = core.StringPtr("testString")

				// Construct an instance of the SupportTime model
				supportTimeModel := new(catalogmanagementv1.SupportTime)
				supportTimeModel.Day = core.Int64Ptr(int64(38))
				supportTimeModel.StartTime = core.StringPtr("testString")
				supportTimeModel.EndTime = core.StringPtr("testString")

				// Construct an instance of the SupportAvailability model
				supportAvailabilityModel := new(catalogmanagementv1.SupportAvailability)
				supportAvailabilityModel.Times = []catalogmanagementv1.SupportTime{*supportTimeModel}
				supportAvailabilityModel.Timezone = core.StringPtr("testString")
				supportAvailabilityModel.AlwaysAvailable = core.BoolPtr(true)

				// Construct an instance of the SupportDetail model
				supportDetailModel := new(catalogmanagementv1.SupportDetail)
				supportDetailModel.Type = core.StringPtr("testString")
				supportDetailModel.Contact = core.StringPtr("testString")
				supportDetailModel.ResponseWaitTime = supportWaitTimeModel
				supportDetailModel.Availability = supportAvailabilityModel

				// Construct an instance of the SupportEscalation model
				supportEscalationModel := new(catalogmanagementv1.SupportEscalation)
				supportEscalationModel.EscalationWaitTime = supportWaitTimeModel
				supportEscalationModel.ResponseWaitTime = supportWaitTimeModel
				supportEscalationModel.Contact = core.StringPtr("testString")

				// Construct an instance of the Support model
				supportModel := new(catalogmanagementv1.Support)
				supportModel.URL = core.StringPtr("testString")
				supportModel.Process = core.StringPtr("testString")
				supportModel.ProcessI18n = map[string]string{"key1": "testString"}
				supportModel.Locations = []string{"testString"}
				supportModel.SupportDetails = []catalogmanagementv1.SupportDetail{*supportDetailModel}
				supportModel.SupportEscalation = supportEscalationModel
				supportModel.SupportType = core.StringPtr("testString")

				// Construct an instance of the LearnMoreLinks model
				learnMoreLinksModel := new(catalogmanagementv1.LearnMoreLinks)
				learnMoreLinksModel.FirstParty = core.StringPtr("testString")
				learnMoreLinksModel.ThirdParty = core.StringPtr("testString")

				// Construct an instance of the Constraint model
				constraintModel := new(catalogmanagementv1.Constraint)
				constraintModel.Type = core.StringPtr("testString")
				constraintModel.Rule = "testString"

				// Construct an instance of the Badge model
				badgeModel := new(catalogmanagementv1.Badge)
				badgeModel.ID = core.StringPtr("testString")
				badgeModel.Label = core.StringPtr("testString")
				badgeModel.LabelI18n = map[string]string{"key1": "testString"}
				badgeModel.Description = core.StringPtr("testString")
				badgeModel.DescriptionI18n = map[string]string{"key1": "testString"}
				badgeModel.Icon = core.StringPtr("testString")
				badgeModel.Authority = core.StringPtr("testString")
				badgeModel.Tag = core.StringPtr("testString")
				badgeModel.LearnMoreLinks = learnMoreLinksModel
				badgeModel.Constraints = []catalogmanagementv1.Constraint{*constraintModel}

				// Construct an instance of the VersionRange model
				versionRangeModel := new(catalogmanagementv1.VersionRange)
				versionRangeModel.Kinds = []string{"testString"}
				versionRangeModel.Version = core.StringPtr("testString")
				versionRangeModel.Flavors = []string{"testString"}

				// Construct an instance of the Plan model
				planModel := new(catalogmanagementv1.Plan)
				planModel.URL = core.StringPtr("testString")
				planModel.CRN = core.StringPtr("testString")
				planModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				planModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				planModel.OfferingID = core.StringPtr("testString")
				planModel.CatalogID = core.StringPtr("testString")
				planModel.Label = core.StringPtr("testString")
				planModel.LabelI18n = map[string]string{"key1": "testString"}
				planModel.Name = core.StringPtr("testString")
				planModel.ShortDescription = core.StringPtr("testString")
				planModel.ShortDescriptionI18n = map[string]string{"key1": "testString"}
				planModel.PricingTags = []string{"testString"}
				planModel.VersionRange = versionRangeModel
				planModel.Features = []catalogmanagementv1.Feature{*featureModel}
				planModel.State = stateModel
				planModel.DeprecatePending = deprecatePendingModel
				planModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				planModel.PublishApproved = core.BoolPtr(true)

				// Construct an instance of the ReplaceOfferingOptions model
				replaceOfferingOptionsModel := new(catalogmanagementv1.ReplaceOfferingOptions)
				replaceOfferingOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				replaceOfferingOptionsModel.OfferingID = core.StringPtr("testString")
				replaceOfferingOptionsModel.ID = core.StringPtr("testString")
				replaceOfferingOptionsModel.Rev = core.StringPtr("testString")
				replaceOfferingOptionsModel.URL = core.StringPtr("testString")
				replaceOfferingOptionsModel.CRN = core.StringPtr("testString")
				replaceOfferingOptionsModel.Label = core.StringPtr("testString")
				replaceOfferingOptionsModel.LabelI18n = map[string]string{"key1": "testString"}
				replaceOfferingOptionsModel.Name = core.StringPtr("testString")
				replaceOfferingOptionsModel.OfferingIconURL = core.StringPtr("testString")
				replaceOfferingOptionsModel.OfferingDocsURL = core.StringPtr("testString")
				replaceOfferingOptionsModel.OfferingSupportURL = core.StringPtr("testString")
				replaceOfferingOptionsModel.Tags = []string{"testString"}
				replaceOfferingOptionsModel.Keywords = []string{"testString"}
				replaceOfferingOptionsModel.Rating = ratingModel
				replaceOfferingOptionsModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				replaceOfferingOptionsModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				replaceOfferingOptionsModel.ShortDescription = core.StringPtr("testString")
				replaceOfferingOptionsModel.ShortDescriptionI18n = map[string]string{"key1": "testString"}
				replaceOfferingOptionsModel.LongDescription = core.StringPtr("testString")
				replaceOfferingOptionsModel.LongDescriptionI18n = map[string]string{"key1": "testString"}
				replaceOfferingOptionsModel.Features = []catalogmanagementv1.Feature{*featureModel}
				replaceOfferingOptionsModel.Kinds = []catalogmanagementv1.Kind{*kindModel}
				replaceOfferingOptionsModel.Publish = publishObjectModel
				replaceOfferingOptionsModel.PcManaged = core.BoolPtr(true)
				replaceOfferingOptionsModel.PublishApproved = core.BoolPtr(true)
				replaceOfferingOptionsModel.ShareWithAll = core.BoolPtr(true)
				replaceOfferingOptionsModel.ShareWithIBM = core.BoolPtr(true)
				replaceOfferingOptionsModel.ShareEnabled = core.BoolPtr(true)
				replaceOfferingOptionsModel.PublicOriginalCRN = core.StringPtr("testString")
				replaceOfferingOptionsModel.PublishPublicCRN = core.StringPtr("testString")
				replaceOfferingOptionsModel.PortalApprovalRecord = core.StringPtr("testString")
				replaceOfferingOptionsModel.PortalUIURL = core.StringPtr("testString")
				replaceOfferingOptionsModel.CatalogID = core.StringPtr("testString")
				replaceOfferingOptionsModel.CatalogName = core.StringPtr("testString")
				replaceOfferingOptionsModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				replaceOfferingOptionsModel.Disclaimer = core.StringPtr("testString")
				replaceOfferingOptionsModel.Hidden = core.BoolPtr(true)
				replaceOfferingOptionsModel.Provider = core.StringPtr("testString")
				replaceOfferingOptionsModel.ProviderInfo = providerInfoModel
				replaceOfferingOptionsModel.RepoInfo = repoInfoModel
				replaceOfferingOptionsModel.ImagePullKeys = []catalogmanagementv1.ImagePullKey{*imagePullKeyModel}
				replaceOfferingOptionsModel.Support = supportModel
				replaceOfferingOptionsModel.Media = []catalogmanagementv1.MediaItem{*mediaItemModel}
				replaceOfferingOptionsModel.DeprecatePending = deprecatePendingModel
				replaceOfferingOptionsModel.ProductKind = core.StringPtr("testString")
				replaceOfferingOptionsModel.Badges = []catalogmanagementv1.Badge{*badgeModel}
				replaceOfferingOptionsModel.Plans = []catalogmanagementv1.Plan{*planModel}
				replaceOfferingOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.ReplaceOffering(replaceOfferingOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ReplaceOffering with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the Rating model
				ratingModel := new(catalogmanagementv1.Rating)
				ratingModel.OneStarCount = core.Int64Ptr(int64(38))
				ratingModel.TwoStarCount = core.Int64Ptr(int64(38))
				ratingModel.ThreeStarCount = core.Int64Ptr(int64(38))
				ratingModel.FourStarCount = core.Int64Ptr(int64(38))

				// Construct an instance of the Feature model
				featureModel := new(catalogmanagementv1.Feature)
				featureModel.Title = core.StringPtr("testString")
				featureModel.TitleI18n = map[string]string{"key1": "testString"}
				featureModel.Description = core.StringPtr("testString")
				featureModel.DescriptionI18n = map[string]string{"key1": "testString"}

				// Construct an instance of the Flavor model
				flavorModel := new(catalogmanagementv1.Flavor)
				flavorModel.Name = core.StringPtr("testString")
				flavorModel.Label = core.StringPtr("testString")
				flavorModel.LabelI18n = map[string]string{"key1": "testString"}
				flavorModel.Index = core.Int64Ptr(int64(38))

				// Construct an instance of the RenderTypeAssociationsParametersItem model
				renderTypeAssociationsParametersItemModel := new(catalogmanagementv1.RenderTypeAssociationsParametersItem)
				renderTypeAssociationsParametersItemModel.Name = core.StringPtr("testString")
				renderTypeAssociationsParametersItemModel.OptionsRefresh = core.BoolPtr(true)

				// Construct an instance of the RenderTypeAssociations model
				renderTypeAssociationsModel := new(catalogmanagementv1.RenderTypeAssociations)
				renderTypeAssociationsModel.Parameters = []catalogmanagementv1.RenderTypeAssociationsParametersItem{*renderTypeAssociationsParametersItemModel}

				// Construct an instance of the RenderType model
				renderTypeModel := new(catalogmanagementv1.RenderType)
				renderTypeModel.Type = core.StringPtr("testString")
				renderTypeModel.Grouping = core.StringPtr("testString")
				renderTypeModel.OriginalGrouping = core.StringPtr("testString")
				renderTypeModel.GroupingIndex = core.Int64Ptr(int64(38))
				renderTypeModel.ConfigConstraints = map[string]interface{}{"anyKey": "anyValue"}
				renderTypeModel.Associations = renderTypeAssociationsModel

				// Construct an instance of the Configuration model
				configurationModel := new(catalogmanagementv1.Configuration)
				configurationModel.Key = core.StringPtr("testString")
				configurationModel.Type = core.StringPtr("testString")
				configurationModel.DefaultValue = "testString"
				configurationModel.DisplayName = core.StringPtr("testString")
				configurationModel.ValueConstraint = core.StringPtr("testString")
				configurationModel.Description = core.StringPtr("testString")
				configurationModel.Required = core.BoolPtr(true)
				configurationModel.Options = []interface{}{"testString"}
				configurationModel.Hidden = core.BoolPtr(true)
				configurationModel.CustomConfig = renderTypeModel
				configurationModel.TypeMetadata = core.StringPtr("testString")

				// Construct an instance of the Output model
				outputModel := new(catalogmanagementv1.Output)
				outputModel.Key = core.StringPtr("testString")
				outputModel.Description = core.StringPtr("testString")

				// Construct an instance of the IamResource model
				iamResourceModel := new(catalogmanagementv1.IamResource)
				iamResourceModel.Name = core.StringPtr("testString")
				iamResourceModel.Description = core.StringPtr("testString")
				iamResourceModel.RoleCrns = []string{"testString"}

				// Construct an instance of the IamPermission model
				iamPermissionModel := new(catalogmanagementv1.IamPermission)
				iamPermissionModel.ServiceName = core.StringPtr("testString")
				iamPermissionModel.RoleCrns = []string{"testString"}
				iamPermissionModel.Resources = []catalogmanagementv1.IamResource{*iamResourceModel}

				// Construct an instance of the Validation model
				validationModel := new(catalogmanagementv1.Validation)
				validationModel.Validated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				validationModel.Requested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				validationModel.State = core.StringPtr("testString")
				validationModel.LastOperation = core.StringPtr("testString")
				validationModel.Target = map[string]interface{}{"anyKey": "anyValue"}
				validationModel.Message = core.StringPtr("testString")

				// Construct an instance of the Resource model
				resourceModel := new(catalogmanagementv1.Resource)
				resourceModel.Type = core.StringPtr("mem")
				resourceModel.Value = "testString"

				// Construct an instance of the SchematicsEnvValues model
				schematicsEnvValuesModel := new(catalogmanagementv1.SchematicsEnvValues)
				schematicsEnvValuesModel.Value = core.StringPtr("[{\"name\": \"TF_LOG\",\"value\": \"TRACE\",\"secure\": false,\"hidden\": false}]")
				schematicsEnvValuesModel.SmRef = core.StringPtr("cmsm_v1:{\"name\": \"envVarSecret\",\"id\":\"1234567890\",\"service_id\":\"crn:v1:bluemix:public:secrets-manager:eu-gb:a/1234567890:1234567890::\",\"service_name\":\"My SM Instance\",\"group_id\":\"1234567890\",\"group_name\":\"My SM Group\",\"resource_group_id\":\"1234567890\",\"region\":\"eu-gb\",\"type\":\"arbitrary\"}")

				// Construct an instance of the Script model
				scriptModel := new(catalogmanagementv1.Script)
				scriptModel.Instructions = core.StringPtr("testString")
				scriptModel.InstructionsI18n = map[string]string{"key1": "testString"}
				scriptModel.Script = core.StringPtr("testString")
				scriptModel.ScriptPermission = core.StringPtr("testString")
				scriptModel.DeleteScript = core.StringPtr("testString")
				scriptModel.Scope = core.StringPtr("testString")

				// Construct an instance of the ScriptRef model
				scriptRefModel := new(catalogmanagementv1.ScriptRef)
				scriptRefModel.ShortDescription = core.StringPtr("testString")
				scriptRefModel.Type = core.StringPtr("ansible")
				scriptRefModel.Path = core.StringPtr("scripts/validate-post-ansible-playbook.yaml")
				scriptRefModel.Stage = core.StringPtr("pre")
				scriptRefModel.Action = core.StringPtr("validate")

				// Construct an instance of the VersionEntitlement model
				versionEntitlementModel := new(catalogmanagementv1.VersionEntitlement)
				versionEntitlementModel.ProviderName = core.StringPtr("testString")
				versionEntitlementModel.ProviderID = core.StringPtr("testString")
				versionEntitlementModel.ProductID = core.StringPtr("testString")
				versionEntitlementModel.PartNumbers = []string{"testString"}
				versionEntitlementModel.ImageRepoName = core.StringPtr("testString")

				// Construct an instance of the License model
				licenseModel := new(catalogmanagementv1.License)
				licenseModel.ID = core.StringPtr("testString")
				licenseModel.Name = core.StringPtr("testString")
				licenseModel.Type = core.StringPtr("testString")
				licenseModel.URL = core.StringPtr("testString")
				licenseModel.Description = core.StringPtr("testString")

				// Construct an instance of the State model
				stateModel := new(catalogmanagementv1.State)
				stateModel.Current = core.StringPtr("testString")
				stateModel.CurrentEntered = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Pending = core.StringPtr("testString")
				stateModel.PendingRequested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Previous = core.StringPtr("testString")

				// Construct an instance of the DeprecatePending model
				deprecatePendingModel := new(catalogmanagementv1.DeprecatePending)
				deprecatePendingModel.DeprecateDate = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				deprecatePendingModel.DeprecateState = core.StringPtr("testString")
				deprecatePendingModel.Description = core.StringPtr("testString")

				// Construct an instance of the URLProxy model
				urlProxyModel := new(catalogmanagementv1.URLProxy)
				urlProxyModel.URL = core.StringPtr("testString")
				urlProxyModel.Sha = core.StringPtr("testString")

				// Construct an instance of the MediaItem model
				mediaItemModel := new(catalogmanagementv1.MediaItem)
				mediaItemModel.URL = core.StringPtr("testString")
				mediaItemModel.APIURL = core.StringPtr("testString")
				mediaItemModel.URLProxy = urlProxyModel
				mediaItemModel.Caption = core.StringPtr("testString")
				mediaItemModel.CaptionI18n = map[string]string{"key1": "testString"}
				mediaItemModel.Type = core.StringPtr("testString")
				mediaItemModel.ThumbnailURL = core.StringPtr("testString")

				// Construct an instance of the ArchitectureDiagram model
				architectureDiagramModel := new(catalogmanagementv1.ArchitectureDiagram)
				architectureDiagramModel.Diagram = mediaItemModel
				architectureDiagramModel.Description = core.StringPtr("testString")
				architectureDiagramModel.DescriptionI18n = map[string]string{"key1": "testString"}

				// Construct an instance of the CostComponent model
				costComponentModel := new(catalogmanagementv1.CostComponent)
				costComponentModel.Name = core.StringPtr("testString")
				costComponentModel.Unit = core.StringPtr("testString")
				costComponentModel.HourlyQuantity = core.StringPtr("testString")
				costComponentModel.MonthlyQuantity = core.StringPtr("testString")
				costComponentModel.Price = core.StringPtr("testString")
				costComponentModel.HourlyCost = core.StringPtr("testString")
				costComponentModel.MonthlyCost = core.StringPtr("testString")

				// Construct an instance of the CostResource model
				costResourceModel := new(catalogmanagementv1.CostResource)
				costResourceModel.Name = core.StringPtr("testString")
				costResourceModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				costResourceModel.HourlyCost = core.StringPtr("testString")
				costResourceModel.MonthlyCost = core.StringPtr("testString")
				costResourceModel.CostComponents = []catalogmanagementv1.CostComponent{*costComponentModel}

				// Construct an instance of the CostBreakdown model
				costBreakdownModel := new(catalogmanagementv1.CostBreakdown)
				costBreakdownModel.TotalHourlyCost = core.StringPtr("testString")
				costBreakdownModel.TotalMonthlyCost = core.StringPtr("testString")
				costBreakdownModel.Resources = []catalogmanagementv1.CostResource{*costResourceModel}

				// Construct an instance of the CostSummary model
				costSummaryModel := new(catalogmanagementv1.CostSummary)
				costSummaryModel.TotalDetectedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalSupportedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalUnsupportedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalUsageBasedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalNoPriceResources = core.Int64Ptr(int64(38))
				costSummaryModel.UnsupportedResourceCounts = map[string]int64{"key1": int64(38)}
				costSummaryModel.NoPriceResourceCounts = map[string]int64{"key1": int64(38)}

				// Construct an instance of the Project model
				projectModel := new(catalogmanagementv1.Project)
				projectModel.Name = core.StringPtr("testString")
				projectModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				projectModel.PastBreakdown = costBreakdownModel
				projectModel.Breakdown = costBreakdownModel
				projectModel.Diff = costBreakdownModel
				projectModel.Summary = costSummaryModel

				// Construct an instance of the CostEstimate model
				costEstimateModel := new(catalogmanagementv1.CostEstimate)
				costEstimateModel.Version = core.StringPtr("testString")
				costEstimateModel.Currency = core.StringPtr("testString")
				costEstimateModel.Projects = []catalogmanagementv1.Project{*projectModel}
				costEstimateModel.Summary = costSummaryModel
				costEstimateModel.TotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.TotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.PastTotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.PastTotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.DiffTotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.DiffTotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.TimeGenerated = CreateMockDateTime("2019-01-01T12:00:00.000Z")

				// Construct an instance of the OfferingReference model
				offeringReferenceModel := new(catalogmanagementv1.OfferingReference)
				offeringReferenceModel.CatalogID = core.StringPtr("testString")
				offeringReferenceModel.ID = core.StringPtr("testString")
				offeringReferenceModel.Name = core.StringPtr("testString")
				offeringReferenceModel.Kind = core.StringPtr("testString")
				offeringReferenceModel.Version = core.StringPtr("testString")
				offeringReferenceModel.Description = core.StringPtr("testString")
				offeringReferenceModel.DefaultFlavor = core.StringPtr("testString")
				offeringReferenceModel.Flavors = []string{"testString"}
				offeringReferenceModel.Optional = core.BoolPtr(true)
				offeringReferenceModel.OnByDefault = core.BoolPtr(true)

				// Construct an instance of the SolutionInfo model
				solutionInfoModel := new(catalogmanagementv1.SolutionInfo)
				solutionInfoModel.ArchitectureDiagrams = []catalogmanagementv1.ArchitectureDiagram{*architectureDiagramModel}
				solutionInfoModel.Features = []catalogmanagementv1.Feature{*featureModel}
				solutionInfoModel.CostEstimate = costEstimateModel
				solutionInfoModel.Dependencies = []catalogmanagementv1.OfferingReference{*offeringReferenceModel}
				solutionInfoModel.InstallType = core.StringPtr("testString")

				// Construct an instance of the SccProfile model
				sccProfileModel := new(catalogmanagementv1.SccProfile)
				sccProfileModel.ID = core.StringPtr("testString")
				sccProfileModel.Name = core.StringPtr("testString")
				sccProfileModel.Version = core.StringPtr("testString")
				sccProfileModel.Description = core.StringPtr("testString")
				sccProfileModel.Type = core.StringPtr("testString")
				sccProfileModel.UIHref = core.StringPtr("testString")

				// Construct an instance of the ClaimedControl model
				claimedControlModel := new(catalogmanagementv1.ClaimedControl)
				claimedControlModel.Profile = sccProfileModel
				claimedControlModel.Names = []string{"testString"}

				// Construct an instance of the Claims model
				claimsModel := new(catalogmanagementv1.Claims)
				claimsModel.Profiles = []catalogmanagementv1.SccProfile{*sccProfileModel}
				claimsModel.Controls = []catalogmanagementv1.ClaimedControl{*claimedControlModel}

				// Construct an instance of the Result model
				resultModel := new(catalogmanagementv1.Result)
				resultModel.FailureCount = core.Int64Ptr(int64(38))
				resultModel.ScanTime = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				resultModel.ErrorMessage = core.StringPtr("testString")
				resultModel.CompleteScan = core.BoolPtr(true)
				resultModel.UnscannedResources = []string{"testString"}

				// Construct an instance of the SccAssessment model
				sccAssessmentModel := new(catalogmanagementv1.SccAssessment)
				sccAssessmentModel.ID = core.StringPtr("testString")
				sccAssessmentModel.Description = core.StringPtr("testString")
				sccAssessmentModel.Version = core.StringPtr("testString")
				sccAssessmentModel.Type = core.StringPtr("testString")
				sccAssessmentModel.Method = core.StringPtr("testString")
				sccAssessmentModel.UIHref = core.StringPtr("testString")

				// Construct an instance of the SccSpecification model
				sccSpecificationModel := new(catalogmanagementv1.SccSpecification)
				sccSpecificationModel.ID = core.StringPtr("testString")
				sccSpecificationModel.Description = core.StringPtr("testString")
				sccSpecificationModel.ComponentName = core.StringPtr("testString")
				sccSpecificationModel.Assessments = []catalogmanagementv1.SccAssessment{*sccAssessmentModel}
				sccSpecificationModel.UIHref = core.StringPtr("testString")

				// Construct an instance of the SccControl model
				sccControlModel := new(catalogmanagementv1.SccControl)
				sccControlModel.ID = core.StringPtr("testString")
				sccControlModel.Name = core.StringPtr("testString")
				sccControlModel.Version = core.StringPtr("testString")
				sccControlModel.Description = core.StringPtr("testString")
				sccControlModel.Profile = sccProfileModel
				sccControlModel.ParentName = core.StringPtr("testString")
				sccControlModel.Specifications = []catalogmanagementv1.SccSpecification{*sccSpecificationModel}
				sccControlModel.UIHref = core.StringPtr("testString")

				// Construct an instance of the EvaluatedControl model
				evaluatedControlModel := new(catalogmanagementv1.EvaluatedControl)
				evaluatedControlModel.ID = core.StringPtr("testString")
				evaluatedControlModel.Name = core.StringPtr("testString")
				evaluatedControlModel.Description = core.StringPtr("testString")
				evaluatedControlModel.Specifications = []catalogmanagementv1.SccSpecification{*sccSpecificationModel}
				evaluatedControlModel.FailureCount = core.Int64Ptr(int64(38))
				evaluatedControlModel.PassCount = core.Int64Ptr(int64(38))
				evaluatedControlModel.Parent = sccControlModel
				evaluatedControlModel.UIHref = core.StringPtr("testString")

				// Construct an instance of the Evaluation model
				evaluationModel := new(catalogmanagementv1.Evaluation)
				evaluationModel.ScanID = core.StringPtr("testString")
				evaluationModel.AccountID = core.StringPtr("testString")
				evaluationModel.Profile = sccProfileModel
				evaluationModel.Result = resultModel
				evaluationModel.Controls = []catalogmanagementv1.EvaluatedControl{*evaluatedControlModel}

				// Construct an instance of the Compliance model
				complianceModel := new(catalogmanagementv1.Compliance)
				complianceModel.Authority = core.StringPtr("testString")
				complianceModel.Claims = claimsModel
				complianceModel.Evaluations = []catalogmanagementv1.Evaluation{*evaluationModel}

				// Construct an instance of the ChangeNotices model
				changeNoticesModel := new(catalogmanagementv1.ChangeNotices)
				changeNoticesModel.Breaking = []catalogmanagementv1.Feature{*featureModel}
				changeNoticesModel.New = []catalogmanagementv1.Feature{*featureModel}
				changeNoticesModel.Update = []catalogmanagementv1.Feature{*featureModel}

				// Construct an instance of the Version model
				versionModel := new(catalogmanagementv1.Version)
				versionModel.CRN = core.StringPtr("testString")
				versionModel.Version = core.StringPtr("testString")
				versionModel.Flavor = flavorModel
				versionModel.Sha = core.StringPtr("testString")
				versionModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				versionModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				versionModel.OfferingID = core.StringPtr("testString")
				versionModel.CatalogID = core.StringPtr("testString")
				versionModel.KindID = core.StringPtr("testString")
				versionModel.Tags = []string{"testString"}
				versionModel.RepoURL = core.StringPtr("testString")
				versionModel.SourceURL = core.StringPtr("testString")
				versionModel.TgzURL = core.StringPtr("testString")
				versionModel.Configuration = []catalogmanagementv1.Configuration{*configurationModel}
				versionModel.Outputs = []catalogmanagementv1.Output{*outputModel}
				versionModel.IamPermissions = []catalogmanagementv1.IamPermission{*iamPermissionModel}
				versionModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				versionModel.Validation = validationModel
				versionModel.RequiredResources = []catalogmanagementv1.Resource{*resourceModel}
				versionModel.SingleInstance = core.BoolPtr(true)
				versionModel.SchematicsEnvValues = schematicsEnvValuesModel
				versionModel.Install = scriptModel
				versionModel.PreInstall = []catalogmanagementv1.Script{*scriptModel}
				versionModel.Scripts = map[string]catalogmanagementv1.ScriptRef{"key1": *scriptRefModel}
				versionModel.Entitlement = versionEntitlementModel
				versionModel.Licenses = []catalogmanagementv1.License{*licenseModel}
				versionModel.ImageManifestURL = core.StringPtr("testString")
				versionModel.Deprecated = core.BoolPtr(true)
				versionModel.PackageVersion = core.StringPtr("testString")
				versionModel.State = stateModel
				versionModel.VersionLocator = core.StringPtr("testString")
				versionModel.LongDescription = core.StringPtr("testString")
				versionModel.LongDescriptionI18n = map[string]string{"key1": "testString"}
				versionModel.WhitelistedAccounts = []string{"testString"}
				versionModel.ImagePullKeyName = core.StringPtr("testString")
				versionModel.DeprecatePending = deprecatePendingModel
				versionModel.SolutionInfo = solutionInfoModel
				versionModel.IsConsumable = core.BoolPtr(true)
				versionModel.ComplianceV3 = complianceModel
				versionModel.ChangeNotices = changeNoticesModel
				versionModel.PlanIds = []string{"testString"}
				versionModel.Stack = map[string]interface{}{"anyKey": "anyValue"}
				versionModel.MinimumCompatibleVersion = core.StringPtr("testString")
				versionModel.Scripts["foo"] = *scriptRefModel

				// Construct an instance of the PaginationTokenLink model
				paginationTokenLinkModel := new(catalogmanagementv1.PaginationTokenLink)
				paginationTokenLinkModel.Href = core.StringPtr("testString")
				paginationTokenLinkModel.Start = core.StringPtr("testString")

				// Construct an instance of the KindAllVersions model
				kindAllVersionsModel := new(catalogmanagementv1.KindAllVersions)
				kindAllVersionsModel.First = paginationTokenLinkModel
				kindAllVersionsModel.Next = paginationTokenLinkModel

				// Construct an instance of the Kind model
				kindModel := new(catalogmanagementv1.Kind)
				kindModel.ID = core.StringPtr("testString")
				kindModel.FormatKind = core.StringPtr("testString")
				kindModel.FormatKindLabel = core.StringPtr("testString")
				kindModel.InstallKind = core.StringPtr("testString")
				kindModel.InstallKindLabel = core.StringPtr("testString")
				kindModel.TargetKind = core.StringPtr("testString")
				kindModel.TargetKindLabel = core.StringPtr("testString")
				kindModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				kindModel.Tags = []string{"testString"}
				kindModel.AdditionalFeatures = []catalogmanagementv1.Feature{*featureModel}
				kindModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				kindModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				kindModel.Versions = []catalogmanagementv1.Version{*versionModel}
				kindModel.AllVersions = kindAllVersionsModel

				// Construct an instance of the PublishObject model
				publishObjectModel := new(catalogmanagementv1.PublishObject)
				publishObjectModel.PcManaged = core.BoolPtr(true)
				publishObjectModel.ApprovalType = core.StringPtr("testString")
				publishObjectModel.PublishApproved = core.BoolPtr(true)
				publishObjectModel.ShareWithAll = core.BoolPtr(true)
				publishObjectModel.ShareWithIBM = core.BoolPtr(true)
				publishObjectModel.ShareEnabled = core.BoolPtr(true)
				publishObjectModel.OriginalCRN = core.StringPtr("testString")
				publishObjectModel.PublicCRN = core.StringPtr("testString")
				publishObjectModel.ApprovalRecord = map[string]interface{}{"anyKey": "anyValue"}
				publishObjectModel.PermitIBMPublicPublish = core.BoolPtr(true)
				publishObjectModel.IBMApproved = core.BoolPtr(true)
				publishObjectModel.PublicApproved = core.BoolPtr(true)

				// Construct an instance of the ProviderInfo model
				providerInfoModel := new(catalogmanagementv1.ProviderInfo)
				providerInfoModel.ID = core.StringPtr("testString")
				providerInfoModel.Name = core.StringPtr("testString")

				// Construct an instance of the RepoInfo model
				repoInfoModel := new(catalogmanagementv1.RepoInfo)
				repoInfoModel.Token = core.StringPtr("testString")
				repoInfoModel.Type = core.StringPtr("testString")

				// Construct an instance of the ImagePullKey model
				imagePullKeyModel := new(catalogmanagementv1.ImagePullKey)
				imagePullKeyModel.Name = core.StringPtr("testString")
				imagePullKeyModel.Value = core.StringPtr("testString")
				imagePullKeyModel.Description = core.StringPtr("testString")

				// Construct an instance of the SupportWaitTime model
				supportWaitTimeModel := new(catalogmanagementv1.SupportWaitTime)
				supportWaitTimeModel.Value = core.Int64Ptr(int64(38))
				supportWaitTimeModel.Type = core.StringPtr("testString")

				// Construct an instance of the SupportTime model
				supportTimeModel := new(catalogmanagementv1.SupportTime)
				supportTimeModel.Day = core.Int64Ptr(int64(38))
				supportTimeModel.StartTime = core.StringPtr("testString")
				supportTimeModel.EndTime = core.StringPtr("testString")

				// Construct an instance of the SupportAvailability model
				supportAvailabilityModel := new(catalogmanagementv1.SupportAvailability)
				supportAvailabilityModel.Times = []catalogmanagementv1.SupportTime{*supportTimeModel}
				supportAvailabilityModel.Timezone = core.StringPtr("testString")
				supportAvailabilityModel.AlwaysAvailable = core.BoolPtr(true)

				// Construct an instance of the SupportDetail model
				supportDetailModel := new(catalogmanagementv1.SupportDetail)
				supportDetailModel.Type = core.StringPtr("testString")
				supportDetailModel.Contact = core.StringPtr("testString")
				supportDetailModel.ResponseWaitTime = supportWaitTimeModel
				supportDetailModel.Availability = supportAvailabilityModel

				// Construct an instance of the SupportEscalation model
				supportEscalationModel := new(catalogmanagementv1.SupportEscalation)
				supportEscalationModel.EscalationWaitTime = supportWaitTimeModel
				supportEscalationModel.ResponseWaitTime = supportWaitTimeModel
				supportEscalationModel.Contact = core.StringPtr("testString")

				// Construct an instance of the Support model
				supportModel := new(catalogmanagementv1.Support)
				supportModel.URL = core.StringPtr("testString")
				supportModel.Process = core.StringPtr("testString")
				supportModel.ProcessI18n = map[string]string{"key1": "testString"}
				supportModel.Locations = []string{"testString"}
				supportModel.SupportDetails = []catalogmanagementv1.SupportDetail{*supportDetailModel}
				supportModel.SupportEscalation = supportEscalationModel
				supportModel.SupportType = core.StringPtr("testString")

				// Construct an instance of the LearnMoreLinks model
				learnMoreLinksModel := new(catalogmanagementv1.LearnMoreLinks)
				learnMoreLinksModel.FirstParty = core.StringPtr("testString")
				learnMoreLinksModel.ThirdParty = core.StringPtr("testString")

				// Construct an instance of the Constraint model
				constraintModel := new(catalogmanagementv1.Constraint)
				constraintModel.Type = core.StringPtr("testString")
				constraintModel.Rule = "testString"

				// Construct an instance of the Badge model
				badgeModel := new(catalogmanagementv1.Badge)
				badgeModel.ID = core.StringPtr("testString")
				badgeModel.Label = core.StringPtr("testString")
				badgeModel.LabelI18n = map[string]string{"key1": "testString"}
				badgeModel.Description = core.StringPtr("testString")
				badgeModel.DescriptionI18n = map[string]string{"key1": "testString"}
				badgeModel.Icon = core.StringPtr("testString")
				badgeModel.Authority = core.StringPtr("testString")
				badgeModel.Tag = core.StringPtr("testString")
				badgeModel.LearnMoreLinks = learnMoreLinksModel
				badgeModel.Constraints = []catalogmanagementv1.Constraint{*constraintModel}

				// Construct an instance of the VersionRange model
				versionRangeModel := new(catalogmanagementv1.VersionRange)
				versionRangeModel.Kinds = []string{"testString"}
				versionRangeModel.Version = core.StringPtr("testString")
				versionRangeModel.Flavors = []string{"testString"}

				// Construct an instance of the Plan model
				planModel := new(catalogmanagementv1.Plan)
				planModel.URL = core.StringPtr("testString")
				planModel.CRN = core.StringPtr("testString")
				planModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				planModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				planModel.OfferingID = core.StringPtr("testString")
				planModel.CatalogID = core.StringPtr("testString")
				planModel.Label = core.StringPtr("testString")
				planModel.LabelI18n = map[string]string{"key1": "testString"}
				planModel.Name = core.StringPtr("testString")
				planModel.ShortDescription = core.StringPtr("testString")
				planModel.ShortDescriptionI18n = map[string]string{"key1": "testString"}
				planModel.PricingTags = []string{"testString"}
				planModel.VersionRange = versionRangeModel
				planModel.Features = []catalogmanagementv1.Feature{*featureModel}
				planModel.State = stateModel
				planModel.DeprecatePending = deprecatePendingModel
				planModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				planModel.PublishApproved = core.BoolPtr(true)

				// Construct an instance of the ReplaceOfferingOptions model
				replaceOfferingOptionsModel := new(catalogmanagementv1.ReplaceOfferingOptions)
				replaceOfferingOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				replaceOfferingOptionsModel.OfferingID = core.StringPtr("testString")
				replaceOfferingOptionsModel.ID = core.StringPtr("testString")
				replaceOfferingOptionsModel.Rev = core.StringPtr("testString")
				replaceOfferingOptionsModel.URL = core.StringPtr("testString")
				replaceOfferingOptionsModel.CRN = core.StringPtr("testString")
				replaceOfferingOptionsModel.Label = core.StringPtr("testString")
				replaceOfferingOptionsModel.LabelI18n = map[string]string{"key1": "testString"}
				replaceOfferingOptionsModel.Name = core.StringPtr("testString")
				replaceOfferingOptionsModel.OfferingIconURL = core.StringPtr("testString")
				replaceOfferingOptionsModel.OfferingDocsURL = core.StringPtr("testString")
				replaceOfferingOptionsModel.OfferingSupportURL = core.StringPtr("testString")
				replaceOfferingOptionsModel.Tags = []string{"testString"}
				replaceOfferingOptionsModel.Keywords = []string{"testString"}
				replaceOfferingOptionsModel.Rating = ratingModel
				replaceOfferingOptionsModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				replaceOfferingOptionsModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				replaceOfferingOptionsModel.ShortDescription = core.StringPtr("testString")
				replaceOfferingOptionsModel.ShortDescriptionI18n = map[string]string{"key1": "testString"}
				replaceOfferingOptionsModel.LongDescription = core.StringPtr("testString")
				replaceOfferingOptionsModel.LongDescriptionI18n = map[string]string{"key1": "testString"}
				replaceOfferingOptionsModel.Features = []catalogmanagementv1.Feature{*featureModel}
				replaceOfferingOptionsModel.Kinds = []catalogmanagementv1.Kind{*kindModel}
				replaceOfferingOptionsModel.Publish = publishObjectModel
				replaceOfferingOptionsModel.PcManaged = core.BoolPtr(true)
				replaceOfferingOptionsModel.PublishApproved = core.BoolPtr(true)
				replaceOfferingOptionsModel.ShareWithAll = core.BoolPtr(true)
				replaceOfferingOptionsModel.ShareWithIBM = core.BoolPtr(true)
				replaceOfferingOptionsModel.ShareEnabled = core.BoolPtr(true)
				replaceOfferingOptionsModel.PublicOriginalCRN = core.StringPtr("testString")
				replaceOfferingOptionsModel.PublishPublicCRN = core.StringPtr("testString")
				replaceOfferingOptionsModel.PortalApprovalRecord = core.StringPtr("testString")
				replaceOfferingOptionsModel.PortalUIURL = core.StringPtr("testString")
				replaceOfferingOptionsModel.CatalogID = core.StringPtr("testString")
				replaceOfferingOptionsModel.CatalogName = core.StringPtr("testString")
				replaceOfferingOptionsModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				replaceOfferingOptionsModel.Disclaimer = core.StringPtr("testString")
				replaceOfferingOptionsModel.Hidden = core.BoolPtr(true)
				replaceOfferingOptionsModel.Provider = core.StringPtr("testString")
				replaceOfferingOptionsModel.ProviderInfo = providerInfoModel
				replaceOfferingOptionsModel.RepoInfo = repoInfoModel
				replaceOfferingOptionsModel.ImagePullKeys = []catalogmanagementv1.ImagePullKey{*imagePullKeyModel}
				replaceOfferingOptionsModel.Support = supportModel
				replaceOfferingOptionsModel.Media = []catalogmanagementv1.MediaItem{*mediaItemModel}
				replaceOfferingOptionsModel.DeprecatePending = deprecatePendingModel
				replaceOfferingOptionsModel.ProductKind = core.StringPtr("testString")
				replaceOfferingOptionsModel.Badges = []catalogmanagementv1.Badge{*badgeModel}
				replaceOfferingOptionsModel.Plans = []catalogmanagementv1.Plan{*planModel}
				replaceOfferingOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.ReplaceOffering(replaceOfferingOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the ReplaceOfferingOptions model with no property values
				replaceOfferingOptionsModelNew := new(catalogmanagementv1.ReplaceOfferingOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.ReplaceOffering(replaceOfferingOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ReplaceOffering successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the Rating model
				ratingModel := new(catalogmanagementv1.Rating)
				ratingModel.OneStarCount = core.Int64Ptr(int64(38))
				ratingModel.TwoStarCount = core.Int64Ptr(int64(38))
				ratingModel.ThreeStarCount = core.Int64Ptr(int64(38))
				ratingModel.FourStarCount = core.Int64Ptr(int64(38))

				// Construct an instance of the Feature model
				featureModel := new(catalogmanagementv1.Feature)
				featureModel.Title = core.StringPtr("testString")
				featureModel.TitleI18n = map[string]string{"key1": "testString"}
				featureModel.Description = core.StringPtr("testString")
				featureModel.DescriptionI18n = map[string]string{"key1": "testString"}

				// Construct an instance of the Flavor model
				flavorModel := new(catalogmanagementv1.Flavor)
				flavorModel.Name = core.StringPtr("testString")
				flavorModel.Label = core.StringPtr("testString")
				flavorModel.LabelI18n = map[string]string{"key1": "testString"}
				flavorModel.Index = core.Int64Ptr(int64(38))

				// Construct an instance of the RenderTypeAssociationsParametersItem model
				renderTypeAssociationsParametersItemModel := new(catalogmanagementv1.RenderTypeAssociationsParametersItem)
				renderTypeAssociationsParametersItemModel.Name = core.StringPtr("testString")
				renderTypeAssociationsParametersItemModel.OptionsRefresh = core.BoolPtr(true)

				// Construct an instance of the RenderTypeAssociations model
				renderTypeAssociationsModel := new(catalogmanagementv1.RenderTypeAssociations)
				renderTypeAssociationsModel.Parameters = []catalogmanagementv1.RenderTypeAssociationsParametersItem{*renderTypeAssociationsParametersItemModel}

				// Construct an instance of the RenderType model
				renderTypeModel := new(catalogmanagementv1.RenderType)
				renderTypeModel.Type = core.StringPtr("testString")
				renderTypeModel.Grouping = core.StringPtr("testString")
				renderTypeModel.OriginalGrouping = core.StringPtr("testString")
				renderTypeModel.GroupingIndex = core.Int64Ptr(int64(38))
				renderTypeModel.ConfigConstraints = map[string]interface{}{"anyKey": "anyValue"}
				renderTypeModel.Associations = renderTypeAssociationsModel

				// Construct an instance of the Configuration model
				configurationModel := new(catalogmanagementv1.Configuration)
				configurationModel.Key = core.StringPtr("testString")
				configurationModel.Type = core.StringPtr("testString")
				configurationModel.DefaultValue = "testString"
				configurationModel.DisplayName = core.StringPtr("testString")
				configurationModel.ValueConstraint = core.StringPtr("testString")
				configurationModel.Description = core.StringPtr("testString")
				configurationModel.Required = core.BoolPtr(true)
				configurationModel.Options = []interface{}{"testString"}
				configurationModel.Hidden = core.BoolPtr(true)
				configurationModel.CustomConfig = renderTypeModel
				configurationModel.TypeMetadata = core.StringPtr("testString")

				// Construct an instance of the Output model
				outputModel := new(catalogmanagementv1.Output)
				outputModel.Key = core.StringPtr("testString")
				outputModel.Description = core.StringPtr("testString")

				// Construct an instance of the IamResource model
				iamResourceModel := new(catalogmanagementv1.IamResource)
				iamResourceModel.Name = core.StringPtr("testString")
				iamResourceModel.Description = core.StringPtr("testString")
				iamResourceModel.RoleCrns = []string{"testString"}

				// Construct an instance of the IamPermission model
				iamPermissionModel := new(catalogmanagementv1.IamPermission)
				iamPermissionModel.ServiceName = core.StringPtr("testString")
				iamPermissionModel.RoleCrns = []string{"testString"}
				iamPermissionModel.Resources = []catalogmanagementv1.IamResource{*iamResourceModel}

				// Construct an instance of the Validation model
				validationModel := new(catalogmanagementv1.Validation)
				validationModel.Validated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				validationModel.Requested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				validationModel.State = core.StringPtr("testString")
				validationModel.LastOperation = core.StringPtr("testString")
				validationModel.Target = map[string]interface{}{"anyKey": "anyValue"}
				validationModel.Message = core.StringPtr("testString")

				// Construct an instance of the Resource model
				resourceModel := new(catalogmanagementv1.Resource)
				resourceModel.Type = core.StringPtr("mem")
				resourceModel.Value = "testString"

				// Construct an instance of the SchematicsEnvValues model
				schematicsEnvValuesModel := new(catalogmanagementv1.SchematicsEnvValues)
				schematicsEnvValuesModel.Value = core.StringPtr("[{\"name\": \"TF_LOG\",\"value\": \"TRACE\",\"secure\": false,\"hidden\": false}]")
				schematicsEnvValuesModel.SmRef = core.StringPtr("cmsm_v1:{\"name\": \"envVarSecret\",\"id\":\"1234567890\",\"service_id\":\"crn:v1:bluemix:public:secrets-manager:eu-gb:a/1234567890:1234567890::\",\"service_name\":\"My SM Instance\",\"group_id\":\"1234567890\",\"group_name\":\"My SM Group\",\"resource_group_id\":\"1234567890\",\"region\":\"eu-gb\",\"type\":\"arbitrary\"}")

				// Construct an instance of the Script model
				scriptModel := new(catalogmanagementv1.Script)
				scriptModel.Instructions = core.StringPtr("testString")
				scriptModel.InstructionsI18n = map[string]string{"key1": "testString"}
				scriptModel.Script = core.StringPtr("testString")
				scriptModel.ScriptPermission = core.StringPtr("testString")
				scriptModel.DeleteScript = core.StringPtr("testString")
				scriptModel.Scope = core.StringPtr("testString")

				// Construct an instance of the ScriptRef model
				scriptRefModel := new(catalogmanagementv1.ScriptRef)
				scriptRefModel.ShortDescription = core.StringPtr("testString")
				scriptRefModel.Type = core.StringPtr("ansible")
				scriptRefModel.Path = core.StringPtr("scripts/validate-post-ansible-playbook.yaml")
				scriptRefModel.Stage = core.StringPtr("pre")
				scriptRefModel.Action = core.StringPtr("validate")

				// Construct an instance of the VersionEntitlement model
				versionEntitlementModel := new(catalogmanagementv1.VersionEntitlement)
				versionEntitlementModel.ProviderName = core.StringPtr("testString")
				versionEntitlementModel.ProviderID = core.StringPtr("testString")
				versionEntitlementModel.ProductID = core.StringPtr("testString")
				versionEntitlementModel.PartNumbers = []string{"testString"}
				versionEntitlementModel.ImageRepoName = core.StringPtr("testString")

				// Construct an instance of the License model
				licenseModel := new(catalogmanagementv1.License)
				licenseModel.ID = core.StringPtr("testString")
				licenseModel.Name = core.StringPtr("testString")
				licenseModel.Type = core.StringPtr("testString")
				licenseModel.URL = core.StringPtr("testString")
				licenseModel.Description = core.StringPtr("testString")

				// Construct an instance of the State model
				stateModel := new(catalogmanagementv1.State)
				stateModel.Current = core.StringPtr("testString")
				stateModel.CurrentEntered = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Pending = core.StringPtr("testString")
				stateModel.PendingRequested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Previous = core.StringPtr("testString")

				// Construct an instance of the DeprecatePending model
				deprecatePendingModel := new(catalogmanagementv1.DeprecatePending)
				deprecatePendingModel.DeprecateDate = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				deprecatePendingModel.DeprecateState = core.StringPtr("testString")
				deprecatePendingModel.Description = core.StringPtr("testString")

				// Construct an instance of the URLProxy model
				urlProxyModel := new(catalogmanagementv1.URLProxy)
				urlProxyModel.URL = core.StringPtr("testString")
				urlProxyModel.Sha = core.StringPtr("testString")

				// Construct an instance of the MediaItem model
				mediaItemModel := new(catalogmanagementv1.MediaItem)
				mediaItemModel.URL = core.StringPtr("testString")
				mediaItemModel.APIURL = core.StringPtr("testString")
				mediaItemModel.URLProxy = urlProxyModel
				mediaItemModel.Caption = core.StringPtr("testString")
				mediaItemModel.CaptionI18n = map[string]string{"key1": "testString"}
				mediaItemModel.Type = core.StringPtr("testString")
				mediaItemModel.ThumbnailURL = core.StringPtr("testString")

				// Construct an instance of the ArchitectureDiagram model
				architectureDiagramModel := new(catalogmanagementv1.ArchitectureDiagram)
				architectureDiagramModel.Diagram = mediaItemModel
				architectureDiagramModel.Description = core.StringPtr("testString")
				architectureDiagramModel.DescriptionI18n = map[string]string{"key1": "testString"}

				// Construct an instance of the CostComponent model
				costComponentModel := new(catalogmanagementv1.CostComponent)
				costComponentModel.Name = core.StringPtr("testString")
				costComponentModel.Unit = core.StringPtr("testString")
				costComponentModel.HourlyQuantity = core.StringPtr("testString")
				costComponentModel.MonthlyQuantity = core.StringPtr("testString")
				costComponentModel.Price = core.StringPtr("testString")
				costComponentModel.HourlyCost = core.StringPtr("testString")
				costComponentModel.MonthlyCost = core.StringPtr("testString")

				// Construct an instance of the CostResource model
				costResourceModel := new(catalogmanagementv1.CostResource)
				costResourceModel.Name = core.StringPtr("testString")
				costResourceModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				costResourceModel.HourlyCost = core.StringPtr("testString")
				costResourceModel.MonthlyCost = core.StringPtr("testString")
				costResourceModel.CostComponents = []catalogmanagementv1.CostComponent{*costComponentModel}

				// Construct an instance of the CostBreakdown model
				costBreakdownModel := new(catalogmanagementv1.CostBreakdown)
				costBreakdownModel.TotalHourlyCost = core.StringPtr("testString")
				costBreakdownModel.TotalMonthlyCost = core.StringPtr("testString")
				costBreakdownModel.Resources = []catalogmanagementv1.CostResource{*costResourceModel}

				// Construct an instance of the CostSummary model
				costSummaryModel := new(catalogmanagementv1.CostSummary)
				costSummaryModel.TotalDetectedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalSupportedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalUnsupportedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalUsageBasedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalNoPriceResources = core.Int64Ptr(int64(38))
				costSummaryModel.UnsupportedResourceCounts = map[string]int64{"key1": int64(38)}
				costSummaryModel.NoPriceResourceCounts = map[string]int64{"key1": int64(38)}

				// Construct an instance of the Project model
				projectModel := new(catalogmanagementv1.Project)
				projectModel.Name = core.StringPtr("testString")
				projectModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				projectModel.PastBreakdown = costBreakdownModel
				projectModel.Breakdown = costBreakdownModel
				projectModel.Diff = costBreakdownModel
				projectModel.Summary = costSummaryModel

				// Construct an instance of the CostEstimate model
				costEstimateModel := new(catalogmanagementv1.CostEstimate)
				costEstimateModel.Version = core.StringPtr("testString")
				costEstimateModel.Currency = core.StringPtr("testString")
				costEstimateModel.Projects = []catalogmanagementv1.Project{*projectModel}
				costEstimateModel.Summary = costSummaryModel
				costEstimateModel.TotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.TotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.PastTotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.PastTotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.DiffTotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.DiffTotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.TimeGenerated = CreateMockDateTime("2019-01-01T12:00:00.000Z")

				// Construct an instance of the OfferingReference model
				offeringReferenceModel := new(catalogmanagementv1.OfferingReference)
				offeringReferenceModel.CatalogID = core.StringPtr("testString")
				offeringReferenceModel.ID = core.StringPtr("testString")
				offeringReferenceModel.Name = core.StringPtr("testString")
				offeringReferenceModel.Kind = core.StringPtr("testString")
				offeringReferenceModel.Version = core.StringPtr("testString")
				offeringReferenceModel.Description = core.StringPtr("testString")
				offeringReferenceModel.DefaultFlavor = core.StringPtr("testString")
				offeringReferenceModel.Flavors = []string{"testString"}
				offeringReferenceModel.Optional = core.BoolPtr(true)
				offeringReferenceModel.OnByDefault = core.BoolPtr(true)

				// Construct an instance of the SolutionInfo model
				solutionInfoModel := new(catalogmanagementv1.SolutionInfo)
				solutionInfoModel.ArchitectureDiagrams = []catalogmanagementv1.ArchitectureDiagram{*architectureDiagramModel}
				solutionInfoModel.Features = []catalogmanagementv1.Feature{*featureModel}
				solutionInfoModel.CostEstimate = costEstimateModel
				solutionInfoModel.Dependencies = []catalogmanagementv1.OfferingReference{*offeringReferenceModel}
				solutionInfoModel.InstallType = core.StringPtr("testString")

				// Construct an instance of the SccProfile model
				sccProfileModel := new(catalogmanagementv1.SccProfile)
				sccProfileModel.ID = core.StringPtr("testString")
				sccProfileModel.Name = core.StringPtr("testString")
				sccProfileModel.Version = core.StringPtr("testString")
				sccProfileModel.Description = core.StringPtr("testString")
				sccProfileModel.Type = core.StringPtr("testString")
				sccProfileModel.UIHref = core.StringPtr("testString")

				// Construct an instance of the ClaimedControl model
				claimedControlModel := new(catalogmanagementv1.ClaimedControl)
				claimedControlModel.Profile = sccProfileModel
				claimedControlModel.Names = []string{"testString"}

				// Construct an instance of the Claims model
				claimsModel := new(catalogmanagementv1.Claims)
				claimsModel.Profiles = []catalogmanagementv1.SccProfile{*sccProfileModel}
				claimsModel.Controls = []catalogmanagementv1.ClaimedControl{*claimedControlModel}

				// Construct an instance of the Result model
				resultModel := new(catalogmanagementv1.Result)
				resultModel.FailureCount = core.Int64Ptr(int64(38))
				resultModel.ScanTime = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				resultModel.ErrorMessage = core.StringPtr("testString")
				resultModel.CompleteScan = core.BoolPtr(true)
				resultModel.UnscannedResources = []string{"testString"}

				// Construct an instance of the SccAssessment model
				sccAssessmentModel := new(catalogmanagementv1.SccAssessment)
				sccAssessmentModel.ID = core.StringPtr("testString")
				sccAssessmentModel.Description = core.StringPtr("testString")
				sccAssessmentModel.Version = core.StringPtr("testString")
				sccAssessmentModel.Type = core.StringPtr("testString")
				sccAssessmentModel.Method = core.StringPtr("testString")
				sccAssessmentModel.UIHref = core.StringPtr("testString")

				// Construct an instance of the SccSpecification model
				sccSpecificationModel := new(catalogmanagementv1.SccSpecification)
				sccSpecificationModel.ID = core.StringPtr("testString")
				sccSpecificationModel.Description = core.StringPtr("testString")
				sccSpecificationModel.ComponentName = core.StringPtr("testString")
				sccSpecificationModel.Assessments = []catalogmanagementv1.SccAssessment{*sccAssessmentModel}
				sccSpecificationModel.UIHref = core.StringPtr("testString")

				// Construct an instance of the SccControl model
				sccControlModel := new(catalogmanagementv1.SccControl)
				sccControlModel.ID = core.StringPtr("testString")
				sccControlModel.Name = core.StringPtr("testString")
				sccControlModel.Version = core.StringPtr("testString")
				sccControlModel.Description = core.StringPtr("testString")
				sccControlModel.Profile = sccProfileModel
				sccControlModel.ParentName = core.StringPtr("testString")
				sccControlModel.Specifications = []catalogmanagementv1.SccSpecification{*sccSpecificationModel}
				sccControlModel.UIHref = core.StringPtr("testString")

				// Construct an instance of the EvaluatedControl model
				evaluatedControlModel := new(catalogmanagementv1.EvaluatedControl)
				evaluatedControlModel.ID = core.StringPtr("testString")
				evaluatedControlModel.Name = core.StringPtr("testString")
				evaluatedControlModel.Description = core.StringPtr("testString")
				evaluatedControlModel.Specifications = []catalogmanagementv1.SccSpecification{*sccSpecificationModel}
				evaluatedControlModel.FailureCount = core.Int64Ptr(int64(38))
				evaluatedControlModel.PassCount = core.Int64Ptr(int64(38))
				evaluatedControlModel.Parent = sccControlModel
				evaluatedControlModel.UIHref = core.StringPtr("testString")

				// Construct an instance of the Evaluation model
				evaluationModel := new(catalogmanagementv1.Evaluation)
				evaluationModel.ScanID = core.StringPtr("testString")
				evaluationModel.AccountID = core.StringPtr("testString")
				evaluationModel.Profile = sccProfileModel
				evaluationModel.Result = resultModel
				evaluationModel.Controls = []catalogmanagementv1.EvaluatedControl{*evaluatedControlModel}

				// Construct an instance of the Compliance model
				complianceModel := new(catalogmanagementv1.Compliance)
				complianceModel.Authority = core.StringPtr("testString")
				complianceModel.Claims = claimsModel
				complianceModel.Evaluations = []catalogmanagementv1.Evaluation{*evaluationModel}

				// Construct an instance of the ChangeNotices model
				changeNoticesModel := new(catalogmanagementv1.ChangeNotices)
				changeNoticesModel.Breaking = []catalogmanagementv1.Feature{*featureModel}
				changeNoticesModel.New = []catalogmanagementv1.Feature{*featureModel}
				changeNoticesModel.Update = []catalogmanagementv1.Feature{*featureModel}

				// Construct an instance of the Version model
				versionModel := new(catalogmanagementv1.Version)
				versionModel.CRN = core.StringPtr("testString")
				versionModel.Version = core.StringPtr("testString")
				versionModel.Flavor = flavorModel
				versionModel.Sha = core.StringPtr("testString")
				versionModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				versionModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				versionModel.OfferingID = core.StringPtr("testString")
				versionModel.CatalogID = core.StringPtr("testString")
				versionModel.KindID = core.StringPtr("testString")
				versionModel.Tags = []string{"testString"}
				versionModel.RepoURL = core.StringPtr("testString")
				versionModel.SourceURL = core.StringPtr("testString")
				versionModel.TgzURL = core.StringPtr("testString")
				versionModel.Configuration = []catalogmanagementv1.Configuration{*configurationModel}
				versionModel.Outputs = []catalogmanagementv1.Output{*outputModel}
				versionModel.IamPermissions = []catalogmanagementv1.IamPermission{*iamPermissionModel}
				versionModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				versionModel.Validation = validationModel
				versionModel.RequiredResources = []catalogmanagementv1.Resource{*resourceModel}
				versionModel.SingleInstance = core.BoolPtr(true)
				versionModel.SchematicsEnvValues = schematicsEnvValuesModel
				versionModel.Install = scriptModel
				versionModel.PreInstall = []catalogmanagementv1.Script{*scriptModel}
				versionModel.Scripts = map[string]catalogmanagementv1.ScriptRef{"key1": *scriptRefModel}
				versionModel.Entitlement = versionEntitlementModel
				versionModel.Licenses = []catalogmanagementv1.License{*licenseModel}
				versionModel.ImageManifestURL = core.StringPtr("testString")
				versionModel.Deprecated = core.BoolPtr(true)
				versionModel.PackageVersion = core.StringPtr("testString")
				versionModel.State = stateModel
				versionModel.VersionLocator = core.StringPtr("testString")
				versionModel.LongDescription = core.StringPtr("testString")
				versionModel.LongDescriptionI18n = map[string]string{"key1": "testString"}
				versionModel.WhitelistedAccounts = []string{"testString"}
				versionModel.ImagePullKeyName = core.StringPtr("testString")
				versionModel.DeprecatePending = deprecatePendingModel
				versionModel.SolutionInfo = solutionInfoModel
				versionModel.IsConsumable = core.BoolPtr(true)
				versionModel.ComplianceV3 = complianceModel
				versionModel.ChangeNotices = changeNoticesModel
				versionModel.PlanIds = []string{"testString"}
				versionModel.Stack = map[string]interface{}{"anyKey": "anyValue"}
				versionModel.MinimumCompatibleVersion = core.StringPtr("testString")
				versionModel.Scripts["foo"] = *scriptRefModel

				// Construct an instance of the PaginationTokenLink model
				paginationTokenLinkModel := new(catalogmanagementv1.PaginationTokenLink)
				paginationTokenLinkModel.Href = core.StringPtr("testString")
				paginationTokenLinkModel.Start = core.StringPtr("testString")

				// Construct an instance of the KindAllVersions model
				kindAllVersionsModel := new(catalogmanagementv1.KindAllVersions)
				kindAllVersionsModel.First = paginationTokenLinkModel
				kindAllVersionsModel.Next = paginationTokenLinkModel

				// Construct an instance of the Kind model
				kindModel := new(catalogmanagementv1.Kind)
				kindModel.ID = core.StringPtr("testString")
				kindModel.FormatKind = core.StringPtr("testString")
				kindModel.FormatKindLabel = core.StringPtr("testString")
				kindModel.InstallKind = core.StringPtr("testString")
				kindModel.InstallKindLabel = core.StringPtr("testString")
				kindModel.TargetKind = core.StringPtr("testString")
				kindModel.TargetKindLabel = core.StringPtr("testString")
				kindModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				kindModel.Tags = []string{"testString"}
				kindModel.AdditionalFeatures = []catalogmanagementv1.Feature{*featureModel}
				kindModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				kindModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				kindModel.Versions = []catalogmanagementv1.Version{*versionModel}
				kindModel.AllVersions = kindAllVersionsModel

				// Construct an instance of the PublishObject model
				publishObjectModel := new(catalogmanagementv1.PublishObject)
				publishObjectModel.PcManaged = core.BoolPtr(true)
				publishObjectModel.ApprovalType = core.StringPtr("testString")
				publishObjectModel.PublishApproved = core.BoolPtr(true)
				publishObjectModel.ShareWithAll = core.BoolPtr(true)
				publishObjectModel.ShareWithIBM = core.BoolPtr(true)
				publishObjectModel.ShareEnabled = core.BoolPtr(true)
				publishObjectModel.OriginalCRN = core.StringPtr("testString")
				publishObjectModel.PublicCRN = core.StringPtr("testString")
				publishObjectModel.ApprovalRecord = map[string]interface{}{"anyKey": "anyValue"}
				publishObjectModel.PermitIBMPublicPublish = core.BoolPtr(true)
				publishObjectModel.IBMApproved = core.BoolPtr(true)
				publishObjectModel.PublicApproved = core.BoolPtr(true)

				// Construct an instance of the ProviderInfo model
				providerInfoModel := new(catalogmanagementv1.ProviderInfo)
				providerInfoModel.ID = core.StringPtr("testString")
				providerInfoModel.Name = core.StringPtr("testString")

				// Construct an instance of the RepoInfo model
				repoInfoModel := new(catalogmanagementv1.RepoInfo)
				repoInfoModel.Token = core.StringPtr("testString")
				repoInfoModel.Type = core.StringPtr("testString")

				// Construct an instance of the ImagePullKey model
				imagePullKeyModel := new(catalogmanagementv1.ImagePullKey)
				imagePullKeyModel.Name = core.StringPtr("testString")
				imagePullKeyModel.Value = core.StringPtr("testString")
				imagePullKeyModel.Description = core.StringPtr("testString")

				// Construct an instance of the SupportWaitTime model
				supportWaitTimeModel := new(catalogmanagementv1.SupportWaitTime)
				supportWaitTimeModel.Value = core.Int64Ptr(int64(38))
				supportWaitTimeModel.Type = core.StringPtr("testString")

				// Construct an instance of the SupportTime model
				supportTimeModel := new(catalogmanagementv1.SupportTime)
				supportTimeModel.Day = core.Int64Ptr(int64(38))
				supportTimeModel.StartTime = core.StringPtr("testString")
				supportTimeModel.EndTime = core.StringPtr("testString")

				// Construct an instance of the SupportAvailability model
				supportAvailabilityModel := new(catalogmanagementv1.SupportAvailability)
				supportAvailabilityModel.Times = []catalogmanagementv1.SupportTime{*supportTimeModel}
				supportAvailabilityModel.Timezone = core.StringPtr("testString")
				supportAvailabilityModel.AlwaysAvailable = core.BoolPtr(true)

				// Construct an instance of the SupportDetail model
				supportDetailModel := new(catalogmanagementv1.SupportDetail)
				supportDetailModel.Type = core.StringPtr("testString")
				supportDetailModel.Contact = core.StringPtr("testString")
				supportDetailModel.ResponseWaitTime = supportWaitTimeModel
				supportDetailModel.Availability = supportAvailabilityModel

				// Construct an instance of the SupportEscalation model
				supportEscalationModel := new(catalogmanagementv1.SupportEscalation)
				supportEscalationModel.EscalationWaitTime = supportWaitTimeModel
				supportEscalationModel.ResponseWaitTime = supportWaitTimeModel
				supportEscalationModel.Contact = core.StringPtr("testString")

				// Construct an instance of the Support model
				supportModel := new(catalogmanagementv1.Support)
				supportModel.URL = core.StringPtr("testString")
				supportModel.Process = core.StringPtr("testString")
				supportModel.ProcessI18n = map[string]string{"key1": "testString"}
				supportModel.Locations = []string{"testString"}
				supportModel.SupportDetails = []catalogmanagementv1.SupportDetail{*supportDetailModel}
				supportModel.SupportEscalation = supportEscalationModel
				supportModel.SupportType = core.StringPtr("testString")

				// Construct an instance of the LearnMoreLinks model
				learnMoreLinksModel := new(catalogmanagementv1.LearnMoreLinks)
				learnMoreLinksModel.FirstParty = core.StringPtr("testString")
				learnMoreLinksModel.ThirdParty = core.StringPtr("testString")

				// Construct an instance of the Constraint model
				constraintModel := new(catalogmanagementv1.Constraint)
				constraintModel.Type = core.StringPtr("testString")
				constraintModel.Rule = "testString"

				// Construct an instance of the Badge model
				badgeModel := new(catalogmanagementv1.Badge)
				badgeModel.ID = core.StringPtr("testString")
				badgeModel.Label = core.StringPtr("testString")
				badgeModel.LabelI18n = map[string]string{"key1": "testString"}
				badgeModel.Description = core.StringPtr("testString")
				badgeModel.DescriptionI18n = map[string]string{"key1": "testString"}
				badgeModel.Icon = core.StringPtr("testString")
				badgeModel.Authority = core.StringPtr("testString")
				badgeModel.Tag = core.StringPtr("testString")
				badgeModel.LearnMoreLinks = learnMoreLinksModel
				badgeModel.Constraints = []catalogmanagementv1.Constraint{*constraintModel}

				// Construct an instance of the VersionRange model
				versionRangeModel := new(catalogmanagementv1.VersionRange)
				versionRangeModel.Kinds = []string{"testString"}
				versionRangeModel.Version = core.StringPtr("testString")
				versionRangeModel.Flavors = []string{"testString"}

				// Construct an instance of the Plan model
				planModel := new(catalogmanagementv1.Plan)
				planModel.URL = core.StringPtr("testString")
				planModel.CRN = core.StringPtr("testString")
				planModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				planModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				planModel.OfferingID = core.StringPtr("testString")
				planModel.CatalogID = core.StringPtr("testString")
				planModel.Label = core.StringPtr("testString")
				planModel.LabelI18n = map[string]string{"key1": "testString"}
				planModel.Name = core.StringPtr("testString")
				planModel.ShortDescription = core.StringPtr("testString")
				planModel.ShortDescriptionI18n = map[string]string{"key1": "testString"}
				planModel.PricingTags = []string{"testString"}
				planModel.VersionRange = versionRangeModel
				planModel.Features = []catalogmanagementv1.Feature{*featureModel}
				planModel.State = stateModel
				planModel.DeprecatePending = deprecatePendingModel
				planModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				planModel.PublishApproved = core.BoolPtr(true)

				// Construct an instance of the ReplaceOfferingOptions model
				replaceOfferingOptionsModel := new(catalogmanagementv1.ReplaceOfferingOptions)
				replaceOfferingOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				replaceOfferingOptionsModel.OfferingID = core.StringPtr("testString")
				replaceOfferingOptionsModel.ID = core.StringPtr("testString")
				replaceOfferingOptionsModel.Rev = core.StringPtr("testString")
				replaceOfferingOptionsModel.URL = core.StringPtr("testString")
				replaceOfferingOptionsModel.CRN = core.StringPtr("testString")
				replaceOfferingOptionsModel.Label = core.StringPtr("testString")
				replaceOfferingOptionsModel.LabelI18n = map[string]string{"key1": "testString"}
				replaceOfferingOptionsModel.Name = core.StringPtr("testString")
				replaceOfferingOptionsModel.OfferingIconURL = core.StringPtr("testString")
				replaceOfferingOptionsModel.OfferingDocsURL = core.StringPtr("testString")
				replaceOfferingOptionsModel.OfferingSupportURL = core.StringPtr("testString")
				replaceOfferingOptionsModel.Tags = []string{"testString"}
				replaceOfferingOptionsModel.Keywords = []string{"testString"}
				replaceOfferingOptionsModel.Rating = ratingModel
				replaceOfferingOptionsModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				replaceOfferingOptionsModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				replaceOfferingOptionsModel.ShortDescription = core.StringPtr("testString")
				replaceOfferingOptionsModel.ShortDescriptionI18n = map[string]string{"key1": "testString"}
				replaceOfferingOptionsModel.LongDescription = core.StringPtr("testString")
				replaceOfferingOptionsModel.LongDescriptionI18n = map[string]string{"key1": "testString"}
				replaceOfferingOptionsModel.Features = []catalogmanagementv1.Feature{*featureModel}
				replaceOfferingOptionsModel.Kinds = []catalogmanagementv1.Kind{*kindModel}
				replaceOfferingOptionsModel.Publish = publishObjectModel
				replaceOfferingOptionsModel.PcManaged = core.BoolPtr(true)
				replaceOfferingOptionsModel.PublishApproved = core.BoolPtr(true)
				replaceOfferingOptionsModel.ShareWithAll = core.BoolPtr(true)
				replaceOfferingOptionsModel.ShareWithIBM = core.BoolPtr(true)
				replaceOfferingOptionsModel.ShareEnabled = core.BoolPtr(true)
				replaceOfferingOptionsModel.PublicOriginalCRN = core.StringPtr("testString")
				replaceOfferingOptionsModel.PublishPublicCRN = core.StringPtr("testString")
				replaceOfferingOptionsModel.PortalApprovalRecord = core.StringPtr("testString")
				replaceOfferingOptionsModel.PortalUIURL = core.StringPtr("testString")
				replaceOfferingOptionsModel.CatalogID = core.StringPtr("testString")
				replaceOfferingOptionsModel.CatalogName = core.StringPtr("testString")
				replaceOfferingOptionsModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				replaceOfferingOptionsModel.Disclaimer = core.StringPtr("testString")
				replaceOfferingOptionsModel.Hidden = core.BoolPtr(true)
				replaceOfferingOptionsModel.Provider = core.StringPtr("testString")
				replaceOfferingOptionsModel.ProviderInfo = providerInfoModel
				replaceOfferingOptionsModel.RepoInfo = repoInfoModel
				replaceOfferingOptionsModel.ImagePullKeys = []catalogmanagementv1.ImagePullKey{*imagePullKeyModel}
				replaceOfferingOptionsModel.Support = supportModel
				replaceOfferingOptionsModel.Media = []catalogmanagementv1.MediaItem{*mediaItemModel}
				replaceOfferingOptionsModel.DeprecatePending = deprecatePendingModel
				replaceOfferingOptionsModel.ProductKind = core.StringPtr("testString")
				replaceOfferingOptionsModel.Badges = []catalogmanagementv1.Badge{*badgeModel}
				replaceOfferingOptionsModel.Plans = []catalogmanagementv1.Plan{*planModel}
				replaceOfferingOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.ReplaceOffering(replaceOfferingOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`UpdateOffering(updateOfferingOptions *UpdateOfferingOptions) - Operation response error`, func() {
		updateOfferingPath := "/catalogs/testString/offerings/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updateOfferingPath))
					Expect(req.Method).To(Equal("PATCH"))
					Expect(req.Header["If-Match"]).ToNot(BeNil())
					Expect(req.Header["If-Match"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke UpdateOffering with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the JSONPatchOperation model
				jsonPatchOperationModel := new(catalogmanagementv1.JSONPatchOperation)
				jsonPatchOperationModel.Op = core.StringPtr("add")
				jsonPatchOperationModel.Path = core.StringPtr("testString")
				jsonPatchOperationModel.Value = "testString"
				jsonPatchOperationModel.From = core.StringPtr("testString")

				// Construct an instance of the UpdateOfferingOptions model
				updateOfferingOptionsModel := new(catalogmanagementv1.UpdateOfferingOptions)
				updateOfferingOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				updateOfferingOptionsModel.OfferingID = core.StringPtr("testString")
				updateOfferingOptionsModel.IfMatch = core.StringPtr("testString")
				updateOfferingOptionsModel.Updates = []catalogmanagementv1.JSONPatchOperation{*jsonPatchOperationModel}
				updateOfferingOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.UpdateOffering(updateOfferingOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.UpdateOffering(updateOfferingOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`UpdateOffering(updateOfferingOptions *UpdateOfferingOptions)`, func() {
		updateOfferingPath := "/catalogs/testString/offerings/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updateOfferingPath))
					Expect(req.Method).To(Equal("PATCH"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["If-Match"]).ToNot(BeNil())
					Expect(req.Header["If-Match"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "name": "Name", "offering_icon_url": "OfferingIconURL", "offering_docs_url": "OfferingDocsURL", "offering_support_url": "OfferingSupportURL", "tags": ["Tags"], "keywords": ["Keywords"], "rating": {"one_star_count": 12, "two_star_count": 12, "three_star_count": 14, "four_star_count": 13}, "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "kinds": [{"id": "ID", "format_kind": "FormatKind", "format_kind_label": "FormatKindLabel", "install_kind": "InstallKind", "install_kind_label": "InstallKindLabel", "target_kind": "TargetKind", "target_kind_label": "TargetKindLabel", "metadata": {"anyKey": "anyValue"}, "tags": ["Tags"], "additional_features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "versions": [{"id": "ID", "_rev": "Rev", "crn": "CRN", "version": "Version", "flavor": {"name": "Name", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "index": 5}, "sha": "Sha", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "offering_id": "OfferingID", "catalog_id": "CatalogID", "kind_id": "KindID", "tags": ["Tags"], "repo_url": "RepoURL", "source_url": "SourceURL", "tgz_url": "TgzURL", "configuration": [{"key": "Key", "type": "Type", "default_value": "anyValue", "display_name": "DisplayName", "value_constraint": "ValueConstraint", "description": "Description", "required": true, "options": ["anyValue"], "hidden": true, "custom_config": {"type": "Type", "grouping": "Grouping", "original_grouping": "OriginalGrouping", "grouping_index": 13, "config_constraints": {"anyKey": "anyValue"}, "associations": {"parameters": [{"name": "Name", "optionsRefresh": true}]}}, "type_metadata": "TypeMetadata"}], "outputs": [{"key": "Key", "description": "Description"}], "iam_permissions": [{"service_name": "ServiceName", "role_crns": ["RoleCrns"], "resources": [{"name": "Name", "description": "Description", "role_crns": ["RoleCrns"]}]}], "metadata": {"anyKey": "anyValue"}, "validation": {"validated": "2019-01-01T12:00:00.000Z", "requested": "2019-01-01T12:00:00.000Z", "state": "State", "last_operation": "LastOperation", "target": {"anyKey": "anyValue"}, "message": "Message"}, "required_resources": [{"type": "mem", "value": "anyValue"}], "single_instance": true, "schematics_env_values": {"value": "[{\"name\": \"TF_LOG\",\"value\": \"TRACE\",\"secure\": false,\"hidden\": false}]", "sm_ref": "cmsm_v1:{\"name\": \"envVarSecret\",\"id\":\"1234567890\",\"service_id\":\"crn:v1:bluemix:public:secrets-manager:eu-gb:a/1234567890:1234567890::\",\"service_name\":\"My SM Instance\",\"group_id\":\"1234567890\",\"group_name\":\"My SM Group\",\"resource_group_id\":\"1234567890\",\"region\":\"eu-gb\",\"type\":\"arbitrary\"}"}, "install": {"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}, "pre_install": [{"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}], "scripts": {"mapKey": {"short_description": "ShortDescription", "type": "ansible", "path": "scripts/validate-post-ansible-playbook.yaml", "stage": "pre", "action": "validate"}}, "entitlement": {"provider_name": "ProviderName", "provider_id": "ProviderID", "product_id": "ProductID", "part_numbers": ["PartNumbers"], "image_repo_name": "ImageRepoName"}, "licenses": [{"id": "ID", "name": "Name", "type": "Type", "url": "URL", "description": "Description"}], "image_manifest_url": "ImageManifestURL", "deprecated": true, "package_version": "PackageVersion", "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "version_locator": "VersionLocator", "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "whitelisted_accounts": ["WhitelistedAccounts"], "image_pull_key_name": "ImagePullKeyName", "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "solution_info": {"architecture_diagrams": [{"diagram": {"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "cost_estimate": {"version": "Version", "currency": "Currency", "projects": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "pastBreakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "breakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "diff": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}}], "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}, "totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "pastTotalHourlyCost": "PastTotalHourlyCost", "pastTotalMonthlyCost": "PastTotalMonthlyCost", "diffTotalHourlyCost": "DiffTotalHourlyCost", "diffTotalMonthlyCost": "DiffTotalMonthlyCost", "timeGenerated": "2019-01-01T12:00:00.000Z"}, "dependencies": [{"catalog_id": "CatalogID", "id": "ID", "name": "Name", "kind": "Kind", "version": "Version", "description": "Description", "default_flavor": "DefaultFlavor", "flavors": ["Flavors"], "optional": true, "on_by_default": false}], "install_type": "InstallType"}, "is_consumable": true, "compliance_v3": {"authority": "Authority", "claims": {"profiles": [{"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}], "controls": [{"profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "names": ["Names"]}]}, "evaluations": [{"scan_id": "ScanID", "account_id": "AccountID", "profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "result": {"failure_count": 12, "scan_time": "2019-01-01T12:00:00.000Z", "error_message": "ErrorMessage", "complete_scan": true, "unscanned_resources": ["UnscannedResources"]}, "controls": [{"id": "ID", "name": "Name", "description": "Description", "specifications": [{"id": "ID", "description": "Description", "component_name": "ComponentName", "assessments": [{"id": "ID", "description": "Description", "version": "Version", "type": "Type", "method": "Method", "ui_href": "UIHref"}], "ui_href": "UIHref"}], "failure_count": 12, "pass_count": 9, "parent": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "parent_name": "ParentName", "specifications": [{"id": "ID", "description": "Description", "component_name": "ComponentName", "assessments": [{"id": "ID", "description": "Description", "version": "Version", "type": "Type", "method": "Method", "ui_href": "UIHref"}], "ui_href": "UIHref"}], "ui_href": "UIHref"}, "ui_href": "UIHref"}]}]}, "change_notices": {"breaking": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "new": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "update": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}]}, "plan_ids": ["PlanIds"], "stack": {"anyKey": "anyValue"}, "minimum_compatible_version": "MinimumCompatibleVersion"}], "all_versions": {"first": {"href": "Href", "start": "Start"}, "next": {"href": "Href", "start": "Start"}}}], "publish": {"pc_managed": false, "approval_type": "ApprovalType", "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "original_crn": "OriginalCRN", "public_crn": "PublicCRN", "approval_record": {"anyKey": "anyValue"}, "permit_ibm_public_publish": true, "ibm_approved": false, "public_approved": true}, "pc_managed": false, "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "public_original_crn": "PublicOriginalCRN", "publish_public_crn": "PublishPublicCRN", "portal_approval_record": "PortalApprovalRecord", "portal_ui_url": "PortalUIURL", "catalog_id": "CatalogID", "catalog_name": "CatalogName", "metadata": {"anyKey": "anyValue"}, "disclaimer": "Disclaimer", "hidden": true, "provider": "Provider", "provider_info": {"id": "ID", "name": "Name"}, "repo_info": {"token": "Token", "type": "Type"}, "image_pull_keys": [{"name": "Name", "value": "Value", "description": "Description"}], "support": {"url": "URL", "process": "Process", "process_i18n": {"mapKey": "Inner"}, "locations": ["Locations"], "support_details": [{"type": "Type", "contact": "Contact", "response_wait_time": {"value": 5, "type": "Type"}, "availability": {"times": [{"day": 3, "start_time": "StartTime", "end_time": "EndTime"}], "timezone": "Timezone", "always_available": false}}], "support_escalation": {"escalation_wait_time": {"value": 5, "type": "Type"}, "response_wait_time": {"value": 5, "type": "Type"}, "contact": "Contact"}, "support_type": "SupportType"}, "media": [{"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}], "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "product_kind": "ProductKind", "badges": [{"id": "ID", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}, "icon": "Icon", "authority": "Authority", "tag": "Tag", "learn_more_links": {"first_party": "FirstParty", "third_party": "ThirdParty"}, "constraints": [{"type": "Type", "rule": "anyValue"}]}], "plans": [{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "offering_id": "OfferingID", "catalog_id": "CatalogID", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "name": "Name", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "pricing_tags": ["PricingTags"], "version_range": {"kinds": ["Kinds"], "version": "Version", "flavors": ["Flavors"]}, "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "metadata": {"anyKey": "anyValue"}, "publish_approved": false}]}`)
				}))
			})
			It(`Invoke UpdateOffering successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the JSONPatchOperation model
				jsonPatchOperationModel := new(catalogmanagementv1.JSONPatchOperation)
				jsonPatchOperationModel.Op = core.StringPtr("add")
				jsonPatchOperationModel.Path = core.StringPtr("testString")
				jsonPatchOperationModel.Value = "testString"
				jsonPatchOperationModel.From = core.StringPtr("testString")

				// Construct an instance of the UpdateOfferingOptions model
				updateOfferingOptionsModel := new(catalogmanagementv1.UpdateOfferingOptions)
				updateOfferingOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				updateOfferingOptionsModel.OfferingID = core.StringPtr("testString")
				updateOfferingOptionsModel.IfMatch = core.StringPtr("testString")
				updateOfferingOptionsModel.Updates = []catalogmanagementv1.JSONPatchOperation{*jsonPatchOperationModel}
				updateOfferingOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.UpdateOfferingWithContext(ctx, updateOfferingOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.UpdateOffering(updateOfferingOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.UpdateOfferingWithContext(ctx, updateOfferingOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updateOfferingPath))
					Expect(req.Method).To(Equal("PATCH"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["If-Match"]).ToNot(BeNil())
					Expect(req.Header["If-Match"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "name": "Name", "offering_icon_url": "OfferingIconURL", "offering_docs_url": "OfferingDocsURL", "offering_support_url": "OfferingSupportURL", "tags": ["Tags"], "keywords": ["Keywords"], "rating": {"one_star_count": 12, "two_star_count": 12, "three_star_count": 14, "four_star_count": 13}, "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "kinds": [{"id": "ID", "format_kind": "FormatKind", "format_kind_label": "FormatKindLabel", "install_kind": "InstallKind", "install_kind_label": "InstallKindLabel", "target_kind": "TargetKind", "target_kind_label": "TargetKindLabel", "metadata": {"anyKey": "anyValue"}, "tags": ["Tags"], "additional_features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "versions": [{"id": "ID", "_rev": "Rev", "crn": "CRN", "version": "Version", "flavor": {"name": "Name", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "index": 5}, "sha": "Sha", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "offering_id": "OfferingID", "catalog_id": "CatalogID", "kind_id": "KindID", "tags": ["Tags"], "repo_url": "RepoURL", "source_url": "SourceURL", "tgz_url": "TgzURL", "configuration": [{"key": "Key", "type": "Type", "default_value": "anyValue", "display_name": "DisplayName", "value_constraint": "ValueConstraint", "description": "Description", "required": true, "options": ["anyValue"], "hidden": true, "custom_config": {"type": "Type", "grouping": "Grouping", "original_grouping": "OriginalGrouping", "grouping_index": 13, "config_constraints": {"anyKey": "anyValue"}, "associations": {"parameters": [{"name": "Name", "optionsRefresh": true}]}}, "type_metadata": "TypeMetadata"}], "outputs": [{"key": "Key", "description": "Description"}], "iam_permissions": [{"service_name": "ServiceName", "role_crns": ["RoleCrns"], "resources": [{"name": "Name", "description": "Description", "role_crns": ["RoleCrns"]}]}], "metadata": {"anyKey": "anyValue"}, "validation": {"validated": "2019-01-01T12:00:00.000Z", "requested": "2019-01-01T12:00:00.000Z", "state": "State", "last_operation": "LastOperation", "target": {"anyKey": "anyValue"}, "message": "Message"}, "required_resources": [{"type": "mem", "value": "anyValue"}], "single_instance": true, "schematics_env_values": {"value": "[{\"name\": \"TF_LOG\",\"value\": \"TRACE\",\"secure\": false,\"hidden\": false}]", "sm_ref": "cmsm_v1:{\"name\": \"envVarSecret\",\"id\":\"1234567890\",\"service_id\":\"crn:v1:bluemix:public:secrets-manager:eu-gb:a/1234567890:1234567890::\",\"service_name\":\"My SM Instance\",\"group_id\":\"1234567890\",\"group_name\":\"My SM Group\",\"resource_group_id\":\"1234567890\",\"region\":\"eu-gb\",\"type\":\"arbitrary\"}"}, "install": {"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}, "pre_install": [{"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}], "scripts": {"mapKey": {"short_description": "ShortDescription", "type": "ansible", "path": "scripts/validate-post-ansible-playbook.yaml", "stage": "pre", "action": "validate"}}, "entitlement": {"provider_name": "ProviderName", "provider_id": "ProviderID", "product_id": "ProductID", "part_numbers": ["PartNumbers"], "image_repo_name": "ImageRepoName"}, "licenses": [{"id": "ID", "name": "Name", "type": "Type", "url": "URL", "description": "Description"}], "image_manifest_url": "ImageManifestURL", "deprecated": true, "package_version": "PackageVersion", "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "version_locator": "VersionLocator", "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "whitelisted_accounts": ["WhitelistedAccounts"], "image_pull_key_name": "ImagePullKeyName", "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "solution_info": {"architecture_diagrams": [{"diagram": {"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "cost_estimate": {"version": "Version", "currency": "Currency", "projects": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "pastBreakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "breakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "diff": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}}], "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}, "totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "pastTotalHourlyCost": "PastTotalHourlyCost", "pastTotalMonthlyCost": "PastTotalMonthlyCost", "diffTotalHourlyCost": "DiffTotalHourlyCost", "diffTotalMonthlyCost": "DiffTotalMonthlyCost", "timeGenerated": "2019-01-01T12:00:00.000Z"}, "dependencies": [{"catalog_id": "CatalogID", "id": "ID", "name": "Name", "kind": "Kind", "version": "Version", "description": "Description", "default_flavor": "DefaultFlavor", "flavors": ["Flavors"], "optional": true, "on_by_default": false}], "install_type": "InstallType"}, "is_consumable": true, "compliance_v3": {"authority": "Authority", "claims": {"profiles": [{"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}], "controls": [{"profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "names": ["Names"]}]}, "evaluations": [{"scan_id": "ScanID", "account_id": "AccountID", "profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "result": {"failure_count": 12, "scan_time": "2019-01-01T12:00:00.000Z", "error_message": "ErrorMessage", "complete_scan": true, "unscanned_resources": ["UnscannedResources"]}, "controls": [{"id": "ID", "name": "Name", "description": "Description", "specifications": [{"id": "ID", "description": "Description", "component_name": "ComponentName", "assessments": [{"id": "ID", "description": "Description", "version": "Version", "type": "Type", "method": "Method", "ui_href": "UIHref"}], "ui_href": "UIHref"}], "failure_count": 12, "pass_count": 9, "parent": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "parent_name": "ParentName", "specifications": [{"id": "ID", "description": "Description", "component_name": "ComponentName", "assessments": [{"id": "ID", "description": "Description", "version": "Version", "type": "Type", "method": "Method", "ui_href": "UIHref"}], "ui_href": "UIHref"}], "ui_href": "UIHref"}, "ui_href": "UIHref"}]}]}, "change_notices": {"breaking": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "new": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "update": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}]}, "plan_ids": ["PlanIds"], "stack": {"anyKey": "anyValue"}, "minimum_compatible_version": "MinimumCompatibleVersion"}], "all_versions": {"first": {"href": "Href", "start": "Start"}, "next": {"href": "Href", "start": "Start"}}}], "publish": {"pc_managed": false, "approval_type": "ApprovalType", "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "original_crn": "OriginalCRN", "public_crn": "PublicCRN", "approval_record": {"anyKey": "anyValue"}, "permit_ibm_public_publish": true, "ibm_approved": false, "public_approved": true}, "pc_managed": false, "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "public_original_crn": "PublicOriginalCRN", "publish_public_crn": "PublishPublicCRN", "portal_approval_record": "PortalApprovalRecord", "portal_ui_url": "PortalUIURL", "catalog_id": "CatalogID", "catalog_name": "CatalogName", "metadata": {"anyKey": "anyValue"}, "disclaimer": "Disclaimer", "hidden": true, "provider": "Provider", "provider_info": {"id": "ID", "name": "Name"}, "repo_info": {"token": "Token", "type": "Type"}, "image_pull_keys": [{"name": "Name", "value": "Value", "description": "Description"}], "support": {"url": "URL", "process": "Process", "process_i18n": {"mapKey": "Inner"}, "locations": ["Locations"], "support_details": [{"type": "Type", "contact": "Contact", "response_wait_time": {"value": 5, "type": "Type"}, "availability": {"times": [{"day": 3, "start_time": "StartTime", "end_time": "EndTime"}], "timezone": "Timezone", "always_available": false}}], "support_escalation": {"escalation_wait_time": {"value": 5, "type": "Type"}, "response_wait_time": {"value": 5, "type": "Type"}, "contact": "Contact"}, "support_type": "SupportType"}, "media": [{"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}], "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "product_kind": "ProductKind", "badges": [{"id": "ID", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}, "icon": "Icon", "authority": "Authority", "tag": "Tag", "learn_more_links": {"first_party": "FirstParty", "third_party": "ThirdParty"}, "constraints": [{"type": "Type", "rule": "anyValue"}]}], "plans": [{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "offering_id": "OfferingID", "catalog_id": "CatalogID", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "name": "Name", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "pricing_tags": ["PricingTags"], "version_range": {"kinds": ["Kinds"], "version": "Version", "flavors": ["Flavors"]}, "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "metadata": {"anyKey": "anyValue"}, "publish_approved": false}]}`)
				}))
			})
			It(`Invoke UpdateOffering successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.UpdateOffering(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the JSONPatchOperation model
				jsonPatchOperationModel := new(catalogmanagementv1.JSONPatchOperation)
				jsonPatchOperationModel.Op = core.StringPtr("add")
				jsonPatchOperationModel.Path = core.StringPtr("testString")
				jsonPatchOperationModel.Value = "testString"
				jsonPatchOperationModel.From = core.StringPtr("testString")

				// Construct an instance of the UpdateOfferingOptions model
				updateOfferingOptionsModel := new(catalogmanagementv1.UpdateOfferingOptions)
				updateOfferingOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				updateOfferingOptionsModel.OfferingID = core.StringPtr("testString")
				updateOfferingOptionsModel.IfMatch = core.StringPtr("testString")
				updateOfferingOptionsModel.Updates = []catalogmanagementv1.JSONPatchOperation{*jsonPatchOperationModel}
				updateOfferingOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.UpdateOffering(updateOfferingOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke UpdateOffering with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the JSONPatchOperation model
				jsonPatchOperationModel := new(catalogmanagementv1.JSONPatchOperation)
				jsonPatchOperationModel.Op = core.StringPtr("add")
				jsonPatchOperationModel.Path = core.StringPtr("testString")
				jsonPatchOperationModel.Value = "testString"
				jsonPatchOperationModel.From = core.StringPtr("testString")

				// Construct an instance of the UpdateOfferingOptions model
				updateOfferingOptionsModel := new(catalogmanagementv1.UpdateOfferingOptions)
				updateOfferingOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				updateOfferingOptionsModel.OfferingID = core.StringPtr("testString")
				updateOfferingOptionsModel.IfMatch = core.StringPtr("testString")
				updateOfferingOptionsModel.Updates = []catalogmanagementv1.JSONPatchOperation{*jsonPatchOperationModel}
				updateOfferingOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.UpdateOffering(updateOfferingOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the UpdateOfferingOptions model with no property values
				updateOfferingOptionsModelNew := new(catalogmanagementv1.UpdateOfferingOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.UpdateOffering(updateOfferingOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke UpdateOffering successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the JSONPatchOperation model
				jsonPatchOperationModel := new(catalogmanagementv1.JSONPatchOperation)
				jsonPatchOperationModel.Op = core.StringPtr("add")
				jsonPatchOperationModel.Path = core.StringPtr("testString")
				jsonPatchOperationModel.Value = "testString"
				jsonPatchOperationModel.From = core.StringPtr("testString")

				// Construct an instance of the UpdateOfferingOptions model
				updateOfferingOptionsModel := new(catalogmanagementv1.UpdateOfferingOptions)
				updateOfferingOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				updateOfferingOptionsModel.OfferingID = core.StringPtr("testString")
				updateOfferingOptionsModel.IfMatch = core.StringPtr("testString")
				updateOfferingOptionsModel.Updates = []catalogmanagementv1.JSONPatchOperation{*jsonPatchOperationModel}
				updateOfferingOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.UpdateOffering(updateOfferingOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`DeleteOffering(deleteOfferingOptions *DeleteOfferingOptions)`, func() {
		deleteOfferingPath := "/catalogs/testString/offerings/testString"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deleteOfferingPath))
					Expect(req.Method).To(Equal("DELETE"))

					Expect(req.Header["X-Approver-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Approver-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.WriteHeader(200)
				}))
			})
			It(`Invoke DeleteOffering successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := catalogManagementService.DeleteOffering(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the DeleteOfferingOptions model
				deleteOfferingOptionsModel := new(catalogmanagementv1.DeleteOfferingOptions)
				deleteOfferingOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				deleteOfferingOptionsModel.OfferingID = core.StringPtr("testString")
				deleteOfferingOptionsModel.XApproverToken = core.StringPtr("testString")
				deleteOfferingOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = catalogManagementService.DeleteOffering(deleteOfferingOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke DeleteOffering with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the DeleteOfferingOptions model
				deleteOfferingOptionsModel := new(catalogmanagementv1.DeleteOfferingOptions)
				deleteOfferingOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				deleteOfferingOptionsModel.OfferingID = core.StringPtr("testString")
				deleteOfferingOptionsModel.XApproverToken = core.StringPtr("testString")
				deleteOfferingOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := catalogManagementService.DeleteOffering(deleteOfferingOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the DeleteOfferingOptions model with no property values
				deleteOfferingOptionsModelNew := new(catalogmanagementv1.DeleteOfferingOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = catalogManagementService.DeleteOffering(deleteOfferingOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetOfferingStats(getOfferingStatsOptions *GetOfferingStatsOptions) - Operation response error`, func() {
		getOfferingStatsPath := "/catalogs/testString/offerings/testString/stats"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingStatsPath))
					Expect(req.Method).To(Equal("GET"))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetOfferingStats with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOfferingStatsOptions model
				getOfferingStatsOptionsModel := new(catalogmanagementv1.GetOfferingStatsOptions)
				getOfferingStatsOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getOfferingStatsOptionsModel.OfferingID = core.StringPtr("testString")
				getOfferingStatsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.GetOfferingStats(getOfferingStatsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.GetOfferingStats(getOfferingStatsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetOfferingStats(getOfferingStatsOptions *GetOfferingStatsOptions)`, func() {
		getOfferingStatsPath := "/catalogs/testString/offerings/testString/stats"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingStatsPath))
					Expect(req.Method).To(Equal("GET"))

					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"target_type": "TargetType", "id": "ID", "stats": [{"year_week_idx": 11, "download": 8, "update": 6, "get": 3, "bundle_download": 14}], "totals": {"year_week_idx": 11, "download": 8, "update": 6, "get": 3, "bundle_download": 14}}`)
				}))
			})
			It(`Invoke GetOfferingStats successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the GetOfferingStatsOptions model
				getOfferingStatsOptionsModel := new(catalogmanagementv1.GetOfferingStatsOptions)
				getOfferingStatsOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getOfferingStatsOptionsModel.OfferingID = core.StringPtr("testString")
				getOfferingStatsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.GetOfferingStatsWithContext(ctx, getOfferingStatsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.GetOfferingStats(getOfferingStatsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.GetOfferingStatsWithContext(ctx, getOfferingStatsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingStatsPath))
					Expect(req.Method).To(Equal("GET"))

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"target_type": "TargetType", "id": "ID", "stats": [{"year_week_idx": 11, "download": 8, "update": 6, "get": 3, "bundle_download": 14}], "totals": {"year_week_idx": 11, "download": 8, "update": 6, "get": 3, "bundle_download": 14}}`)
				}))
			})
			It(`Invoke GetOfferingStats successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.GetOfferingStats(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetOfferingStatsOptions model
				getOfferingStatsOptionsModel := new(catalogmanagementv1.GetOfferingStatsOptions)
				getOfferingStatsOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getOfferingStatsOptionsModel.OfferingID = core.StringPtr("testString")
				getOfferingStatsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.GetOfferingStats(getOfferingStatsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetOfferingStats with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOfferingStatsOptions model
				getOfferingStatsOptionsModel := new(catalogmanagementv1.GetOfferingStatsOptions)
				getOfferingStatsOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getOfferingStatsOptionsModel.OfferingID = core.StringPtr("testString")
				getOfferingStatsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.GetOfferingStats(getOfferingStatsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetOfferingStatsOptions model with no property values
				getOfferingStatsOptionsModelNew := new(catalogmanagementv1.GetOfferingStatsOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.GetOfferingStats(getOfferingStatsOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetOfferingStats successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOfferingStatsOptions model
				getOfferingStatsOptionsModel := new(catalogmanagementv1.GetOfferingStatsOptions)
				getOfferingStatsOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getOfferingStatsOptionsModel.OfferingID = core.StringPtr("testString")
				getOfferingStatsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.GetOfferingStats(getOfferingStatsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListOfferingAudits(listOfferingAuditsOptions *ListOfferingAuditsOptions) - Operation response error`, func() {
		listOfferingAuditsPath := "/catalogs/testString/offerings/testString/audits"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listOfferingAuditsPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.URL.Query()["start"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(10))}))
					// TODO: Add check for lookupnames query parameter
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ListOfferingAudits with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ListOfferingAuditsOptions model
				listOfferingAuditsOptionsModel := new(catalogmanagementv1.ListOfferingAuditsOptions)
				listOfferingAuditsOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				listOfferingAuditsOptionsModel.OfferingID = core.StringPtr("testString")
				listOfferingAuditsOptionsModel.Start = core.StringPtr("testString")
				listOfferingAuditsOptionsModel.Limit = core.Int64Ptr(int64(10))
				listOfferingAuditsOptionsModel.Lookupnames = core.BoolPtr(true)
				listOfferingAuditsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.ListOfferingAudits(listOfferingAuditsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.ListOfferingAudits(listOfferingAuditsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListOfferingAudits(listOfferingAuditsOptions *ListOfferingAuditsOptions)`, func() {
		listOfferingAuditsPath := "/catalogs/testString/offerings/testString/audits"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listOfferingAuditsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.URL.Query()["start"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(10))}))
					// TODO: Add check for lookupnames query parameter
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"start": "Start", "limit": 5, "total_count": 10, "resource_count": 13, "first": {"href": "Href", "start": "Start"}, "next": {"href": "Href", "start": "Start"}, "prev": {"href": "Href", "start": "Start"}, "last": {"href": "Href", "start": "Start"}, "audits": [{"id": "ID", "_rev": "Rev", "created": "2019-01-01T12:00:00.000Z", "change_type": "ChangeType", "target_type": "TargetType", "target_id": "TargetID", "who_email": "WhoEmail", "who_delegate_email": "WhoDelegateEmail", "message": "Message"}]}`)
				}))
			})
			It(`Invoke ListOfferingAudits successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the ListOfferingAuditsOptions model
				listOfferingAuditsOptionsModel := new(catalogmanagementv1.ListOfferingAuditsOptions)
				listOfferingAuditsOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				listOfferingAuditsOptionsModel.OfferingID = core.StringPtr("testString")
				listOfferingAuditsOptionsModel.Start = core.StringPtr("testString")
				listOfferingAuditsOptionsModel.Limit = core.Int64Ptr(int64(10))
				listOfferingAuditsOptionsModel.Lookupnames = core.BoolPtr(true)
				listOfferingAuditsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.ListOfferingAuditsWithContext(ctx, listOfferingAuditsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.ListOfferingAudits(listOfferingAuditsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.ListOfferingAuditsWithContext(ctx, listOfferingAuditsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listOfferingAuditsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.URL.Query()["start"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(10))}))
					// TODO: Add check for lookupnames query parameter
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"start": "Start", "limit": 5, "total_count": 10, "resource_count": 13, "first": {"href": "Href", "start": "Start"}, "next": {"href": "Href", "start": "Start"}, "prev": {"href": "Href", "start": "Start"}, "last": {"href": "Href", "start": "Start"}, "audits": [{"id": "ID", "_rev": "Rev", "created": "2019-01-01T12:00:00.000Z", "change_type": "ChangeType", "target_type": "TargetType", "target_id": "TargetID", "who_email": "WhoEmail", "who_delegate_email": "WhoDelegateEmail", "message": "Message"}]}`)
				}))
			})
			It(`Invoke ListOfferingAudits successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.ListOfferingAudits(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ListOfferingAuditsOptions model
				listOfferingAuditsOptionsModel := new(catalogmanagementv1.ListOfferingAuditsOptions)
				listOfferingAuditsOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				listOfferingAuditsOptionsModel.OfferingID = core.StringPtr("testString")
				listOfferingAuditsOptionsModel.Start = core.StringPtr("testString")
				listOfferingAuditsOptionsModel.Limit = core.Int64Ptr(int64(10))
				listOfferingAuditsOptionsModel.Lookupnames = core.BoolPtr(true)
				listOfferingAuditsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.ListOfferingAudits(listOfferingAuditsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ListOfferingAudits with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ListOfferingAuditsOptions model
				listOfferingAuditsOptionsModel := new(catalogmanagementv1.ListOfferingAuditsOptions)
				listOfferingAuditsOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				listOfferingAuditsOptionsModel.OfferingID = core.StringPtr("testString")
				listOfferingAuditsOptionsModel.Start = core.StringPtr("testString")
				listOfferingAuditsOptionsModel.Limit = core.Int64Ptr(int64(10))
				listOfferingAuditsOptionsModel.Lookupnames = core.BoolPtr(true)
				listOfferingAuditsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.ListOfferingAudits(listOfferingAuditsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the ListOfferingAuditsOptions model with no property values
				listOfferingAuditsOptionsModelNew := new(catalogmanagementv1.ListOfferingAuditsOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.ListOfferingAudits(listOfferingAuditsOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ListOfferingAudits successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ListOfferingAuditsOptions model
				listOfferingAuditsOptionsModel := new(catalogmanagementv1.ListOfferingAuditsOptions)
				listOfferingAuditsOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				listOfferingAuditsOptionsModel.OfferingID = core.StringPtr("testString")
				listOfferingAuditsOptionsModel.Start = core.StringPtr("testString")
				listOfferingAuditsOptionsModel.Limit = core.Int64Ptr(int64(10))
				listOfferingAuditsOptionsModel.Lookupnames = core.BoolPtr(true)
				listOfferingAuditsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.ListOfferingAudits(listOfferingAuditsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Test pagination helper method on response`, func() {
			It(`Invoke GetNextStart successfully`, func() {
				responseObject := new(catalogmanagementv1.AuditLogs)
				nextObject := new(catalogmanagementv1.PaginationTokenLink)
				nextObject.Start = core.StringPtr("abc-123")
				responseObject.Next = nextObject

				value, err := responseObject.GetNextStart()
				Expect(err).To(BeNil())
				Expect(value).To(Equal(core.StringPtr("abc-123")))
			})
			It(`Invoke GetNextStart without a "Next" property in the response`, func() {
				responseObject := new(catalogmanagementv1.AuditLogs)

				value, err := responseObject.GetNextStart()
				Expect(err).To(BeNil())
				Expect(value).To(BeNil())
			})
		})
		Context(`Using mock server endpoint - paginated response`, func() {
			BeforeEach(func() {
				var requestNumber int = 0
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listOfferingAuditsPath))
					Expect(req.Method).To(Equal("GET"))

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					requestNumber++
					if requestNumber == 1 {
						fmt.Fprintf(res, "%s", `{"next":{"start":"1"},"total_count":2,"limit":1,"audits":[{"id":"ID","_rev":"Rev","created":"2019-01-01T12:00:00.000Z","change_type":"ChangeType","target_type":"TargetType","target_id":"TargetID","who_email":"WhoEmail","who_delegate_email":"WhoDelegateEmail","message":"Message"}]}`)
					} else if requestNumber == 2 {
						fmt.Fprintf(res, "%s", `{"total_count":2,"limit":1,"audits":[{"id":"ID","_rev":"Rev","created":"2019-01-01T12:00:00.000Z","change_type":"ChangeType","target_type":"TargetType","target_id":"TargetID","who_email":"WhoEmail","who_delegate_email":"WhoDelegateEmail","message":"Message"}]}`)
					} else {
						res.WriteHeader(400)
					}
				}))
			})
			It(`Use OfferingAuditsPager.GetNext successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				listOfferingAuditsOptionsModel := &catalogmanagementv1.ListOfferingAuditsOptions{
					CatalogIdentifier: core.StringPtr("testString"),
					OfferingID:        core.StringPtr("testString"),
					Limit:             core.Int64Ptr(int64(10)),
					Lookupnames:       core.BoolPtr(true),
				}

				pager, err := catalogManagementService.NewOfferingAuditsPager(listOfferingAuditsOptionsModel)
				Expect(err).To(BeNil())
				Expect(pager).ToNot(BeNil())

				var allResults []catalogmanagementv1.AuditLogDigest
				for pager.HasNext() {
					nextPage, err := pager.GetNext()
					Expect(err).To(BeNil())
					Expect(nextPage).ToNot(BeNil())
					allResults = append(allResults, nextPage...)
				}
				Expect(len(allResults)).To(Equal(2))
			})
			It(`Use OfferingAuditsPager.GetAll successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				listOfferingAuditsOptionsModel := &catalogmanagementv1.ListOfferingAuditsOptions{
					CatalogIdentifier: core.StringPtr("testString"),
					OfferingID:        core.StringPtr("testString"),
					Limit:             core.Int64Ptr(int64(10)),
					Lookupnames:       core.BoolPtr(true),
				}

				pager, err := catalogManagementService.NewOfferingAuditsPager(listOfferingAuditsOptionsModel)
				Expect(err).To(BeNil())
				Expect(pager).ToNot(BeNil())

				allResults, err := pager.GetAll()
				Expect(err).To(BeNil())
				Expect(allResults).ToNot(BeNil())
				Expect(len(allResults)).To(Equal(2))
			})
		})
	})
	Describe(`GetOfferingAudit(getOfferingAuditOptions *GetOfferingAuditOptions) - Operation response error`, func() {
		getOfferingAuditPath := "/catalogs/testString/offerings/testString/audits/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingAuditPath))
					Expect(req.Method).To(Equal("GET"))
					// TODO: Add check for lookupnames query parameter
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetOfferingAudit with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOfferingAuditOptions model
				getOfferingAuditOptionsModel := new(catalogmanagementv1.GetOfferingAuditOptions)
				getOfferingAuditOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getOfferingAuditOptionsModel.OfferingID = core.StringPtr("testString")
				getOfferingAuditOptionsModel.AuditlogIdentifier = core.StringPtr("testString")
				getOfferingAuditOptionsModel.Lookupnames = core.BoolPtr(true)
				getOfferingAuditOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.GetOfferingAudit(getOfferingAuditOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.GetOfferingAudit(getOfferingAuditOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetOfferingAudit(getOfferingAuditOptions *GetOfferingAuditOptions)`, func() {
		getOfferingAuditPath := "/catalogs/testString/offerings/testString/audits/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingAuditPath))
					Expect(req.Method).To(Equal("GET"))

					// TODO: Add check for lookupnames query parameter
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "created": "2019-01-01T12:00:00.000Z", "change_type": "ChangeType", "target_type": "TargetType", "target_id": "TargetID", "who_email": "WhoEmail", "who_delegate_email": "WhoDelegateEmail", "message": "Message", "gid": "Gid", "who_id": "WhoID", "who_name": "WhoName", "who_delegate_id": "WhoDelegateID", "who_delegate_name": "WhoDelegateName", "data": "anyValue"}`)
				}))
			})
			It(`Invoke GetOfferingAudit successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the GetOfferingAuditOptions model
				getOfferingAuditOptionsModel := new(catalogmanagementv1.GetOfferingAuditOptions)
				getOfferingAuditOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getOfferingAuditOptionsModel.OfferingID = core.StringPtr("testString")
				getOfferingAuditOptionsModel.AuditlogIdentifier = core.StringPtr("testString")
				getOfferingAuditOptionsModel.Lookupnames = core.BoolPtr(true)
				getOfferingAuditOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.GetOfferingAuditWithContext(ctx, getOfferingAuditOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.GetOfferingAudit(getOfferingAuditOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.GetOfferingAuditWithContext(ctx, getOfferingAuditOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingAuditPath))
					Expect(req.Method).To(Equal("GET"))

					// TODO: Add check for lookupnames query parameter
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "created": "2019-01-01T12:00:00.000Z", "change_type": "ChangeType", "target_type": "TargetType", "target_id": "TargetID", "who_email": "WhoEmail", "who_delegate_email": "WhoDelegateEmail", "message": "Message", "gid": "Gid", "who_id": "WhoID", "who_name": "WhoName", "who_delegate_id": "WhoDelegateID", "who_delegate_name": "WhoDelegateName", "data": "anyValue"}`)
				}))
			})
			It(`Invoke GetOfferingAudit successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.GetOfferingAudit(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetOfferingAuditOptions model
				getOfferingAuditOptionsModel := new(catalogmanagementv1.GetOfferingAuditOptions)
				getOfferingAuditOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getOfferingAuditOptionsModel.OfferingID = core.StringPtr("testString")
				getOfferingAuditOptionsModel.AuditlogIdentifier = core.StringPtr("testString")
				getOfferingAuditOptionsModel.Lookupnames = core.BoolPtr(true)
				getOfferingAuditOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.GetOfferingAudit(getOfferingAuditOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetOfferingAudit with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOfferingAuditOptions model
				getOfferingAuditOptionsModel := new(catalogmanagementv1.GetOfferingAuditOptions)
				getOfferingAuditOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getOfferingAuditOptionsModel.OfferingID = core.StringPtr("testString")
				getOfferingAuditOptionsModel.AuditlogIdentifier = core.StringPtr("testString")
				getOfferingAuditOptionsModel.Lookupnames = core.BoolPtr(true)
				getOfferingAuditOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.GetOfferingAudit(getOfferingAuditOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetOfferingAuditOptions model with no property values
				getOfferingAuditOptionsModelNew := new(catalogmanagementv1.GetOfferingAuditOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.GetOfferingAudit(getOfferingAuditOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetOfferingAudit successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOfferingAuditOptions model
				getOfferingAuditOptionsModel := new(catalogmanagementv1.GetOfferingAuditOptions)
				getOfferingAuditOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getOfferingAuditOptionsModel.OfferingID = core.StringPtr("testString")
				getOfferingAuditOptionsModel.AuditlogIdentifier = core.StringPtr("testString")
				getOfferingAuditOptionsModel.Lookupnames = core.BoolPtr(true)
				getOfferingAuditOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.GetOfferingAudit(getOfferingAuditOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`SetOfferingPublish(setOfferingPublishOptions *SetOfferingPublishOptions) - Operation response error`, func() {
		setOfferingPublishPath := "/catalogs/testString/offerings/testString/publish/pc_managed/true"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(setOfferingPublishPath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["X-Approver-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Approver-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.Header["X-Auth-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["portal_record"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["portal_url"]).To(Equal([]string{"testString"}))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke SetOfferingPublish with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the SetOfferingPublishOptions model
				setOfferingPublishOptionsModel := new(catalogmanagementv1.SetOfferingPublishOptions)
				setOfferingPublishOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				setOfferingPublishOptionsModel.OfferingID = core.StringPtr("testString")
				setOfferingPublishOptionsModel.ApprovalType = core.StringPtr("pc_managed")
				setOfferingPublishOptionsModel.Approved = core.StringPtr("true")
				setOfferingPublishOptionsModel.PortalRecord = core.StringPtr("testString")
				setOfferingPublishOptionsModel.PortalURL = core.StringPtr("testString")
				setOfferingPublishOptionsModel.XApproverToken = core.StringPtr("testString")
				setOfferingPublishOptionsModel.XAuthToken = core.StringPtr("testString")
				setOfferingPublishOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.SetOfferingPublish(setOfferingPublishOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.SetOfferingPublish(setOfferingPublishOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`SetOfferingPublish(setOfferingPublishOptions *SetOfferingPublishOptions)`, func() {
		setOfferingPublishPath := "/catalogs/testString/offerings/testString/publish/pc_managed/true"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(setOfferingPublishPath))
					Expect(req.Method).To(Equal("POST"))

					Expect(req.Header["X-Approver-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Approver-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.Header["X-Auth-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["portal_record"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["portal_url"]).To(Equal([]string{"testString"}))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"shared": true, "ibm": false, "public": true, "allow_request": true, "approved": true, "portal_record": "PortalRecord", "portal_url": "PortalURL", "changed": false}`)
				}))
			})
			It(`Invoke SetOfferingPublish successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the SetOfferingPublishOptions model
				setOfferingPublishOptionsModel := new(catalogmanagementv1.SetOfferingPublishOptions)
				setOfferingPublishOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				setOfferingPublishOptionsModel.OfferingID = core.StringPtr("testString")
				setOfferingPublishOptionsModel.ApprovalType = core.StringPtr("pc_managed")
				setOfferingPublishOptionsModel.Approved = core.StringPtr("true")
				setOfferingPublishOptionsModel.PortalRecord = core.StringPtr("testString")
				setOfferingPublishOptionsModel.PortalURL = core.StringPtr("testString")
				setOfferingPublishOptionsModel.XApproverToken = core.StringPtr("testString")
				setOfferingPublishOptionsModel.XAuthToken = core.StringPtr("testString")
				setOfferingPublishOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.SetOfferingPublishWithContext(ctx, setOfferingPublishOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.SetOfferingPublish(setOfferingPublishOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.SetOfferingPublishWithContext(ctx, setOfferingPublishOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(setOfferingPublishPath))
					Expect(req.Method).To(Equal("POST"))

					Expect(req.Header["X-Approver-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Approver-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.Header["X-Auth-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["portal_record"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["portal_url"]).To(Equal([]string{"testString"}))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"shared": true, "ibm": false, "public": true, "allow_request": true, "approved": true, "portal_record": "PortalRecord", "portal_url": "PortalURL", "changed": false}`)
				}))
			})
			It(`Invoke SetOfferingPublish successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.SetOfferingPublish(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the SetOfferingPublishOptions model
				setOfferingPublishOptionsModel := new(catalogmanagementv1.SetOfferingPublishOptions)
				setOfferingPublishOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				setOfferingPublishOptionsModel.OfferingID = core.StringPtr("testString")
				setOfferingPublishOptionsModel.ApprovalType = core.StringPtr("pc_managed")
				setOfferingPublishOptionsModel.Approved = core.StringPtr("true")
				setOfferingPublishOptionsModel.PortalRecord = core.StringPtr("testString")
				setOfferingPublishOptionsModel.PortalURL = core.StringPtr("testString")
				setOfferingPublishOptionsModel.XApproverToken = core.StringPtr("testString")
				setOfferingPublishOptionsModel.XAuthToken = core.StringPtr("testString")
				setOfferingPublishOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.SetOfferingPublish(setOfferingPublishOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke SetOfferingPublish with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the SetOfferingPublishOptions model
				setOfferingPublishOptionsModel := new(catalogmanagementv1.SetOfferingPublishOptions)
				setOfferingPublishOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				setOfferingPublishOptionsModel.OfferingID = core.StringPtr("testString")
				setOfferingPublishOptionsModel.ApprovalType = core.StringPtr("pc_managed")
				setOfferingPublishOptionsModel.Approved = core.StringPtr("true")
				setOfferingPublishOptionsModel.PortalRecord = core.StringPtr("testString")
				setOfferingPublishOptionsModel.PortalURL = core.StringPtr("testString")
				setOfferingPublishOptionsModel.XApproverToken = core.StringPtr("testString")
				setOfferingPublishOptionsModel.XAuthToken = core.StringPtr("testString")
				setOfferingPublishOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.SetOfferingPublish(setOfferingPublishOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the SetOfferingPublishOptions model with no property values
				setOfferingPublishOptionsModelNew := new(catalogmanagementv1.SetOfferingPublishOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.SetOfferingPublish(setOfferingPublishOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke SetOfferingPublish successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the SetOfferingPublishOptions model
				setOfferingPublishOptionsModel := new(catalogmanagementv1.SetOfferingPublishOptions)
				setOfferingPublishOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				setOfferingPublishOptionsModel.OfferingID = core.StringPtr("testString")
				setOfferingPublishOptionsModel.ApprovalType = core.StringPtr("pc_managed")
				setOfferingPublishOptionsModel.Approved = core.StringPtr("true")
				setOfferingPublishOptionsModel.PortalRecord = core.StringPtr("testString")
				setOfferingPublishOptionsModel.PortalURL = core.StringPtr("testString")
				setOfferingPublishOptionsModel.XApproverToken = core.StringPtr("testString")
				setOfferingPublishOptionsModel.XAuthToken = core.StringPtr("testString")
				setOfferingPublishOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.SetOfferingPublish(setOfferingPublishOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`DeprecateOffering(deprecateOfferingOptions *DeprecateOfferingOptions)`, func() {
		deprecateOfferingPath := "/catalogs/testString/offerings/testString/deprecate/true"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deprecateOfferingPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					res.WriteHeader(202)
				}))
			})
			It(`Invoke DeprecateOffering successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := catalogManagementService.DeprecateOffering(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the DeprecateOfferingOptions model
				deprecateOfferingOptionsModel := new(catalogmanagementv1.DeprecateOfferingOptions)
				deprecateOfferingOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				deprecateOfferingOptionsModel.OfferingID = core.StringPtr("testString")
				deprecateOfferingOptionsModel.Setting = core.StringPtr("true")
				deprecateOfferingOptionsModel.Description = core.StringPtr("testString")
				deprecateOfferingOptionsModel.DaysUntilDeprecate = core.Int64Ptr(int64(38))
				deprecateOfferingOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = catalogManagementService.DeprecateOffering(deprecateOfferingOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke DeprecateOffering with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the DeprecateOfferingOptions model
				deprecateOfferingOptionsModel := new(catalogmanagementv1.DeprecateOfferingOptions)
				deprecateOfferingOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				deprecateOfferingOptionsModel.OfferingID = core.StringPtr("testString")
				deprecateOfferingOptionsModel.Setting = core.StringPtr("true")
				deprecateOfferingOptionsModel.Description = core.StringPtr("testString")
				deprecateOfferingOptionsModel.DaysUntilDeprecate = core.Int64Ptr(int64(38))
				deprecateOfferingOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := catalogManagementService.DeprecateOffering(deprecateOfferingOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the DeprecateOfferingOptions model with no property values
				deprecateOfferingOptionsModelNew := new(catalogmanagementv1.DeprecateOfferingOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = catalogManagementService.DeprecateOffering(deprecateOfferingOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ShareOffering(shareOfferingOptions *ShareOfferingOptions) - Operation response error`, func() {
		shareOfferingPath := "/catalogs/testString/offerings/testString/share"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(shareOfferingPath))
					Expect(req.Method).To(Equal("POST"))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ShareOffering with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ShareOfferingOptions model
				shareOfferingOptionsModel := new(catalogmanagementv1.ShareOfferingOptions)
				shareOfferingOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				shareOfferingOptionsModel.OfferingID = core.StringPtr("testString")
				shareOfferingOptionsModel.IBM = core.BoolPtr(true)
				shareOfferingOptionsModel.Public = core.BoolPtr(true)
				shareOfferingOptionsModel.Enabled = core.BoolPtr(true)
				shareOfferingOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.ShareOffering(shareOfferingOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.ShareOffering(shareOfferingOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ShareOffering(shareOfferingOptions *ShareOfferingOptions)`, func() {
		shareOfferingPath := "/catalogs/testString/offerings/testString/share"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(shareOfferingPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"ibm": false, "public": true, "enabled": false}`)
				}))
			})
			It(`Invoke ShareOffering successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the ShareOfferingOptions model
				shareOfferingOptionsModel := new(catalogmanagementv1.ShareOfferingOptions)
				shareOfferingOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				shareOfferingOptionsModel.OfferingID = core.StringPtr("testString")
				shareOfferingOptionsModel.IBM = core.BoolPtr(true)
				shareOfferingOptionsModel.Public = core.BoolPtr(true)
				shareOfferingOptionsModel.Enabled = core.BoolPtr(true)
				shareOfferingOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.ShareOfferingWithContext(ctx, shareOfferingOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.ShareOffering(shareOfferingOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.ShareOfferingWithContext(ctx, shareOfferingOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(shareOfferingPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"ibm": false, "public": true, "enabled": false}`)
				}))
			})
			It(`Invoke ShareOffering successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.ShareOffering(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ShareOfferingOptions model
				shareOfferingOptionsModel := new(catalogmanagementv1.ShareOfferingOptions)
				shareOfferingOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				shareOfferingOptionsModel.OfferingID = core.StringPtr("testString")
				shareOfferingOptionsModel.IBM = core.BoolPtr(true)
				shareOfferingOptionsModel.Public = core.BoolPtr(true)
				shareOfferingOptionsModel.Enabled = core.BoolPtr(true)
				shareOfferingOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.ShareOffering(shareOfferingOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ShareOffering with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ShareOfferingOptions model
				shareOfferingOptionsModel := new(catalogmanagementv1.ShareOfferingOptions)
				shareOfferingOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				shareOfferingOptionsModel.OfferingID = core.StringPtr("testString")
				shareOfferingOptionsModel.IBM = core.BoolPtr(true)
				shareOfferingOptionsModel.Public = core.BoolPtr(true)
				shareOfferingOptionsModel.Enabled = core.BoolPtr(true)
				shareOfferingOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.ShareOffering(shareOfferingOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the ShareOfferingOptions model with no property values
				shareOfferingOptionsModelNew := new(catalogmanagementv1.ShareOfferingOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.ShareOffering(shareOfferingOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ShareOffering successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ShareOfferingOptions model
				shareOfferingOptionsModel := new(catalogmanagementv1.ShareOfferingOptions)
				shareOfferingOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				shareOfferingOptionsModel.OfferingID = core.StringPtr("testString")
				shareOfferingOptionsModel.IBM = core.BoolPtr(true)
				shareOfferingOptionsModel.Public = core.BoolPtr(true)
				shareOfferingOptionsModel.Enabled = core.BoolPtr(true)
				shareOfferingOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.ShareOffering(shareOfferingOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetOfferingAccess(getOfferingAccessOptions *GetOfferingAccessOptions) - Operation response error`, func() {
		getOfferingAccessPath := "/catalogs/testString/offerings/testString/access/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingAccessPath))
					Expect(req.Method).To(Equal("GET"))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetOfferingAccess with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOfferingAccessOptions model
				getOfferingAccessOptionsModel := new(catalogmanagementv1.GetOfferingAccessOptions)
				getOfferingAccessOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getOfferingAccessOptionsModel.OfferingID = core.StringPtr("testString")
				getOfferingAccessOptionsModel.AccessIdentifier = core.StringPtr("testString")
				getOfferingAccessOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.GetOfferingAccess(getOfferingAccessOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.GetOfferingAccess(getOfferingAccessOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetOfferingAccess(getOfferingAccessOptions *GetOfferingAccessOptions)`, func() {
		getOfferingAccessPath := "/catalogs/testString/offerings/testString/access/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingAccessPath))
					Expect(req.Method).To(Equal("GET"))

					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "account": "Account", "account_type": 11, "catalog_id": "CatalogID", "target_id": "TargetID", "target_account": "TargetAccount", "target_kind": "TargetKind", "created": "2019-01-01T12:00:00.000Z", "approval_state": "ApprovalState", "visible_states": ["VisibleStates"]}`)
				}))
			})
			It(`Invoke GetOfferingAccess successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the GetOfferingAccessOptions model
				getOfferingAccessOptionsModel := new(catalogmanagementv1.GetOfferingAccessOptions)
				getOfferingAccessOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getOfferingAccessOptionsModel.OfferingID = core.StringPtr("testString")
				getOfferingAccessOptionsModel.AccessIdentifier = core.StringPtr("testString")
				getOfferingAccessOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.GetOfferingAccessWithContext(ctx, getOfferingAccessOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.GetOfferingAccess(getOfferingAccessOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.GetOfferingAccessWithContext(ctx, getOfferingAccessOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingAccessPath))
					Expect(req.Method).To(Equal("GET"))

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "account": "Account", "account_type": 11, "catalog_id": "CatalogID", "target_id": "TargetID", "target_account": "TargetAccount", "target_kind": "TargetKind", "created": "2019-01-01T12:00:00.000Z", "approval_state": "ApprovalState", "visible_states": ["VisibleStates"]}`)
				}))
			})
			It(`Invoke GetOfferingAccess successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.GetOfferingAccess(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetOfferingAccessOptions model
				getOfferingAccessOptionsModel := new(catalogmanagementv1.GetOfferingAccessOptions)
				getOfferingAccessOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getOfferingAccessOptionsModel.OfferingID = core.StringPtr("testString")
				getOfferingAccessOptionsModel.AccessIdentifier = core.StringPtr("testString")
				getOfferingAccessOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.GetOfferingAccess(getOfferingAccessOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetOfferingAccess with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOfferingAccessOptions model
				getOfferingAccessOptionsModel := new(catalogmanagementv1.GetOfferingAccessOptions)
				getOfferingAccessOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getOfferingAccessOptionsModel.OfferingID = core.StringPtr("testString")
				getOfferingAccessOptionsModel.AccessIdentifier = core.StringPtr("testString")
				getOfferingAccessOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.GetOfferingAccess(getOfferingAccessOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetOfferingAccessOptions model with no property values
				getOfferingAccessOptionsModelNew := new(catalogmanagementv1.GetOfferingAccessOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.GetOfferingAccess(getOfferingAccessOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetOfferingAccess successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOfferingAccessOptions model
				getOfferingAccessOptionsModel := new(catalogmanagementv1.GetOfferingAccessOptions)
				getOfferingAccessOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getOfferingAccessOptionsModel.OfferingID = core.StringPtr("testString")
				getOfferingAccessOptionsModel.AccessIdentifier = core.StringPtr("testString")
				getOfferingAccessOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.GetOfferingAccess(getOfferingAccessOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetOfferingAccessList(getOfferingAccessListOptions *GetOfferingAccessListOptions) - Operation response error`, func() {
		getOfferingAccessListPath := "/catalogs/testString/offerings/testString/access"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingAccessListPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.URL.Query()["start"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(10))}))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetOfferingAccessList with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOfferingAccessListOptions model
				getOfferingAccessListOptionsModel := new(catalogmanagementv1.GetOfferingAccessListOptions)
				getOfferingAccessListOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getOfferingAccessListOptionsModel.OfferingID = core.StringPtr("testString")
				getOfferingAccessListOptionsModel.Start = core.StringPtr("testString")
				getOfferingAccessListOptionsModel.Limit = core.Int64Ptr(int64(10))
				getOfferingAccessListOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.GetOfferingAccessList(getOfferingAccessListOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.GetOfferingAccessList(getOfferingAccessListOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetOfferingAccessList(getOfferingAccessListOptions *GetOfferingAccessListOptions)`, func() {
		getOfferingAccessListPath := "/catalogs/testString/offerings/testString/access"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingAccessListPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.URL.Query()["start"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(10))}))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"start": "Start", "limit": 5, "total_count": 10, "resource_count": 13, "first": {"href": "Href", "start": "Start"}, "next": {"href": "Href", "start": "Start"}, "prev": {"href": "Href", "start": "Start"}, "last": {"href": "Href", "start": "Start"}, "resources": [{"id": "ID", "account": "Account", "account_type": 11, "catalog_id": "CatalogID", "target_id": "TargetID", "target_account": "TargetAccount", "target_kind": "TargetKind", "created": "2019-01-01T12:00:00.000Z", "approval_state": "ApprovalState", "visible_states": ["VisibleStates"]}]}`)
				}))
			})
			It(`Invoke GetOfferingAccessList successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the GetOfferingAccessListOptions model
				getOfferingAccessListOptionsModel := new(catalogmanagementv1.GetOfferingAccessListOptions)
				getOfferingAccessListOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getOfferingAccessListOptionsModel.OfferingID = core.StringPtr("testString")
				getOfferingAccessListOptionsModel.Start = core.StringPtr("testString")
				getOfferingAccessListOptionsModel.Limit = core.Int64Ptr(int64(10))
				getOfferingAccessListOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.GetOfferingAccessListWithContext(ctx, getOfferingAccessListOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.GetOfferingAccessList(getOfferingAccessListOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.GetOfferingAccessListWithContext(ctx, getOfferingAccessListOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingAccessListPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.URL.Query()["start"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(10))}))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"start": "Start", "limit": 5, "total_count": 10, "resource_count": 13, "first": {"href": "Href", "start": "Start"}, "next": {"href": "Href", "start": "Start"}, "prev": {"href": "Href", "start": "Start"}, "last": {"href": "Href", "start": "Start"}, "resources": [{"id": "ID", "account": "Account", "account_type": 11, "catalog_id": "CatalogID", "target_id": "TargetID", "target_account": "TargetAccount", "target_kind": "TargetKind", "created": "2019-01-01T12:00:00.000Z", "approval_state": "ApprovalState", "visible_states": ["VisibleStates"]}]}`)
				}))
			})
			It(`Invoke GetOfferingAccessList successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.GetOfferingAccessList(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetOfferingAccessListOptions model
				getOfferingAccessListOptionsModel := new(catalogmanagementv1.GetOfferingAccessListOptions)
				getOfferingAccessListOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getOfferingAccessListOptionsModel.OfferingID = core.StringPtr("testString")
				getOfferingAccessListOptionsModel.Start = core.StringPtr("testString")
				getOfferingAccessListOptionsModel.Limit = core.Int64Ptr(int64(10))
				getOfferingAccessListOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.GetOfferingAccessList(getOfferingAccessListOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetOfferingAccessList with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOfferingAccessListOptions model
				getOfferingAccessListOptionsModel := new(catalogmanagementv1.GetOfferingAccessListOptions)
				getOfferingAccessListOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getOfferingAccessListOptionsModel.OfferingID = core.StringPtr("testString")
				getOfferingAccessListOptionsModel.Start = core.StringPtr("testString")
				getOfferingAccessListOptionsModel.Limit = core.Int64Ptr(int64(10))
				getOfferingAccessListOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.GetOfferingAccessList(getOfferingAccessListOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetOfferingAccessListOptions model with no property values
				getOfferingAccessListOptionsModelNew := new(catalogmanagementv1.GetOfferingAccessListOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.GetOfferingAccessList(getOfferingAccessListOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetOfferingAccessList successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOfferingAccessListOptions model
				getOfferingAccessListOptionsModel := new(catalogmanagementv1.GetOfferingAccessListOptions)
				getOfferingAccessListOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getOfferingAccessListOptionsModel.OfferingID = core.StringPtr("testString")
				getOfferingAccessListOptionsModel.Start = core.StringPtr("testString")
				getOfferingAccessListOptionsModel.Limit = core.Int64Ptr(int64(10))
				getOfferingAccessListOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.GetOfferingAccessList(getOfferingAccessListOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Test pagination helper method on response`, func() {
			It(`Invoke GetNextStart successfully`, func() {
				responseObject := new(catalogmanagementv1.AccessListResult)
				nextObject := new(catalogmanagementv1.PaginationTokenLink)
				nextObject.Start = core.StringPtr("abc-123")
				responseObject.Next = nextObject

				value, err := responseObject.GetNextStart()
				Expect(err).To(BeNil())
				Expect(value).To(Equal(core.StringPtr("abc-123")))
			})
			It(`Invoke GetNextStart without a "Next" property in the response`, func() {
				responseObject := new(catalogmanagementv1.AccessListResult)

				value, err := responseObject.GetNextStart()
				Expect(err).To(BeNil())
				Expect(value).To(BeNil())
			})
		})
		Context(`Using mock server endpoint - paginated response`, func() {
			BeforeEach(func() {
				var requestNumber int = 0
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingAccessListPath))
					Expect(req.Method).To(Equal("GET"))

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					requestNumber++
					if requestNumber == 1 {
						fmt.Fprintf(res, "%s", `{"next":{"start":"1"},"total_count":2,"limit":1,"resources":[{"id":"ID","account":"Account","account_type":11,"catalog_id":"CatalogID","target_id":"TargetID","target_account":"TargetAccount","target_kind":"TargetKind","created":"2019-01-01T12:00:00.000Z","approval_state":"ApprovalState","visible_states":["VisibleStates"]}]}`)
					} else if requestNumber == 2 {
						fmt.Fprintf(res, "%s", `{"total_count":2,"limit":1,"resources":[{"id":"ID","account":"Account","account_type":11,"catalog_id":"CatalogID","target_id":"TargetID","target_account":"TargetAccount","target_kind":"TargetKind","created":"2019-01-01T12:00:00.000Z","approval_state":"ApprovalState","visible_states":["VisibleStates"]}]}`)
					} else {
						res.WriteHeader(400)
					}
				}))
			})
			It(`Use GetOfferingAccessListPager.GetNext successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				getOfferingAccessListOptionsModel := &catalogmanagementv1.GetOfferingAccessListOptions{
					CatalogIdentifier: core.StringPtr("testString"),
					OfferingID:        core.StringPtr("testString"),
					Limit:             core.Int64Ptr(int64(10)),
				}

				pager, err := catalogManagementService.NewGetOfferingAccessListPager(getOfferingAccessListOptionsModel)
				Expect(err).To(BeNil())
				Expect(pager).ToNot(BeNil())

				var allResults []catalogmanagementv1.Access
				for pager.HasNext() {
					nextPage, err := pager.GetNext()
					Expect(err).To(BeNil())
					Expect(nextPage).ToNot(BeNil())
					allResults = append(allResults, nextPage...)
				}
				Expect(len(allResults)).To(Equal(2))
			})
			It(`Use GetOfferingAccessListPager.GetAll successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				getOfferingAccessListOptionsModel := &catalogmanagementv1.GetOfferingAccessListOptions{
					CatalogIdentifier: core.StringPtr("testString"),
					OfferingID:        core.StringPtr("testString"),
					Limit:             core.Int64Ptr(int64(10)),
				}

				pager, err := catalogManagementService.NewGetOfferingAccessListPager(getOfferingAccessListOptionsModel)
				Expect(err).To(BeNil())
				Expect(pager).ToNot(BeNil())

				allResults, err := pager.GetAll()
				Expect(err).To(BeNil())
				Expect(allResults).ToNot(BeNil())
				Expect(len(allResults)).To(Equal(2))
			})
		})
	})
	Describe(`DeleteOfferingAccessList(deleteOfferingAccessListOptions *DeleteOfferingAccessListOptions) - Operation response error`, func() {
		deleteOfferingAccessListPath := "/catalogs/testString/offerings/testString/access"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deleteOfferingAccessListPath))
					Expect(req.Method).To(Equal("DELETE"))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke DeleteOfferingAccessList with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the DeleteOfferingAccessListOptions model
				deleteOfferingAccessListOptionsModel := new(catalogmanagementv1.DeleteOfferingAccessListOptions)
				deleteOfferingAccessListOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				deleteOfferingAccessListOptionsModel.OfferingID = core.StringPtr("testString")
				deleteOfferingAccessListOptionsModel.Accesses = []string{"testString"}
				deleteOfferingAccessListOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.DeleteOfferingAccessList(deleteOfferingAccessListOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.DeleteOfferingAccessList(deleteOfferingAccessListOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`DeleteOfferingAccessList(deleteOfferingAccessListOptions *DeleteOfferingAccessListOptions)`, func() {
		deleteOfferingAccessListPath := "/catalogs/testString/offerings/testString/access"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deleteOfferingAccessListPath))
					Expect(req.Method).To(Equal("DELETE"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"errors": {"mapKey": "Inner"}}`)
				}))
			})
			It(`Invoke DeleteOfferingAccessList successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the DeleteOfferingAccessListOptions model
				deleteOfferingAccessListOptionsModel := new(catalogmanagementv1.DeleteOfferingAccessListOptions)
				deleteOfferingAccessListOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				deleteOfferingAccessListOptionsModel.OfferingID = core.StringPtr("testString")
				deleteOfferingAccessListOptionsModel.Accesses = []string{"testString"}
				deleteOfferingAccessListOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.DeleteOfferingAccessListWithContext(ctx, deleteOfferingAccessListOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.DeleteOfferingAccessList(deleteOfferingAccessListOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.DeleteOfferingAccessListWithContext(ctx, deleteOfferingAccessListOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deleteOfferingAccessListPath))
					Expect(req.Method).To(Equal("DELETE"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"errors": {"mapKey": "Inner"}}`)
				}))
			})
			It(`Invoke DeleteOfferingAccessList successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.DeleteOfferingAccessList(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the DeleteOfferingAccessListOptions model
				deleteOfferingAccessListOptionsModel := new(catalogmanagementv1.DeleteOfferingAccessListOptions)
				deleteOfferingAccessListOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				deleteOfferingAccessListOptionsModel.OfferingID = core.StringPtr("testString")
				deleteOfferingAccessListOptionsModel.Accesses = []string{"testString"}
				deleteOfferingAccessListOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.DeleteOfferingAccessList(deleteOfferingAccessListOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke DeleteOfferingAccessList with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the DeleteOfferingAccessListOptions model
				deleteOfferingAccessListOptionsModel := new(catalogmanagementv1.DeleteOfferingAccessListOptions)
				deleteOfferingAccessListOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				deleteOfferingAccessListOptionsModel.OfferingID = core.StringPtr("testString")
				deleteOfferingAccessListOptionsModel.Accesses = []string{"testString"}
				deleteOfferingAccessListOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.DeleteOfferingAccessList(deleteOfferingAccessListOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the DeleteOfferingAccessListOptions model with no property values
				deleteOfferingAccessListOptionsModelNew := new(catalogmanagementv1.DeleteOfferingAccessListOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.DeleteOfferingAccessList(deleteOfferingAccessListOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke DeleteOfferingAccessList successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the DeleteOfferingAccessListOptions model
				deleteOfferingAccessListOptionsModel := new(catalogmanagementv1.DeleteOfferingAccessListOptions)
				deleteOfferingAccessListOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				deleteOfferingAccessListOptionsModel.OfferingID = core.StringPtr("testString")
				deleteOfferingAccessListOptionsModel.Accesses = []string{"testString"}
				deleteOfferingAccessListOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.DeleteOfferingAccessList(deleteOfferingAccessListOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`AddOfferingAccessList(addOfferingAccessListOptions *AddOfferingAccessListOptions) - Operation response error`, func() {
		addOfferingAccessListPath := "/catalogs/testString/offerings/testString/access"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(addOfferingAccessListPath))
					Expect(req.Method).To(Equal("POST"))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke AddOfferingAccessList with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the AddOfferingAccessListOptions model
				addOfferingAccessListOptionsModel := new(catalogmanagementv1.AddOfferingAccessListOptions)
				addOfferingAccessListOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				addOfferingAccessListOptionsModel.OfferingID = core.StringPtr("testString")
				addOfferingAccessListOptionsModel.Accesses = []string{"testString"}
				addOfferingAccessListOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.AddOfferingAccessList(addOfferingAccessListOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.AddOfferingAccessList(addOfferingAccessListOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`AddOfferingAccessList(addOfferingAccessListOptions *AddOfferingAccessListOptions)`, func() {
		addOfferingAccessListPath := "/catalogs/testString/offerings/testString/access"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(addOfferingAccessListPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"start": "Start", "limit": 5, "total_count": 10, "resource_count": 13, "first": {"href": "Href", "start": "Start"}, "next": {"href": "Href", "start": "Start"}, "prev": {"href": "Href", "start": "Start"}, "last": {"href": "Href", "start": "Start"}, "resources": [{"id": "ID", "account": "Account", "account_type": 11, "catalog_id": "CatalogID", "target_id": "TargetID", "target_account": "TargetAccount", "target_kind": "TargetKind", "created": "2019-01-01T12:00:00.000Z", "approval_state": "ApprovalState", "visible_states": ["VisibleStates"]}]}`)
				}))
			})
			It(`Invoke AddOfferingAccessList successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the AddOfferingAccessListOptions model
				addOfferingAccessListOptionsModel := new(catalogmanagementv1.AddOfferingAccessListOptions)
				addOfferingAccessListOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				addOfferingAccessListOptionsModel.OfferingID = core.StringPtr("testString")
				addOfferingAccessListOptionsModel.Accesses = []string{"testString"}
				addOfferingAccessListOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.AddOfferingAccessListWithContext(ctx, addOfferingAccessListOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.AddOfferingAccessList(addOfferingAccessListOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.AddOfferingAccessListWithContext(ctx, addOfferingAccessListOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(addOfferingAccessListPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"start": "Start", "limit": 5, "total_count": 10, "resource_count": 13, "first": {"href": "Href", "start": "Start"}, "next": {"href": "Href", "start": "Start"}, "prev": {"href": "Href", "start": "Start"}, "last": {"href": "Href", "start": "Start"}, "resources": [{"id": "ID", "account": "Account", "account_type": 11, "catalog_id": "CatalogID", "target_id": "TargetID", "target_account": "TargetAccount", "target_kind": "TargetKind", "created": "2019-01-01T12:00:00.000Z", "approval_state": "ApprovalState", "visible_states": ["VisibleStates"]}]}`)
				}))
			})
			It(`Invoke AddOfferingAccessList successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.AddOfferingAccessList(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the AddOfferingAccessListOptions model
				addOfferingAccessListOptionsModel := new(catalogmanagementv1.AddOfferingAccessListOptions)
				addOfferingAccessListOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				addOfferingAccessListOptionsModel.OfferingID = core.StringPtr("testString")
				addOfferingAccessListOptionsModel.Accesses = []string{"testString"}
				addOfferingAccessListOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.AddOfferingAccessList(addOfferingAccessListOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke AddOfferingAccessList with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the AddOfferingAccessListOptions model
				addOfferingAccessListOptionsModel := new(catalogmanagementv1.AddOfferingAccessListOptions)
				addOfferingAccessListOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				addOfferingAccessListOptionsModel.OfferingID = core.StringPtr("testString")
				addOfferingAccessListOptionsModel.Accesses = []string{"testString"}
				addOfferingAccessListOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.AddOfferingAccessList(addOfferingAccessListOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the AddOfferingAccessListOptions model with no property values
				addOfferingAccessListOptionsModelNew := new(catalogmanagementv1.AddOfferingAccessListOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.AddOfferingAccessList(addOfferingAccessListOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(201)
				}))
			})
			It(`Invoke AddOfferingAccessList successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the AddOfferingAccessListOptions model
				addOfferingAccessListOptionsModel := new(catalogmanagementv1.AddOfferingAccessListOptions)
				addOfferingAccessListOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				addOfferingAccessListOptionsModel.OfferingID = core.StringPtr("testString")
				addOfferingAccessListOptionsModel.Accesses = []string{"testString"}
				addOfferingAccessListOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.AddOfferingAccessList(addOfferingAccessListOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetOfferingUpdates(getOfferingUpdatesOptions *GetOfferingUpdatesOptions) - Operation response error`, func() {
		getOfferingUpdatesPath := "/catalogs/testString/offerings/testString/updates"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingUpdatesPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["X-Auth-Refresh-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Refresh-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["kind"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["target"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["version"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["cluster_id"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["region"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["resource_group_id"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["namespace"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["sha"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["channel"]).To(Equal([]string{"testString"}))
					// TODO: Add check for all_namespaces query parameter
					Expect(req.URL.Query()["flavor"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["install_type"]).To(Equal([]string{"testString"}))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetOfferingUpdates with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOfferingUpdatesOptions model
				getOfferingUpdatesOptionsModel := new(catalogmanagementv1.GetOfferingUpdatesOptions)
				getOfferingUpdatesOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.OfferingID = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Kind = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Target = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Version = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.ClusterID = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Region = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.ResourceGroupID = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Namespace = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Sha = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Channel = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Namespaces = []string{"testString"}
				getOfferingUpdatesOptionsModel.AllNamespaces = core.BoolPtr(true)
				getOfferingUpdatesOptionsModel.Flavor = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.InstallType = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.GetOfferingUpdates(getOfferingUpdatesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.GetOfferingUpdates(getOfferingUpdatesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetOfferingUpdates(getOfferingUpdatesOptions *GetOfferingUpdatesOptions)`, func() {
		getOfferingUpdatesPath := "/catalogs/testString/offerings/testString/updates"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingUpdatesPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["X-Auth-Refresh-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Refresh-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["kind"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["target"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["version"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["cluster_id"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["region"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["resource_group_id"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["namespace"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["sha"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["channel"]).To(Equal([]string{"testString"}))
					// TODO: Add check for all_namespaces query parameter
					Expect(req.URL.Query()["flavor"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["install_type"]).To(Equal([]string{"testString"}))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `[{"version_locator": "VersionLocator", "version": "Version", "flavor": {"name": "Name", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "index": 5}, "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "required_resources": [{"type": "mem", "value": "anyValue"}], "package_version": "PackageVersion", "sha": "Sha", "can_update": false, "messages": {"mapKey": "Inner"}}]`)
				}))
			})
			It(`Invoke GetOfferingUpdates successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the GetOfferingUpdatesOptions model
				getOfferingUpdatesOptionsModel := new(catalogmanagementv1.GetOfferingUpdatesOptions)
				getOfferingUpdatesOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.OfferingID = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Kind = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Target = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Version = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.ClusterID = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Region = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.ResourceGroupID = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Namespace = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Sha = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Channel = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Namespaces = []string{"testString"}
				getOfferingUpdatesOptionsModel.AllNamespaces = core.BoolPtr(true)
				getOfferingUpdatesOptionsModel.Flavor = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.InstallType = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.GetOfferingUpdatesWithContext(ctx, getOfferingUpdatesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.GetOfferingUpdates(getOfferingUpdatesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.GetOfferingUpdatesWithContext(ctx, getOfferingUpdatesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingUpdatesPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["X-Auth-Refresh-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Refresh-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["kind"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["target"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["version"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["cluster_id"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["region"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["resource_group_id"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["namespace"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["sha"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["channel"]).To(Equal([]string{"testString"}))
					// TODO: Add check for all_namespaces query parameter
					Expect(req.URL.Query()["flavor"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["install_type"]).To(Equal([]string{"testString"}))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `[{"version_locator": "VersionLocator", "version": "Version", "flavor": {"name": "Name", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "index": 5}, "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "required_resources": [{"type": "mem", "value": "anyValue"}], "package_version": "PackageVersion", "sha": "Sha", "can_update": false, "messages": {"mapKey": "Inner"}}]`)
				}))
			})
			It(`Invoke GetOfferingUpdates successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.GetOfferingUpdates(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetOfferingUpdatesOptions model
				getOfferingUpdatesOptionsModel := new(catalogmanagementv1.GetOfferingUpdatesOptions)
				getOfferingUpdatesOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.OfferingID = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Kind = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Target = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Version = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.ClusterID = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Region = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.ResourceGroupID = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Namespace = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Sha = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Channel = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Namespaces = []string{"testString"}
				getOfferingUpdatesOptionsModel.AllNamespaces = core.BoolPtr(true)
				getOfferingUpdatesOptionsModel.Flavor = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.InstallType = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.GetOfferingUpdates(getOfferingUpdatesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetOfferingUpdates with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOfferingUpdatesOptions model
				getOfferingUpdatesOptionsModel := new(catalogmanagementv1.GetOfferingUpdatesOptions)
				getOfferingUpdatesOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.OfferingID = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Kind = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Target = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Version = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.ClusterID = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Region = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.ResourceGroupID = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Namespace = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Sha = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Channel = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Namespaces = []string{"testString"}
				getOfferingUpdatesOptionsModel.AllNamespaces = core.BoolPtr(true)
				getOfferingUpdatesOptionsModel.Flavor = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.InstallType = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.GetOfferingUpdates(getOfferingUpdatesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetOfferingUpdatesOptions model with no property values
				getOfferingUpdatesOptionsModelNew := new(catalogmanagementv1.GetOfferingUpdatesOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.GetOfferingUpdates(getOfferingUpdatesOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetOfferingUpdates successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOfferingUpdatesOptions model
				getOfferingUpdatesOptionsModel := new(catalogmanagementv1.GetOfferingUpdatesOptions)
				getOfferingUpdatesOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.OfferingID = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Kind = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Target = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Version = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.ClusterID = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Region = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.ResourceGroupID = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Namespace = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Sha = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Channel = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Namespaces = []string{"testString"}
				getOfferingUpdatesOptionsModel.AllNamespaces = core.BoolPtr(true)
				getOfferingUpdatesOptionsModel.Flavor = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.InstallType = core.StringPtr("testString")
				getOfferingUpdatesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.GetOfferingUpdates(getOfferingUpdatesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetOfferingChangeNotices(getOfferingChangeNoticesOptions *GetOfferingChangeNoticesOptions) - Operation response error`, func() {
		getOfferingChangeNoticesPath := "/catalogs/testString/offerings/testString/changeNotices"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingChangeNoticesPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.URL.Query()["kind"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["target"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["version"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["flavor"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["versions"]).To(Equal([]string{"latest"}))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetOfferingChangeNotices with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOfferingChangeNoticesOptions model
				getOfferingChangeNoticesOptionsModel := new(catalogmanagementv1.GetOfferingChangeNoticesOptions)
				getOfferingChangeNoticesOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getOfferingChangeNoticesOptionsModel.OfferingID = core.StringPtr("testString")
				getOfferingChangeNoticesOptionsModel.Kind = core.StringPtr("testString")
				getOfferingChangeNoticesOptionsModel.Target = core.StringPtr("testString")
				getOfferingChangeNoticesOptionsModel.Version = core.StringPtr("testString")
				getOfferingChangeNoticesOptionsModel.Flavor = core.StringPtr("testString")
				getOfferingChangeNoticesOptionsModel.Versions = core.StringPtr("latest")
				getOfferingChangeNoticesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.GetOfferingChangeNotices(getOfferingChangeNoticesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.GetOfferingChangeNotices(getOfferingChangeNoticesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetOfferingChangeNotices(getOfferingChangeNoticesOptions *GetOfferingChangeNoticesOptions)`, func() {
		getOfferingChangeNoticesPath := "/catalogs/testString/offerings/testString/changeNotices"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingChangeNoticesPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.URL.Query()["kind"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["target"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["version"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["flavor"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["versions"]).To(Equal([]string{"latest"}))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"has_breaking": false, "has_new": true, "has_update": false, "change_notices": [{"version_locator": "VersionLocator", "version": "Version", "flavor": {"name": "Name", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "index": 5}, "breaking": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "new": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "update": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}]}]}`)
				}))
			})
			It(`Invoke GetOfferingChangeNotices successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the GetOfferingChangeNoticesOptions model
				getOfferingChangeNoticesOptionsModel := new(catalogmanagementv1.GetOfferingChangeNoticesOptions)
				getOfferingChangeNoticesOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getOfferingChangeNoticesOptionsModel.OfferingID = core.StringPtr("testString")
				getOfferingChangeNoticesOptionsModel.Kind = core.StringPtr("testString")
				getOfferingChangeNoticesOptionsModel.Target = core.StringPtr("testString")
				getOfferingChangeNoticesOptionsModel.Version = core.StringPtr("testString")
				getOfferingChangeNoticesOptionsModel.Flavor = core.StringPtr("testString")
				getOfferingChangeNoticesOptionsModel.Versions = core.StringPtr("latest")
				getOfferingChangeNoticesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.GetOfferingChangeNoticesWithContext(ctx, getOfferingChangeNoticesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.GetOfferingChangeNotices(getOfferingChangeNoticesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.GetOfferingChangeNoticesWithContext(ctx, getOfferingChangeNoticesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingChangeNoticesPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.URL.Query()["kind"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["target"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["version"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["flavor"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["versions"]).To(Equal([]string{"latest"}))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"has_breaking": false, "has_new": true, "has_update": false, "change_notices": [{"version_locator": "VersionLocator", "version": "Version", "flavor": {"name": "Name", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "index": 5}, "breaking": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "new": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "update": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}]}]}`)
				}))
			})
			It(`Invoke GetOfferingChangeNotices successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.GetOfferingChangeNotices(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetOfferingChangeNoticesOptions model
				getOfferingChangeNoticesOptionsModel := new(catalogmanagementv1.GetOfferingChangeNoticesOptions)
				getOfferingChangeNoticesOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getOfferingChangeNoticesOptionsModel.OfferingID = core.StringPtr("testString")
				getOfferingChangeNoticesOptionsModel.Kind = core.StringPtr("testString")
				getOfferingChangeNoticesOptionsModel.Target = core.StringPtr("testString")
				getOfferingChangeNoticesOptionsModel.Version = core.StringPtr("testString")
				getOfferingChangeNoticesOptionsModel.Flavor = core.StringPtr("testString")
				getOfferingChangeNoticesOptionsModel.Versions = core.StringPtr("latest")
				getOfferingChangeNoticesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.GetOfferingChangeNotices(getOfferingChangeNoticesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetOfferingChangeNotices with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOfferingChangeNoticesOptions model
				getOfferingChangeNoticesOptionsModel := new(catalogmanagementv1.GetOfferingChangeNoticesOptions)
				getOfferingChangeNoticesOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getOfferingChangeNoticesOptionsModel.OfferingID = core.StringPtr("testString")
				getOfferingChangeNoticesOptionsModel.Kind = core.StringPtr("testString")
				getOfferingChangeNoticesOptionsModel.Target = core.StringPtr("testString")
				getOfferingChangeNoticesOptionsModel.Version = core.StringPtr("testString")
				getOfferingChangeNoticesOptionsModel.Flavor = core.StringPtr("testString")
				getOfferingChangeNoticesOptionsModel.Versions = core.StringPtr("latest")
				getOfferingChangeNoticesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.GetOfferingChangeNotices(getOfferingChangeNoticesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetOfferingChangeNoticesOptions model with no property values
				getOfferingChangeNoticesOptionsModelNew := new(catalogmanagementv1.GetOfferingChangeNoticesOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.GetOfferingChangeNotices(getOfferingChangeNoticesOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetOfferingChangeNotices successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOfferingChangeNoticesOptions model
				getOfferingChangeNoticesOptionsModel := new(catalogmanagementv1.GetOfferingChangeNoticesOptions)
				getOfferingChangeNoticesOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getOfferingChangeNoticesOptionsModel.OfferingID = core.StringPtr("testString")
				getOfferingChangeNoticesOptionsModel.Kind = core.StringPtr("testString")
				getOfferingChangeNoticesOptionsModel.Target = core.StringPtr("testString")
				getOfferingChangeNoticesOptionsModel.Version = core.StringPtr("testString")
				getOfferingChangeNoticesOptionsModel.Flavor = core.StringPtr("testString")
				getOfferingChangeNoticesOptionsModel.Versions = core.StringPtr("latest")
				getOfferingChangeNoticesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.GetOfferingChangeNotices(getOfferingChangeNoticesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetOfferingSource(getOfferingSourceOptions *GetOfferingSourceOptions)`, func() {
		getOfferingSourcePath := "/offering/source"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingSourcePath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Accept"]).ToNot(BeNil())
					Expect(req.Header["Accept"][0]).To(Equal(fmt.Sprintf("%v", "application/yaml")))
					Expect(req.URL.Query()["version"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["catalogID"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["name"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["id"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["kind"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["channel"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["flavor"]).To(Equal([]string{"testString"}))
					// TODO: Add check for asIs query parameter
					Expect(req.URL.Query()["installType"]).To(Equal([]string{"testString"}))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/yaml")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `This is a mock binary response.`)
				}))
			})
			It(`Invoke GetOfferingSource successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the GetOfferingSourceOptions model
				getOfferingSourceOptionsModel := new(catalogmanagementv1.GetOfferingSourceOptions)
				getOfferingSourceOptionsModel.Version = core.StringPtr("testString")
				getOfferingSourceOptionsModel.Accept = core.StringPtr("application/yaml")
				getOfferingSourceOptionsModel.CatalogID = core.StringPtr("testString")
				getOfferingSourceOptionsModel.Name = core.StringPtr("testString")
				getOfferingSourceOptionsModel.ID = core.StringPtr("testString")
				getOfferingSourceOptionsModel.Kind = core.StringPtr("testString")
				getOfferingSourceOptionsModel.Channel = core.StringPtr("testString")
				getOfferingSourceOptionsModel.Flavor = core.StringPtr("testString")
				getOfferingSourceOptionsModel.AsIs = core.BoolPtr(true)
				getOfferingSourceOptionsModel.InstallType = core.StringPtr("testString")
				getOfferingSourceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.GetOfferingSourceWithContext(ctx, getOfferingSourceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.GetOfferingSource(getOfferingSourceOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.GetOfferingSourceWithContext(ctx, getOfferingSourceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingSourcePath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Accept"]).ToNot(BeNil())
					Expect(req.Header["Accept"][0]).To(Equal(fmt.Sprintf("%v", "application/yaml")))
					Expect(req.URL.Query()["version"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["catalogID"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["name"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["id"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["kind"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["channel"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["flavor"]).To(Equal([]string{"testString"}))
					// TODO: Add check for asIs query parameter
					Expect(req.URL.Query()["installType"]).To(Equal([]string{"testString"}))
					// Set mock response
					res.Header().Set("Content-type", "application/yaml")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `This is a mock binary response.`)
				}))
			})
			It(`Invoke GetOfferingSource successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.GetOfferingSource(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetOfferingSourceOptions model
				getOfferingSourceOptionsModel := new(catalogmanagementv1.GetOfferingSourceOptions)
				getOfferingSourceOptionsModel.Version = core.StringPtr("testString")
				getOfferingSourceOptionsModel.Accept = core.StringPtr("application/yaml")
				getOfferingSourceOptionsModel.CatalogID = core.StringPtr("testString")
				getOfferingSourceOptionsModel.Name = core.StringPtr("testString")
				getOfferingSourceOptionsModel.ID = core.StringPtr("testString")
				getOfferingSourceOptionsModel.Kind = core.StringPtr("testString")
				getOfferingSourceOptionsModel.Channel = core.StringPtr("testString")
				getOfferingSourceOptionsModel.Flavor = core.StringPtr("testString")
				getOfferingSourceOptionsModel.AsIs = core.BoolPtr(true)
				getOfferingSourceOptionsModel.InstallType = core.StringPtr("testString")
				getOfferingSourceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.GetOfferingSource(getOfferingSourceOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetOfferingSource with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOfferingSourceOptions model
				getOfferingSourceOptionsModel := new(catalogmanagementv1.GetOfferingSourceOptions)
				getOfferingSourceOptionsModel.Version = core.StringPtr("testString")
				getOfferingSourceOptionsModel.Accept = core.StringPtr("application/yaml")
				getOfferingSourceOptionsModel.CatalogID = core.StringPtr("testString")
				getOfferingSourceOptionsModel.Name = core.StringPtr("testString")
				getOfferingSourceOptionsModel.ID = core.StringPtr("testString")
				getOfferingSourceOptionsModel.Kind = core.StringPtr("testString")
				getOfferingSourceOptionsModel.Channel = core.StringPtr("testString")
				getOfferingSourceOptionsModel.Flavor = core.StringPtr("testString")
				getOfferingSourceOptionsModel.AsIs = core.BoolPtr(true)
				getOfferingSourceOptionsModel.InstallType = core.StringPtr("testString")
				getOfferingSourceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.GetOfferingSource(getOfferingSourceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetOfferingSourceOptions model with no property values
				getOfferingSourceOptionsModelNew := new(catalogmanagementv1.GetOfferingSourceOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.GetOfferingSource(getOfferingSourceOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetOfferingSource successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOfferingSourceOptions model
				getOfferingSourceOptionsModel := new(catalogmanagementv1.GetOfferingSourceOptions)
				getOfferingSourceOptionsModel.Version = core.StringPtr("testString")
				getOfferingSourceOptionsModel.Accept = core.StringPtr("application/yaml")
				getOfferingSourceOptionsModel.CatalogID = core.StringPtr("testString")
				getOfferingSourceOptionsModel.Name = core.StringPtr("testString")
				getOfferingSourceOptionsModel.ID = core.StringPtr("testString")
				getOfferingSourceOptionsModel.Kind = core.StringPtr("testString")
				getOfferingSourceOptionsModel.Channel = core.StringPtr("testString")
				getOfferingSourceOptionsModel.Flavor = core.StringPtr("testString")
				getOfferingSourceOptionsModel.AsIs = core.BoolPtr(true)
				getOfferingSourceOptionsModel.InstallType = core.StringPtr("testString")
				getOfferingSourceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.GetOfferingSource(getOfferingSourceOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify empty byte buffer.
				Expect(result).ToNot(BeNil())
				buffer, operationErr := io.ReadAll(result)
				Expect(operationErr).To(BeNil())
				Expect(buffer).ToNot(BeNil())
				Expect(len(buffer)).To(Equal(0))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetOfferingSourceArchive(getOfferingSourceArchiveOptions *GetOfferingSourceArchiveOptions)`, func() {
		getOfferingSourceArchivePath := "/offering/source/archive"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingSourceArchivePath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Accept"]).ToNot(BeNil())
					Expect(req.Header["Accept"][0]).To(Equal(fmt.Sprintf("%v", "application/yaml")))
					Expect(req.URL.Query()["version"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["catalogID"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["name"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["id"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["kind"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["channel"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["flavor"]).To(Equal([]string{"testString"}))
					// TODO: Add check for asIs query parameter
					Expect(req.URL.Query()["installType"]).To(Equal([]string{"testString"}))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/yaml")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `This is a mock binary response.`)
				}))
			})
			It(`Invoke GetOfferingSourceArchive successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the GetOfferingSourceArchiveOptions model
				getOfferingSourceArchiveOptionsModel := new(catalogmanagementv1.GetOfferingSourceArchiveOptions)
				getOfferingSourceArchiveOptionsModel.Version = core.StringPtr("testString")
				getOfferingSourceArchiveOptionsModel.Accept = core.StringPtr("application/yaml")
				getOfferingSourceArchiveOptionsModel.CatalogID = core.StringPtr("testString")
				getOfferingSourceArchiveOptionsModel.Name = core.StringPtr("testString")
				getOfferingSourceArchiveOptionsModel.ID = core.StringPtr("testString")
				getOfferingSourceArchiveOptionsModel.Kind = core.StringPtr("testString")
				getOfferingSourceArchiveOptionsModel.Channel = core.StringPtr("testString")
				getOfferingSourceArchiveOptionsModel.Flavor = core.StringPtr("testString")
				getOfferingSourceArchiveOptionsModel.AsIs = core.BoolPtr(true)
				getOfferingSourceArchiveOptionsModel.InstallType = core.StringPtr("testString")
				getOfferingSourceArchiveOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.GetOfferingSourceArchiveWithContext(ctx, getOfferingSourceArchiveOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.GetOfferingSourceArchive(getOfferingSourceArchiveOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.GetOfferingSourceArchiveWithContext(ctx, getOfferingSourceArchiveOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingSourceArchivePath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Accept"]).ToNot(BeNil())
					Expect(req.Header["Accept"][0]).To(Equal(fmt.Sprintf("%v", "application/yaml")))
					Expect(req.URL.Query()["version"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["catalogID"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["name"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["id"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["kind"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["channel"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["flavor"]).To(Equal([]string{"testString"}))
					// TODO: Add check for asIs query parameter
					Expect(req.URL.Query()["installType"]).To(Equal([]string{"testString"}))
					// Set mock response
					res.Header().Set("Content-type", "application/yaml")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `This is a mock binary response.`)
				}))
			})
			It(`Invoke GetOfferingSourceArchive successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.GetOfferingSourceArchive(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetOfferingSourceArchiveOptions model
				getOfferingSourceArchiveOptionsModel := new(catalogmanagementv1.GetOfferingSourceArchiveOptions)
				getOfferingSourceArchiveOptionsModel.Version = core.StringPtr("testString")
				getOfferingSourceArchiveOptionsModel.Accept = core.StringPtr("application/yaml")
				getOfferingSourceArchiveOptionsModel.CatalogID = core.StringPtr("testString")
				getOfferingSourceArchiveOptionsModel.Name = core.StringPtr("testString")
				getOfferingSourceArchiveOptionsModel.ID = core.StringPtr("testString")
				getOfferingSourceArchiveOptionsModel.Kind = core.StringPtr("testString")
				getOfferingSourceArchiveOptionsModel.Channel = core.StringPtr("testString")
				getOfferingSourceArchiveOptionsModel.Flavor = core.StringPtr("testString")
				getOfferingSourceArchiveOptionsModel.AsIs = core.BoolPtr(true)
				getOfferingSourceArchiveOptionsModel.InstallType = core.StringPtr("testString")
				getOfferingSourceArchiveOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.GetOfferingSourceArchive(getOfferingSourceArchiveOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetOfferingSourceArchive with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOfferingSourceArchiveOptions model
				getOfferingSourceArchiveOptionsModel := new(catalogmanagementv1.GetOfferingSourceArchiveOptions)
				getOfferingSourceArchiveOptionsModel.Version = core.StringPtr("testString")
				getOfferingSourceArchiveOptionsModel.Accept = core.StringPtr("application/yaml")
				getOfferingSourceArchiveOptionsModel.CatalogID = core.StringPtr("testString")
				getOfferingSourceArchiveOptionsModel.Name = core.StringPtr("testString")
				getOfferingSourceArchiveOptionsModel.ID = core.StringPtr("testString")
				getOfferingSourceArchiveOptionsModel.Kind = core.StringPtr("testString")
				getOfferingSourceArchiveOptionsModel.Channel = core.StringPtr("testString")
				getOfferingSourceArchiveOptionsModel.Flavor = core.StringPtr("testString")
				getOfferingSourceArchiveOptionsModel.AsIs = core.BoolPtr(true)
				getOfferingSourceArchiveOptionsModel.InstallType = core.StringPtr("testString")
				getOfferingSourceArchiveOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.GetOfferingSourceArchive(getOfferingSourceArchiveOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetOfferingSourceArchiveOptions model with no property values
				getOfferingSourceArchiveOptionsModelNew := new(catalogmanagementv1.GetOfferingSourceArchiveOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.GetOfferingSourceArchive(getOfferingSourceArchiveOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetOfferingSourceArchive successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOfferingSourceArchiveOptions model
				getOfferingSourceArchiveOptionsModel := new(catalogmanagementv1.GetOfferingSourceArchiveOptions)
				getOfferingSourceArchiveOptionsModel.Version = core.StringPtr("testString")
				getOfferingSourceArchiveOptionsModel.Accept = core.StringPtr("application/yaml")
				getOfferingSourceArchiveOptionsModel.CatalogID = core.StringPtr("testString")
				getOfferingSourceArchiveOptionsModel.Name = core.StringPtr("testString")
				getOfferingSourceArchiveOptionsModel.ID = core.StringPtr("testString")
				getOfferingSourceArchiveOptionsModel.Kind = core.StringPtr("testString")
				getOfferingSourceArchiveOptionsModel.Channel = core.StringPtr("testString")
				getOfferingSourceArchiveOptionsModel.Flavor = core.StringPtr("testString")
				getOfferingSourceArchiveOptionsModel.AsIs = core.BoolPtr(true)
				getOfferingSourceArchiveOptionsModel.InstallType = core.StringPtr("testString")
				getOfferingSourceArchiveOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.GetOfferingSourceArchive(getOfferingSourceArchiveOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify empty byte buffer.
				Expect(result).ToNot(BeNil())
				buffer, operationErr := io.ReadAll(result)
				Expect(operationErr).To(BeNil())
				Expect(buffer).ToNot(BeNil())
				Expect(len(buffer)).To(Equal(0))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetOfferingSourceURL(getOfferingSourceURLOptions *GetOfferingSourceURLOptions)`, func() {
		getOfferingSourceURLPath := "/offering/source/url/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingSourceURLPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Accept"]).ToNot(BeNil())
					Expect(req.Header["Accept"][0]).To(Equal(fmt.Sprintf("%v", "application/yaml")))
					Expect(req.URL.Query()["catalogID"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["name"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["id"]).To(Equal([]string{"testString"}))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/yaml")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `This is a mock binary response.`)
				}))
			})
			It(`Invoke GetOfferingSourceURL successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the GetOfferingSourceURLOptions model
				getOfferingSourceURLOptionsModel := new(catalogmanagementv1.GetOfferingSourceURLOptions)
				getOfferingSourceURLOptionsModel.KeyIdentifier = core.StringPtr("testString")
				getOfferingSourceURLOptionsModel.Accept = core.StringPtr("application/yaml")
				getOfferingSourceURLOptionsModel.CatalogID = core.StringPtr("testString")
				getOfferingSourceURLOptionsModel.Name = core.StringPtr("testString")
				getOfferingSourceURLOptionsModel.ID = core.StringPtr("testString")
				getOfferingSourceURLOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.GetOfferingSourceURLWithContext(ctx, getOfferingSourceURLOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.GetOfferingSourceURL(getOfferingSourceURLOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.GetOfferingSourceURLWithContext(ctx, getOfferingSourceURLOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingSourceURLPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Accept"]).ToNot(BeNil())
					Expect(req.Header["Accept"][0]).To(Equal(fmt.Sprintf("%v", "application/yaml")))
					Expect(req.URL.Query()["catalogID"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["name"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["id"]).To(Equal([]string{"testString"}))
					// Set mock response
					res.Header().Set("Content-type", "application/yaml")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `This is a mock binary response.`)
				}))
			})
			It(`Invoke GetOfferingSourceURL successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.GetOfferingSourceURL(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetOfferingSourceURLOptions model
				getOfferingSourceURLOptionsModel := new(catalogmanagementv1.GetOfferingSourceURLOptions)
				getOfferingSourceURLOptionsModel.KeyIdentifier = core.StringPtr("testString")
				getOfferingSourceURLOptionsModel.Accept = core.StringPtr("application/yaml")
				getOfferingSourceURLOptionsModel.CatalogID = core.StringPtr("testString")
				getOfferingSourceURLOptionsModel.Name = core.StringPtr("testString")
				getOfferingSourceURLOptionsModel.ID = core.StringPtr("testString")
				getOfferingSourceURLOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.GetOfferingSourceURL(getOfferingSourceURLOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetOfferingSourceURL with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOfferingSourceURLOptions model
				getOfferingSourceURLOptionsModel := new(catalogmanagementv1.GetOfferingSourceURLOptions)
				getOfferingSourceURLOptionsModel.KeyIdentifier = core.StringPtr("testString")
				getOfferingSourceURLOptionsModel.Accept = core.StringPtr("application/yaml")
				getOfferingSourceURLOptionsModel.CatalogID = core.StringPtr("testString")
				getOfferingSourceURLOptionsModel.Name = core.StringPtr("testString")
				getOfferingSourceURLOptionsModel.ID = core.StringPtr("testString")
				getOfferingSourceURLOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.GetOfferingSourceURL(getOfferingSourceURLOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetOfferingSourceURLOptions model with no property values
				getOfferingSourceURLOptionsModelNew := new(catalogmanagementv1.GetOfferingSourceURLOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.GetOfferingSourceURL(getOfferingSourceURLOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetOfferingSourceURL successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOfferingSourceURLOptions model
				getOfferingSourceURLOptionsModel := new(catalogmanagementv1.GetOfferingSourceURLOptions)
				getOfferingSourceURLOptionsModel.KeyIdentifier = core.StringPtr("testString")
				getOfferingSourceURLOptionsModel.Accept = core.StringPtr("application/yaml")
				getOfferingSourceURLOptionsModel.CatalogID = core.StringPtr("testString")
				getOfferingSourceURLOptionsModel.Name = core.StringPtr("testString")
				getOfferingSourceURLOptionsModel.ID = core.StringPtr("testString")
				getOfferingSourceURLOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.GetOfferingSourceURL(getOfferingSourceURLOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify empty byte buffer.
				Expect(result).ToNot(BeNil())
				buffer, operationErr := io.ReadAll(result)
				Expect(operationErr).To(BeNil())
				Expect(buffer).ToNot(BeNil())
				Expect(len(buffer)).To(Equal(0))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetVersions(getVersionsOptions *GetVersionsOptions) - Operation response error`, func() {
		getVersionsPath := "/catalogs/testString/offerings/testString/kinds/testString/versions"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getVersionsPath))
					Expect(req.Method).To(Equal("GET"))
					// TODO: Add check for digest query parameter
					// TODO: Add check for catalog query parameter
					Expect(req.URL.Query()["start"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(10))}))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetVersions with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetVersionsOptions model
				getVersionsOptionsModel := new(catalogmanagementv1.GetVersionsOptions)
				getVersionsOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getVersionsOptionsModel.OfferingID = core.StringPtr("testString")
				getVersionsOptionsModel.KindID = core.StringPtr("testString")
				getVersionsOptionsModel.Digest = core.BoolPtr(true)
				getVersionsOptionsModel.Catalog = core.BoolPtr(true)
				getVersionsOptionsModel.Start = core.StringPtr("testString")
				getVersionsOptionsModel.Limit = core.Int64Ptr(int64(10))
				getVersionsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.GetVersions(getVersionsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.GetVersions(getVersionsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetVersions(getVersionsOptions *GetVersionsOptions)`, func() {
		getVersionsPath := "/catalogs/testString/offerings/testString/kinds/testString/versions"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getVersionsPath))
					Expect(req.Method).To(Equal("GET"))

					// TODO: Add check for digest query parameter
					// TODO: Add check for catalog query parameter
					Expect(req.URL.Query()["start"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(10))}))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"start": "Start", "limit": 5, "total_count": 10, "resource_count": 13, "first": {"href": "Href", "start": "Start"}, "next": {"href": "Href", "start": "Start"}, "prev": {"href": "Href", "start": "Start"}, "last": {"href": "Href", "start": "Start"}, "versions": [{"id": "ID", "_rev": "Rev", "crn": "CRN", "version": "Version", "flavor": {"name": "Name", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "index": 5}, "sha": "Sha", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "offering_id": "OfferingID", "catalog_id": "CatalogID", "kind_id": "KindID", "tags": ["Tags"], "repo_url": "RepoURL", "source_url": "SourceURL", "tgz_url": "TgzURL", "configuration": [{"key": "Key", "type": "Type", "default_value": "anyValue", "display_name": "DisplayName", "value_constraint": "ValueConstraint", "description": "Description", "required": true, "options": ["anyValue"], "hidden": true, "custom_config": {"type": "Type", "grouping": "Grouping", "original_grouping": "OriginalGrouping", "grouping_index": 13, "config_constraints": {"anyKey": "anyValue"}, "associations": {"parameters": [{"name": "Name", "optionsRefresh": true}]}}, "type_metadata": "TypeMetadata"}], "outputs": [{"key": "Key", "description": "Description"}], "iam_permissions": [{"service_name": "ServiceName", "role_crns": ["RoleCrns"], "resources": [{"name": "Name", "description": "Description", "role_crns": ["RoleCrns"]}]}], "metadata": {"anyKey": "anyValue"}, "validation": {"validated": "2019-01-01T12:00:00.000Z", "requested": "2019-01-01T12:00:00.000Z", "state": "State", "last_operation": "LastOperation", "target": {"anyKey": "anyValue"}, "message": "Message"}, "required_resources": [{"type": "mem", "value": "anyValue"}], "single_instance": true, "schematics_env_values": {"value": "[{\"name\": \"TF_LOG\",\"value\": \"TRACE\",\"secure\": false,\"hidden\": false}]", "sm_ref": "cmsm_v1:{\"name\": \"envVarSecret\",\"id\":\"1234567890\",\"service_id\":\"crn:v1:bluemix:public:secrets-manager:eu-gb:a/1234567890:1234567890::\",\"service_name\":\"My SM Instance\",\"group_id\":\"1234567890\",\"group_name\":\"My SM Group\",\"resource_group_id\":\"1234567890\",\"region\":\"eu-gb\",\"type\":\"arbitrary\"}"}, "install": {"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}, "pre_install": [{"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}], "scripts": {"mapKey": {"short_description": "ShortDescription", "type": "ansible", "path": "scripts/validate-post-ansible-playbook.yaml", "stage": "pre", "action": "validate"}}, "entitlement": {"provider_name": "ProviderName", "provider_id": "ProviderID", "product_id": "ProductID", "part_numbers": ["PartNumbers"], "image_repo_name": "ImageRepoName"}, "licenses": [{"id": "ID", "name": "Name", "type": "Type", "url": "URL", "description": "Description"}], "image_manifest_url": "ImageManifestURL", "deprecated": true, "package_version": "PackageVersion", "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "version_locator": "VersionLocator", "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "whitelisted_accounts": ["WhitelistedAccounts"], "image_pull_key_name": "ImagePullKeyName", "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "solution_info": {"architecture_diagrams": [{"diagram": {"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "cost_estimate": {"version": "Version", "currency": "Currency", "projects": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "pastBreakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "breakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "diff": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}}], "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}, "totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "pastTotalHourlyCost": "PastTotalHourlyCost", "pastTotalMonthlyCost": "PastTotalMonthlyCost", "diffTotalHourlyCost": "DiffTotalHourlyCost", "diffTotalMonthlyCost": "DiffTotalMonthlyCost", "timeGenerated": "2019-01-01T12:00:00.000Z"}, "dependencies": [{"catalog_id": "CatalogID", "id": "ID", "name": "Name", "kind": "Kind", "version": "Version", "description": "Description", "default_flavor": "DefaultFlavor", "flavors": ["Flavors"], "optional": true, "on_by_default": false}], "install_type": "InstallType"}, "is_consumable": true, "compliance_v3": {"authority": "Authority", "claims": {"profiles": [{"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}], "controls": [{"profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "names": ["Names"]}]}, "evaluations": [{"scan_id": "ScanID", "account_id": "AccountID", "profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "result": {"failure_count": 12, "scan_time": "2019-01-01T12:00:00.000Z", "error_message": "ErrorMessage", "complete_scan": true, "unscanned_resources": ["UnscannedResources"]}, "controls": [{"id": "ID", "name": "Name", "description": "Description", "specifications": [{"id": "ID", "description": "Description", "component_name": "ComponentName", "assessments": [{"id": "ID", "description": "Description", "version": "Version", "type": "Type", "method": "Method", "ui_href": "UIHref"}], "ui_href": "UIHref"}], "failure_count": 12, "pass_count": 9, "parent": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "parent_name": "ParentName", "specifications": [{"id": "ID", "description": "Description", "component_name": "ComponentName", "assessments": [{"id": "ID", "description": "Description", "version": "Version", "type": "Type", "method": "Method", "ui_href": "UIHref"}], "ui_href": "UIHref"}], "ui_href": "UIHref"}, "ui_href": "UIHref"}]}]}, "change_notices": {"breaking": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "new": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "update": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}]}, "plan_ids": ["PlanIds"], "stack": {"anyKey": "anyValue"}, "minimum_compatible_version": "MinimumCompatibleVersion"}]}`)
				}))
			})
			It(`Invoke GetVersions successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the GetVersionsOptions model
				getVersionsOptionsModel := new(catalogmanagementv1.GetVersionsOptions)
				getVersionsOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getVersionsOptionsModel.OfferingID = core.StringPtr("testString")
				getVersionsOptionsModel.KindID = core.StringPtr("testString")
				getVersionsOptionsModel.Digest = core.BoolPtr(true)
				getVersionsOptionsModel.Catalog = core.BoolPtr(true)
				getVersionsOptionsModel.Start = core.StringPtr("testString")
				getVersionsOptionsModel.Limit = core.Int64Ptr(int64(10))
				getVersionsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.GetVersionsWithContext(ctx, getVersionsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.GetVersions(getVersionsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.GetVersionsWithContext(ctx, getVersionsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getVersionsPath))
					Expect(req.Method).To(Equal("GET"))

					// TODO: Add check for digest query parameter
					// TODO: Add check for catalog query parameter
					Expect(req.URL.Query()["start"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(10))}))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"start": "Start", "limit": 5, "total_count": 10, "resource_count": 13, "first": {"href": "Href", "start": "Start"}, "next": {"href": "Href", "start": "Start"}, "prev": {"href": "Href", "start": "Start"}, "last": {"href": "Href", "start": "Start"}, "versions": [{"id": "ID", "_rev": "Rev", "crn": "CRN", "version": "Version", "flavor": {"name": "Name", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "index": 5}, "sha": "Sha", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "offering_id": "OfferingID", "catalog_id": "CatalogID", "kind_id": "KindID", "tags": ["Tags"], "repo_url": "RepoURL", "source_url": "SourceURL", "tgz_url": "TgzURL", "configuration": [{"key": "Key", "type": "Type", "default_value": "anyValue", "display_name": "DisplayName", "value_constraint": "ValueConstraint", "description": "Description", "required": true, "options": ["anyValue"], "hidden": true, "custom_config": {"type": "Type", "grouping": "Grouping", "original_grouping": "OriginalGrouping", "grouping_index": 13, "config_constraints": {"anyKey": "anyValue"}, "associations": {"parameters": [{"name": "Name", "optionsRefresh": true}]}}, "type_metadata": "TypeMetadata"}], "outputs": [{"key": "Key", "description": "Description"}], "iam_permissions": [{"service_name": "ServiceName", "role_crns": ["RoleCrns"], "resources": [{"name": "Name", "description": "Description", "role_crns": ["RoleCrns"]}]}], "metadata": {"anyKey": "anyValue"}, "validation": {"validated": "2019-01-01T12:00:00.000Z", "requested": "2019-01-01T12:00:00.000Z", "state": "State", "last_operation": "LastOperation", "target": {"anyKey": "anyValue"}, "message": "Message"}, "required_resources": [{"type": "mem", "value": "anyValue"}], "single_instance": true, "schematics_env_values": {"value": "[{\"name\": \"TF_LOG\",\"value\": \"TRACE\",\"secure\": false,\"hidden\": false}]", "sm_ref": "cmsm_v1:{\"name\": \"envVarSecret\",\"id\":\"1234567890\",\"service_id\":\"crn:v1:bluemix:public:secrets-manager:eu-gb:a/1234567890:1234567890::\",\"service_name\":\"My SM Instance\",\"group_id\":\"1234567890\",\"group_name\":\"My SM Group\",\"resource_group_id\":\"1234567890\",\"region\":\"eu-gb\",\"type\":\"arbitrary\"}"}, "install": {"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}, "pre_install": [{"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}], "scripts": {"mapKey": {"short_description": "ShortDescription", "type": "ansible", "path": "scripts/validate-post-ansible-playbook.yaml", "stage": "pre", "action": "validate"}}, "entitlement": {"provider_name": "ProviderName", "provider_id": "ProviderID", "product_id": "ProductID", "part_numbers": ["PartNumbers"], "image_repo_name": "ImageRepoName"}, "licenses": [{"id": "ID", "name": "Name", "type": "Type", "url": "URL", "description": "Description"}], "image_manifest_url": "ImageManifestURL", "deprecated": true, "package_version": "PackageVersion", "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "version_locator": "VersionLocator", "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "whitelisted_accounts": ["WhitelistedAccounts"], "image_pull_key_name": "ImagePullKeyName", "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "solution_info": {"architecture_diagrams": [{"diagram": {"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "cost_estimate": {"version": "Version", "currency": "Currency", "projects": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "pastBreakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "breakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "diff": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}}], "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}, "totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "pastTotalHourlyCost": "PastTotalHourlyCost", "pastTotalMonthlyCost": "PastTotalMonthlyCost", "diffTotalHourlyCost": "DiffTotalHourlyCost", "diffTotalMonthlyCost": "DiffTotalMonthlyCost", "timeGenerated": "2019-01-01T12:00:00.000Z"}, "dependencies": [{"catalog_id": "CatalogID", "id": "ID", "name": "Name", "kind": "Kind", "version": "Version", "description": "Description", "default_flavor": "DefaultFlavor", "flavors": ["Flavors"], "optional": true, "on_by_default": false}], "install_type": "InstallType"}, "is_consumable": true, "compliance_v3": {"authority": "Authority", "claims": {"profiles": [{"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}], "controls": [{"profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "names": ["Names"]}]}, "evaluations": [{"scan_id": "ScanID", "account_id": "AccountID", "profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "result": {"failure_count": 12, "scan_time": "2019-01-01T12:00:00.000Z", "error_message": "ErrorMessage", "complete_scan": true, "unscanned_resources": ["UnscannedResources"]}, "controls": [{"id": "ID", "name": "Name", "description": "Description", "specifications": [{"id": "ID", "description": "Description", "component_name": "ComponentName", "assessments": [{"id": "ID", "description": "Description", "version": "Version", "type": "Type", "method": "Method", "ui_href": "UIHref"}], "ui_href": "UIHref"}], "failure_count": 12, "pass_count": 9, "parent": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "parent_name": "ParentName", "specifications": [{"id": "ID", "description": "Description", "component_name": "ComponentName", "assessments": [{"id": "ID", "description": "Description", "version": "Version", "type": "Type", "method": "Method", "ui_href": "UIHref"}], "ui_href": "UIHref"}], "ui_href": "UIHref"}, "ui_href": "UIHref"}]}]}, "change_notices": {"breaking": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "new": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "update": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}]}, "plan_ids": ["PlanIds"], "stack": {"anyKey": "anyValue"}, "minimum_compatible_version": "MinimumCompatibleVersion"}]}`)
				}))
			})
			It(`Invoke GetVersions successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.GetVersions(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetVersionsOptions model
				getVersionsOptionsModel := new(catalogmanagementv1.GetVersionsOptions)
				getVersionsOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getVersionsOptionsModel.OfferingID = core.StringPtr("testString")
				getVersionsOptionsModel.KindID = core.StringPtr("testString")
				getVersionsOptionsModel.Digest = core.BoolPtr(true)
				getVersionsOptionsModel.Catalog = core.BoolPtr(true)
				getVersionsOptionsModel.Start = core.StringPtr("testString")
				getVersionsOptionsModel.Limit = core.Int64Ptr(int64(10))
				getVersionsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.GetVersions(getVersionsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetVersions with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetVersionsOptions model
				getVersionsOptionsModel := new(catalogmanagementv1.GetVersionsOptions)
				getVersionsOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getVersionsOptionsModel.OfferingID = core.StringPtr("testString")
				getVersionsOptionsModel.KindID = core.StringPtr("testString")
				getVersionsOptionsModel.Digest = core.BoolPtr(true)
				getVersionsOptionsModel.Catalog = core.BoolPtr(true)
				getVersionsOptionsModel.Start = core.StringPtr("testString")
				getVersionsOptionsModel.Limit = core.Int64Ptr(int64(10))
				getVersionsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.GetVersions(getVersionsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetVersionsOptions model with no property values
				getVersionsOptionsModelNew := new(catalogmanagementv1.GetVersionsOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.GetVersions(getVersionsOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetVersions successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetVersionsOptions model
				getVersionsOptionsModel := new(catalogmanagementv1.GetVersionsOptions)
				getVersionsOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getVersionsOptionsModel.OfferingID = core.StringPtr("testString")
				getVersionsOptionsModel.KindID = core.StringPtr("testString")
				getVersionsOptionsModel.Digest = core.BoolPtr(true)
				getVersionsOptionsModel.Catalog = core.BoolPtr(true)
				getVersionsOptionsModel.Start = core.StringPtr("testString")
				getVersionsOptionsModel.Limit = core.Int64Ptr(int64(10))
				getVersionsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.GetVersions(getVersionsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Test pagination helper method on response`, func() {
			It(`Invoke GetNextStart successfully`, func() {
				responseObject := new(catalogmanagementv1.VersionsResult)
				nextObject := new(catalogmanagementv1.PaginationTokenLink)
				nextObject.Start = core.StringPtr("abc-123")
				responseObject.Next = nextObject

				value, err := responseObject.GetNextStart()
				Expect(err).To(BeNil())
				Expect(value).To(Equal(core.StringPtr("abc-123")))
			})
			It(`Invoke GetNextStart without a "Next" property in the response`, func() {
				responseObject := new(catalogmanagementv1.VersionsResult)

				value, err := responseObject.GetNextStart()
				Expect(err).To(BeNil())
				Expect(value).To(BeNil())
			})
		})
		Context(`Using mock server endpoint - paginated response`, func() {
			BeforeEach(func() {
				var requestNumber int = 0
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getVersionsPath))
					Expect(req.Method).To(Equal("GET"))

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					requestNumber++
					if requestNumber == 1 {
						fmt.Fprintf(res, "%s", `{"next":{"start":"1"},"versions":[{"id":"ID","_rev":"Rev","crn":"CRN","version":"Version","flavor":{"name":"Name","label":"Label","label_i18n":{"mapKey":"Inner"},"index":5},"sha":"Sha","created":"2019-01-01T12:00:00.000Z","updated":"2019-01-01T12:00:00.000Z","offering_id":"OfferingID","catalog_id":"CatalogID","kind_id":"KindID","tags":["Tags"],"repo_url":"RepoURL","source_url":"SourceURL","tgz_url":"TgzURL","configuration":[{"key":"Key","type":"Type","default_value":"anyValue","display_name":"DisplayName","value_constraint":"ValueConstraint","description":"Description","required":true,"options":["anyValue"],"hidden":true,"custom_config":{"type":"Type","grouping":"Grouping","original_grouping":"OriginalGrouping","grouping_index":13,"config_constraints":{"anyKey":"anyValue"},"associations":{"parameters":[{"name":"Name","optionsRefresh":true}]}},"type_metadata":"TypeMetadata"}],"outputs":[{"key":"Key","description":"Description"}],"iam_permissions":[{"service_name":"ServiceName","role_crns":["RoleCrns"],"resources":[{"name":"Name","description":"Description","role_crns":["RoleCrns"]}]}],"metadata":{"anyKey":"anyValue"},"validation":{"validated":"2019-01-01T12:00:00.000Z","requested":"2019-01-01T12:00:00.000Z","state":"State","last_operation":"LastOperation","target":{"anyKey":"anyValue"},"message":"Message"},"required_resources":[{"type":"mem","value":"anyValue"}],"single_instance":true,"schematics_env_values":{"value":"[{\"name\": \"TF_LOG\",\"value\": \"TRACE\",\"secure\": false,\"hidden\": false}]","sm_ref":"cmsm_v1:{\"name\": \"envVarSecret\",\"id\":\"1234567890\",\"service_id\":\"crn:v1:bluemix:public:secrets-manager:eu-gb:a/1234567890:1234567890::\",\"service_name\":\"My SM Instance\",\"group_id\":\"1234567890\",\"group_name\":\"My SM Group\",\"resource_group_id\":\"1234567890\",\"region\":\"eu-gb\",\"type\":\"arbitrary\"}"},"install":{"instructions":"Instructions","instructions_i18n":{"mapKey":"Inner"},"script":"Script","script_permission":"ScriptPermission","delete_script":"DeleteScript","scope":"Scope"},"pre_install":[{"instructions":"Instructions","instructions_i18n":{"mapKey":"Inner"},"script":"Script","script_permission":"ScriptPermission","delete_script":"DeleteScript","scope":"Scope"}],"scripts":{"mapKey":{"short_description":"ShortDescription","type":"ansible","path":"scripts/validate-post-ansible-playbook.yaml","stage":"pre","action":"validate"}},"entitlement":{"provider_name":"ProviderName","provider_id":"ProviderID","product_id":"ProductID","part_numbers":["PartNumbers"],"image_repo_name":"ImageRepoName"},"licenses":[{"id":"ID","name":"Name","type":"Type","url":"URL","description":"Description"}],"image_manifest_url":"ImageManifestURL","deprecated":true,"package_version":"PackageVersion","state":{"current":"Current","current_entered":"2019-01-01T12:00:00.000Z","pending":"Pending","pending_requested":"2019-01-01T12:00:00.000Z","previous":"Previous"},"version_locator":"VersionLocator","long_description":"LongDescription","long_description_i18n":{"mapKey":"Inner"},"whitelisted_accounts":["WhitelistedAccounts"],"image_pull_key_name":"ImagePullKeyName","deprecate_pending":{"deprecate_date":"2019-01-01T12:00:00.000Z","deprecate_state":"DeprecateState","description":"Description"},"solution_info":{"architecture_diagrams":[{"diagram":{"url":"URL","api_url":"APIURL","url_proxy":{"url":"URL","sha":"Sha"},"caption":"Caption","caption_i18n":{"mapKey":"Inner"},"type":"Type","thumbnail_url":"ThumbnailURL"},"description":"Description","description_i18n":{"mapKey":"Inner"}}],"features":[{"title":"Title","title_i18n":{"mapKey":"Inner"},"description":"Description","description_i18n":{"mapKey":"Inner"}}],"cost_estimate":{"version":"Version","currency":"Currency","projects":[{"name":"Name","metadata":{"anyKey":"anyValue"},"pastBreakdown":{"totalHourlyCost":"TotalHourlyCost","totalMonthlyCost":"TotalMonthlyCost","resources":[{"name":"Name","metadata":{"anyKey":"anyValue"},"hourlyCost":"HourlyCost","monthlyCost":"MonthlyCost","costComponents":[{"name":"Name","unit":"Unit","hourlyQuantity":"HourlyQuantity","monthlyQuantity":"MonthlyQuantity","price":"Price","hourlyCost":"HourlyCost","monthlyCost":"MonthlyCost"}]}]},"breakdown":{"totalHourlyCost":"TotalHourlyCost","totalMonthlyCost":"TotalMonthlyCost","resources":[{"name":"Name","metadata":{"anyKey":"anyValue"},"hourlyCost":"HourlyCost","monthlyCost":"MonthlyCost","costComponents":[{"name":"Name","unit":"Unit","hourlyQuantity":"HourlyQuantity","monthlyQuantity":"MonthlyQuantity","price":"Price","hourlyCost":"HourlyCost","monthlyCost":"MonthlyCost"}]}]},"diff":{"totalHourlyCost":"TotalHourlyCost","totalMonthlyCost":"TotalMonthlyCost","resources":[{"name":"Name","metadata":{"anyKey":"anyValue"},"hourlyCost":"HourlyCost","monthlyCost":"MonthlyCost","costComponents":[{"name":"Name","unit":"Unit","hourlyQuantity":"HourlyQuantity","monthlyQuantity":"MonthlyQuantity","price":"Price","hourlyCost":"HourlyCost","monthlyCost":"MonthlyCost"}]}]},"summary":{"totalDetectedResources":22,"totalSupportedResources":23,"totalUnsupportedResources":25,"totalUsageBasedResources":24,"totalNoPriceResources":21,"unsupportedResourceCounts":{"mapKey":5},"noPriceResourceCounts":{"mapKey":5}}}],"summary":{"totalDetectedResources":22,"totalSupportedResources":23,"totalUnsupportedResources":25,"totalUsageBasedResources":24,"totalNoPriceResources":21,"unsupportedResourceCounts":{"mapKey":5},"noPriceResourceCounts":{"mapKey":5}},"totalHourlyCost":"TotalHourlyCost","totalMonthlyCost":"TotalMonthlyCost","pastTotalHourlyCost":"PastTotalHourlyCost","pastTotalMonthlyCost":"PastTotalMonthlyCost","diffTotalHourlyCost":"DiffTotalHourlyCost","diffTotalMonthlyCost":"DiffTotalMonthlyCost","timeGenerated":"2019-01-01T12:00:00.000Z"},"dependencies":[{"catalog_id":"CatalogID","id":"ID","name":"Name","kind":"Kind","version":"Version","description":"Description","default_flavor":"DefaultFlavor","flavors":["Flavors"],"optional":true,"on_by_default":false}],"install_type":"InstallType"},"is_consumable":true,"compliance_v3":{"authority":"Authority","claims":{"profiles":[{"id":"ID","name":"Name","version":"Version","description":"Description","type":"Type","ui_href":"UIHref"}],"controls":[{"profile":{"id":"ID","name":"Name","version":"Version","description":"Description","type":"Type","ui_href":"UIHref"},"names":["Names"]}]},"evaluations":[{"scan_id":"ScanID","account_id":"AccountID","profile":{"id":"ID","name":"Name","version":"Version","description":"Description","type":"Type","ui_href":"UIHref"},"result":{"failure_count":12,"scan_time":"2019-01-01T12:00:00.000Z","error_message":"ErrorMessage","complete_scan":true,"unscanned_resources":["UnscannedResources"]},"controls":[{"id":"ID","name":"Name","description":"Description","specifications":[{"id":"ID","description":"Description","component_name":"ComponentName","assessments":[{"id":"ID","description":"Description","version":"Version","type":"Type","method":"Method","ui_href":"UIHref"}],"ui_href":"UIHref"}],"failure_count":12,"pass_count":9,"parent":{"id":"ID","name":"Name","version":"Version","description":"Description","profile":{"id":"ID","name":"Name","version":"Version","description":"Description","type":"Type","ui_href":"UIHref"},"parent_name":"ParentName","specifications":[{"id":"ID","description":"Description","component_name":"ComponentName","assessments":[{"id":"ID","description":"Description","version":"Version","type":"Type","method":"Method","ui_href":"UIHref"}],"ui_href":"UIHref"}],"ui_href":"UIHref"},"ui_href":"UIHref"}]}]},"change_notices":{"breaking":[{"title":"Title","title_i18n":{"mapKey":"Inner"},"description":"Description","description_i18n":{"mapKey":"Inner"}}],"new":[{"title":"Title","title_i18n":{"mapKey":"Inner"},"description":"Description","description_i18n":{"mapKey":"Inner"}}],"update":[{"title":"Title","title_i18n":{"mapKey":"Inner"},"description":"Description","description_i18n":{"mapKey":"Inner"}}]},"plan_ids":["PlanIds"],"stack":{"anyKey":"anyValue"},"minimum_compatible_version":"MinimumCompatibleVersion"}],"total_count":2,"limit":1}`)
					} else if requestNumber == 2 {
						fmt.Fprintf(res, "%s", `{"versions":[{"id":"ID","_rev":"Rev","crn":"CRN","version":"Version","flavor":{"name":"Name","label":"Label","label_i18n":{"mapKey":"Inner"},"index":5},"sha":"Sha","created":"2019-01-01T12:00:00.000Z","updated":"2019-01-01T12:00:00.000Z","offering_id":"OfferingID","catalog_id":"CatalogID","kind_id":"KindID","tags":["Tags"],"repo_url":"RepoURL","source_url":"SourceURL","tgz_url":"TgzURL","configuration":[{"key":"Key","type":"Type","default_value":"anyValue","display_name":"DisplayName","value_constraint":"ValueConstraint","description":"Description","required":true,"options":["anyValue"],"hidden":true,"custom_config":{"type":"Type","grouping":"Grouping","original_grouping":"OriginalGrouping","grouping_index":13,"config_constraints":{"anyKey":"anyValue"},"associations":{"parameters":[{"name":"Name","optionsRefresh":true}]}},"type_metadata":"TypeMetadata"}],"outputs":[{"key":"Key","description":"Description"}],"iam_permissions":[{"service_name":"ServiceName","role_crns":["RoleCrns"],"resources":[{"name":"Name","description":"Description","role_crns":["RoleCrns"]}]}],"metadata":{"anyKey":"anyValue"},"validation":{"validated":"2019-01-01T12:00:00.000Z","requested":"2019-01-01T12:00:00.000Z","state":"State","last_operation":"LastOperation","target":{"anyKey":"anyValue"},"message":"Message"},"required_resources":[{"type":"mem","value":"anyValue"}],"single_instance":true,"schematics_env_values":{"value":"[{\"name\": \"TF_LOG\",\"value\": \"TRACE\",\"secure\": false,\"hidden\": false}]","sm_ref":"cmsm_v1:{\"name\": \"envVarSecret\",\"id\":\"1234567890\",\"service_id\":\"crn:v1:bluemix:public:secrets-manager:eu-gb:a/1234567890:1234567890::\",\"service_name\":\"My SM Instance\",\"group_id\":\"1234567890\",\"group_name\":\"My SM Group\",\"resource_group_id\":\"1234567890\",\"region\":\"eu-gb\",\"type\":\"arbitrary\"}"},"install":{"instructions":"Instructions","instructions_i18n":{"mapKey":"Inner"},"script":"Script","script_permission":"ScriptPermission","delete_script":"DeleteScript","scope":"Scope"},"pre_install":[{"instructions":"Instructions","instructions_i18n":{"mapKey":"Inner"},"script":"Script","script_permission":"ScriptPermission","delete_script":"DeleteScript","scope":"Scope"}],"scripts":{"mapKey":{"short_description":"ShortDescription","type":"ansible","path":"scripts/validate-post-ansible-playbook.yaml","stage":"pre","action":"validate"}},"entitlement":{"provider_name":"ProviderName","provider_id":"ProviderID","product_id":"ProductID","part_numbers":["PartNumbers"],"image_repo_name":"ImageRepoName"},"licenses":[{"id":"ID","name":"Name","type":"Type","url":"URL","description":"Description"}],"image_manifest_url":"ImageManifestURL","deprecated":true,"package_version":"PackageVersion","state":{"current":"Current","current_entered":"2019-01-01T12:00:00.000Z","pending":"Pending","pending_requested":"2019-01-01T12:00:00.000Z","previous":"Previous"},"version_locator":"VersionLocator","long_description":"LongDescription","long_description_i18n":{"mapKey":"Inner"},"whitelisted_accounts":["WhitelistedAccounts"],"image_pull_key_name":"ImagePullKeyName","deprecate_pending":{"deprecate_date":"2019-01-01T12:00:00.000Z","deprecate_state":"DeprecateState","description":"Description"},"solution_info":{"architecture_diagrams":[{"diagram":{"url":"URL","api_url":"APIURL","url_proxy":{"url":"URL","sha":"Sha"},"caption":"Caption","caption_i18n":{"mapKey":"Inner"},"type":"Type","thumbnail_url":"ThumbnailURL"},"description":"Description","description_i18n":{"mapKey":"Inner"}}],"features":[{"title":"Title","title_i18n":{"mapKey":"Inner"},"description":"Description","description_i18n":{"mapKey":"Inner"}}],"cost_estimate":{"version":"Version","currency":"Currency","projects":[{"name":"Name","metadata":{"anyKey":"anyValue"},"pastBreakdown":{"totalHourlyCost":"TotalHourlyCost","totalMonthlyCost":"TotalMonthlyCost","resources":[{"name":"Name","metadata":{"anyKey":"anyValue"},"hourlyCost":"HourlyCost","monthlyCost":"MonthlyCost","costComponents":[{"name":"Name","unit":"Unit","hourlyQuantity":"HourlyQuantity","monthlyQuantity":"MonthlyQuantity","price":"Price","hourlyCost":"HourlyCost","monthlyCost":"MonthlyCost"}]}]},"breakdown":{"totalHourlyCost":"TotalHourlyCost","totalMonthlyCost":"TotalMonthlyCost","resources":[{"name":"Name","metadata":{"anyKey":"anyValue"},"hourlyCost":"HourlyCost","monthlyCost":"MonthlyCost","costComponents":[{"name":"Name","unit":"Unit","hourlyQuantity":"HourlyQuantity","monthlyQuantity":"MonthlyQuantity","price":"Price","hourlyCost":"HourlyCost","monthlyCost":"MonthlyCost"}]}]},"diff":{"totalHourlyCost":"TotalHourlyCost","totalMonthlyCost":"TotalMonthlyCost","resources":[{"name":"Name","metadata":{"anyKey":"anyValue"},"hourlyCost":"HourlyCost","monthlyCost":"MonthlyCost","costComponents":[{"name":"Name","unit":"Unit","hourlyQuantity":"HourlyQuantity","monthlyQuantity":"MonthlyQuantity","price":"Price","hourlyCost":"HourlyCost","monthlyCost":"MonthlyCost"}]}]},"summary":{"totalDetectedResources":22,"totalSupportedResources":23,"totalUnsupportedResources":25,"totalUsageBasedResources":24,"totalNoPriceResources":21,"unsupportedResourceCounts":{"mapKey":5},"noPriceResourceCounts":{"mapKey":5}}}],"summary":{"totalDetectedResources":22,"totalSupportedResources":23,"totalUnsupportedResources":25,"totalUsageBasedResources":24,"totalNoPriceResources":21,"unsupportedResourceCounts":{"mapKey":5},"noPriceResourceCounts":{"mapKey":5}},"totalHourlyCost":"TotalHourlyCost","totalMonthlyCost":"TotalMonthlyCost","pastTotalHourlyCost":"PastTotalHourlyCost","pastTotalMonthlyCost":"PastTotalMonthlyCost","diffTotalHourlyCost":"DiffTotalHourlyCost","diffTotalMonthlyCost":"DiffTotalMonthlyCost","timeGenerated":"2019-01-01T12:00:00.000Z"},"dependencies":[{"catalog_id":"CatalogID","id":"ID","name":"Name","kind":"Kind","version":"Version","description":"Description","default_flavor":"DefaultFlavor","flavors":["Flavors"],"optional":true,"on_by_default":false}],"install_type":"InstallType"},"is_consumable":true,"compliance_v3":{"authority":"Authority","claims":{"profiles":[{"id":"ID","name":"Name","version":"Version","description":"Description","type":"Type","ui_href":"UIHref"}],"controls":[{"profile":{"id":"ID","name":"Name","version":"Version","description":"Description","type":"Type","ui_href":"UIHref"},"names":["Names"]}]},"evaluations":[{"scan_id":"ScanID","account_id":"AccountID","profile":{"id":"ID","name":"Name","version":"Version","description":"Description","type":"Type","ui_href":"UIHref"},"result":{"failure_count":12,"scan_time":"2019-01-01T12:00:00.000Z","error_message":"ErrorMessage","complete_scan":true,"unscanned_resources":["UnscannedResources"]},"controls":[{"id":"ID","name":"Name","description":"Description","specifications":[{"id":"ID","description":"Description","component_name":"ComponentName","assessments":[{"id":"ID","description":"Description","version":"Version","type":"Type","method":"Method","ui_href":"UIHref"}],"ui_href":"UIHref"}],"failure_count":12,"pass_count":9,"parent":{"id":"ID","name":"Name","version":"Version","description":"Description","profile":{"id":"ID","name":"Name","version":"Version","description":"Description","type":"Type","ui_href":"UIHref"},"parent_name":"ParentName","specifications":[{"id":"ID","description":"Description","component_name":"ComponentName","assessments":[{"id":"ID","description":"Description","version":"Version","type":"Type","method":"Method","ui_href":"UIHref"}],"ui_href":"UIHref"}],"ui_href":"UIHref"},"ui_href":"UIHref"}]}]},"change_notices":{"breaking":[{"title":"Title","title_i18n":{"mapKey":"Inner"},"description":"Description","description_i18n":{"mapKey":"Inner"}}],"new":[{"title":"Title","title_i18n":{"mapKey":"Inner"},"description":"Description","description_i18n":{"mapKey":"Inner"}}],"update":[{"title":"Title","title_i18n":{"mapKey":"Inner"},"description":"Description","description_i18n":{"mapKey":"Inner"}}]},"plan_ids":["PlanIds"],"stack":{"anyKey":"anyValue"},"minimum_compatible_version":"MinimumCompatibleVersion"}],"total_count":2,"limit":1}`)
					} else {
						res.WriteHeader(400)
					}
				}))
			})
			It(`Use GetVersionsPager.GetNext successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				getVersionsOptionsModel := &catalogmanagementv1.GetVersionsOptions{
					CatalogIdentifier: core.StringPtr("testString"),
					OfferingID:        core.StringPtr("testString"),
					KindID:            core.StringPtr("testString"),
					Digest:            core.BoolPtr(true),
					Catalog:           core.BoolPtr(true),
					Limit:             core.Int64Ptr(int64(10)),
				}

				pager, err := catalogManagementService.NewGetVersionsPager(getVersionsOptionsModel)
				Expect(err).To(BeNil())
				Expect(pager).ToNot(BeNil())

				var allResults []catalogmanagementv1.Version
				for pager.HasNext() {
					nextPage, err := pager.GetNext()
					Expect(err).To(BeNil())
					Expect(nextPage).ToNot(BeNil())
					allResults = append(allResults, nextPage...)
				}
				Expect(len(allResults)).To(Equal(2))
			})
			It(`Use GetVersionsPager.GetAll successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				getVersionsOptionsModel := &catalogmanagementv1.GetVersionsOptions{
					CatalogIdentifier: core.StringPtr("testString"),
					OfferingID:        core.StringPtr("testString"),
					KindID:            core.StringPtr("testString"),
					Digest:            core.BoolPtr(true),
					Catalog:           core.BoolPtr(true),
					Limit:             core.Int64Ptr(int64(10)),
				}

				pager, err := catalogManagementService.NewGetVersionsPager(getVersionsOptionsModel)
				Expect(err).To(BeNil())
				Expect(pager).ToNot(BeNil())

				allResults, err := pager.GetAll()
				Expect(err).To(BeNil())
				Expect(allResults).ToNot(BeNil())
				Expect(len(allResults)).To(Equal(2))
			})
		})
	})
	Describe(`GetOfferingAbout(getOfferingAboutOptions *GetOfferingAboutOptions)`, func() {
		getOfferingAboutPath := "/versions/testString/about"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingAboutPath))
					Expect(req.Method).To(Equal("GET"))

					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "text/markdown")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `"OperationResponse"`)
				}))
			})
			It(`Invoke GetOfferingAbout successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the GetOfferingAboutOptions model
				getOfferingAboutOptionsModel := new(catalogmanagementv1.GetOfferingAboutOptions)
				getOfferingAboutOptionsModel.VersionLocID = core.StringPtr("testString")
				getOfferingAboutOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.GetOfferingAboutWithContext(ctx, getOfferingAboutOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.GetOfferingAbout(getOfferingAboutOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.GetOfferingAboutWithContext(ctx, getOfferingAboutOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingAboutPath))
					Expect(req.Method).To(Equal("GET"))

					// Set mock response
					res.Header().Set("Content-type", "text/markdown")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `"OperationResponse"`)
				}))
			})
			It(`Invoke GetOfferingAbout successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.GetOfferingAbout(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetOfferingAboutOptions model
				getOfferingAboutOptionsModel := new(catalogmanagementv1.GetOfferingAboutOptions)
				getOfferingAboutOptionsModel.VersionLocID = core.StringPtr("testString")
				getOfferingAboutOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.GetOfferingAbout(getOfferingAboutOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetOfferingAbout with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOfferingAboutOptions model
				getOfferingAboutOptionsModel := new(catalogmanagementv1.GetOfferingAboutOptions)
				getOfferingAboutOptionsModel.VersionLocID = core.StringPtr("testString")
				getOfferingAboutOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.GetOfferingAbout(getOfferingAboutOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetOfferingAboutOptions model with no property values
				getOfferingAboutOptionsModelNew := new(catalogmanagementv1.GetOfferingAboutOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.GetOfferingAbout(getOfferingAboutOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetOfferingAbout successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOfferingAboutOptions model
				getOfferingAboutOptionsModel := new(catalogmanagementv1.GetOfferingAboutOptions)
				getOfferingAboutOptionsModel.VersionLocID = core.StringPtr("testString")
				getOfferingAboutOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.GetOfferingAbout(getOfferingAboutOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetIamPermissions(getIamPermissionsOptions *GetIamPermissionsOptions) - Operation response error`, func() {
		getIamPermissionsPath := "/versions/testString/iamPermissions"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getIamPermissionsPath))
					Expect(req.Method).To(Equal("GET"))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetIamPermissions with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetIamPermissionsOptions model
				getIamPermissionsOptionsModel := new(catalogmanagementv1.GetIamPermissionsOptions)
				getIamPermissionsOptionsModel.VersionLocID = core.StringPtr("testString")
				getIamPermissionsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.GetIamPermissions(getIamPermissionsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.GetIamPermissions(getIamPermissionsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetIamPermissions(getIamPermissionsOptions *GetIamPermissionsOptions)`, func() {
		getIamPermissionsPath := "/versions/testString/iamPermissions"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getIamPermissionsPath))
					Expect(req.Method).To(Equal("GET"))

					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `[{"service_name": "ServiceName", "service_display_name": "ServiceDisplayName", "role_crns": [{"id": "ID", "display_name": "DisplayName", "description": "Description", "has_permissions": true}], "resources": [{"name": "Name", "description": "Description", "role_crns": ["RoleCrns"]}]}]`)
				}))
			})
			It(`Invoke GetIamPermissions successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the GetIamPermissionsOptions model
				getIamPermissionsOptionsModel := new(catalogmanagementv1.GetIamPermissionsOptions)
				getIamPermissionsOptionsModel.VersionLocID = core.StringPtr("testString")
				getIamPermissionsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.GetIamPermissionsWithContext(ctx, getIamPermissionsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.GetIamPermissions(getIamPermissionsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.GetIamPermissionsWithContext(ctx, getIamPermissionsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getIamPermissionsPath))
					Expect(req.Method).To(Equal("GET"))

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `[{"service_name": "ServiceName", "service_display_name": "ServiceDisplayName", "role_crns": [{"id": "ID", "display_name": "DisplayName", "description": "Description", "has_permissions": true}], "resources": [{"name": "Name", "description": "Description", "role_crns": ["RoleCrns"]}]}]`)
				}))
			})
			It(`Invoke GetIamPermissions successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.GetIamPermissions(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetIamPermissionsOptions model
				getIamPermissionsOptionsModel := new(catalogmanagementv1.GetIamPermissionsOptions)
				getIamPermissionsOptionsModel.VersionLocID = core.StringPtr("testString")
				getIamPermissionsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.GetIamPermissions(getIamPermissionsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetIamPermissions with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetIamPermissionsOptions model
				getIamPermissionsOptionsModel := new(catalogmanagementv1.GetIamPermissionsOptions)
				getIamPermissionsOptionsModel.VersionLocID = core.StringPtr("testString")
				getIamPermissionsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.GetIamPermissions(getIamPermissionsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetIamPermissionsOptions model with no property values
				getIamPermissionsOptionsModelNew := new(catalogmanagementv1.GetIamPermissionsOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.GetIamPermissions(getIamPermissionsOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetIamPermissions successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetIamPermissionsOptions model
				getIamPermissionsOptionsModel := new(catalogmanagementv1.GetIamPermissionsOptions)
				getIamPermissionsOptionsModel.VersionLocID = core.StringPtr("testString")
				getIamPermissionsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.GetIamPermissions(getIamPermissionsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetOfferingLicense(getOfferingLicenseOptions *GetOfferingLicenseOptions)`, func() {
		getOfferingLicensePath := "/versions/testString/licenses/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingLicensePath))
					Expect(req.Method).To(Equal("GET"))

					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "text/plain")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `"OperationResponse"`)
				}))
			})
			It(`Invoke GetOfferingLicense successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the GetOfferingLicenseOptions model
				getOfferingLicenseOptionsModel := new(catalogmanagementv1.GetOfferingLicenseOptions)
				getOfferingLicenseOptionsModel.VersionLocID = core.StringPtr("testString")
				getOfferingLicenseOptionsModel.LicenseID = core.StringPtr("testString")
				getOfferingLicenseOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.GetOfferingLicenseWithContext(ctx, getOfferingLicenseOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.GetOfferingLicense(getOfferingLicenseOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.GetOfferingLicenseWithContext(ctx, getOfferingLicenseOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingLicensePath))
					Expect(req.Method).To(Equal("GET"))

					// Set mock response
					res.Header().Set("Content-type", "text/plain")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `"OperationResponse"`)
				}))
			})
			It(`Invoke GetOfferingLicense successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.GetOfferingLicense(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetOfferingLicenseOptions model
				getOfferingLicenseOptionsModel := new(catalogmanagementv1.GetOfferingLicenseOptions)
				getOfferingLicenseOptionsModel.VersionLocID = core.StringPtr("testString")
				getOfferingLicenseOptionsModel.LicenseID = core.StringPtr("testString")
				getOfferingLicenseOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.GetOfferingLicense(getOfferingLicenseOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetOfferingLicense with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOfferingLicenseOptions model
				getOfferingLicenseOptionsModel := new(catalogmanagementv1.GetOfferingLicenseOptions)
				getOfferingLicenseOptionsModel.VersionLocID = core.StringPtr("testString")
				getOfferingLicenseOptionsModel.LicenseID = core.StringPtr("testString")
				getOfferingLicenseOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.GetOfferingLicense(getOfferingLicenseOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetOfferingLicenseOptions model with no property values
				getOfferingLicenseOptionsModelNew := new(catalogmanagementv1.GetOfferingLicenseOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.GetOfferingLicense(getOfferingLicenseOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetOfferingLicense successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOfferingLicenseOptions model
				getOfferingLicenseOptionsModel := new(catalogmanagementv1.GetOfferingLicenseOptions)
				getOfferingLicenseOptionsModel.VersionLocID = core.StringPtr("testString")
				getOfferingLicenseOptionsModel.LicenseID = core.StringPtr("testString")
				getOfferingLicenseOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.GetOfferingLicense(getOfferingLicenseOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetOfferingContainerImages(getOfferingContainerImagesOptions *GetOfferingContainerImagesOptions) - Operation response error`, func() {
		getOfferingContainerImagesPath := "/versions/testString/containerImages"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingContainerImagesPath))
					Expect(req.Method).To(Equal("GET"))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetOfferingContainerImages with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOfferingContainerImagesOptions model
				getOfferingContainerImagesOptionsModel := new(catalogmanagementv1.GetOfferingContainerImagesOptions)
				getOfferingContainerImagesOptionsModel.VersionLocID = core.StringPtr("testString")
				getOfferingContainerImagesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.GetOfferingContainerImages(getOfferingContainerImagesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.GetOfferingContainerImages(getOfferingContainerImagesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetOfferingContainerImages(getOfferingContainerImagesOptions *GetOfferingContainerImagesOptions)`, func() {
		getOfferingContainerImagesPath := "/versions/testString/containerImages"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingContainerImagesPath))
					Expect(req.Method).To(Equal("GET"))

					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"description": "Description", "images": [{"image": "Image"}]}`)
				}))
			})
			It(`Invoke GetOfferingContainerImages successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the GetOfferingContainerImagesOptions model
				getOfferingContainerImagesOptionsModel := new(catalogmanagementv1.GetOfferingContainerImagesOptions)
				getOfferingContainerImagesOptionsModel.VersionLocID = core.StringPtr("testString")
				getOfferingContainerImagesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.GetOfferingContainerImagesWithContext(ctx, getOfferingContainerImagesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.GetOfferingContainerImages(getOfferingContainerImagesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.GetOfferingContainerImagesWithContext(ctx, getOfferingContainerImagesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingContainerImagesPath))
					Expect(req.Method).To(Equal("GET"))

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"description": "Description", "images": [{"image": "Image"}]}`)
				}))
			})
			It(`Invoke GetOfferingContainerImages successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.GetOfferingContainerImages(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetOfferingContainerImagesOptions model
				getOfferingContainerImagesOptionsModel := new(catalogmanagementv1.GetOfferingContainerImagesOptions)
				getOfferingContainerImagesOptionsModel.VersionLocID = core.StringPtr("testString")
				getOfferingContainerImagesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.GetOfferingContainerImages(getOfferingContainerImagesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetOfferingContainerImages with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOfferingContainerImagesOptions model
				getOfferingContainerImagesOptionsModel := new(catalogmanagementv1.GetOfferingContainerImagesOptions)
				getOfferingContainerImagesOptionsModel.VersionLocID = core.StringPtr("testString")
				getOfferingContainerImagesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.GetOfferingContainerImages(getOfferingContainerImagesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetOfferingContainerImagesOptions model with no property values
				getOfferingContainerImagesOptionsModelNew := new(catalogmanagementv1.GetOfferingContainerImagesOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.GetOfferingContainerImages(getOfferingContainerImagesOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetOfferingContainerImages successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOfferingContainerImagesOptions model
				getOfferingContainerImagesOptionsModel := new(catalogmanagementv1.GetOfferingContainerImagesOptions)
				getOfferingContainerImagesOptionsModel.VersionLocID = core.StringPtr("testString")
				getOfferingContainerImagesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.GetOfferingContainerImages(getOfferingContainerImagesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ArchiveVersion(archiveVersionOptions *ArchiveVersionOptions)`, func() {
		archiveVersionPath := "/versions/testString/archive"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(archiveVersionPath))
					Expect(req.Method).To(Equal("POST"))

					res.WriteHeader(202)
				}))
			})
			It(`Invoke ArchiveVersion successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := catalogManagementService.ArchiveVersion(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the ArchiveVersionOptions model
				archiveVersionOptionsModel := new(catalogmanagementv1.ArchiveVersionOptions)
				archiveVersionOptionsModel.VersionLocID = core.StringPtr("testString")
				archiveVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = catalogManagementService.ArchiveVersion(archiveVersionOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke ArchiveVersion with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ArchiveVersionOptions model
				archiveVersionOptionsModel := new(catalogmanagementv1.ArchiveVersionOptions)
				archiveVersionOptionsModel.VersionLocID = core.StringPtr("testString")
				archiveVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := catalogManagementService.ArchiveVersion(archiveVersionOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the ArchiveVersionOptions model with no property values
				archiveVersionOptionsModelNew := new(catalogmanagementv1.ArchiveVersionOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = catalogManagementService.ArchiveVersion(archiveVersionOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`SetDeprecateVersion(setDeprecateVersionOptions *SetDeprecateVersionOptions)`, func() {
		setDeprecateVersionPath := "/versions/testString/deprecate/true"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(setDeprecateVersionPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					res.WriteHeader(202)
				}))
			})
			It(`Invoke SetDeprecateVersion successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := catalogManagementService.SetDeprecateVersion(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the SetDeprecateVersionOptions model
				setDeprecateVersionOptionsModel := new(catalogmanagementv1.SetDeprecateVersionOptions)
				setDeprecateVersionOptionsModel.VersionLocID = core.StringPtr("testString")
				setDeprecateVersionOptionsModel.Setting = core.StringPtr("true")
				setDeprecateVersionOptionsModel.Description = core.StringPtr("testString")
				setDeprecateVersionOptionsModel.DaysUntilDeprecate = core.Int64Ptr(int64(38))
				setDeprecateVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = catalogManagementService.SetDeprecateVersion(setDeprecateVersionOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke SetDeprecateVersion with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the SetDeprecateVersionOptions model
				setDeprecateVersionOptionsModel := new(catalogmanagementv1.SetDeprecateVersionOptions)
				setDeprecateVersionOptionsModel.VersionLocID = core.StringPtr("testString")
				setDeprecateVersionOptionsModel.Setting = core.StringPtr("true")
				setDeprecateVersionOptionsModel.Description = core.StringPtr("testString")
				setDeprecateVersionOptionsModel.DaysUntilDeprecate = core.Int64Ptr(int64(38))
				setDeprecateVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := catalogManagementService.SetDeprecateVersion(setDeprecateVersionOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the SetDeprecateVersionOptions model with no property values
				setDeprecateVersionOptionsModelNew := new(catalogmanagementv1.SetDeprecateVersionOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = catalogManagementService.SetDeprecateVersion(setDeprecateVersionOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ConsumableVersion(consumableVersionOptions *ConsumableVersionOptions)`, func() {
		consumableVersionPath := "/versions/testString/consume-publish"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(consumableVersionPath))
					Expect(req.Method).To(Equal("POST"))

					res.WriteHeader(202)
				}))
			})
			It(`Invoke ConsumableVersion successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := catalogManagementService.ConsumableVersion(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the ConsumableVersionOptions model
				consumableVersionOptionsModel := new(catalogmanagementv1.ConsumableVersionOptions)
				consumableVersionOptionsModel.VersionLocID = core.StringPtr("testString")
				consumableVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = catalogManagementService.ConsumableVersion(consumableVersionOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke ConsumableVersion with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ConsumableVersionOptions model
				consumableVersionOptionsModel := new(catalogmanagementv1.ConsumableVersionOptions)
				consumableVersionOptionsModel.VersionLocID = core.StringPtr("testString")
				consumableVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := catalogManagementService.ConsumableVersion(consumableVersionOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the ConsumableVersionOptions model with no property values
				consumableVersionOptionsModelNew := new(catalogmanagementv1.ConsumableVersionOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = catalogManagementService.ConsumableVersion(consumableVersionOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`PrereleaseVersion(prereleaseVersionOptions *PrereleaseVersionOptions)`, func() {
		prereleaseVersionPath := "/versions/testString/prerelease-publish"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(prereleaseVersionPath))
					Expect(req.Method).To(Equal("POST"))

					res.WriteHeader(202)
				}))
			})
			It(`Invoke PrereleaseVersion successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := catalogManagementService.PrereleaseVersion(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the PrereleaseVersionOptions model
				prereleaseVersionOptionsModel := new(catalogmanagementv1.PrereleaseVersionOptions)
				prereleaseVersionOptionsModel.VersionLocID = core.StringPtr("testString")
				prereleaseVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = catalogManagementService.PrereleaseVersion(prereleaseVersionOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke PrereleaseVersion with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the PrereleaseVersionOptions model
				prereleaseVersionOptionsModel := new(catalogmanagementv1.PrereleaseVersionOptions)
				prereleaseVersionOptionsModel.VersionLocID = core.StringPtr("testString")
				prereleaseVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := catalogManagementService.PrereleaseVersion(prereleaseVersionOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the PrereleaseVersionOptions model with no property values
				prereleaseVersionOptionsModelNew := new(catalogmanagementv1.PrereleaseVersionOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = catalogManagementService.PrereleaseVersion(prereleaseVersionOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`TestVersion(testVersionOptions *TestVersionOptions)`, func() {
		testVersionPath := "/versions/testString/test-publish"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(testVersionPath))
					Expect(req.Method).To(Equal("POST"))

					res.WriteHeader(202)
				}))
			})
			It(`Invoke TestVersion successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := catalogManagementService.TestVersion(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the TestVersionOptions model
				testVersionOptionsModel := new(catalogmanagementv1.TestVersionOptions)
				testVersionOptionsModel.VersionLocID = core.StringPtr("testString")
				testVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = catalogManagementService.TestVersion(testVersionOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke TestVersion with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the TestVersionOptions model
				testVersionOptionsModel := new(catalogmanagementv1.TestVersionOptions)
				testVersionOptionsModel.VersionLocID = core.StringPtr("testString")
				testVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := catalogManagementService.TestVersion(testVersionOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the TestVersionOptions model with no property values
				testVersionOptionsModelNew := new(catalogmanagementv1.TestVersionOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = catalogManagementService.TestVersion(testVersionOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`SuspendVersion(suspendVersionOptions *SuspendVersionOptions)`, func() {
		suspendVersionPath := "/versions/testString/suspend"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(suspendVersionPath))
					Expect(req.Method).To(Equal("POST"))

					res.WriteHeader(202)
				}))
			})
			It(`Invoke SuspendVersion successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := catalogManagementService.SuspendVersion(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the SuspendVersionOptions model
				suspendVersionOptionsModel := new(catalogmanagementv1.SuspendVersionOptions)
				suspendVersionOptionsModel.VersionLocID = core.StringPtr("testString")
				suspendVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = catalogManagementService.SuspendVersion(suspendVersionOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke SuspendVersion with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the SuspendVersionOptions model
				suspendVersionOptionsModel := new(catalogmanagementv1.SuspendVersionOptions)
				suspendVersionOptionsModel.VersionLocID = core.StringPtr("testString")
				suspendVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := catalogManagementService.SuspendVersion(suspendVersionOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the SuspendVersionOptions model with no property values
				suspendVersionOptionsModelNew := new(catalogmanagementv1.SuspendVersionOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = catalogManagementService.SuspendVersion(suspendVersionOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CommitVersion(commitVersionOptions *CommitVersionOptions)`, func() {
		commitVersionPath := "/versions/testString/commit"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(commitVersionPath))
					Expect(req.Method).To(Equal("POST"))

					res.WriteHeader(200)
				}))
			})
			It(`Invoke CommitVersion successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := catalogManagementService.CommitVersion(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the CommitVersionOptions model
				commitVersionOptionsModel := new(catalogmanagementv1.CommitVersionOptions)
				commitVersionOptionsModel.VersionLocID = core.StringPtr("testString")
				commitVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = catalogManagementService.CommitVersion(commitVersionOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke CommitVersion with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the CommitVersionOptions model
				commitVersionOptionsModel := new(catalogmanagementv1.CommitVersionOptions)
				commitVersionOptionsModel.VersionLocID = core.StringPtr("testString")
				commitVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := catalogManagementService.CommitVersion(commitVersionOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the CommitVersionOptions model with no property values
				commitVersionOptionsModelNew := new(catalogmanagementv1.CommitVersionOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = catalogManagementService.CommitVersion(commitVersionOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CopyVersion(copyVersionOptions *CopyVersionOptions)`, func() {
		copyVersionPath := "/versions/testString/copy"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(copyVersionPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					res.WriteHeader(200)
				}))
			})
			It(`Invoke CopyVersion successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := catalogManagementService.CopyVersion(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the Flavor model
				flavorModel := new(catalogmanagementv1.Flavor)
				flavorModel.Name = core.StringPtr("testString")
				flavorModel.Label = core.StringPtr("testString")
				flavorModel.LabelI18n = map[string]string{"key1": "testString"}
				flavorModel.Index = core.Int64Ptr(int64(38))

				// Construct an instance of the CopyVersionOptions model
				copyVersionOptionsModel := new(catalogmanagementv1.CopyVersionOptions)
				copyVersionOptionsModel.VersionLocID = core.StringPtr("testString")
				copyVersionOptionsModel.Tags = []string{"testString"}
				copyVersionOptionsModel.Content = CreateMockByteArray("VGhpcyBpcyBhIG1vY2sgYnl0ZSBhcnJheSB2YWx1ZS4=")
				copyVersionOptionsModel.TargetKinds = []string{"testString"}
				copyVersionOptionsModel.FormatKind = core.StringPtr("testString")
				copyVersionOptionsModel.Flavor = flavorModel
				copyVersionOptionsModel.WorkingDirectory = core.StringPtr("testString")
				copyVersionOptionsModel.InstallType = core.StringPtr("testString")
				copyVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = catalogManagementService.CopyVersion(copyVersionOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke CopyVersion with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the Flavor model
				flavorModel := new(catalogmanagementv1.Flavor)
				flavorModel.Name = core.StringPtr("testString")
				flavorModel.Label = core.StringPtr("testString")
				flavorModel.LabelI18n = map[string]string{"key1": "testString"}
				flavorModel.Index = core.Int64Ptr(int64(38))

				// Construct an instance of the CopyVersionOptions model
				copyVersionOptionsModel := new(catalogmanagementv1.CopyVersionOptions)
				copyVersionOptionsModel.VersionLocID = core.StringPtr("testString")
				copyVersionOptionsModel.Tags = []string{"testString"}
				copyVersionOptionsModel.Content = CreateMockByteArray("VGhpcyBpcyBhIG1vY2sgYnl0ZSBhcnJheSB2YWx1ZS4=")
				copyVersionOptionsModel.TargetKinds = []string{"testString"}
				copyVersionOptionsModel.FormatKind = core.StringPtr("testString")
				copyVersionOptionsModel.Flavor = flavorModel
				copyVersionOptionsModel.WorkingDirectory = core.StringPtr("testString")
				copyVersionOptionsModel.InstallType = core.StringPtr("testString")
				copyVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := catalogManagementService.CopyVersion(copyVersionOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the CopyVersionOptions model with no property values
				copyVersionOptionsModelNew := new(catalogmanagementv1.CopyVersionOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = catalogManagementService.CopyVersion(copyVersionOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetOfferingWorkingCopy(getOfferingWorkingCopyOptions *GetOfferingWorkingCopyOptions) - Operation response error`, func() {
		getOfferingWorkingCopyPath := "/versions/testString/workingcopy"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingWorkingCopyPath))
					Expect(req.Method).To(Equal("POST"))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetOfferingWorkingCopy with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOfferingWorkingCopyOptions model
				getOfferingWorkingCopyOptionsModel := new(catalogmanagementv1.GetOfferingWorkingCopyOptions)
				getOfferingWorkingCopyOptionsModel.VersionLocID = core.StringPtr("testString")
				getOfferingWorkingCopyOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.GetOfferingWorkingCopy(getOfferingWorkingCopyOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.GetOfferingWorkingCopy(getOfferingWorkingCopyOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetOfferingWorkingCopy(getOfferingWorkingCopyOptions *GetOfferingWorkingCopyOptions)`, func() {
		getOfferingWorkingCopyPath := "/versions/testString/workingcopy"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingWorkingCopyPath))
					Expect(req.Method).To(Equal("POST"))

					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "crn": "CRN", "version": "Version", "flavor": {"name": "Name", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "index": 5}, "sha": "Sha", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "offering_id": "OfferingID", "catalog_id": "CatalogID", "kind_id": "KindID", "tags": ["Tags"], "repo_url": "RepoURL", "source_url": "SourceURL", "tgz_url": "TgzURL", "configuration": [{"key": "Key", "type": "Type", "default_value": "anyValue", "display_name": "DisplayName", "value_constraint": "ValueConstraint", "description": "Description", "required": true, "options": ["anyValue"], "hidden": true, "custom_config": {"type": "Type", "grouping": "Grouping", "original_grouping": "OriginalGrouping", "grouping_index": 13, "config_constraints": {"anyKey": "anyValue"}, "associations": {"parameters": [{"name": "Name", "optionsRefresh": true}]}}, "type_metadata": "TypeMetadata"}], "outputs": [{"key": "Key", "description": "Description"}], "iam_permissions": [{"service_name": "ServiceName", "role_crns": ["RoleCrns"], "resources": [{"name": "Name", "description": "Description", "role_crns": ["RoleCrns"]}]}], "metadata": {"anyKey": "anyValue"}, "validation": {"validated": "2019-01-01T12:00:00.000Z", "requested": "2019-01-01T12:00:00.000Z", "state": "State", "last_operation": "LastOperation", "target": {"anyKey": "anyValue"}, "message": "Message"}, "required_resources": [{"type": "mem", "value": "anyValue"}], "single_instance": true, "schematics_env_values": {"value": "[{\"name\": \"TF_LOG\",\"value\": \"TRACE\",\"secure\": false,\"hidden\": false}]", "sm_ref": "cmsm_v1:{\"name\": \"envVarSecret\",\"id\":\"1234567890\",\"service_id\":\"crn:v1:bluemix:public:secrets-manager:eu-gb:a/1234567890:1234567890::\",\"service_name\":\"My SM Instance\",\"group_id\":\"1234567890\",\"group_name\":\"My SM Group\",\"resource_group_id\":\"1234567890\",\"region\":\"eu-gb\",\"type\":\"arbitrary\"}"}, "install": {"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}, "pre_install": [{"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}], "scripts": {"mapKey": {"short_description": "ShortDescription", "type": "ansible", "path": "scripts/validate-post-ansible-playbook.yaml", "stage": "pre", "action": "validate"}}, "entitlement": {"provider_name": "ProviderName", "provider_id": "ProviderID", "product_id": "ProductID", "part_numbers": ["PartNumbers"], "image_repo_name": "ImageRepoName"}, "licenses": [{"id": "ID", "name": "Name", "type": "Type", "url": "URL", "description": "Description"}], "image_manifest_url": "ImageManifestURL", "deprecated": true, "package_version": "PackageVersion", "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "version_locator": "VersionLocator", "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "whitelisted_accounts": ["WhitelistedAccounts"], "image_pull_key_name": "ImagePullKeyName", "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "solution_info": {"architecture_diagrams": [{"diagram": {"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "cost_estimate": {"version": "Version", "currency": "Currency", "projects": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "pastBreakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "breakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "diff": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}}], "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}, "totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "pastTotalHourlyCost": "PastTotalHourlyCost", "pastTotalMonthlyCost": "PastTotalMonthlyCost", "diffTotalHourlyCost": "DiffTotalHourlyCost", "diffTotalMonthlyCost": "DiffTotalMonthlyCost", "timeGenerated": "2019-01-01T12:00:00.000Z"}, "dependencies": [{"catalog_id": "CatalogID", "id": "ID", "name": "Name", "kind": "Kind", "version": "Version", "description": "Description", "default_flavor": "DefaultFlavor", "flavors": ["Flavors"], "optional": true, "on_by_default": false}], "install_type": "InstallType"}, "is_consumable": true, "compliance_v3": {"authority": "Authority", "claims": {"profiles": [{"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}], "controls": [{"profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "names": ["Names"]}]}, "evaluations": [{"scan_id": "ScanID", "account_id": "AccountID", "profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "result": {"failure_count": 12, "scan_time": "2019-01-01T12:00:00.000Z", "error_message": "ErrorMessage", "complete_scan": true, "unscanned_resources": ["UnscannedResources"]}, "controls": [{"id": "ID", "name": "Name", "description": "Description", "specifications": [{"id": "ID", "description": "Description", "component_name": "ComponentName", "assessments": [{"id": "ID", "description": "Description", "version": "Version", "type": "Type", "method": "Method", "ui_href": "UIHref"}], "ui_href": "UIHref"}], "failure_count": 12, "pass_count": 9, "parent": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "parent_name": "ParentName", "specifications": [{"id": "ID", "description": "Description", "component_name": "ComponentName", "assessments": [{"id": "ID", "description": "Description", "version": "Version", "type": "Type", "method": "Method", "ui_href": "UIHref"}], "ui_href": "UIHref"}], "ui_href": "UIHref"}, "ui_href": "UIHref"}]}]}, "change_notices": {"breaking": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "new": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "update": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}]}, "plan_ids": ["PlanIds"], "stack": {"anyKey": "anyValue"}, "minimum_compatible_version": "MinimumCompatibleVersion"}`)
				}))
			})
			It(`Invoke GetOfferingWorkingCopy successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the GetOfferingWorkingCopyOptions model
				getOfferingWorkingCopyOptionsModel := new(catalogmanagementv1.GetOfferingWorkingCopyOptions)
				getOfferingWorkingCopyOptionsModel.VersionLocID = core.StringPtr("testString")
				getOfferingWorkingCopyOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.GetOfferingWorkingCopyWithContext(ctx, getOfferingWorkingCopyOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.GetOfferingWorkingCopy(getOfferingWorkingCopyOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.GetOfferingWorkingCopyWithContext(ctx, getOfferingWorkingCopyOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingWorkingCopyPath))
					Expect(req.Method).To(Equal("POST"))

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "crn": "CRN", "version": "Version", "flavor": {"name": "Name", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "index": 5}, "sha": "Sha", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "offering_id": "OfferingID", "catalog_id": "CatalogID", "kind_id": "KindID", "tags": ["Tags"], "repo_url": "RepoURL", "source_url": "SourceURL", "tgz_url": "TgzURL", "configuration": [{"key": "Key", "type": "Type", "default_value": "anyValue", "display_name": "DisplayName", "value_constraint": "ValueConstraint", "description": "Description", "required": true, "options": ["anyValue"], "hidden": true, "custom_config": {"type": "Type", "grouping": "Grouping", "original_grouping": "OriginalGrouping", "grouping_index": 13, "config_constraints": {"anyKey": "anyValue"}, "associations": {"parameters": [{"name": "Name", "optionsRefresh": true}]}}, "type_metadata": "TypeMetadata"}], "outputs": [{"key": "Key", "description": "Description"}], "iam_permissions": [{"service_name": "ServiceName", "role_crns": ["RoleCrns"], "resources": [{"name": "Name", "description": "Description", "role_crns": ["RoleCrns"]}]}], "metadata": {"anyKey": "anyValue"}, "validation": {"validated": "2019-01-01T12:00:00.000Z", "requested": "2019-01-01T12:00:00.000Z", "state": "State", "last_operation": "LastOperation", "target": {"anyKey": "anyValue"}, "message": "Message"}, "required_resources": [{"type": "mem", "value": "anyValue"}], "single_instance": true, "schematics_env_values": {"value": "[{\"name\": \"TF_LOG\",\"value\": \"TRACE\",\"secure\": false,\"hidden\": false}]", "sm_ref": "cmsm_v1:{\"name\": \"envVarSecret\",\"id\":\"1234567890\",\"service_id\":\"crn:v1:bluemix:public:secrets-manager:eu-gb:a/1234567890:1234567890::\",\"service_name\":\"My SM Instance\",\"group_id\":\"1234567890\",\"group_name\":\"My SM Group\",\"resource_group_id\":\"1234567890\",\"region\":\"eu-gb\",\"type\":\"arbitrary\"}"}, "install": {"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}, "pre_install": [{"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}], "scripts": {"mapKey": {"short_description": "ShortDescription", "type": "ansible", "path": "scripts/validate-post-ansible-playbook.yaml", "stage": "pre", "action": "validate"}}, "entitlement": {"provider_name": "ProviderName", "provider_id": "ProviderID", "product_id": "ProductID", "part_numbers": ["PartNumbers"], "image_repo_name": "ImageRepoName"}, "licenses": [{"id": "ID", "name": "Name", "type": "Type", "url": "URL", "description": "Description"}], "image_manifest_url": "ImageManifestURL", "deprecated": true, "package_version": "PackageVersion", "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "version_locator": "VersionLocator", "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "whitelisted_accounts": ["WhitelistedAccounts"], "image_pull_key_name": "ImagePullKeyName", "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "solution_info": {"architecture_diagrams": [{"diagram": {"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "cost_estimate": {"version": "Version", "currency": "Currency", "projects": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "pastBreakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "breakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "diff": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}}], "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}, "totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "pastTotalHourlyCost": "PastTotalHourlyCost", "pastTotalMonthlyCost": "PastTotalMonthlyCost", "diffTotalHourlyCost": "DiffTotalHourlyCost", "diffTotalMonthlyCost": "DiffTotalMonthlyCost", "timeGenerated": "2019-01-01T12:00:00.000Z"}, "dependencies": [{"catalog_id": "CatalogID", "id": "ID", "name": "Name", "kind": "Kind", "version": "Version", "description": "Description", "default_flavor": "DefaultFlavor", "flavors": ["Flavors"], "optional": true, "on_by_default": false}], "install_type": "InstallType"}, "is_consumable": true, "compliance_v3": {"authority": "Authority", "claims": {"profiles": [{"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}], "controls": [{"profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "names": ["Names"]}]}, "evaluations": [{"scan_id": "ScanID", "account_id": "AccountID", "profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "result": {"failure_count": 12, "scan_time": "2019-01-01T12:00:00.000Z", "error_message": "ErrorMessage", "complete_scan": true, "unscanned_resources": ["UnscannedResources"]}, "controls": [{"id": "ID", "name": "Name", "description": "Description", "specifications": [{"id": "ID", "description": "Description", "component_name": "ComponentName", "assessments": [{"id": "ID", "description": "Description", "version": "Version", "type": "Type", "method": "Method", "ui_href": "UIHref"}], "ui_href": "UIHref"}], "failure_count": 12, "pass_count": 9, "parent": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "parent_name": "ParentName", "specifications": [{"id": "ID", "description": "Description", "component_name": "ComponentName", "assessments": [{"id": "ID", "description": "Description", "version": "Version", "type": "Type", "method": "Method", "ui_href": "UIHref"}], "ui_href": "UIHref"}], "ui_href": "UIHref"}, "ui_href": "UIHref"}]}]}, "change_notices": {"breaking": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "new": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "update": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}]}, "plan_ids": ["PlanIds"], "stack": {"anyKey": "anyValue"}, "minimum_compatible_version": "MinimumCompatibleVersion"}`)
				}))
			})
			It(`Invoke GetOfferingWorkingCopy successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.GetOfferingWorkingCopy(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetOfferingWorkingCopyOptions model
				getOfferingWorkingCopyOptionsModel := new(catalogmanagementv1.GetOfferingWorkingCopyOptions)
				getOfferingWorkingCopyOptionsModel.VersionLocID = core.StringPtr("testString")
				getOfferingWorkingCopyOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.GetOfferingWorkingCopy(getOfferingWorkingCopyOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetOfferingWorkingCopy with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOfferingWorkingCopyOptions model
				getOfferingWorkingCopyOptionsModel := new(catalogmanagementv1.GetOfferingWorkingCopyOptions)
				getOfferingWorkingCopyOptionsModel.VersionLocID = core.StringPtr("testString")
				getOfferingWorkingCopyOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.GetOfferingWorkingCopy(getOfferingWorkingCopyOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetOfferingWorkingCopyOptions model with no property values
				getOfferingWorkingCopyOptionsModelNew := new(catalogmanagementv1.GetOfferingWorkingCopyOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.GetOfferingWorkingCopy(getOfferingWorkingCopyOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetOfferingWorkingCopy successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOfferingWorkingCopyOptions model
				getOfferingWorkingCopyOptionsModel := new(catalogmanagementv1.GetOfferingWorkingCopyOptions)
				getOfferingWorkingCopyOptionsModel.VersionLocID = core.StringPtr("testString")
				getOfferingWorkingCopyOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.GetOfferingWorkingCopy(getOfferingWorkingCopyOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CopyFromPreviousVersion(copyFromPreviousVersionOptions *CopyFromPreviousVersionOptions)`, func() {
		copyFromPreviousVersionPath := "/versions/testString/copy/testString/testString"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(copyFromPreviousVersionPath))
					Expect(req.Method).To(Equal("POST"))

					res.WriteHeader(200)
				}))
			})
			It(`Invoke CopyFromPreviousVersion successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := catalogManagementService.CopyFromPreviousVersion(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the CopyFromPreviousVersionOptions model
				copyFromPreviousVersionOptionsModel := new(catalogmanagementv1.CopyFromPreviousVersionOptions)
				copyFromPreviousVersionOptionsModel.VersionLocID = core.StringPtr("testString")
				copyFromPreviousVersionOptionsModel.Type = core.StringPtr("testString")
				copyFromPreviousVersionOptionsModel.VersionLocIDToCopyFrom = core.StringPtr("testString")
				copyFromPreviousVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = catalogManagementService.CopyFromPreviousVersion(copyFromPreviousVersionOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke CopyFromPreviousVersion with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the CopyFromPreviousVersionOptions model
				copyFromPreviousVersionOptionsModel := new(catalogmanagementv1.CopyFromPreviousVersionOptions)
				copyFromPreviousVersionOptionsModel.VersionLocID = core.StringPtr("testString")
				copyFromPreviousVersionOptionsModel.Type = core.StringPtr("testString")
				copyFromPreviousVersionOptionsModel.VersionLocIDToCopyFrom = core.StringPtr("testString")
				copyFromPreviousVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := catalogManagementService.CopyFromPreviousVersion(copyFromPreviousVersionOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the CopyFromPreviousVersionOptions model with no property values
				copyFromPreviousVersionOptionsModelNew := new(catalogmanagementv1.CopyFromPreviousVersionOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = catalogManagementService.CopyFromPreviousVersion(copyFromPreviousVersionOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ValidateInputs(validateInputsOptions *ValidateInputsOptions) - Operation response error`, func() {
		validateInputsPath := "/versions/testString/validateInputs"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(validateInputsPath))
					Expect(req.Method).To(Equal("POST"))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ValidateInputs with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ValidateInputsOptions model
				validateInputsOptionsModel := new(catalogmanagementv1.ValidateInputsOptions)
				validateInputsOptionsModel.VersionLocID = core.StringPtr("testString")
				validateInputsOptionsModel.Input1 = core.StringPtr("testString")
				validateInputsOptionsModel.Input2 = core.StringPtr("testString")
				validateInputsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.ValidateInputs(validateInputsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.ValidateInputs(validateInputsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ValidateInputs(validateInputsOptions *ValidateInputsOptions)`, func() {
		validateInputsPath := "/versions/testString/validateInputs"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(validateInputsPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"message": "Message", "code": "Code", "global_transaction_id": "GlobalTransactionID", "errors": [{"message": "Message", "entity": "Entity", "error_code": "ErrorCode"}]}`)
				}))
			})
			It(`Invoke ValidateInputs successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the ValidateInputsOptions model
				validateInputsOptionsModel := new(catalogmanagementv1.ValidateInputsOptions)
				validateInputsOptionsModel.VersionLocID = core.StringPtr("testString")
				validateInputsOptionsModel.Input1 = core.StringPtr("testString")
				validateInputsOptionsModel.Input2 = core.StringPtr("testString")
				validateInputsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.ValidateInputsWithContext(ctx, validateInputsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.ValidateInputs(validateInputsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.ValidateInputsWithContext(ctx, validateInputsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(validateInputsPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"message": "Message", "code": "Code", "global_transaction_id": "GlobalTransactionID", "errors": [{"message": "Message", "entity": "Entity", "error_code": "ErrorCode"}]}`)
				}))
			})
			It(`Invoke ValidateInputs successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.ValidateInputs(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ValidateInputsOptions model
				validateInputsOptionsModel := new(catalogmanagementv1.ValidateInputsOptions)
				validateInputsOptionsModel.VersionLocID = core.StringPtr("testString")
				validateInputsOptionsModel.Input1 = core.StringPtr("testString")
				validateInputsOptionsModel.Input2 = core.StringPtr("testString")
				validateInputsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.ValidateInputs(validateInputsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ValidateInputs with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ValidateInputsOptions model
				validateInputsOptionsModel := new(catalogmanagementv1.ValidateInputsOptions)
				validateInputsOptionsModel.VersionLocID = core.StringPtr("testString")
				validateInputsOptionsModel.Input1 = core.StringPtr("testString")
				validateInputsOptionsModel.Input2 = core.StringPtr("testString")
				validateInputsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.ValidateInputs(validateInputsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the ValidateInputsOptions model with no property values
				validateInputsOptionsModelNew := new(catalogmanagementv1.ValidateInputsOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.ValidateInputs(validateInputsOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ValidateInputs successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ValidateInputsOptions model
				validateInputsOptionsModel := new(catalogmanagementv1.ValidateInputsOptions)
				validateInputsOptionsModel.VersionLocID = core.StringPtr("testString")
				validateInputsOptionsModel.Input1 = core.StringPtr("testString")
				validateInputsOptionsModel.Input2 = core.StringPtr("testString")
				validateInputsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.ValidateInputs(validateInputsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetVersion(getVersionOptions *GetVersionOptions) - Operation response error`, func() {
		getVersionPath := "/versions/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getVersionPath))
					Expect(req.Method).To(Equal("GET"))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetVersion with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetVersionOptions model
				getVersionOptionsModel := new(catalogmanagementv1.GetVersionOptions)
				getVersionOptionsModel.VersionLocID = core.StringPtr("testString")
				getVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.GetVersion(getVersionOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.GetVersion(getVersionOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetVersion(getVersionOptions *GetVersionOptions)`, func() {
		getVersionPath := "/versions/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getVersionPath))
					Expect(req.Method).To(Equal("GET"))

					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "name": "Name", "offering_icon_url": "OfferingIconURL", "offering_docs_url": "OfferingDocsURL", "offering_support_url": "OfferingSupportURL", "tags": ["Tags"], "keywords": ["Keywords"], "rating": {"one_star_count": 12, "two_star_count": 12, "three_star_count": 14, "four_star_count": 13}, "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "kinds": [{"id": "ID", "format_kind": "FormatKind", "format_kind_label": "FormatKindLabel", "install_kind": "InstallKind", "install_kind_label": "InstallKindLabel", "target_kind": "TargetKind", "target_kind_label": "TargetKindLabel", "metadata": {"anyKey": "anyValue"}, "tags": ["Tags"], "additional_features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "versions": [{"id": "ID", "_rev": "Rev", "crn": "CRN", "version": "Version", "flavor": {"name": "Name", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "index": 5}, "sha": "Sha", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "offering_id": "OfferingID", "catalog_id": "CatalogID", "kind_id": "KindID", "tags": ["Tags"], "repo_url": "RepoURL", "source_url": "SourceURL", "tgz_url": "TgzURL", "configuration": [{"key": "Key", "type": "Type", "default_value": "anyValue", "display_name": "DisplayName", "value_constraint": "ValueConstraint", "description": "Description", "required": true, "options": ["anyValue"], "hidden": true, "custom_config": {"type": "Type", "grouping": "Grouping", "original_grouping": "OriginalGrouping", "grouping_index": 13, "config_constraints": {"anyKey": "anyValue"}, "associations": {"parameters": [{"name": "Name", "optionsRefresh": true}]}}, "type_metadata": "TypeMetadata"}], "outputs": [{"key": "Key", "description": "Description"}], "iam_permissions": [{"service_name": "ServiceName", "role_crns": ["RoleCrns"], "resources": [{"name": "Name", "description": "Description", "role_crns": ["RoleCrns"]}]}], "metadata": {"anyKey": "anyValue"}, "validation": {"validated": "2019-01-01T12:00:00.000Z", "requested": "2019-01-01T12:00:00.000Z", "state": "State", "last_operation": "LastOperation", "target": {"anyKey": "anyValue"}, "message": "Message"}, "required_resources": [{"type": "mem", "value": "anyValue"}], "single_instance": true, "schematics_env_values": {"value": "[{\"name\": \"TF_LOG\",\"value\": \"TRACE\",\"secure\": false,\"hidden\": false}]", "sm_ref": "cmsm_v1:{\"name\": \"envVarSecret\",\"id\":\"1234567890\",\"service_id\":\"crn:v1:bluemix:public:secrets-manager:eu-gb:a/1234567890:1234567890::\",\"service_name\":\"My SM Instance\",\"group_id\":\"1234567890\",\"group_name\":\"My SM Group\",\"resource_group_id\":\"1234567890\",\"region\":\"eu-gb\",\"type\":\"arbitrary\"}"}, "install": {"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}, "pre_install": [{"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}], "scripts": {"mapKey": {"short_description": "ShortDescription", "type": "ansible", "path": "scripts/validate-post-ansible-playbook.yaml", "stage": "pre", "action": "validate"}}, "entitlement": {"provider_name": "ProviderName", "provider_id": "ProviderID", "product_id": "ProductID", "part_numbers": ["PartNumbers"], "image_repo_name": "ImageRepoName"}, "licenses": [{"id": "ID", "name": "Name", "type": "Type", "url": "URL", "description": "Description"}], "image_manifest_url": "ImageManifestURL", "deprecated": true, "package_version": "PackageVersion", "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "version_locator": "VersionLocator", "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "whitelisted_accounts": ["WhitelistedAccounts"], "image_pull_key_name": "ImagePullKeyName", "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "solution_info": {"architecture_diagrams": [{"diagram": {"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "cost_estimate": {"version": "Version", "currency": "Currency", "projects": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "pastBreakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "breakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "diff": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}}], "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}, "totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "pastTotalHourlyCost": "PastTotalHourlyCost", "pastTotalMonthlyCost": "PastTotalMonthlyCost", "diffTotalHourlyCost": "DiffTotalHourlyCost", "diffTotalMonthlyCost": "DiffTotalMonthlyCost", "timeGenerated": "2019-01-01T12:00:00.000Z"}, "dependencies": [{"catalog_id": "CatalogID", "id": "ID", "name": "Name", "kind": "Kind", "version": "Version", "description": "Description", "default_flavor": "DefaultFlavor", "flavors": ["Flavors"], "optional": true, "on_by_default": false}], "install_type": "InstallType"}, "is_consumable": true, "compliance_v3": {"authority": "Authority", "claims": {"profiles": [{"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}], "controls": [{"profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "names": ["Names"]}]}, "evaluations": [{"scan_id": "ScanID", "account_id": "AccountID", "profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "result": {"failure_count": 12, "scan_time": "2019-01-01T12:00:00.000Z", "error_message": "ErrorMessage", "complete_scan": true, "unscanned_resources": ["UnscannedResources"]}, "controls": [{"id": "ID", "name": "Name", "description": "Description", "specifications": [{"id": "ID", "description": "Description", "component_name": "ComponentName", "assessments": [{"id": "ID", "description": "Description", "version": "Version", "type": "Type", "method": "Method", "ui_href": "UIHref"}], "ui_href": "UIHref"}], "failure_count": 12, "pass_count": 9, "parent": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "parent_name": "ParentName", "specifications": [{"id": "ID", "description": "Description", "component_name": "ComponentName", "assessments": [{"id": "ID", "description": "Description", "version": "Version", "type": "Type", "method": "Method", "ui_href": "UIHref"}], "ui_href": "UIHref"}], "ui_href": "UIHref"}, "ui_href": "UIHref"}]}]}, "change_notices": {"breaking": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "new": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "update": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}]}, "plan_ids": ["PlanIds"], "stack": {"anyKey": "anyValue"}, "minimum_compatible_version": "MinimumCompatibleVersion"}], "all_versions": {"first": {"href": "Href", "start": "Start"}, "next": {"href": "Href", "start": "Start"}}}], "publish": {"pc_managed": false, "approval_type": "ApprovalType", "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "original_crn": "OriginalCRN", "public_crn": "PublicCRN", "approval_record": {"anyKey": "anyValue"}, "permit_ibm_public_publish": true, "ibm_approved": false, "public_approved": true}, "pc_managed": false, "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "public_original_crn": "PublicOriginalCRN", "publish_public_crn": "PublishPublicCRN", "portal_approval_record": "PortalApprovalRecord", "portal_ui_url": "PortalUIURL", "catalog_id": "CatalogID", "catalog_name": "CatalogName", "metadata": {"anyKey": "anyValue"}, "disclaimer": "Disclaimer", "hidden": true, "provider": "Provider", "provider_info": {"id": "ID", "name": "Name"}, "repo_info": {"token": "Token", "type": "Type"}, "image_pull_keys": [{"name": "Name", "value": "Value", "description": "Description"}], "support": {"url": "URL", "process": "Process", "process_i18n": {"mapKey": "Inner"}, "locations": ["Locations"], "support_details": [{"type": "Type", "contact": "Contact", "response_wait_time": {"value": 5, "type": "Type"}, "availability": {"times": [{"day": 3, "start_time": "StartTime", "end_time": "EndTime"}], "timezone": "Timezone", "always_available": false}}], "support_escalation": {"escalation_wait_time": {"value": 5, "type": "Type"}, "response_wait_time": {"value": 5, "type": "Type"}, "contact": "Contact"}, "support_type": "SupportType"}, "media": [{"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}], "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "product_kind": "ProductKind", "badges": [{"id": "ID", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}, "icon": "Icon", "authority": "Authority", "tag": "Tag", "learn_more_links": {"first_party": "FirstParty", "third_party": "ThirdParty"}, "constraints": [{"type": "Type", "rule": "anyValue"}]}], "plans": [{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "offering_id": "OfferingID", "catalog_id": "CatalogID", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "name": "Name", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "pricing_tags": ["PricingTags"], "version_range": {"kinds": ["Kinds"], "version": "Version", "flavors": ["Flavors"]}, "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "metadata": {"anyKey": "anyValue"}, "publish_approved": false}]}`)
				}))
			})
			It(`Invoke GetVersion successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the GetVersionOptions model
				getVersionOptionsModel := new(catalogmanagementv1.GetVersionOptions)
				getVersionOptionsModel.VersionLocID = core.StringPtr("testString")
				getVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.GetVersionWithContext(ctx, getVersionOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.GetVersion(getVersionOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.GetVersionWithContext(ctx, getVersionOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getVersionPath))
					Expect(req.Method).To(Equal("GET"))

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "name": "Name", "offering_icon_url": "OfferingIconURL", "offering_docs_url": "OfferingDocsURL", "offering_support_url": "OfferingSupportURL", "tags": ["Tags"], "keywords": ["Keywords"], "rating": {"one_star_count": 12, "two_star_count": 12, "three_star_count": 14, "four_star_count": 13}, "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "kinds": [{"id": "ID", "format_kind": "FormatKind", "format_kind_label": "FormatKindLabel", "install_kind": "InstallKind", "install_kind_label": "InstallKindLabel", "target_kind": "TargetKind", "target_kind_label": "TargetKindLabel", "metadata": {"anyKey": "anyValue"}, "tags": ["Tags"], "additional_features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "versions": [{"id": "ID", "_rev": "Rev", "crn": "CRN", "version": "Version", "flavor": {"name": "Name", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "index": 5}, "sha": "Sha", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "offering_id": "OfferingID", "catalog_id": "CatalogID", "kind_id": "KindID", "tags": ["Tags"], "repo_url": "RepoURL", "source_url": "SourceURL", "tgz_url": "TgzURL", "configuration": [{"key": "Key", "type": "Type", "default_value": "anyValue", "display_name": "DisplayName", "value_constraint": "ValueConstraint", "description": "Description", "required": true, "options": ["anyValue"], "hidden": true, "custom_config": {"type": "Type", "grouping": "Grouping", "original_grouping": "OriginalGrouping", "grouping_index": 13, "config_constraints": {"anyKey": "anyValue"}, "associations": {"parameters": [{"name": "Name", "optionsRefresh": true}]}}, "type_metadata": "TypeMetadata"}], "outputs": [{"key": "Key", "description": "Description"}], "iam_permissions": [{"service_name": "ServiceName", "role_crns": ["RoleCrns"], "resources": [{"name": "Name", "description": "Description", "role_crns": ["RoleCrns"]}]}], "metadata": {"anyKey": "anyValue"}, "validation": {"validated": "2019-01-01T12:00:00.000Z", "requested": "2019-01-01T12:00:00.000Z", "state": "State", "last_operation": "LastOperation", "target": {"anyKey": "anyValue"}, "message": "Message"}, "required_resources": [{"type": "mem", "value": "anyValue"}], "single_instance": true, "schematics_env_values": {"value": "[{\"name\": \"TF_LOG\",\"value\": \"TRACE\",\"secure\": false,\"hidden\": false}]", "sm_ref": "cmsm_v1:{\"name\": \"envVarSecret\",\"id\":\"1234567890\",\"service_id\":\"crn:v1:bluemix:public:secrets-manager:eu-gb:a/1234567890:1234567890::\",\"service_name\":\"My SM Instance\",\"group_id\":\"1234567890\",\"group_name\":\"My SM Group\",\"resource_group_id\":\"1234567890\",\"region\":\"eu-gb\",\"type\":\"arbitrary\"}"}, "install": {"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}, "pre_install": [{"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}], "scripts": {"mapKey": {"short_description": "ShortDescription", "type": "ansible", "path": "scripts/validate-post-ansible-playbook.yaml", "stage": "pre", "action": "validate"}}, "entitlement": {"provider_name": "ProviderName", "provider_id": "ProviderID", "product_id": "ProductID", "part_numbers": ["PartNumbers"], "image_repo_name": "ImageRepoName"}, "licenses": [{"id": "ID", "name": "Name", "type": "Type", "url": "URL", "description": "Description"}], "image_manifest_url": "ImageManifestURL", "deprecated": true, "package_version": "PackageVersion", "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "version_locator": "VersionLocator", "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "whitelisted_accounts": ["WhitelistedAccounts"], "image_pull_key_name": "ImagePullKeyName", "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "solution_info": {"architecture_diagrams": [{"diagram": {"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "cost_estimate": {"version": "Version", "currency": "Currency", "projects": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "pastBreakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "breakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "diff": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}}], "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}, "totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "pastTotalHourlyCost": "PastTotalHourlyCost", "pastTotalMonthlyCost": "PastTotalMonthlyCost", "diffTotalHourlyCost": "DiffTotalHourlyCost", "diffTotalMonthlyCost": "DiffTotalMonthlyCost", "timeGenerated": "2019-01-01T12:00:00.000Z"}, "dependencies": [{"catalog_id": "CatalogID", "id": "ID", "name": "Name", "kind": "Kind", "version": "Version", "description": "Description", "default_flavor": "DefaultFlavor", "flavors": ["Flavors"], "optional": true, "on_by_default": false}], "install_type": "InstallType"}, "is_consumable": true, "compliance_v3": {"authority": "Authority", "claims": {"profiles": [{"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}], "controls": [{"profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "names": ["Names"]}]}, "evaluations": [{"scan_id": "ScanID", "account_id": "AccountID", "profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "result": {"failure_count": 12, "scan_time": "2019-01-01T12:00:00.000Z", "error_message": "ErrorMessage", "complete_scan": true, "unscanned_resources": ["UnscannedResources"]}, "controls": [{"id": "ID", "name": "Name", "description": "Description", "specifications": [{"id": "ID", "description": "Description", "component_name": "ComponentName", "assessments": [{"id": "ID", "description": "Description", "version": "Version", "type": "Type", "method": "Method", "ui_href": "UIHref"}], "ui_href": "UIHref"}], "failure_count": 12, "pass_count": 9, "parent": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "parent_name": "ParentName", "specifications": [{"id": "ID", "description": "Description", "component_name": "ComponentName", "assessments": [{"id": "ID", "description": "Description", "version": "Version", "type": "Type", "method": "Method", "ui_href": "UIHref"}], "ui_href": "UIHref"}], "ui_href": "UIHref"}, "ui_href": "UIHref"}]}]}, "change_notices": {"breaking": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "new": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "update": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}]}, "plan_ids": ["PlanIds"], "stack": {"anyKey": "anyValue"}, "minimum_compatible_version": "MinimumCompatibleVersion"}], "all_versions": {"first": {"href": "Href", "start": "Start"}, "next": {"href": "Href", "start": "Start"}}}], "publish": {"pc_managed": false, "approval_type": "ApprovalType", "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "original_crn": "OriginalCRN", "public_crn": "PublicCRN", "approval_record": {"anyKey": "anyValue"}, "permit_ibm_public_publish": true, "ibm_approved": false, "public_approved": true}, "pc_managed": false, "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "public_original_crn": "PublicOriginalCRN", "publish_public_crn": "PublishPublicCRN", "portal_approval_record": "PortalApprovalRecord", "portal_ui_url": "PortalUIURL", "catalog_id": "CatalogID", "catalog_name": "CatalogName", "metadata": {"anyKey": "anyValue"}, "disclaimer": "Disclaimer", "hidden": true, "provider": "Provider", "provider_info": {"id": "ID", "name": "Name"}, "repo_info": {"token": "Token", "type": "Type"}, "image_pull_keys": [{"name": "Name", "value": "Value", "description": "Description"}], "support": {"url": "URL", "process": "Process", "process_i18n": {"mapKey": "Inner"}, "locations": ["Locations"], "support_details": [{"type": "Type", "contact": "Contact", "response_wait_time": {"value": 5, "type": "Type"}, "availability": {"times": [{"day": 3, "start_time": "StartTime", "end_time": "EndTime"}], "timezone": "Timezone", "always_available": false}}], "support_escalation": {"escalation_wait_time": {"value": 5, "type": "Type"}, "response_wait_time": {"value": 5, "type": "Type"}, "contact": "Contact"}, "support_type": "SupportType"}, "media": [{"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}], "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "product_kind": "ProductKind", "badges": [{"id": "ID", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}, "icon": "Icon", "authority": "Authority", "tag": "Tag", "learn_more_links": {"first_party": "FirstParty", "third_party": "ThirdParty"}, "constraints": [{"type": "Type", "rule": "anyValue"}]}], "plans": [{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "offering_id": "OfferingID", "catalog_id": "CatalogID", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "name": "Name", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "pricing_tags": ["PricingTags"], "version_range": {"kinds": ["Kinds"], "version": "Version", "flavors": ["Flavors"]}, "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "metadata": {"anyKey": "anyValue"}, "publish_approved": false}]}`)
				}))
			})
			It(`Invoke GetVersion successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.GetVersion(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetVersionOptions model
				getVersionOptionsModel := new(catalogmanagementv1.GetVersionOptions)
				getVersionOptionsModel.VersionLocID = core.StringPtr("testString")
				getVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.GetVersion(getVersionOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetVersion with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetVersionOptions model
				getVersionOptionsModel := new(catalogmanagementv1.GetVersionOptions)
				getVersionOptionsModel.VersionLocID = core.StringPtr("testString")
				getVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.GetVersion(getVersionOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetVersionOptions model with no property values
				getVersionOptionsModelNew := new(catalogmanagementv1.GetVersionOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.GetVersion(getVersionOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetVersion successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetVersionOptions model
				getVersionOptionsModel := new(catalogmanagementv1.GetVersionOptions)
				getVersionOptionsModel.VersionLocID = core.StringPtr("testString")
				getVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.GetVersion(getVersionOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`UpdateVersion(updateVersionOptions *UpdateVersionOptions) - Operation response error`, func() {
		updateVersionPath := "/versions/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updateVersionPath))
					Expect(req.Method).To(Equal("PUT"))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke UpdateVersion with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the Rating model
				ratingModel := new(catalogmanagementv1.Rating)
				ratingModel.OneStarCount = core.Int64Ptr(int64(38))
				ratingModel.TwoStarCount = core.Int64Ptr(int64(38))
				ratingModel.ThreeStarCount = core.Int64Ptr(int64(38))
				ratingModel.FourStarCount = core.Int64Ptr(int64(38))

				// Construct an instance of the Feature model
				featureModel := new(catalogmanagementv1.Feature)
				featureModel.Title = core.StringPtr("testString")
				featureModel.TitleI18n = map[string]string{"key1": "testString"}
				featureModel.Description = core.StringPtr("testString")
				featureModel.DescriptionI18n = map[string]string{"key1": "testString"}

				// Construct an instance of the Flavor model
				flavorModel := new(catalogmanagementv1.Flavor)
				flavorModel.Name = core.StringPtr("testString")
				flavorModel.Label = core.StringPtr("testString")
				flavorModel.LabelI18n = map[string]string{"key1": "testString"}
				flavorModel.Index = core.Int64Ptr(int64(38))

				// Construct an instance of the RenderTypeAssociationsParametersItem model
				renderTypeAssociationsParametersItemModel := new(catalogmanagementv1.RenderTypeAssociationsParametersItem)
				renderTypeAssociationsParametersItemModel.Name = core.StringPtr("testString")
				renderTypeAssociationsParametersItemModel.OptionsRefresh = core.BoolPtr(true)

				// Construct an instance of the RenderTypeAssociations model
				renderTypeAssociationsModel := new(catalogmanagementv1.RenderTypeAssociations)
				renderTypeAssociationsModel.Parameters = []catalogmanagementv1.RenderTypeAssociationsParametersItem{*renderTypeAssociationsParametersItemModel}

				// Construct an instance of the RenderType model
				renderTypeModel := new(catalogmanagementv1.RenderType)
				renderTypeModel.Type = core.StringPtr("testString")
				renderTypeModel.Grouping = core.StringPtr("testString")
				renderTypeModel.OriginalGrouping = core.StringPtr("testString")
				renderTypeModel.GroupingIndex = core.Int64Ptr(int64(38))
				renderTypeModel.ConfigConstraints = map[string]interface{}{"anyKey": "anyValue"}
				renderTypeModel.Associations = renderTypeAssociationsModel

				// Construct an instance of the Configuration model
				configurationModel := new(catalogmanagementv1.Configuration)
				configurationModel.Key = core.StringPtr("testString")
				configurationModel.Type = core.StringPtr("testString")
				configurationModel.DefaultValue = "testString"
				configurationModel.DisplayName = core.StringPtr("testString")
				configurationModel.ValueConstraint = core.StringPtr("testString")
				configurationModel.Description = core.StringPtr("testString")
				configurationModel.Required = core.BoolPtr(true)
				configurationModel.Options = []interface{}{"testString"}
				configurationModel.Hidden = core.BoolPtr(true)
				configurationModel.CustomConfig = renderTypeModel
				configurationModel.TypeMetadata = core.StringPtr("testString")

				// Construct an instance of the Output model
				outputModel := new(catalogmanagementv1.Output)
				outputModel.Key = core.StringPtr("testString")
				outputModel.Description = core.StringPtr("testString")

				// Construct an instance of the IamResource model
				iamResourceModel := new(catalogmanagementv1.IamResource)
				iamResourceModel.Name = core.StringPtr("testString")
				iamResourceModel.Description = core.StringPtr("testString")
				iamResourceModel.RoleCrns = []string{"testString"}

				// Construct an instance of the IamPermission model
				iamPermissionModel := new(catalogmanagementv1.IamPermission)
				iamPermissionModel.ServiceName = core.StringPtr("testString")
				iamPermissionModel.RoleCrns = []string{"testString"}
				iamPermissionModel.Resources = []catalogmanagementv1.IamResource{*iamResourceModel}

				// Construct an instance of the Validation model
				validationModel := new(catalogmanagementv1.Validation)
				validationModel.Validated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				validationModel.Requested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				validationModel.State = core.StringPtr("testString")
				validationModel.LastOperation = core.StringPtr("testString")
				validationModel.Target = map[string]interface{}{"anyKey": "anyValue"}
				validationModel.Message = core.StringPtr("testString")

				// Construct an instance of the Resource model
				resourceModel := new(catalogmanagementv1.Resource)
				resourceModel.Type = core.StringPtr("mem")
				resourceModel.Value = "testString"

				// Construct an instance of the SchematicsEnvValues model
				schematicsEnvValuesModel := new(catalogmanagementv1.SchematicsEnvValues)
				schematicsEnvValuesModel.Value = core.StringPtr("[{\"name\": \"TF_LOG\",\"value\": \"TRACE\",\"secure\": false,\"hidden\": false}]")
				schematicsEnvValuesModel.SmRef = core.StringPtr("cmsm_v1:{\"name\": \"envVarSecret\",\"id\":\"1234567890\",\"service_id\":\"crn:v1:bluemix:public:secrets-manager:eu-gb:a/1234567890:1234567890::\",\"service_name\":\"My SM Instance\",\"group_id\":\"1234567890\",\"group_name\":\"My SM Group\",\"resource_group_id\":\"1234567890\",\"region\":\"eu-gb\",\"type\":\"arbitrary\"}")

				// Construct an instance of the Script model
				scriptModel := new(catalogmanagementv1.Script)
				scriptModel.Instructions = core.StringPtr("testString")
				scriptModel.InstructionsI18n = map[string]string{"key1": "testString"}
				scriptModel.Script = core.StringPtr("testString")
				scriptModel.ScriptPermission = core.StringPtr("testString")
				scriptModel.DeleteScript = core.StringPtr("testString")
				scriptModel.Scope = core.StringPtr("testString")

				// Construct an instance of the ScriptRef model
				scriptRefModel := new(catalogmanagementv1.ScriptRef)
				scriptRefModel.ShortDescription = core.StringPtr("testString")
				scriptRefModel.Type = core.StringPtr("ansible")
				scriptRefModel.Path = core.StringPtr("scripts/validate-post-ansible-playbook.yaml")
				scriptRefModel.Stage = core.StringPtr("pre")
				scriptRefModel.Action = core.StringPtr("validate")

				// Construct an instance of the VersionEntitlement model
				versionEntitlementModel := new(catalogmanagementv1.VersionEntitlement)
				versionEntitlementModel.ProviderName = core.StringPtr("testString")
				versionEntitlementModel.ProviderID = core.StringPtr("testString")
				versionEntitlementModel.ProductID = core.StringPtr("testString")
				versionEntitlementModel.PartNumbers = []string{"testString"}
				versionEntitlementModel.ImageRepoName = core.StringPtr("testString")

				// Construct an instance of the License model
				licenseModel := new(catalogmanagementv1.License)
				licenseModel.ID = core.StringPtr("testString")
				licenseModel.Name = core.StringPtr("testString")
				licenseModel.Type = core.StringPtr("testString")
				licenseModel.URL = core.StringPtr("testString")
				licenseModel.Description = core.StringPtr("testString")

				// Construct an instance of the State model
				stateModel := new(catalogmanagementv1.State)
				stateModel.Current = core.StringPtr("testString")
				stateModel.CurrentEntered = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Pending = core.StringPtr("testString")
				stateModel.PendingRequested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Previous = core.StringPtr("testString")

				// Construct an instance of the DeprecatePending model
				deprecatePendingModel := new(catalogmanagementv1.DeprecatePending)
				deprecatePendingModel.DeprecateDate = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				deprecatePendingModel.DeprecateState = core.StringPtr("testString")
				deprecatePendingModel.Description = core.StringPtr("testString")

				// Construct an instance of the URLProxy model
				urlProxyModel := new(catalogmanagementv1.URLProxy)
				urlProxyModel.URL = core.StringPtr("testString")
				urlProxyModel.Sha = core.StringPtr("testString")

				// Construct an instance of the MediaItem model
				mediaItemModel := new(catalogmanagementv1.MediaItem)
				mediaItemModel.URL = core.StringPtr("testString")
				mediaItemModel.APIURL = core.StringPtr("testString")
				mediaItemModel.URLProxy = urlProxyModel
				mediaItemModel.Caption = core.StringPtr("testString")
				mediaItemModel.CaptionI18n = map[string]string{"key1": "testString"}
				mediaItemModel.Type = core.StringPtr("testString")
				mediaItemModel.ThumbnailURL = core.StringPtr("testString")

				// Construct an instance of the ArchitectureDiagram model
				architectureDiagramModel := new(catalogmanagementv1.ArchitectureDiagram)
				architectureDiagramModel.Diagram = mediaItemModel
				architectureDiagramModel.Description = core.StringPtr("testString")
				architectureDiagramModel.DescriptionI18n = map[string]string{"key1": "testString"}

				// Construct an instance of the CostComponent model
				costComponentModel := new(catalogmanagementv1.CostComponent)
				costComponentModel.Name = core.StringPtr("testString")
				costComponentModel.Unit = core.StringPtr("testString")
				costComponentModel.HourlyQuantity = core.StringPtr("testString")
				costComponentModel.MonthlyQuantity = core.StringPtr("testString")
				costComponentModel.Price = core.StringPtr("testString")
				costComponentModel.HourlyCost = core.StringPtr("testString")
				costComponentModel.MonthlyCost = core.StringPtr("testString")

				// Construct an instance of the CostResource model
				costResourceModel := new(catalogmanagementv1.CostResource)
				costResourceModel.Name = core.StringPtr("testString")
				costResourceModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				costResourceModel.HourlyCost = core.StringPtr("testString")
				costResourceModel.MonthlyCost = core.StringPtr("testString")
				costResourceModel.CostComponents = []catalogmanagementv1.CostComponent{*costComponentModel}

				// Construct an instance of the CostBreakdown model
				costBreakdownModel := new(catalogmanagementv1.CostBreakdown)
				costBreakdownModel.TotalHourlyCost = core.StringPtr("testString")
				costBreakdownModel.TotalMonthlyCost = core.StringPtr("testString")
				costBreakdownModel.Resources = []catalogmanagementv1.CostResource{*costResourceModel}

				// Construct an instance of the CostSummary model
				costSummaryModel := new(catalogmanagementv1.CostSummary)
				costSummaryModel.TotalDetectedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalSupportedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalUnsupportedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalUsageBasedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalNoPriceResources = core.Int64Ptr(int64(38))
				costSummaryModel.UnsupportedResourceCounts = map[string]int64{"key1": int64(38)}
				costSummaryModel.NoPriceResourceCounts = map[string]int64{"key1": int64(38)}

				// Construct an instance of the Project model
				projectModel := new(catalogmanagementv1.Project)
				projectModel.Name = core.StringPtr("testString")
				projectModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				projectModel.PastBreakdown = costBreakdownModel
				projectModel.Breakdown = costBreakdownModel
				projectModel.Diff = costBreakdownModel
				projectModel.Summary = costSummaryModel

				// Construct an instance of the CostEstimate model
				costEstimateModel := new(catalogmanagementv1.CostEstimate)
				costEstimateModel.Version = core.StringPtr("testString")
				costEstimateModel.Currency = core.StringPtr("testString")
				costEstimateModel.Projects = []catalogmanagementv1.Project{*projectModel}
				costEstimateModel.Summary = costSummaryModel
				costEstimateModel.TotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.TotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.PastTotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.PastTotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.DiffTotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.DiffTotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.TimeGenerated = CreateMockDateTime("2019-01-01T12:00:00.000Z")

				// Construct an instance of the OfferingReference model
				offeringReferenceModel := new(catalogmanagementv1.OfferingReference)
				offeringReferenceModel.CatalogID = core.StringPtr("testString")
				offeringReferenceModel.ID = core.StringPtr("testString")
				offeringReferenceModel.Name = core.StringPtr("testString")
				offeringReferenceModel.Kind = core.StringPtr("testString")
				offeringReferenceModel.Version = core.StringPtr("testString")
				offeringReferenceModel.Description = core.StringPtr("testString")
				offeringReferenceModel.DefaultFlavor = core.StringPtr("testString")
				offeringReferenceModel.Flavors = []string{"testString"}
				offeringReferenceModel.Optional = core.BoolPtr(true)
				offeringReferenceModel.OnByDefault = core.BoolPtr(true)

				// Construct an instance of the SolutionInfo model
				solutionInfoModel := new(catalogmanagementv1.SolutionInfo)
				solutionInfoModel.ArchitectureDiagrams = []catalogmanagementv1.ArchitectureDiagram{*architectureDiagramModel}
				solutionInfoModel.Features = []catalogmanagementv1.Feature{*featureModel}
				solutionInfoModel.CostEstimate = costEstimateModel
				solutionInfoModel.Dependencies = []catalogmanagementv1.OfferingReference{*offeringReferenceModel}
				solutionInfoModel.InstallType = core.StringPtr("testString")

				// Construct an instance of the SccProfile model
				sccProfileModel := new(catalogmanagementv1.SccProfile)
				sccProfileModel.ID = core.StringPtr("testString")
				sccProfileModel.Name = core.StringPtr("testString")
				sccProfileModel.Version = core.StringPtr("testString")
				sccProfileModel.Description = core.StringPtr("testString")
				sccProfileModel.Type = core.StringPtr("testString")
				sccProfileModel.UIHref = core.StringPtr("testString")

				// Construct an instance of the ClaimedControl model
				claimedControlModel := new(catalogmanagementv1.ClaimedControl)
				claimedControlModel.Profile = sccProfileModel
				claimedControlModel.Names = []string{"testString"}

				// Construct an instance of the Claims model
				claimsModel := new(catalogmanagementv1.Claims)
				claimsModel.Profiles = []catalogmanagementv1.SccProfile{*sccProfileModel}
				claimsModel.Controls = []catalogmanagementv1.ClaimedControl{*claimedControlModel}

				// Construct an instance of the Result model
				resultModel := new(catalogmanagementv1.Result)
				resultModel.FailureCount = core.Int64Ptr(int64(38))
				resultModel.ScanTime = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				resultModel.ErrorMessage = core.StringPtr("testString")
				resultModel.CompleteScan = core.BoolPtr(true)
				resultModel.UnscannedResources = []string{"testString"}

				// Construct an instance of the SccAssessment model
				sccAssessmentModel := new(catalogmanagementv1.SccAssessment)
				sccAssessmentModel.ID = core.StringPtr("testString")
				sccAssessmentModel.Description = core.StringPtr("testString")
				sccAssessmentModel.Version = core.StringPtr("testString")
				sccAssessmentModel.Type = core.StringPtr("testString")
				sccAssessmentModel.Method = core.StringPtr("testString")
				sccAssessmentModel.UIHref = core.StringPtr("testString")

				// Construct an instance of the SccSpecification model
				sccSpecificationModel := new(catalogmanagementv1.SccSpecification)
				sccSpecificationModel.ID = core.StringPtr("testString")
				sccSpecificationModel.Description = core.StringPtr("testString")
				sccSpecificationModel.ComponentName = core.StringPtr("testString")
				sccSpecificationModel.Assessments = []catalogmanagementv1.SccAssessment{*sccAssessmentModel}
				sccSpecificationModel.UIHref = core.StringPtr("testString")

				// Construct an instance of the SccControl model
				sccControlModel := new(catalogmanagementv1.SccControl)
				sccControlModel.ID = core.StringPtr("testString")
				sccControlModel.Name = core.StringPtr("testString")
				sccControlModel.Version = core.StringPtr("testString")
				sccControlModel.Description = core.StringPtr("testString")
				sccControlModel.Profile = sccProfileModel
				sccControlModel.ParentName = core.StringPtr("testString")
				sccControlModel.Specifications = []catalogmanagementv1.SccSpecification{*sccSpecificationModel}
				sccControlModel.UIHref = core.StringPtr("testString")

				// Construct an instance of the EvaluatedControl model
				evaluatedControlModel := new(catalogmanagementv1.EvaluatedControl)
				evaluatedControlModel.ID = core.StringPtr("testString")
				evaluatedControlModel.Name = core.StringPtr("testString")
				evaluatedControlModel.Description = core.StringPtr("testString")
				evaluatedControlModel.Specifications = []catalogmanagementv1.SccSpecification{*sccSpecificationModel}
				evaluatedControlModel.FailureCount = core.Int64Ptr(int64(38))
				evaluatedControlModel.PassCount = core.Int64Ptr(int64(38))
				evaluatedControlModel.Parent = sccControlModel
				evaluatedControlModel.UIHref = core.StringPtr("testString")

				// Construct an instance of the Evaluation model
				evaluationModel := new(catalogmanagementv1.Evaluation)
				evaluationModel.ScanID = core.StringPtr("testString")
				evaluationModel.AccountID = core.StringPtr("testString")
				evaluationModel.Profile = sccProfileModel
				evaluationModel.Result = resultModel
				evaluationModel.Controls = []catalogmanagementv1.EvaluatedControl{*evaluatedControlModel}

				// Construct an instance of the Compliance model
				complianceModel := new(catalogmanagementv1.Compliance)
				complianceModel.Authority = core.StringPtr("testString")
				complianceModel.Claims = claimsModel
				complianceModel.Evaluations = []catalogmanagementv1.Evaluation{*evaluationModel}

				// Construct an instance of the ChangeNotices model
				changeNoticesModel := new(catalogmanagementv1.ChangeNotices)
				changeNoticesModel.Breaking = []catalogmanagementv1.Feature{*featureModel}
				changeNoticesModel.New = []catalogmanagementv1.Feature{*featureModel}
				changeNoticesModel.Update = []catalogmanagementv1.Feature{*featureModel}

				// Construct an instance of the Version model
				versionModel := new(catalogmanagementv1.Version)
				versionModel.CRN = core.StringPtr("testString")
				versionModel.Version = core.StringPtr("testString")
				versionModel.Flavor = flavorModel
				versionModel.Sha = core.StringPtr("testString")
				versionModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				versionModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				versionModel.OfferingID = core.StringPtr("testString")
				versionModel.CatalogID = core.StringPtr("testString")
				versionModel.KindID = core.StringPtr("testString")
				versionModel.Tags = []string{"testString"}
				versionModel.RepoURL = core.StringPtr("testString")
				versionModel.SourceURL = core.StringPtr("testString")
				versionModel.TgzURL = core.StringPtr("testString")
				versionModel.Configuration = []catalogmanagementv1.Configuration{*configurationModel}
				versionModel.Outputs = []catalogmanagementv1.Output{*outputModel}
				versionModel.IamPermissions = []catalogmanagementv1.IamPermission{*iamPermissionModel}
				versionModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				versionModel.Validation = validationModel
				versionModel.RequiredResources = []catalogmanagementv1.Resource{*resourceModel}
				versionModel.SingleInstance = core.BoolPtr(true)
				versionModel.SchematicsEnvValues = schematicsEnvValuesModel
				versionModel.Install = scriptModel
				versionModel.PreInstall = []catalogmanagementv1.Script{*scriptModel}
				versionModel.Scripts = map[string]catalogmanagementv1.ScriptRef{"key1": *scriptRefModel}
				versionModel.Entitlement = versionEntitlementModel
				versionModel.Licenses = []catalogmanagementv1.License{*licenseModel}
				versionModel.ImageManifestURL = core.StringPtr("testString")
				versionModel.Deprecated = core.BoolPtr(true)
				versionModel.PackageVersion = core.StringPtr("testString")
				versionModel.State = stateModel
				versionModel.VersionLocator = core.StringPtr("testString")
				versionModel.LongDescription = core.StringPtr("testString")
				versionModel.LongDescriptionI18n = map[string]string{"key1": "testString"}
				versionModel.WhitelistedAccounts = []string{"testString"}
				versionModel.ImagePullKeyName = core.StringPtr("testString")
				versionModel.DeprecatePending = deprecatePendingModel
				versionModel.SolutionInfo = solutionInfoModel
				versionModel.IsConsumable = core.BoolPtr(true)
				versionModel.ComplianceV3 = complianceModel
				versionModel.ChangeNotices = changeNoticesModel
				versionModel.PlanIds = []string{"testString"}
				versionModel.Stack = map[string]interface{}{"anyKey": "anyValue"}
				versionModel.MinimumCompatibleVersion = core.StringPtr("testString")
				versionModel.Scripts["foo"] = *scriptRefModel

				// Construct an instance of the PaginationTokenLink model
				paginationTokenLinkModel := new(catalogmanagementv1.PaginationTokenLink)
				paginationTokenLinkModel.Href = core.StringPtr("testString")
				paginationTokenLinkModel.Start = core.StringPtr("testString")

				// Construct an instance of the KindAllVersions model
				kindAllVersionsModel := new(catalogmanagementv1.KindAllVersions)
				kindAllVersionsModel.First = paginationTokenLinkModel
				kindAllVersionsModel.Next = paginationTokenLinkModel

				// Construct an instance of the Kind model
				kindModel := new(catalogmanagementv1.Kind)
				kindModel.ID = core.StringPtr("testString")
				kindModel.FormatKind = core.StringPtr("testString")
				kindModel.FormatKindLabel = core.StringPtr("testString")
				kindModel.InstallKind = core.StringPtr("testString")
				kindModel.InstallKindLabel = core.StringPtr("testString")
				kindModel.TargetKind = core.StringPtr("testString")
				kindModel.TargetKindLabel = core.StringPtr("testString")
				kindModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				kindModel.Tags = []string{"testString"}
				kindModel.AdditionalFeatures = []catalogmanagementv1.Feature{*featureModel}
				kindModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				kindModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				kindModel.Versions = []catalogmanagementv1.Version{*versionModel}
				kindModel.AllVersions = kindAllVersionsModel

				// Construct an instance of the PublishObject model
				publishObjectModel := new(catalogmanagementv1.PublishObject)
				publishObjectModel.PcManaged = core.BoolPtr(true)
				publishObjectModel.ApprovalType = core.StringPtr("testString")
				publishObjectModel.PublishApproved = core.BoolPtr(true)
				publishObjectModel.ShareWithAll = core.BoolPtr(true)
				publishObjectModel.ShareWithIBM = core.BoolPtr(true)
				publishObjectModel.ShareEnabled = core.BoolPtr(true)
				publishObjectModel.OriginalCRN = core.StringPtr("testString")
				publishObjectModel.PublicCRN = core.StringPtr("testString")
				publishObjectModel.ApprovalRecord = map[string]interface{}{"anyKey": "anyValue"}
				publishObjectModel.PermitIBMPublicPublish = core.BoolPtr(true)
				publishObjectModel.IBMApproved = core.BoolPtr(true)
				publishObjectModel.PublicApproved = core.BoolPtr(true)

				// Construct an instance of the ProviderInfo model
				providerInfoModel := new(catalogmanagementv1.ProviderInfo)
				providerInfoModel.ID = core.StringPtr("testString")
				providerInfoModel.Name = core.StringPtr("testString")

				// Construct an instance of the RepoInfo model
				repoInfoModel := new(catalogmanagementv1.RepoInfo)
				repoInfoModel.Token = core.StringPtr("testString")
				repoInfoModel.Type = core.StringPtr("testString")

				// Construct an instance of the ImagePullKey model
				imagePullKeyModel := new(catalogmanagementv1.ImagePullKey)
				imagePullKeyModel.Name = core.StringPtr("testString")
				imagePullKeyModel.Value = core.StringPtr("testString")
				imagePullKeyModel.Description = core.StringPtr("testString")

				// Construct an instance of the SupportWaitTime model
				supportWaitTimeModel := new(catalogmanagementv1.SupportWaitTime)
				supportWaitTimeModel.Value = core.Int64Ptr(int64(38))
				supportWaitTimeModel.Type = core.StringPtr("testString")

				// Construct an instance of the SupportTime model
				supportTimeModel := new(catalogmanagementv1.SupportTime)
				supportTimeModel.Day = core.Int64Ptr(int64(38))
				supportTimeModel.StartTime = core.StringPtr("testString")
				supportTimeModel.EndTime = core.StringPtr("testString")

				// Construct an instance of the SupportAvailability model
				supportAvailabilityModel := new(catalogmanagementv1.SupportAvailability)
				supportAvailabilityModel.Times = []catalogmanagementv1.SupportTime{*supportTimeModel}
				supportAvailabilityModel.Timezone = core.StringPtr("testString")
				supportAvailabilityModel.AlwaysAvailable = core.BoolPtr(true)

				// Construct an instance of the SupportDetail model
				supportDetailModel := new(catalogmanagementv1.SupportDetail)
				supportDetailModel.Type = core.StringPtr("testString")
				supportDetailModel.Contact = core.StringPtr("testString")
				supportDetailModel.ResponseWaitTime = supportWaitTimeModel
				supportDetailModel.Availability = supportAvailabilityModel

				// Construct an instance of the SupportEscalation model
				supportEscalationModel := new(catalogmanagementv1.SupportEscalation)
				supportEscalationModel.EscalationWaitTime = supportWaitTimeModel
				supportEscalationModel.ResponseWaitTime = supportWaitTimeModel
				supportEscalationModel.Contact = core.StringPtr("testString")

				// Construct an instance of the Support model
				supportModel := new(catalogmanagementv1.Support)
				supportModel.URL = core.StringPtr("testString")
				supportModel.Process = core.StringPtr("testString")
				supportModel.ProcessI18n = map[string]string{"key1": "testString"}
				supportModel.Locations = []string{"testString"}
				supportModel.SupportDetails = []catalogmanagementv1.SupportDetail{*supportDetailModel}
				supportModel.SupportEscalation = supportEscalationModel
				supportModel.SupportType = core.StringPtr("testString")

				// Construct an instance of the LearnMoreLinks model
				learnMoreLinksModel := new(catalogmanagementv1.LearnMoreLinks)
				learnMoreLinksModel.FirstParty = core.StringPtr("testString")
				learnMoreLinksModel.ThirdParty = core.StringPtr("testString")

				// Construct an instance of the Constraint model
				constraintModel := new(catalogmanagementv1.Constraint)
				constraintModel.Type = core.StringPtr("testString")
				constraintModel.Rule = "testString"

				// Construct an instance of the Badge model
				badgeModel := new(catalogmanagementv1.Badge)
				badgeModel.ID = core.StringPtr("testString")
				badgeModel.Label = core.StringPtr("testString")
				badgeModel.LabelI18n = map[string]string{"key1": "testString"}
				badgeModel.Description = core.StringPtr("testString")
				badgeModel.DescriptionI18n = map[string]string{"key1": "testString"}
				badgeModel.Icon = core.StringPtr("testString")
				badgeModel.Authority = core.StringPtr("testString")
				badgeModel.Tag = core.StringPtr("testString")
				badgeModel.LearnMoreLinks = learnMoreLinksModel
				badgeModel.Constraints = []catalogmanagementv1.Constraint{*constraintModel}

				// Construct an instance of the VersionRange model
				versionRangeModel := new(catalogmanagementv1.VersionRange)
				versionRangeModel.Kinds = []string{"testString"}
				versionRangeModel.Version = core.StringPtr("testString")
				versionRangeModel.Flavors = []string{"testString"}

				// Construct an instance of the Plan model
				planModel := new(catalogmanagementv1.Plan)
				planModel.URL = core.StringPtr("testString")
				planModel.CRN = core.StringPtr("testString")
				planModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				planModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				planModel.OfferingID = core.StringPtr("testString")
				planModel.CatalogID = core.StringPtr("testString")
				planModel.Label = core.StringPtr("testString")
				planModel.LabelI18n = map[string]string{"key1": "testString"}
				planModel.Name = core.StringPtr("testString")
				planModel.ShortDescription = core.StringPtr("testString")
				planModel.ShortDescriptionI18n = map[string]string{"key1": "testString"}
				planModel.PricingTags = []string{"testString"}
				planModel.VersionRange = versionRangeModel
				planModel.Features = []catalogmanagementv1.Feature{*featureModel}
				planModel.State = stateModel
				planModel.DeprecatePending = deprecatePendingModel
				planModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				planModel.PublishApproved = core.BoolPtr(true)

				// Construct an instance of the UpdateVersionOptions model
				updateVersionOptionsModel := new(catalogmanagementv1.UpdateVersionOptions)
				updateVersionOptionsModel.VersionLocID = core.StringPtr("testString")
				updateVersionOptionsModel.ID = core.StringPtr("testString")
				updateVersionOptionsModel.Rev = core.StringPtr("testString")
				updateVersionOptionsModel.URL = core.StringPtr("testString")
				updateVersionOptionsModel.CRN = core.StringPtr("testString")
				updateVersionOptionsModel.Label = core.StringPtr("testString")
				updateVersionOptionsModel.LabelI18n = map[string]string{"key1": "testString"}
				updateVersionOptionsModel.Name = core.StringPtr("testString")
				updateVersionOptionsModel.OfferingIconURL = core.StringPtr("testString")
				updateVersionOptionsModel.OfferingDocsURL = core.StringPtr("testString")
				updateVersionOptionsModel.OfferingSupportURL = core.StringPtr("testString")
				updateVersionOptionsModel.Tags = []string{"testString"}
				updateVersionOptionsModel.Keywords = []string{"testString"}
				updateVersionOptionsModel.Rating = ratingModel
				updateVersionOptionsModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				updateVersionOptionsModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				updateVersionOptionsModel.ShortDescription = core.StringPtr("testString")
				updateVersionOptionsModel.ShortDescriptionI18n = map[string]string{"key1": "testString"}
				updateVersionOptionsModel.LongDescription = core.StringPtr("testString")
				updateVersionOptionsModel.LongDescriptionI18n = map[string]string{"key1": "testString"}
				updateVersionOptionsModel.Features = []catalogmanagementv1.Feature{*featureModel}
				updateVersionOptionsModel.Kinds = []catalogmanagementv1.Kind{*kindModel}
				updateVersionOptionsModel.Publish = publishObjectModel
				updateVersionOptionsModel.PcManaged = core.BoolPtr(true)
				updateVersionOptionsModel.PublishApproved = core.BoolPtr(true)
				updateVersionOptionsModel.ShareWithAll = core.BoolPtr(true)
				updateVersionOptionsModel.ShareWithIBM = core.BoolPtr(true)
				updateVersionOptionsModel.ShareEnabled = core.BoolPtr(true)
				updateVersionOptionsModel.PublicOriginalCRN = core.StringPtr("testString")
				updateVersionOptionsModel.PublishPublicCRN = core.StringPtr("testString")
				updateVersionOptionsModel.PortalApprovalRecord = core.StringPtr("testString")
				updateVersionOptionsModel.PortalUIURL = core.StringPtr("testString")
				updateVersionOptionsModel.CatalogID = core.StringPtr("testString")
				updateVersionOptionsModel.CatalogName = core.StringPtr("testString")
				updateVersionOptionsModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				updateVersionOptionsModel.Disclaimer = core.StringPtr("testString")
				updateVersionOptionsModel.Hidden = core.BoolPtr(true)
				updateVersionOptionsModel.Provider = core.StringPtr("testString")
				updateVersionOptionsModel.ProviderInfo = providerInfoModel
				updateVersionOptionsModel.RepoInfo = repoInfoModel
				updateVersionOptionsModel.ImagePullKeys = []catalogmanagementv1.ImagePullKey{*imagePullKeyModel}
				updateVersionOptionsModel.Support = supportModel
				updateVersionOptionsModel.Media = []catalogmanagementv1.MediaItem{*mediaItemModel}
				updateVersionOptionsModel.DeprecatePending = deprecatePendingModel
				updateVersionOptionsModel.ProductKind = core.StringPtr("testString")
				updateVersionOptionsModel.Badges = []catalogmanagementv1.Badge{*badgeModel}
				updateVersionOptionsModel.Plans = []catalogmanagementv1.Plan{*planModel}
				updateVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.UpdateVersion(updateVersionOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.UpdateVersion(updateVersionOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`UpdateVersion(updateVersionOptions *UpdateVersionOptions)`, func() {
		updateVersionPath := "/versions/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updateVersionPath))
					Expect(req.Method).To(Equal("PUT"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "name": "Name", "offering_icon_url": "OfferingIconURL", "offering_docs_url": "OfferingDocsURL", "offering_support_url": "OfferingSupportURL", "tags": ["Tags"], "keywords": ["Keywords"], "rating": {"one_star_count": 12, "two_star_count": 12, "three_star_count": 14, "four_star_count": 13}, "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "kinds": [{"id": "ID", "format_kind": "FormatKind", "format_kind_label": "FormatKindLabel", "install_kind": "InstallKind", "install_kind_label": "InstallKindLabel", "target_kind": "TargetKind", "target_kind_label": "TargetKindLabel", "metadata": {"anyKey": "anyValue"}, "tags": ["Tags"], "additional_features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "versions": [{"id": "ID", "_rev": "Rev", "crn": "CRN", "version": "Version", "flavor": {"name": "Name", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "index": 5}, "sha": "Sha", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "offering_id": "OfferingID", "catalog_id": "CatalogID", "kind_id": "KindID", "tags": ["Tags"], "repo_url": "RepoURL", "source_url": "SourceURL", "tgz_url": "TgzURL", "configuration": [{"key": "Key", "type": "Type", "default_value": "anyValue", "display_name": "DisplayName", "value_constraint": "ValueConstraint", "description": "Description", "required": true, "options": ["anyValue"], "hidden": true, "custom_config": {"type": "Type", "grouping": "Grouping", "original_grouping": "OriginalGrouping", "grouping_index": 13, "config_constraints": {"anyKey": "anyValue"}, "associations": {"parameters": [{"name": "Name", "optionsRefresh": true}]}}, "type_metadata": "TypeMetadata"}], "outputs": [{"key": "Key", "description": "Description"}], "iam_permissions": [{"service_name": "ServiceName", "role_crns": ["RoleCrns"], "resources": [{"name": "Name", "description": "Description", "role_crns": ["RoleCrns"]}]}], "metadata": {"anyKey": "anyValue"}, "validation": {"validated": "2019-01-01T12:00:00.000Z", "requested": "2019-01-01T12:00:00.000Z", "state": "State", "last_operation": "LastOperation", "target": {"anyKey": "anyValue"}, "message": "Message"}, "required_resources": [{"type": "mem", "value": "anyValue"}], "single_instance": true, "schematics_env_values": {"value": "[{\"name\": \"TF_LOG\",\"value\": \"TRACE\",\"secure\": false,\"hidden\": false}]", "sm_ref": "cmsm_v1:{\"name\": \"envVarSecret\",\"id\":\"1234567890\",\"service_id\":\"crn:v1:bluemix:public:secrets-manager:eu-gb:a/1234567890:1234567890::\",\"service_name\":\"My SM Instance\",\"group_id\":\"1234567890\",\"group_name\":\"My SM Group\",\"resource_group_id\":\"1234567890\",\"region\":\"eu-gb\",\"type\":\"arbitrary\"}"}, "install": {"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}, "pre_install": [{"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}], "scripts": {"mapKey": {"short_description": "ShortDescription", "type": "ansible", "path": "scripts/validate-post-ansible-playbook.yaml", "stage": "pre", "action": "validate"}}, "entitlement": {"provider_name": "ProviderName", "provider_id": "ProviderID", "product_id": "ProductID", "part_numbers": ["PartNumbers"], "image_repo_name": "ImageRepoName"}, "licenses": [{"id": "ID", "name": "Name", "type": "Type", "url": "URL", "description": "Description"}], "image_manifest_url": "ImageManifestURL", "deprecated": true, "package_version": "PackageVersion", "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "version_locator": "VersionLocator", "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "whitelisted_accounts": ["WhitelistedAccounts"], "image_pull_key_name": "ImagePullKeyName", "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "solution_info": {"architecture_diagrams": [{"diagram": {"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "cost_estimate": {"version": "Version", "currency": "Currency", "projects": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "pastBreakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "breakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "diff": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}}], "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}, "totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "pastTotalHourlyCost": "PastTotalHourlyCost", "pastTotalMonthlyCost": "PastTotalMonthlyCost", "diffTotalHourlyCost": "DiffTotalHourlyCost", "diffTotalMonthlyCost": "DiffTotalMonthlyCost", "timeGenerated": "2019-01-01T12:00:00.000Z"}, "dependencies": [{"catalog_id": "CatalogID", "id": "ID", "name": "Name", "kind": "Kind", "version": "Version", "description": "Description", "default_flavor": "DefaultFlavor", "flavors": ["Flavors"], "optional": true, "on_by_default": false}], "install_type": "InstallType"}, "is_consumable": true, "compliance_v3": {"authority": "Authority", "claims": {"profiles": [{"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}], "controls": [{"profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "names": ["Names"]}]}, "evaluations": [{"scan_id": "ScanID", "account_id": "AccountID", "profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "result": {"failure_count": 12, "scan_time": "2019-01-01T12:00:00.000Z", "error_message": "ErrorMessage", "complete_scan": true, "unscanned_resources": ["UnscannedResources"]}, "controls": [{"id": "ID", "name": "Name", "description": "Description", "specifications": [{"id": "ID", "description": "Description", "component_name": "ComponentName", "assessments": [{"id": "ID", "description": "Description", "version": "Version", "type": "Type", "method": "Method", "ui_href": "UIHref"}], "ui_href": "UIHref"}], "failure_count": 12, "pass_count": 9, "parent": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "parent_name": "ParentName", "specifications": [{"id": "ID", "description": "Description", "component_name": "ComponentName", "assessments": [{"id": "ID", "description": "Description", "version": "Version", "type": "Type", "method": "Method", "ui_href": "UIHref"}], "ui_href": "UIHref"}], "ui_href": "UIHref"}, "ui_href": "UIHref"}]}]}, "change_notices": {"breaking": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "new": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "update": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}]}, "plan_ids": ["PlanIds"], "stack": {"anyKey": "anyValue"}, "minimum_compatible_version": "MinimumCompatibleVersion"}], "all_versions": {"first": {"href": "Href", "start": "Start"}, "next": {"href": "Href", "start": "Start"}}}], "publish": {"pc_managed": false, "approval_type": "ApprovalType", "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "original_crn": "OriginalCRN", "public_crn": "PublicCRN", "approval_record": {"anyKey": "anyValue"}, "permit_ibm_public_publish": true, "ibm_approved": false, "public_approved": true}, "pc_managed": false, "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "public_original_crn": "PublicOriginalCRN", "publish_public_crn": "PublishPublicCRN", "portal_approval_record": "PortalApprovalRecord", "portal_ui_url": "PortalUIURL", "catalog_id": "CatalogID", "catalog_name": "CatalogName", "metadata": {"anyKey": "anyValue"}, "disclaimer": "Disclaimer", "hidden": true, "provider": "Provider", "provider_info": {"id": "ID", "name": "Name"}, "repo_info": {"token": "Token", "type": "Type"}, "image_pull_keys": [{"name": "Name", "value": "Value", "description": "Description"}], "support": {"url": "URL", "process": "Process", "process_i18n": {"mapKey": "Inner"}, "locations": ["Locations"], "support_details": [{"type": "Type", "contact": "Contact", "response_wait_time": {"value": 5, "type": "Type"}, "availability": {"times": [{"day": 3, "start_time": "StartTime", "end_time": "EndTime"}], "timezone": "Timezone", "always_available": false}}], "support_escalation": {"escalation_wait_time": {"value": 5, "type": "Type"}, "response_wait_time": {"value": 5, "type": "Type"}, "contact": "Contact"}, "support_type": "SupportType"}, "media": [{"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}], "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "product_kind": "ProductKind", "badges": [{"id": "ID", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}, "icon": "Icon", "authority": "Authority", "tag": "Tag", "learn_more_links": {"first_party": "FirstParty", "third_party": "ThirdParty"}, "constraints": [{"type": "Type", "rule": "anyValue"}]}], "plans": [{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "offering_id": "OfferingID", "catalog_id": "CatalogID", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "name": "Name", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "pricing_tags": ["PricingTags"], "version_range": {"kinds": ["Kinds"], "version": "Version", "flavors": ["Flavors"]}, "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "metadata": {"anyKey": "anyValue"}, "publish_approved": false}]}`)
				}))
			})
			It(`Invoke UpdateVersion successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the Rating model
				ratingModel := new(catalogmanagementv1.Rating)
				ratingModel.OneStarCount = core.Int64Ptr(int64(38))
				ratingModel.TwoStarCount = core.Int64Ptr(int64(38))
				ratingModel.ThreeStarCount = core.Int64Ptr(int64(38))
				ratingModel.FourStarCount = core.Int64Ptr(int64(38))

				// Construct an instance of the Feature model
				featureModel := new(catalogmanagementv1.Feature)
				featureModel.Title = core.StringPtr("testString")
				featureModel.TitleI18n = map[string]string{"key1": "testString"}
				featureModel.Description = core.StringPtr("testString")
				featureModel.DescriptionI18n = map[string]string{"key1": "testString"}

				// Construct an instance of the Flavor model
				flavorModel := new(catalogmanagementv1.Flavor)
				flavorModel.Name = core.StringPtr("testString")
				flavorModel.Label = core.StringPtr("testString")
				flavorModel.LabelI18n = map[string]string{"key1": "testString"}
				flavorModel.Index = core.Int64Ptr(int64(38))

				// Construct an instance of the RenderTypeAssociationsParametersItem model
				renderTypeAssociationsParametersItemModel := new(catalogmanagementv1.RenderTypeAssociationsParametersItem)
				renderTypeAssociationsParametersItemModel.Name = core.StringPtr("testString")
				renderTypeAssociationsParametersItemModel.OptionsRefresh = core.BoolPtr(true)

				// Construct an instance of the RenderTypeAssociations model
				renderTypeAssociationsModel := new(catalogmanagementv1.RenderTypeAssociations)
				renderTypeAssociationsModel.Parameters = []catalogmanagementv1.RenderTypeAssociationsParametersItem{*renderTypeAssociationsParametersItemModel}

				// Construct an instance of the RenderType model
				renderTypeModel := new(catalogmanagementv1.RenderType)
				renderTypeModel.Type = core.StringPtr("testString")
				renderTypeModel.Grouping = core.StringPtr("testString")
				renderTypeModel.OriginalGrouping = core.StringPtr("testString")
				renderTypeModel.GroupingIndex = core.Int64Ptr(int64(38))
				renderTypeModel.ConfigConstraints = map[string]interface{}{"anyKey": "anyValue"}
				renderTypeModel.Associations = renderTypeAssociationsModel

				// Construct an instance of the Configuration model
				configurationModel := new(catalogmanagementv1.Configuration)
				configurationModel.Key = core.StringPtr("testString")
				configurationModel.Type = core.StringPtr("testString")
				configurationModel.DefaultValue = "testString"
				configurationModel.DisplayName = core.StringPtr("testString")
				configurationModel.ValueConstraint = core.StringPtr("testString")
				configurationModel.Description = core.StringPtr("testString")
				configurationModel.Required = core.BoolPtr(true)
				configurationModel.Options = []interface{}{"testString"}
				configurationModel.Hidden = core.BoolPtr(true)
				configurationModel.CustomConfig = renderTypeModel
				configurationModel.TypeMetadata = core.StringPtr("testString")

				// Construct an instance of the Output model
				outputModel := new(catalogmanagementv1.Output)
				outputModel.Key = core.StringPtr("testString")
				outputModel.Description = core.StringPtr("testString")

				// Construct an instance of the IamResource model
				iamResourceModel := new(catalogmanagementv1.IamResource)
				iamResourceModel.Name = core.StringPtr("testString")
				iamResourceModel.Description = core.StringPtr("testString")
				iamResourceModel.RoleCrns = []string{"testString"}

				// Construct an instance of the IamPermission model
				iamPermissionModel := new(catalogmanagementv1.IamPermission)
				iamPermissionModel.ServiceName = core.StringPtr("testString")
				iamPermissionModel.RoleCrns = []string{"testString"}
				iamPermissionModel.Resources = []catalogmanagementv1.IamResource{*iamResourceModel}

				// Construct an instance of the Validation model
				validationModel := new(catalogmanagementv1.Validation)
				validationModel.Validated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				validationModel.Requested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				validationModel.State = core.StringPtr("testString")
				validationModel.LastOperation = core.StringPtr("testString")
				validationModel.Target = map[string]interface{}{"anyKey": "anyValue"}
				validationModel.Message = core.StringPtr("testString")

				// Construct an instance of the Resource model
				resourceModel := new(catalogmanagementv1.Resource)
				resourceModel.Type = core.StringPtr("mem")
				resourceModel.Value = "testString"

				// Construct an instance of the SchematicsEnvValues model
				schematicsEnvValuesModel := new(catalogmanagementv1.SchematicsEnvValues)
				schematicsEnvValuesModel.Value = core.StringPtr("[{\"name\": \"TF_LOG\",\"value\": \"TRACE\",\"secure\": false,\"hidden\": false}]")
				schematicsEnvValuesModel.SmRef = core.StringPtr("cmsm_v1:{\"name\": \"envVarSecret\",\"id\":\"1234567890\",\"service_id\":\"crn:v1:bluemix:public:secrets-manager:eu-gb:a/1234567890:1234567890::\",\"service_name\":\"My SM Instance\",\"group_id\":\"1234567890\",\"group_name\":\"My SM Group\",\"resource_group_id\":\"1234567890\",\"region\":\"eu-gb\",\"type\":\"arbitrary\"}")

				// Construct an instance of the Script model
				scriptModel := new(catalogmanagementv1.Script)
				scriptModel.Instructions = core.StringPtr("testString")
				scriptModel.InstructionsI18n = map[string]string{"key1": "testString"}
				scriptModel.Script = core.StringPtr("testString")
				scriptModel.ScriptPermission = core.StringPtr("testString")
				scriptModel.DeleteScript = core.StringPtr("testString")
				scriptModel.Scope = core.StringPtr("testString")

				// Construct an instance of the ScriptRef model
				scriptRefModel := new(catalogmanagementv1.ScriptRef)
				scriptRefModel.ShortDescription = core.StringPtr("testString")
				scriptRefModel.Type = core.StringPtr("ansible")
				scriptRefModel.Path = core.StringPtr("scripts/validate-post-ansible-playbook.yaml")
				scriptRefModel.Stage = core.StringPtr("pre")
				scriptRefModel.Action = core.StringPtr("validate")

				// Construct an instance of the VersionEntitlement model
				versionEntitlementModel := new(catalogmanagementv1.VersionEntitlement)
				versionEntitlementModel.ProviderName = core.StringPtr("testString")
				versionEntitlementModel.ProviderID = core.StringPtr("testString")
				versionEntitlementModel.ProductID = core.StringPtr("testString")
				versionEntitlementModel.PartNumbers = []string{"testString"}
				versionEntitlementModel.ImageRepoName = core.StringPtr("testString")

				// Construct an instance of the License model
				licenseModel := new(catalogmanagementv1.License)
				licenseModel.ID = core.StringPtr("testString")
				licenseModel.Name = core.StringPtr("testString")
				licenseModel.Type = core.StringPtr("testString")
				licenseModel.URL = core.StringPtr("testString")
				licenseModel.Description = core.StringPtr("testString")

				// Construct an instance of the State model
				stateModel := new(catalogmanagementv1.State)
				stateModel.Current = core.StringPtr("testString")
				stateModel.CurrentEntered = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Pending = core.StringPtr("testString")
				stateModel.PendingRequested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Previous = core.StringPtr("testString")

				// Construct an instance of the DeprecatePending model
				deprecatePendingModel := new(catalogmanagementv1.DeprecatePending)
				deprecatePendingModel.DeprecateDate = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				deprecatePendingModel.DeprecateState = core.StringPtr("testString")
				deprecatePendingModel.Description = core.StringPtr("testString")

				// Construct an instance of the URLProxy model
				urlProxyModel := new(catalogmanagementv1.URLProxy)
				urlProxyModel.URL = core.StringPtr("testString")
				urlProxyModel.Sha = core.StringPtr("testString")

				// Construct an instance of the MediaItem model
				mediaItemModel := new(catalogmanagementv1.MediaItem)
				mediaItemModel.URL = core.StringPtr("testString")
				mediaItemModel.APIURL = core.StringPtr("testString")
				mediaItemModel.URLProxy = urlProxyModel
				mediaItemModel.Caption = core.StringPtr("testString")
				mediaItemModel.CaptionI18n = map[string]string{"key1": "testString"}
				mediaItemModel.Type = core.StringPtr("testString")
				mediaItemModel.ThumbnailURL = core.StringPtr("testString")

				// Construct an instance of the ArchitectureDiagram model
				architectureDiagramModel := new(catalogmanagementv1.ArchitectureDiagram)
				architectureDiagramModel.Diagram = mediaItemModel
				architectureDiagramModel.Description = core.StringPtr("testString")
				architectureDiagramModel.DescriptionI18n = map[string]string{"key1": "testString"}

				// Construct an instance of the CostComponent model
				costComponentModel := new(catalogmanagementv1.CostComponent)
				costComponentModel.Name = core.StringPtr("testString")
				costComponentModel.Unit = core.StringPtr("testString")
				costComponentModel.HourlyQuantity = core.StringPtr("testString")
				costComponentModel.MonthlyQuantity = core.StringPtr("testString")
				costComponentModel.Price = core.StringPtr("testString")
				costComponentModel.HourlyCost = core.StringPtr("testString")
				costComponentModel.MonthlyCost = core.StringPtr("testString")

				// Construct an instance of the CostResource model
				costResourceModel := new(catalogmanagementv1.CostResource)
				costResourceModel.Name = core.StringPtr("testString")
				costResourceModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				costResourceModel.HourlyCost = core.StringPtr("testString")
				costResourceModel.MonthlyCost = core.StringPtr("testString")
				costResourceModel.CostComponents = []catalogmanagementv1.CostComponent{*costComponentModel}

				// Construct an instance of the CostBreakdown model
				costBreakdownModel := new(catalogmanagementv1.CostBreakdown)
				costBreakdownModel.TotalHourlyCost = core.StringPtr("testString")
				costBreakdownModel.TotalMonthlyCost = core.StringPtr("testString")
				costBreakdownModel.Resources = []catalogmanagementv1.CostResource{*costResourceModel}

				// Construct an instance of the CostSummary model
				costSummaryModel := new(catalogmanagementv1.CostSummary)
				costSummaryModel.TotalDetectedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalSupportedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalUnsupportedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalUsageBasedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalNoPriceResources = core.Int64Ptr(int64(38))
				costSummaryModel.UnsupportedResourceCounts = map[string]int64{"key1": int64(38)}
				costSummaryModel.NoPriceResourceCounts = map[string]int64{"key1": int64(38)}

				// Construct an instance of the Project model
				projectModel := new(catalogmanagementv1.Project)
				projectModel.Name = core.StringPtr("testString")
				projectModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				projectModel.PastBreakdown = costBreakdownModel
				projectModel.Breakdown = costBreakdownModel
				projectModel.Diff = costBreakdownModel
				projectModel.Summary = costSummaryModel

				// Construct an instance of the CostEstimate model
				costEstimateModel := new(catalogmanagementv1.CostEstimate)
				costEstimateModel.Version = core.StringPtr("testString")
				costEstimateModel.Currency = core.StringPtr("testString")
				costEstimateModel.Projects = []catalogmanagementv1.Project{*projectModel}
				costEstimateModel.Summary = costSummaryModel
				costEstimateModel.TotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.TotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.PastTotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.PastTotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.DiffTotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.DiffTotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.TimeGenerated = CreateMockDateTime("2019-01-01T12:00:00.000Z")

				// Construct an instance of the OfferingReference model
				offeringReferenceModel := new(catalogmanagementv1.OfferingReference)
				offeringReferenceModel.CatalogID = core.StringPtr("testString")
				offeringReferenceModel.ID = core.StringPtr("testString")
				offeringReferenceModel.Name = core.StringPtr("testString")
				offeringReferenceModel.Kind = core.StringPtr("testString")
				offeringReferenceModel.Version = core.StringPtr("testString")
				offeringReferenceModel.Description = core.StringPtr("testString")
				offeringReferenceModel.DefaultFlavor = core.StringPtr("testString")
				offeringReferenceModel.Flavors = []string{"testString"}
				offeringReferenceModel.Optional = core.BoolPtr(true)
				offeringReferenceModel.OnByDefault = core.BoolPtr(true)

				// Construct an instance of the SolutionInfo model
				solutionInfoModel := new(catalogmanagementv1.SolutionInfo)
				solutionInfoModel.ArchitectureDiagrams = []catalogmanagementv1.ArchitectureDiagram{*architectureDiagramModel}
				solutionInfoModel.Features = []catalogmanagementv1.Feature{*featureModel}
				solutionInfoModel.CostEstimate = costEstimateModel
				solutionInfoModel.Dependencies = []catalogmanagementv1.OfferingReference{*offeringReferenceModel}
				solutionInfoModel.InstallType = core.StringPtr("testString")

				// Construct an instance of the SccProfile model
				sccProfileModel := new(catalogmanagementv1.SccProfile)
				sccProfileModel.ID = core.StringPtr("testString")
				sccProfileModel.Name = core.StringPtr("testString")
				sccProfileModel.Version = core.StringPtr("testString")
				sccProfileModel.Description = core.StringPtr("testString")
				sccProfileModel.Type = core.StringPtr("testString")
				sccProfileModel.UIHref = core.StringPtr("testString")

				// Construct an instance of the ClaimedControl model
				claimedControlModel := new(catalogmanagementv1.ClaimedControl)
				claimedControlModel.Profile = sccProfileModel
				claimedControlModel.Names = []string{"testString"}

				// Construct an instance of the Claims model
				claimsModel := new(catalogmanagementv1.Claims)
				claimsModel.Profiles = []catalogmanagementv1.SccProfile{*sccProfileModel}
				claimsModel.Controls = []catalogmanagementv1.ClaimedControl{*claimedControlModel}

				// Construct an instance of the Result model
				resultModel := new(catalogmanagementv1.Result)
				resultModel.FailureCount = core.Int64Ptr(int64(38))
				resultModel.ScanTime = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				resultModel.ErrorMessage = core.StringPtr("testString")
				resultModel.CompleteScan = core.BoolPtr(true)
				resultModel.UnscannedResources = []string{"testString"}

				// Construct an instance of the SccAssessment model
				sccAssessmentModel := new(catalogmanagementv1.SccAssessment)
				sccAssessmentModel.ID = core.StringPtr("testString")
				sccAssessmentModel.Description = core.StringPtr("testString")
				sccAssessmentModel.Version = core.StringPtr("testString")
				sccAssessmentModel.Type = core.StringPtr("testString")
				sccAssessmentModel.Method = core.StringPtr("testString")
				sccAssessmentModel.UIHref = core.StringPtr("testString")

				// Construct an instance of the SccSpecification model
				sccSpecificationModel := new(catalogmanagementv1.SccSpecification)
				sccSpecificationModel.ID = core.StringPtr("testString")
				sccSpecificationModel.Description = core.StringPtr("testString")
				sccSpecificationModel.ComponentName = core.StringPtr("testString")
				sccSpecificationModel.Assessments = []catalogmanagementv1.SccAssessment{*sccAssessmentModel}
				sccSpecificationModel.UIHref = core.StringPtr("testString")

				// Construct an instance of the SccControl model
				sccControlModel := new(catalogmanagementv1.SccControl)
				sccControlModel.ID = core.StringPtr("testString")
				sccControlModel.Name = core.StringPtr("testString")
				sccControlModel.Version = core.StringPtr("testString")
				sccControlModel.Description = core.StringPtr("testString")
				sccControlModel.Profile = sccProfileModel
				sccControlModel.ParentName = core.StringPtr("testString")
				sccControlModel.Specifications = []catalogmanagementv1.SccSpecification{*sccSpecificationModel}
				sccControlModel.UIHref = core.StringPtr("testString")

				// Construct an instance of the EvaluatedControl model
				evaluatedControlModel := new(catalogmanagementv1.EvaluatedControl)
				evaluatedControlModel.ID = core.StringPtr("testString")
				evaluatedControlModel.Name = core.StringPtr("testString")
				evaluatedControlModel.Description = core.StringPtr("testString")
				evaluatedControlModel.Specifications = []catalogmanagementv1.SccSpecification{*sccSpecificationModel}
				evaluatedControlModel.FailureCount = core.Int64Ptr(int64(38))
				evaluatedControlModel.PassCount = core.Int64Ptr(int64(38))
				evaluatedControlModel.Parent = sccControlModel
				evaluatedControlModel.UIHref = core.StringPtr("testString")

				// Construct an instance of the Evaluation model
				evaluationModel := new(catalogmanagementv1.Evaluation)
				evaluationModel.ScanID = core.StringPtr("testString")
				evaluationModel.AccountID = core.StringPtr("testString")
				evaluationModel.Profile = sccProfileModel
				evaluationModel.Result = resultModel
				evaluationModel.Controls = []catalogmanagementv1.EvaluatedControl{*evaluatedControlModel}

				// Construct an instance of the Compliance model
				complianceModel := new(catalogmanagementv1.Compliance)
				complianceModel.Authority = core.StringPtr("testString")
				complianceModel.Claims = claimsModel
				complianceModel.Evaluations = []catalogmanagementv1.Evaluation{*evaluationModel}

				// Construct an instance of the ChangeNotices model
				changeNoticesModel := new(catalogmanagementv1.ChangeNotices)
				changeNoticesModel.Breaking = []catalogmanagementv1.Feature{*featureModel}
				changeNoticesModel.New = []catalogmanagementv1.Feature{*featureModel}
				changeNoticesModel.Update = []catalogmanagementv1.Feature{*featureModel}

				// Construct an instance of the Version model
				versionModel := new(catalogmanagementv1.Version)
				versionModel.CRN = core.StringPtr("testString")
				versionModel.Version = core.StringPtr("testString")
				versionModel.Flavor = flavorModel
				versionModel.Sha = core.StringPtr("testString")
				versionModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				versionModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				versionModel.OfferingID = core.StringPtr("testString")
				versionModel.CatalogID = core.StringPtr("testString")
				versionModel.KindID = core.StringPtr("testString")
				versionModel.Tags = []string{"testString"}
				versionModel.RepoURL = core.StringPtr("testString")
				versionModel.SourceURL = core.StringPtr("testString")
				versionModel.TgzURL = core.StringPtr("testString")
				versionModel.Configuration = []catalogmanagementv1.Configuration{*configurationModel}
				versionModel.Outputs = []catalogmanagementv1.Output{*outputModel}
				versionModel.IamPermissions = []catalogmanagementv1.IamPermission{*iamPermissionModel}
				versionModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				versionModel.Validation = validationModel
				versionModel.RequiredResources = []catalogmanagementv1.Resource{*resourceModel}
				versionModel.SingleInstance = core.BoolPtr(true)
				versionModel.SchematicsEnvValues = schematicsEnvValuesModel
				versionModel.Install = scriptModel
				versionModel.PreInstall = []catalogmanagementv1.Script{*scriptModel}
				versionModel.Scripts = map[string]catalogmanagementv1.ScriptRef{"key1": *scriptRefModel}
				versionModel.Entitlement = versionEntitlementModel
				versionModel.Licenses = []catalogmanagementv1.License{*licenseModel}
				versionModel.ImageManifestURL = core.StringPtr("testString")
				versionModel.Deprecated = core.BoolPtr(true)
				versionModel.PackageVersion = core.StringPtr("testString")
				versionModel.State = stateModel
				versionModel.VersionLocator = core.StringPtr("testString")
				versionModel.LongDescription = core.StringPtr("testString")
				versionModel.LongDescriptionI18n = map[string]string{"key1": "testString"}
				versionModel.WhitelistedAccounts = []string{"testString"}
				versionModel.ImagePullKeyName = core.StringPtr("testString")
				versionModel.DeprecatePending = deprecatePendingModel
				versionModel.SolutionInfo = solutionInfoModel
				versionModel.IsConsumable = core.BoolPtr(true)
				versionModel.ComplianceV3 = complianceModel
				versionModel.ChangeNotices = changeNoticesModel
				versionModel.PlanIds = []string{"testString"}
				versionModel.Stack = map[string]interface{}{"anyKey": "anyValue"}
				versionModel.MinimumCompatibleVersion = core.StringPtr("testString")
				versionModel.Scripts["foo"] = *scriptRefModel

				// Construct an instance of the PaginationTokenLink model
				paginationTokenLinkModel := new(catalogmanagementv1.PaginationTokenLink)
				paginationTokenLinkModel.Href = core.StringPtr("testString")
				paginationTokenLinkModel.Start = core.StringPtr("testString")

				// Construct an instance of the KindAllVersions model
				kindAllVersionsModel := new(catalogmanagementv1.KindAllVersions)
				kindAllVersionsModel.First = paginationTokenLinkModel
				kindAllVersionsModel.Next = paginationTokenLinkModel

				// Construct an instance of the Kind model
				kindModel := new(catalogmanagementv1.Kind)
				kindModel.ID = core.StringPtr("testString")
				kindModel.FormatKind = core.StringPtr("testString")
				kindModel.FormatKindLabel = core.StringPtr("testString")
				kindModel.InstallKind = core.StringPtr("testString")
				kindModel.InstallKindLabel = core.StringPtr("testString")
				kindModel.TargetKind = core.StringPtr("testString")
				kindModel.TargetKindLabel = core.StringPtr("testString")
				kindModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				kindModel.Tags = []string{"testString"}
				kindModel.AdditionalFeatures = []catalogmanagementv1.Feature{*featureModel}
				kindModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				kindModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				kindModel.Versions = []catalogmanagementv1.Version{*versionModel}
				kindModel.AllVersions = kindAllVersionsModel

				// Construct an instance of the PublishObject model
				publishObjectModel := new(catalogmanagementv1.PublishObject)
				publishObjectModel.PcManaged = core.BoolPtr(true)
				publishObjectModel.ApprovalType = core.StringPtr("testString")
				publishObjectModel.PublishApproved = core.BoolPtr(true)
				publishObjectModel.ShareWithAll = core.BoolPtr(true)
				publishObjectModel.ShareWithIBM = core.BoolPtr(true)
				publishObjectModel.ShareEnabled = core.BoolPtr(true)
				publishObjectModel.OriginalCRN = core.StringPtr("testString")
				publishObjectModel.PublicCRN = core.StringPtr("testString")
				publishObjectModel.ApprovalRecord = map[string]interface{}{"anyKey": "anyValue"}
				publishObjectModel.PermitIBMPublicPublish = core.BoolPtr(true)
				publishObjectModel.IBMApproved = core.BoolPtr(true)
				publishObjectModel.PublicApproved = core.BoolPtr(true)

				// Construct an instance of the ProviderInfo model
				providerInfoModel := new(catalogmanagementv1.ProviderInfo)
				providerInfoModel.ID = core.StringPtr("testString")
				providerInfoModel.Name = core.StringPtr("testString")

				// Construct an instance of the RepoInfo model
				repoInfoModel := new(catalogmanagementv1.RepoInfo)
				repoInfoModel.Token = core.StringPtr("testString")
				repoInfoModel.Type = core.StringPtr("testString")

				// Construct an instance of the ImagePullKey model
				imagePullKeyModel := new(catalogmanagementv1.ImagePullKey)
				imagePullKeyModel.Name = core.StringPtr("testString")
				imagePullKeyModel.Value = core.StringPtr("testString")
				imagePullKeyModel.Description = core.StringPtr("testString")

				// Construct an instance of the SupportWaitTime model
				supportWaitTimeModel := new(catalogmanagementv1.SupportWaitTime)
				supportWaitTimeModel.Value = core.Int64Ptr(int64(38))
				supportWaitTimeModel.Type = core.StringPtr("testString")

				// Construct an instance of the SupportTime model
				supportTimeModel := new(catalogmanagementv1.SupportTime)
				supportTimeModel.Day = core.Int64Ptr(int64(38))
				supportTimeModel.StartTime = core.StringPtr("testString")
				supportTimeModel.EndTime = core.StringPtr("testString")

				// Construct an instance of the SupportAvailability model
				supportAvailabilityModel := new(catalogmanagementv1.SupportAvailability)
				supportAvailabilityModel.Times = []catalogmanagementv1.SupportTime{*supportTimeModel}
				supportAvailabilityModel.Timezone = core.StringPtr("testString")
				supportAvailabilityModel.AlwaysAvailable = core.BoolPtr(true)

				// Construct an instance of the SupportDetail model
				supportDetailModel := new(catalogmanagementv1.SupportDetail)
				supportDetailModel.Type = core.StringPtr("testString")
				supportDetailModel.Contact = core.StringPtr("testString")
				supportDetailModel.ResponseWaitTime = supportWaitTimeModel
				supportDetailModel.Availability = supportAvailabilityModel

				// Construct an instance of the SupportEscalation model
				supportEscalationModel := new(catalogmanagementv1.SupportEscalation)
				supportEscalationModel.EscalationWaitTime = supportWaitTimeModel
				supportEscalationModel.ResponseWaitTime = supportWaitTimeModel
				supportEscalationModel.Contact = core.StringPtr("testString")

				// Construct an instance of the Support model
				supportModel := new(catalogmanagementv1.Support)
				supportModel.URL = core.StringPtr("testString")
				supportModel.Process = core.StringPtr("testString")
				supportModel.ProcessI18n = map[string]string{"key1": "testString"}
				supportModel.Locations = []string{"testString"}
				supportModel.SupportDetails = []catalogmanagementv1.SupportDetail{*supportDetailModel}
				supportModel.SupportEscalation = supportEscalationModel
				supportModel.SupportType = core.StringPtr("testString")

				// Construct an instance of the LearnMoreLinks model
				learnMoreLinksModel := new(catalogmanagementv1.LearnMoreLinks)
				learnMoreLinksModel.FirstParty = core.StringPtr("testString")
				learnMoreLinksModel.ThirdParty = core.StringPtr("testString")

				// Construct an instance of the Constraint model
				constraintModel := new(catalogmanagementv1.Constraint)
				constraintModel.Type = core.StringPtr("testString")
				constraintModel.Rule = "testString"

				// Construct an instance of the Badge model
				badgeModel := new(catalogmanagementv1.Badge)
				badgeModel.ID = core.StringPtr("testString")
				badgeModel.Label = core.StringPtr("testString")
				badgeModel.LabelI18n = map[string]string{"key1": "testString"}
				badgeModel.Description = core.StringPtr("testString")
				badgeModel.DescriptionI18n = map[string]string{"key1": "testString"}
				badgeModel.Icon = core.StringPtr("testString")
				badgeModel.Authority = core.StringPtr("testString")
				badgeModel.Tag = core.StringPtr("testString")
				badgeModel.LearnMoreLinks = learnMoreLinksModel
				badgeModel.Constraints = []catalogmanagementv1.Constraint{*constraintModel}

				// Construct an instance of the VersionRange model
				versionRangeModel := new(catalogmanagementv1.VersionRange)
				versionRangeModel.Kinds = []string{"testString"}
				versionRangeModel.Version = core.StringPtr("testString")
				versionRangeModel.Flavors = []string{"testString"}

				// Construct an instance of the Plan model
				planModel := new(catalogmanagementv1.Plan)
				planModel.URL = core.StringPtr("testString")
				planModel.CRN = core.StringPtr("testString")
				planModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				planModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				planModel.OfferingID = core.StringPtr("testString")
				planModel.CatalogID = core.StringPtr("testString")
				planModel.Label = core.StringPtr("testString")
				planModel.LabelI18n = map[string]string{"key1": "testString"}
				planModel.Name = core.StringPtr("testString")
				planModel.ShortDescription = core.StringPtr("testString")
				planModel.ShortDescriptionI18n = map[string]string{"key1": "testString"}
				planModel.PricingTags = []string{"testString"}
				planModel.VersionRange = versionRangeModel
				planModel.Features = []catalogmanagementv1.Feature{*featureModel}
				planModel.State = stateModel
				planModel.DeprecatePending = deprecatePendingModel
				planModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				planModel.PublishApproved = core.BoolPtr(true)

				// Construct an instance of the UpdateVersionOptions model
				updateVersionOptionsModel := new(catalogmanagementv1.UpdateVersionOptions)
				updateVersionOptionsModel.VersionLocID = core.StringPtr("testString")
				updateVersionOptionsModel.ID = core.StringPtr("testString")
				updateVersionOptionsModel.Rev = core.StringPtr("testString")
				updateVersionOptionsModel.URL = core.StringPtr("testString")
				updateVersionOptionsModel.CRN = core.StringPtr("testString")
				updateVersionOptionsModel.Label = core.StringPtr("testString")
				updateVersionOptionsModel.LabelI18n = map[string]string{"key1": "testString"}
				updateVersionOptionsModel.Name = core.StringPtr("testString")
				updateVersionOptionsModel.OfferingIconURL = core.StringPtr("testString")
				updateVersionOptionsModel.OfferingDocsURL = core.StringPtr("testString")
				updateVersionOptionsModel.OfferingSupportURL = core.StringPtr("testString")
				updateVersionOptionsModel.Tags = []string{"testString"}
				updateVersionOptionsModel.Keywords = []string{"testString"}
				updateVersionOptionsModel.Rating = ratingModel
				updateVersionOptionsModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				updateVersionOptionsModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				updateVersionOptionsModel.ShortDescription = core.StringPtr("testString")
				updateVersionOptionsModel.ShortDescriptionI18n = map[string]string{"key1": "testString"}
				updateVersionOptionsModel.LongDescription = core.StringPtr("testString")
				updateVersionOptionsModel.LongDescriptionI18n = map[string]string{"key1": "testString"}
				updateVersionOptionsModel.Features = []catalogmanagementv1.Feature{*featureModel}
				updateVersionOptionsModel.Kinds = []catalogmanagementv1.Kind{*kindModel}
				updateVersionOptionsModel.Publish = publishObjectModel
				updateVersionOptionsModel.PcManaged = core.BoolPtr(true)
				updateVersionOptionsModel.PublishApproved = core.BoolPtr(true)
				updateVersionOptionsModel.ShareWithAll = core.BoolPtr(true)
				updateVersionOptionsModel.ShareWithIBM = core.BoolPtr(true)
				updateVersionOptionsModel.ShareEnabled = core.BoolPtr(true)
				updateVersionOptionsModel.PublicOriginalCRN = core.StringPtr("testString")
				updateVersionOptionsModel.PublishPublicCRN = core.StringPtr("testString")
				updateVersionOptionsModel.PortalApprovalRecord = core.StringPtr("testString")
				updateVersionOptionsModel.PortalUIURL = core.StringPtr("testString")
				updateVersionOptionsModel.CatalogID = core.StringPtr("testString")
				updateVersionOptionsModel.CatalogName = core.StringPtr("testString")
				updateVersionOptionsModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				updateVersionOptionsModel.Disclaimer = core.StringPtr("testString")
				updateVersionOptionsModel.Hidden = core.BoolPtr(true)
				updateVersionOptionsModel.Provider = core.StringPtr("testString")
				updateVersionOptionsModel.ProviderInfo = providerInfoModel
				updateVersionOptionsModel.RepoInfo = repoInfoModel
				updateVersionOptionsModel.ImagePullKeys = []catalogmanagementv1.ImagePullKey{*imagePullKeyModel}
				updateVersionOptionsModel.Support = supportModel
				updateVersionOptionsModel.Media = []catalogmanagementv1.MediaItem{*mediaItemModel}
				updateVersionOptionsModel.DeprecatePending = deprecatePendingModel
				updateVersionOptionsModel.ProductKind = core.StringPtr("testString")
				updateVersionOptionsModel.Badges = []catalogmanagementv1.Badge{*badgeModel}
				updateVersionOptionsModel.Plans = []catalogmanagementv1.Plan{*planModel}
				updateVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.UpdateVersionWithContext(ctx, updateVersionOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.UpdateVersion(updateVersionOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.UpdateVersionWithContext(ctx, updateVersionOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updateVersionPath))
					Expect(req.Method).To(Equal("PUT"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "name": "Name", "offering_icon_url": "OfferingIconURL", "offering_docs_url": "OfferingDocsURL", "offering_support_url": "OfferingSupportURL", "tags": ["Tags"], "keywords": ["Keywords"], "rating": {"one_star_count": 12, "two_star_count": 12, "three_star_count": 14, "four_star_count": 13}, "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "kinds": [{"id": "ID", "format_kind": "FormatKind", "format_kind_label": "FormatKindLabel", "install_kind": "InstallKind", "install_kind_label": "InstallKindLabel", "target_kind": "TargetKind", "target_kind_label": "TargetKindLabel", "metadata": {"anyKey": "anyValue"}, "tags": ["Tags"], "additional_features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "versions": [{"id": "ID", "_rev": "Rev", "crn": "CRN", "version": "Version", "flavor": {"name": "Name", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "index": 5}, "sha": "Sha", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "offering_id": "OfferingID", "catalog_id": "CatalogID", "kind_id": "KindID", "tags": ["Tags"], "repo_url": "RepoURL", "source_url": "SourceURL", "tgz_url": "TgzURL", "configuration": [{"key": "Key", "type": "Type", "default_value": "anyValue", "display_name": "DisplayName", "value_constraint": "ValueConstraint", "description": "Description", "required": true, "options": ["anyValue"], "hidden": true, "custom_config": {"type": "Type", "grouping": "Grouping", "original_grouping": "OriginalGrouping", "grouping_index": 13, "config_constraints": {"anyKey": "anyValue"}, "associations": {"parameters": [{"name": "Name", "optionsRefresh": true}]}}, "type_metadata": "TypeMetadata"}], "outputs": [{"key": "Key", "description": "Description"}], "iam_permissions": [{"service_name": "ServiceName", "role_crns": ["RoleCrns"], "resources": [{"name": "Name", "description": "Description", "role_crns": ["RoleCrns"]}]}], "metadata": {"anyKey": "anyValue"}, "validation": {"validated": "2019-01-01T12:00:00.000Z", "requested": "2019-01-01T12:00:00.000Z", "state": "State", "last_operation": "LastOperation", "target": {"anyKey": "anyValue"}, "message": "Message"}, "required_resources": [{"type": "mem", "value": "anyValue"}], "single_instance": true, "schematics_env_values": {"value": "[{\"name\": \"TF_LOG\",\"value\": \"TRACE\",\"secure\": false,\"hidden\": false}]", "sm_ref": "cmsm_v1:{\"name\": \"envVarSecret\",\"id\":\"1234567890\",\"service_id\":\"crn:v1:bluemix:public:secrets-manager:eu-gb:a/1234567890:1234567890::\",\"service_name\":\"My SM Instance\",\"group_id\":\"1234567890\",\"group_name\":\"My SM Group\",\"resource_group_id\":\"1234567890\",\"region\":\"eu-gb\",\"type\":\"arbitrary\"}"}, "install": {"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}, "pre_install": [{"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}], "scripts": {"mapKey": {"short_description": "ShortDescription", "type": "ansible", "path": "scripts/validate-post-ansible-playbook.yaml", "stage": "pre", "action": "validate"}}, "entitlement": {"provider_name": "ProviderName", "provider_id": "ProviderID", "product_id": "ProductID", "part_numbers": ["PartNumbers"], "image_repo_name": "ImageRepoName"}, "licenses": [{"id": "ID", "name": "Name", "type": "Type", "url": "URL", "description": "Description"}], "image_manifest_url": "ImageManifestURL", "deprecated": true, "package_version": "PackageVersion", "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "version_locator": "VersionLocator", "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "whitelisted_accounts": ["WhitelistedAccounts"], "image_pull_key_name": "ImagePullKeyName", "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "solution_info": {"architecture_diagrams": [{"diagram": {"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "cost_estimate": {"version": "Version", "currency": "Currency", "projects": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "pastBreakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "breakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "diff": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}}], "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}, "totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "pastTotalHourlyCost": "PastTotalHourlyCost", "pastTotalMonthlyCost": "PastTotalMonthlyCost", "diffTotalHourlyCost": "DiffTotalHourlyCost", "diffTotalMonthlyCost": "DiffTotalMonthlyCost", "timeGenerated": "2019-01-01T12:00:00.000Z"}, "dependencies": [{"catalog_id": "CatalogID", "id": "ID", "name": "Name", "kind": "Kind", "version": "Version", "description": "Description", "default_flavor": "DefaultFlavor", "flavors": ["Flavors"], "optional": true, "on_by_default": false}], "install_type": "InstallType"}, "is_consumable": true, "compliance_v3": {"authority": "Authority", "claims": {"profiles": [{"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}], "controls": [{"profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "names": ["Names"]}]}, "evaluations": [{"scan_id": "ScanID", "account_id": "AccountID", "profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "result": {"failure_count": 12, "scan_time": "2019-01-01T12:00:00.000Z", "error_message": "ErrorMessage", "complete_scan": true, "unscanned_resources": ["UnscannedResources"]}, "controls": [{"id": "ID", "name": "Name", "description": "Description", "specifications": [{"id": "ID", "description": "Description", "component_name": "ComponentName", "assessments": [{"id": "ID", "description": "Description", "version": "Version", "type": "Type", "method": "Method", "ui_href": "UIHref"}], "ui_href": "UIHref"}], "failure_count": 12, "pass_count": 9, "parent": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "parent_name": "ParentName", "specifications": [{"id": "ID", "description": "Description", "component_name": "ComponentName", "assessments": [{"id": "ID", "description": "Description", "version": "Version", "type": "Type", "method": "Method", "ui_href": "UIHref"}], "ui_href": "UIHref"}], "ui_href": "UIHref"}, "ui_href": "UIHref"}]}]}, "change_notices": {"breaking": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "new": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "update": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}]}, "plan_ids": ["PlanIds"], "stack": {"anyKey": "anyValue"}, "minimum_compatible_version": "MinimumCompatibleVersion"}], "all_versions": {"first": {"href": "Href", "start": "Start"}, "next": {"href": "Href", "start": "Start"}}}], "publish": {"pc_managed": false, "approval_type": "ApprovalType", "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "original_crn": "OriginalCRN", "public_crn": "PublicCRN", "approval_record": {"anyKey": "anyValue"}, "permit_ibm_public_publish": true, "ibm_approved": false, "public_approved": true}, "pc_managed": false, "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "public_original_crn": "PublicOriginalCRN", "publish_public_crn": "PublishPublicCRN", "portal_approval_record": "PortalApprovalRecord", "portal_ui_url": "PortalUIURL", "catalog_id": "CatalogID", "catalog_name": "CatalogName", "metadata": {"anyKey": "anyValue"}, "disclaimer": "Disclaimer", "hidden": true, "provider": "Provider", "provider_info": {"id": "ID", "name": "Name"}, "repo_info": {"token": "Token", "type": "Type"}, "image_pull_keys": [{"name": "Name", "value": "Value", "description": "Description"}], "support": {"url": "URL", "process": "Process", "process_i18n": {"mapKey": "Inner"}, "locations": ["Locations"], "support_details": [{"type": "Type", "contact": "Contact", "response_wait_time": {"value": 5, "type": "Type"}, "availability": {"times": [{"day": 3, "start_time": "StartTime", "end_time": "EndTime"}], "timezone": "Timezone", "always_available": false}}], "support_escalation": {"escalation_wait_time": {"value": 5, "type": "Type"}, "response_wait_time": {"value": 5, "type": "Type"}, "contact": "Contact"}, "support_type": "SupportType"}, "media": [{"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}], "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "product_kind": "ProductKind", "badges": [{"id": "ID", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}, "icon": "Icon", "authority": "Authority", "tag": "Tag", "learn_more_links": {"first_party": "FirstParty", "third_party": "ThirdParty"}, "constraints": [{"type": "Type", "rule": "anyValue"}]}], "plans": [{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "offering_id": "OfferingID", "catalog_id": "CatalogID", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "name": "Name", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "pricing_tags": ["PricingTags"], "version_range": {"kinds": ["Kinds"], "version": "Version", "flavors": ["Flavors"]}, "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "metadata": {"anyKey": "anyValue"}, "publish_approved": false}]}`)
				}))
			})
			It(`Invoke UpdateVersion successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.UpdateVersion(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the Rating model
				ratingModel := new(catalogmanagementv1.Rating)
				ratingModel.OneStarCount = core.Int64Ptr(int64(38))
				ratingModel.TwoStarCount = core.Int64Ptr(int64(38))
				ratingModel.ThreeStarCount = core.Int64Ptr(int64(38))
				ratingModel.FourStarCount = core.Int64Ptr(int64(38))

				// Construct an instance of the Feature model
				featureModel := new(catalogmanagementv1.Feature)
				featureModel.Title = core.StringPtr("testString")
				featureModel.TitleI18n = map[string]string{"key1": "testString"}
				featureModel.Description = core.StringPtr("testString")
				featureModel.DescriptionI18n = map[string]string{"key1": "testString"}

				// Construct an instance of the Flavor model
				flavorModel := new(catalogmanagementv1.Flavor)
				flavorModel.Name = core.StringPtr("testString")
				flavorModel.Label = core.StringPtr("testString")
				flavorModel.LabelI18n = map[string]string{"key1": "testString"}
				flavorModel.Index = core.Int64Ptr(int64(38))

				// Construct an instance of the RenderTypeAssociationsParametersItem model
				renderTypeAssociationsParametersItemModel := new(catalogmanagementv1.RenderTypeAssociationsParametersItem)
				renderTypeAssociationsParametersItemModel.Name = core.StringPtr("testString")
				renderTypeAssociationsParametersItemModel.OptionsRefresh = core.BoolPtr(true)

				// Construct an instance of the RenderTypeAssociations model
				renderTypeAssociationsModel := new(catalogmanagementv1.RenderTypeAssociations)
				renderTypeAssociationsModel.Parameters = []catalogmanagementv1.RenderTypeAssociationsParametersItem{*renderTypeAssociationsParametersItemModel}

				// Construct an instance of the RenderType model
				renderTypeModel := new(catalogmanagementv1.RenderType)
				renderTypeModel.Type = core.StringPtr("testString")
				renderTypeModel.Grouping = core.StringPtr("testString")
				renderTypeModel.OriginalGrouping = core.StringPtr("testString")
				renderTypeModel.GroupingIndex = core.Int64Ptr(int64(38))
				renderTypeModel.ConfigConstraints = map[string]interface{}{"anyKey": "anyValue"}
				renderTypeModel.Associations = renderTypeAssociationsModel

				// Construct an instance of the Configuration model
				configurationModel := new(catalogmanagementv1.Configuration)
				configurationModel.Key = core.StringPtr("testString")
				configurationModel.Type = core.StringPtr("testString")
				configurationModel.DefaultValue = "testString"
				configurationModel.DisplayName = core.StringPtr("testString")
				configurationModel.ValueConstraint = core.StringPtr("testString")
				configurationModel.Description = core.StringPtr("testString")
				configurationModel.Required = core.BoolPtr(true)
				configurationModel.Options = []interface{}{"testString"}
				configurationModel.Hidden = core.BoolPtr(true)
				configurationModel.CustomConfig = renderTypeModel
				configurationModel.TypeMetadata = core.StringPtr("testString")

				// Construct an instance of the Output model
				outputModel := new(catalogmanagementv1.Output)
				outputModel.Key = core.StringPtr("testString")
				outputModel.Description = core.StringPtr("testString")

				// Construct an instance of the IamResource model
				iamResourceModel := new(catalogmanagementv1.IamResource)
				iamResourceModel.Name = core.StringPtr("testString")
				iamResourceModel.Description = core.StringPtr("testString")
				iamResourceModel.RoleCrns = []string{"testString"}

				// Construct an instance of the IamPermission model
				iamPermissionModel := new(catalogmanagementv1.IamPermission)
				iamPermissionModel.ServiceName = core.StringPtr("testString")
				iamPermissionModel.RoleCrns = []string{"testString"}
				iamPermissionModel.Resources = []catalogmanagementv1.IamResource{*iamResourceModel}

				// Construct an instance of the Validation model
				validationModel := new(catalogmanagementv1.Validation)
				validationModel.Validated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				validationModel.Requested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				validationModel.State = core.StringPtr("testString")
				validationModel.LastOperation = core.StringPtr("testString")
				validationModel.Target = map[string]interface{}{"anyKey": "anyValue"}
				validationModel.Message = core.StringPtr("testString")

				// Construct an instance of the Resource model
				resourceModel := new(catalogmanagementv1.Resource)
				resourceModel.Type = core.StringPtr("mem")
				resourceModel.Value = "testString"

				// Construct an instance of the SchematicsEnvValues model
				schematicsEnvValuesModel := new(catalogmanagementv1.SchematicsEnvValues)
				schematicsEnvValuesModel.Value = core.StringPtr("[{\"name\": \"TF_LOG\",\"value\": \"TRACE\",\"secure\": false,\"hidden\": false}]")
				schematicsEnvValuesModel.SmRef = core.StringPtr("cmsm_v1:{\"name\": \"envVarSecret\",\"id\":\"1234567890\",\"service_id\":\"crn:v1:bluemix:public:secrets-manager:eu-gb:a/1234567890:1234567890::\",\"service_name\":\"My SM Instance\",\"group_id\":\"1234567890\",\"group_name\":\"My SM Group\",\"resource_group_id\":\"1234567890\",\"region\":\"eu-gb\",\"type\":\"arbitrary\"}")

				// Construct an instance of the Script model
				scriptModel := new(catalogmanagementv1.Script)
				scriptModel.Instructions = core.StringPtr("testString")
				scriptModel.InstructionsI18n = map[string]string{"key1": "testString"}
				scriptModel.Script = core.StringPtr("testString")
				scriptModel.ScriptPermission = core.StringPtr("testString")
				scriptModel.DeleteScript = core.StringPtr("testString")
				scriptModel.Scope = core.StringPtr("testString")

				// Construct an instance of the ScriptRef model
				scriptRefModel := new(catalogmanagementv1.ScriptRef)
				scriptRefModel.ShortDescription = core.StringPtr("testString")
				scriptRefModel.Type = core.StringPtr("ansible")
				scriptRefModel.Path = core.StringPtr("scripts/validate-post-ansible-playbook.yaml")
				scriptRefModel.Stage = core.StringPtr("pre")
				scriptRefModel.Action = core.StringPtr("validate")

				// Construct an instance of the VersionEntitlement model
				versionEntitlementModel := new(catalogmanagementv1.VersionEntitlement)
				versionEntitlementModel.ProviderName = core.StringPtr("testString")
				versionEntitlementModel.ProviderID = core.StringPtr("testString")
				versionEntitlementModel.ProductID = core.StringPtr("testString")
				versionEntitlementModel.PartNumbers = []string{"testString"}
				versionEntitlementModel.ImageRepoName = core.StringPtr("testString")

				// Construct an instance of the License model
				licenseModel := new(catalogmanagementv1.License)
				licenseModel.ID = core.StringPtr("testString")
				licenseModel.Name = core.StringPtr("testString")
				licenseModel.Type = core.StringPtr("testString")
				licenseModel.URL = core.StringPtr("testString")
				licenseModel.Description = core.StringPtr("testString")

				// Construct an instance of the State model
				stateModel := new(catalogmanagementv1.State)
				stateModel.Current = core.StringPtr("testString")
				stateModel.CurrentEntered = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Pending = core.StringPtr("testString")
				stateModel.PendingRequested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Previous = core.StringPtr("testString")

				// Construct an instance of the DeprecatePending model
				deprecatePendingModel := new(catalogmanagementv1.DeprecatePending)
				deprecatePendingModel.DeprecateDate = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				deprecatePendingModel.DeprecateState = core.StringPtr("testString")
				deprecatePendingModel.Description = core.StringPtr("testString")

				// Construct an instance of the URLProxy model
				urlProxyModel := new(catalogmanagementv1.URLProxy)
				urlProxyModel.URL = core.StringPtr("testString")
				urlProxyModel.Sha = core.StringPtr("testString")

				// Construct an instance of the MediaItem model
				mediaItemModel := new(catalogmanagementv1.MediaItem)
				mediaItemModel.URL = core.StringPtr("testString")
				mediaItemModel.APIURL = core.StringPtr("testString")
				mediaItemModel.URLProxy = urlProxyModel
				mediaItemModel.Caption = core.StringPtr("testString")
				mediaItemModel.CaptionI18n = map[string]string{"key1": "testString"}
				mediaItemModel.Type = core.StringPtr("testString")
				mediaItemModel.ThumbnailURL = core.StringPtr("testString")

				// Construct an instance of the ArchitectureDiagram model
				architectureDiagramModel := new(catalogmanagementv1.ArchitectureDiagram)
				architectureDiagramModel.Diagram = mediaItemModel
				architectureDiagramModel.Description = core.StringPtr("testString")
				architectureDiagramModel.DescriptionI18n = map[string]string{"key1": "testString"}

				// Construct an instance of the CostComponent model
				costComponentModel := new(catalogmanagementv1.CostComponent)
				costComponentModel.Name = core.StringPtr("testString")
				costComponentModel.Unit = core.StringPtr("testString")
				costComponentModel.HourlyQuantity = core.StringPtr("testString")
				costComponentModel.MonthlyQuantity = core.StringPtr("testString")
				costComponentModel.Price = core.StringPtr("testString")
				costComponentModel.HourlyCost = core.StringPtr("testString")
				costComponentModel.MonthlyCost = core.StringPtr("testString")

				// Construct an instance of the CostResource model
				costResourceModel := new(catalogmanagementv1.CostResource)
				costResourceModel.Name = core.StringPtr("testString")
				costResourceModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				costResourceModel.HourlyCost = core.StringPtr("testString")
				costResourceModel.MonthlyCost = core.StringPtr("testString")
				costResourceModel.CostComponents = []catalogmanagementv1.CostComponent{*costComponentModel}

				// Construct an instance of the CostBreakdown model
				costBreakdownModel := new(catalogmanagementv1.CostBreakdown)
				costBreakdownModel.TotalHourlyCost = core.StringPtr("testString")
				costBreakdownModel.TotalMonthlyCost = core.StringPtr("testString")
				costBreakdownModel.Resources = []catalogmanagementv1.CostResource{*costResourceModel}

				// Construct an instance of the CostSummary model
				costSummaryModel := new(catalogmanagementv1.CostSummary)
				costSummaryModel.TotalDetectedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalSupportedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalUnsupportedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalUsageBasedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalNoPriceResources = core.Int64Ptr(int64(38))
				costSummaryModel.UnsupportedResourceCounts = map[string]int64{"key1": int64(38)}
				costSummaryModel.NoPriceResourceCounts = map[string]int64{"key1": int64(38)}

				// Construct an instance of the Project model
				projectModel := new(catalogmanagementv1.Project)
				projectModel.Name = core.StringPtr("testString")
				projectModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				projectModel.PastBreakdown = costBreakdownModel
				projectModel.Breakdown = costBreakdownModel
				projectModel.Diff = costBreakdownModel
				projectModel.Summary = costSummaryModel

				// Construct an instance of the CostEstimate model
				costEstimateModel := new(catalogmanagementv1.CostEstimate)
				costEstimateModel.Version = core.StringPtr("testString")
				costEstimateModel.Currency = core.StringPtr("testString")
				costEstimateModel.Projects = []catalogmanagementv1.Project{*projectModel}
				costEstimateModel.Summary = costSummaryModel
				costEstimateModel.TotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.TotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.PastTotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.PastTotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.DiffTotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.DiffTotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.TimeGenerated = CreateMockDateTime("2019-01-01T12:00:00.000Z")

				// Construct an instance of the OfferingReference model
				offeringReferenceModel := new(catalogmanagementv1.OfferingReference)
				offeringReferenceModel.CatalogID = core.StringPtr("testString")
				offeringReferenceModel.ID = core.StringPtr("testString")
				offeringReferenceModel.Name = core.StringPtr("testString")
				offeringReferenceModel.Kind = core.StringPtr("testString")
				offeringReferenceModel.Version = core.StringPtr("testString")
				offeringReferenceModel.Description = core.StringPtr("testString")
				offeringReferenceModel.DefaultFlavor = core.StringPtr("testString")
				offeringReferenceModel.Flavors = []string{"testString"}
				offeringReferenceModel.Optional = core.BoolPtr(true)
				offeringReferenceModel.OnByDefault = core.BoolPtr(true)

				// Construct an instance of the SolutionInfo model
				solutionInfoModel := new(catalogmanagementv1.SolutionInfo)
				solutionInfoModel.ArchitectureDiagrams = []catalogmanagementv1.ArchitectureDiagram{*architectureDiagramModel}
				solutionInfoModel.Features = []catalogmanagementv1.Feature{*featureModel}
				solutionInfoModel.CostEstimate = costEstimateModel
				solutionInfoModel.Dependencies = []catalogmanagementv1.OfferingReference{*offeringReferenceModel}
				solutionInfoModel.InstallType = core.StringPtr("testString")

				// Construct an instance of the SccProfile model
				sccProfileModel := new(catalogmanagementv1.SccProfile)
				sccProfileModel.ID = core.StringPtr("testString")
				sccProfileModel.Name = core.StringPtr("testString")
				sccProfileModel.Version = core.StringPtr("testString")
				sccProfileModel.Description = core.StringPtr("testString")
				sccProfileModel.Type = core.StringPtr("testString")
				sccProfileModel.UIHref = core.StringPtr("testString")

				// Construct an instance of the ClaimedControl model
				claimedControlModel := new(catalogmanagementv1.ClaimedControl)
				claimedControlModel.Profile = sccProfileModel
				claimedControlModel.Names = []string{"testString"}

				// Construct an instance of the Claims model
				claimsModel := new(catalogmanagementv1.Claims)
				claimsModel.Profiles = []catalogmanagementv1.SccProfile{*sccProfileModel}
				claimsModel.Controls = []catalogmanagementv1.ClaimedControl{*claimedControlModel}

				// Construct an instance of the Result model
				resultModel := new(catalogmanagementv1.Result)
				resultModel.FailureCount = core.Int64Ptr(int64(38))
				resultModel.ScanTime = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				resultModel.ErrorMessage = core.StringPtr("testString")
				resultModel.CompleteScan = core.BoolPtr(true)
				resultModel.UnscannedResources = []string{"testString"}

				// Construct an instance of the SccAssessment model
				sccAssessmentModel := new(catalogmanagementv1.SccAssessment)
				sccAssessmentModel.ID = core.StringPtr("testString")
				sccAssessmentModel.Description = core.StringPtr("testString")
				sccAssessmentModel.Version = core.StringPtr("testString")
				sccAssessmentModel.Type = core.StringPtr("testString")
				sccAssessmentModel.Method = core.StringPtr("testString")
				sccAssessmentModel.UIHref = core.StringPtr("testString")

				// Construct an instance of the SccSpecification model
				sccSpecificationModel := new(catalogmanagementv1.SccSpecification)
				sccSpecificationModel.ID = core.StringPtr("testString")
				sccSpecificationModel.Description = core.StringPtr("testString")
				sccSpecificationModel.ComponentName = core.StringPtr("testString")
				sccSpecificationModel.Assessments = []catalogmanagementv1.SccAssessment{*sccAssessmentModel}
				sccSpecificationModel.UIHref = core.StringPtr("testString")

				// Construct an instance of the SccControl model
				sccControlModel := new(catalogmanagementv1.SccControl)
				sccControlModel.ID = core.StringPtr("testString")
				sccControlModel.Name = core.StringPtr("testString")
				sccControlModel.Version = core.StringPtr("testString")
				sccControlModel.Description = core.StringPtr("testString")
				sccControlModel.Profile = sccProfileModel
				sccControlModel.ParentName = core.StringPtr("testString")
				sccControlModel.Specifications = []catalogmanagementv1.SccSpecification{*sccSpecificationModel}
				sccControlModel.UIHref = core.StringPtr("testString")

				// Construct an instance of the EvaluatedControl model
				evaluatedControlModel := new(catalogmanagementv1.EvaluatedControl)
				evaluatedControlModel.ID = core.StringPtr("testString")
				evaluatedControlModel.Name = core.StringPtr("testString")
				evaluatedControlModel.Description = core.StringPtr("testString")
				evaluatedControlModel.Specifications = []catalogmanagementv1.SccSpecification{*sccSpecificationModel}
				evaluatedControlModel.FailureCount = core.Int64Ptr(int64(38))
				evaluatedControlModel.PassCount = core.Int64Ptr(int64(38))
				evaluatedControlModel.Parent = sccControlModel
				evaluatedControlModel.UIHref = core.StringPtr("testString")

				// Construct an instance of the Evaluation model
				evaluationModel := new(catalogmanagementv1.Evaluation)
				evaluationModel.ScanID = core.StringPtr("testString")
				evaluationModel.AccountID = core.StringPtr("testString")
				evaluationModel.Profile = sccProfileModel
				evaluationModel.Result = resultModel
				evaluationModel.Controls = []catalogmanagementv1.EvaluatedControl{*evaluatedControlModel}

				// Construct an instance of the Compliance model
				complianceModel := new(catalogmanagementv1.Compliance)
				complianceModel.Authority = core.StringPtr("testString")
				complianceModel.Claims = claimsModel
				complianceModel.Evaluations = []catalogmanagementv1.Evaluation{*evaluationModel}

				// Construct an instance of the ChangeNotices model
				changeNoticesModel := new(catalogmanagementv1.ChangeNotices)
				changeNoticesModel.Breaking = []catalogmanagementv1.Feature{*featureModel}
				changeNoticesModel.New = []catalogmanagementv1.Feature{*featureModel}
				changeNoticesModel.Update = []catalogmanagementv1.Feature{*featureModel}

				// Construct an instance of the Version model
				versionModel := new(catalogmanagementv1.Version)
				versionModel.CRN = core.StringPtr("testString")
				versionModel.Version = core.StringPtr("testString")
				versionModel.Flavor = flavorModel
				versionModel.Sha = core.StringPtr("testString")
				versionModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				versionModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				versionModel.OfferingID = core.StringPtr("testString")
				versionModel.CatalogID = core.StringPtr("testString")
				versionModel.KindID = core.StringPtr("testString")
				versionModel.Tags = []string{"testString"}
				versionModel.RepoURL = core.StringPtr("testString")
				versionModel.SourceURL = core.StringPtr("testString")
				versionModel.TgzURL = core.StringPtr("testString")
				versionModel.Configuration = []catalogmanagementv1.Configuration{*configurationModel}
				versionModel.Outputs = []catalogmanagementv1.Output{*outputModel}
				versionModel.IamPermissions = []catalogmanagementv1.IamPermission{*iamPermissionModel}
				versionModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				versionModel.Validation = validationModel
				versionModel.RequiredResources = []catalogmanagementv1.Resource{*resourceModel}
				versionModel.SingleInstance = core.BoolPtr(true)
				versionModel.SchematicsEnvValues = schematicsEnvValuesModel
				versionModel.Install = scriptModel
				versionModel.PreInstall = []catalogmanagementv1.Script{*scriptModel}
				versionModel.Scripts = map[string]catalogmanagementv1.ScriptRef{"key1": *scriptRefModel}
				versionModel.Entitlement = versionEntitlementModel
				versionModel.Licenses = []catalogmanagementv1.License{*licenseModel}
				versionModel.ImageManifestURL = core.StringPtr("testString")
				versionModel.Deprecated = core.BoolPtr(true)
				versionModel.PackageVersion = core.StringPtr("testString")
				versionModel.State = stateModel
				versionModel.VersionLocator = core.StringPtr("testString")
				versionModel.LongDescription = core.StringPtr("testString")
				versionModel.LongDescriptionI18n = map[string]string{"key1": "testString"}
				versionModel.WhitelistedAccounts = []string{"testString"}
				versionModel.ImagePullKeyName = core.StringPtr("testString")
				versionModel.DeprecatePending = deprecatePendingModel
				versionModel.SolutionInfo = solutionInfoModel
				versionModel.IsConsumable = core.BoolPtr(true)
				versionModel.ComplianceV3 = complianceModel
				versionModel.ChangeNotices = changeNoticesModel
				versionModel.PlanIds = []string{"testString"}
				versionModel.Stack = map[string]interface{}{"anyKey": "anyValue"}
				versionModel.MinimumCompatibleVersion = core.StringPtr("testString")
				versionModel.Scripts["foo"] = *scriptRefModel

				// Construct an instance of the PaginationTokenLink model
				paginationTokenLinkModel := new(catalogmanagementv1.PaginationTokenLink)
				paginationTokenLinkModel.Href = core.StringPtr("testString")
				paginationTokenLinkModel.Start = core.StringPtr("testString")

				// Construct an instance of the KindAllVersions model
				kindAllVersionsModel := new(catalogmanagementv1.KindAllVersions)
				kindAllVersionsModel.First = paginationTokenLinkModel
				kindAllVersionsModel.Next = paginationTokenLinkModel

				// Construct an instance of the Kind model
				kindModel := new(catalogmanagementv1.Kind)
				kindModel.ID = core.StringPtr("testString")
				kindModel.FormatKind = core.StringPtr("testString")
				kindModel.FormatKindLabel = core.StringPtr("testString")
				kindModel.InstallKind = core.StringPtr("testString")
				kindModel.InstallKindLabel = core.StringPtr("testString")
				kindModel.TargetKind = core.StringPtr("testString")
				kindModel.TargetKindLabel = core.StringPtr("testString")
				kindModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				kindModel.Tags = []string{"testString"}
				kindModel.AdditionalFeatures = []catalogmanagementv1.Feature{*featureModel}
				kindModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				kindModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				kindModel.Versions = []catalogmanagementv1.Version{*versionModel}
				kindModel.AllVersions = kindAllVersionsModel

				// Construct an instance of the PublishObject model
				publishObjectModel := new(catalogmanagementv1.PublishObject)
				publishObjectModel.PcManaged = core.BoolPtr(true)
				publishObjectModel.ApprovalType = core.StringPtr("testString")
				publishObjectModel.PublishApproved = core.BoolPtr(true)
				publishObjectModel.ShareWithAll = core.BoolPtr(true)
				publishObjectModel.ShareWithIBM = core.BoolPtr(true)
				publishObjectModel.ShareEnabled = core.BoolPtr(true)
				publishObjectModel.OriginalCRN = core.StringPtr("testString")
				publishObjectModel.PublicCRN = core.StringPtr("testString")
				publishObjectModel.ApprovalRecord = map[string]interface{}{"anyKey": "anyValue"}
				publishObjectModel.PermitIBMPublicPublish = core.BoolPtr(true)
				publishObjectModel.IBMApproved = core.BoolPtr(true)
				publishObjectModel.PublicApproved = core.BoolPtr(true)

				// Construct an instance of the ProviderInfo model
				providerInfoModel := new(catalogmanagementv1.ProviderInfo)
				providerInfoModel.ID = core.StringPtr("testString")
				providerInfoModel.Name = core.StringPtr("testString")

				// Construct an instance of the RepoInfo model
				repoInfoModel := new(catalogmanagementv1.RepoInfo)
				repoInfoModel.Token = core.StringPtr("testString")
				repoInfoModel.Type = core.StringPtr("testString")

				// Construct an instance of the ImagePullKey model
				imagePullKeyModel := new(catalogmanagementv1.ImagePullKey)
				imagePullKeyModel.Name = core.StringPtr("testString")
				imagePullKeyModel.Value = core.StringPtr("testString")
				imagePullKeyModel.Description = core.StringPtr("testString")

				// Construct an instance of the SupportWaitTime model
				supportWaitTimeModel := new(catalogmanagementv1.SupportWaitTime)
				supportWaitTimeModel.Value = core.Int64Ptr(int64(38))
				supportWaitTimeModel.Type = core.StringPtr("testString")

				// Construct an instance of the SupportTime model
				supportTimeModel := new(catalogmanagementv1.SupportTime)
				supportTimeModel.Day = core.Int64Ptr(int64(38))
				supportTimeModel.StartTime = core.StringPtr("testString")
				supportTimeModel.EndTime = core.StringPtr("testString")

				// Construct an instance of the SupportAvailability model
				supportAvailabilityModel := new(catalogmanagementv1.SupportAvailability)
				supportAvailabilityModel.Times = []catalogmanagementv1.SupportTime{*supportTimeModel}
				supportAvailabilityModel.Timezone = core.StringPtr("testString")
				supportAvailabilityModel.AlwaysAvailable = core.BoolPtr(true)

				// Construct an instance of the SupportDetail model
				supportDetailModel := new(catalogmanagementv1.SupportDetail)
				supportDetailModel.Type = core.StringPtr("testString")
				supportDetailModel.Contact = core.StringPtr("testString")
				supportDetailModel.ResponseWaitTime = supportWaitTimeModel
				supportDetailModel.Availability = supportAvailabilityModel

				// Construct an instance of the SupportEscalation model
				supportEscalationModel := new(catalogmanagementv1.SupportEscalation)
				supportEscalationModel.EscalationWaitTime = supportWaitTimeModel
				supportEscalationModel.ResponseWaitTime = supportWaitTimeModel
				supportEscalationModel.Contact = core.StringPtr("testString")

				// Construct an instance of the Support model
				supportModel := new(catalogmanagementv1.Support)
				supportModel.URL = core.StringPtr("testString")
				supportModel.Process = core.StringPtr("testString")
				supportModel.ProcessI18n = map[string]string{"key1": "testString"}
				supportModel.Locations = []string{"testString"}
				supportModel.SupportDetails = []catalogmanagementv1.SupportDetail{*supportDetailModel}
				supportModel.SupportEscalation = supportEscalationModel
				supportModel.SupportType = core.StringPtr("testString")

				// Construct an instance of the LearnMoreLinks model
				learnMoreLinksModel := new(catalogmanagementv1.LearnMoreLinks)
				learnMoreLinksModel.FirstParty = core.StringPtr("testString")
				learnMoreLinksModel.ThirdParty = core.StringPtr("testString")

				// Construct an instance of the Constraint model
				constraintModel := new(catalogmanagementv1.Constraint)
				constraintModel.Type = core.StringPtr("testString")
				constraintModel.Rule = "testString"

				// Construct an instance of the Badge model
				badgeModel := new(catalogmanagementv1.Badge)
				badgeModel.ID = core.StringPtr("testString")
				badgeModel.Label = core.StringPtr("testString")
				badgeModel.LabelI18n = map[string]string{"key1": "testString"}
				badgeModel.Description = core.StringPtr("testString")
				badgeModel.DescriptionI18n = map[string]string{"key1": "testString"}
				badgeModel.Icon = core.StringPtr("testString")
				badgeModel.Authority = core.StringPtr("testString")
				badgeModel.Tag = core.StringPtr("testString")
				badgeModel.LearnMoreLinks = learnMoreLinksModel
				badgeModel.Constraints = []catalogmanagementv1.Constraint{*constraintModel}

				// Construct an instance of the VersionRange model
				versionRangeModel := new(catalogmanagementv1.VersionRange)
				versionRangeModel.Kinds = []string{"testString"}
				versionRangeModel.Version = core.StringPtr("testString")
				versionRangeModel.Flavors = []string{"testString"}

				// Construct an instance of the Plan model
				planModel := new(catalogmanagementv1.Plan)
				planModel.URL = core.StringPtr("testString")
				planModel.CRN = core.StringPtr("testString")
				planModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				planModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				planModel.OfferingID = core.StringPtr("testString")
				planModel.CatalogID = core.StringPtr("testString")
				planModel.Label = core.StringPtr("testString")
				planModel.LabelI18n = map[string]string{"key1": "testString"}
				planModel.Name = core.StringPtr("testString")
				planModel.ShortDescription = core.StringPtr("testString")
				planModel.ShortDescriptionI18n = map[string]string{"key1": "testString"}
				planModel.PricingTags = []string{"testString"}
				planModel.VersionRange = versionRangeModel
				planModel.Features = []catalogmanagementv1.Feature{*featureModel}
				planModel.State = stateModel
				planModel.DeprecatePending = deprecatePendingModel
				planModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				planModel.PublishApproved = core.BoolPtr(true)

				// Construct an instance of the UpdateVersionOptions model
				updateVersionOptionsModel := new(catalogmanagementv1.UpdateVersionOptions)
				updateVersionOptionsModel.VersionLocID = core.StringPtr("testString")
				updateVersionOptionsModel.ID = core.StringPtr("testString")
				updateVersionOptionsModel.Rev = core.StringPtr("testString")
				updateVersionOptionsModel.URL = core.StringPtr("testString")
				updateVersionOptionsModel.CRN = core.StringPtr("testString")
				updateVersionOptionsModel.Label = core.StringPtr("testString")
				updateVersionOptionsModel.LabelI18n = map[string]string{"key1": "testString"}
				updateVersionOptionsModel.Name = core.StringPtr("testString")
				updateVersionOptionsModel.OfferingIconURL = core.StringPtr("testString")
				updateVersionOptionsModel.OfferingDocsURL = core.StringPtr("testString")
				updateVersionOptionsModel.OfferingSupportURL = core.StringPtr("testString")
				updateVersionOptionsModel.Tags = []string{"testString"}
				updateVersionOptionsModel.Keywords = []string{"testString"}
				updateVersionOptionsModel.Rating = ratingModel
				updateVersionOptionsModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				updateVersionOptionsModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				updateVersionOptionsModel.ShortDescription = core.StringPtr("testString")
				updateVersionOptionsModel.ShortDescriptionI18n = map[string]string{"key1": "testString"}
				updateVersionOptionsModel.LongDescription = core.StringPtr("testString")
				updateVersionOptionsModel.LongDescriptionI18n = map[string]string{"key1": "testString"}
				updateVersionOptionsModel.Features = []catalogmanagementv1.Feature{*featureModel}
				updateVersionOptionsModel.Kinds = []catalogmanagementv1.Kind{*kindModel}
				updateVersionOptionsModel.Publish = publishObjectModel
				updateVersionOptionsModel.PcManaged = core.BoolPtr(true)
				updateVersionOptionsModel.PublishApproved = core.BoolPtr(true)
				updateVersionOptionsModel.ShareWithAll = core.BoolPtr(true)
				updateVersionOptionsModel.ShareWithIBM = core.BoolPtr(true)
				updateVersionOptionsModel.ShareEnabled = core.BoolPtr(true)
				updateVersionOptionsModel.PublicOriginalCRN = core.StringPtr("testString")
				updateVersionOptionsModel.PublishPublicCRN = core.StringPtr("testString")
				updateVersionOptionsModel.PortalApprovalRecord = core.StringPtr("testString")
				updateVersionOptionsModel.PortalUIURL = core.StringPtr("testString")
				updateVersionOptionsModel.CatalogID = core.StringPtr("testString")
				updateVersionOptionsModel.CatalogName = core.StringPtr("testString")
				updateVersionOptionsModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				updateVersionOptionsModel.Disclaimer = core.StringPtr("testString")
				updateVersionOptionsModel.Hidden = core.BoolPtr(true)
				updateVersionOptionsModel.Provider = core.StringPtr("testString")
				updateVersionOptionsModel.ProviderInfo = providerInfoModel
				updateVersionOptionsModel.RepoInfo = repoInfoModel
				updateVersionOptionsModel.ImagePullKeys = []catalogmanagementv1.ImagePullKey{*imagePullKeyModel}
				updateVersionOptionsModel.Support = supportModel
				updateVersionOptionsModel.Media = []catalogmanagementv1.MediaItem{*mediaItemModel}
				updateVersionOptionsModel.DeprecatePending = deprecatePendingModel
				updateVersionOptionsModel.ProductKind = core.StringPtr("testString")
				updateVersionOptionsModel.Badges = []catalogmanagementv1.Badge{*badgeModel}
				updateVersionOptionsModel.Plans = []catalogmanagementv1.Plan{*planModel}
				updateVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.UpdateVersion(updateVersionOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke UpdateVersion with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the Rating model
				ratingModel := new(catalogmanagementv1.Rating)
				ratingModel.OneStarCount = core.Int64Ptr(int64(38))
				ratingModel.TwoStarCount = core.Int64Ptr(int64(38))
				ratingModel.ThreeStarCount = core.Int64Ptr(int64(38))
				ratingModel.FourStarCount = core.Int64Ptr(int64(38))

				// Construct an instance of the Feature model
				featureModel := new(catalogmanagementv1.Feature)
				featureModel.Title = core.StringPtr("testString")
				featureModel.TitleI18n = map[string]string{"key1": "testString"}
				featureModel.Description = core.StringPtr("testString")
				featureModel.DescriptionI18n = map[string]string{"key1": "testString"}

				// Construct an instance of the Flavor model
				flavorModel := new(catalogmanagementv1.Flavor)
				flavorModel.Name = core.StringPtr("testString")
				flavorModel.Label = core.StringPtr("testString")
				flavorModel.LabelI18n = map[string]string{"key1": "testString"}
				flavorModel.Index = core.Int64Ptr(int64(38))

				// Construct an instance of the RenderTypeAssociationsParametersItem model
				renderTypeAssociationsParametersItemModel := new(catalogmanagementv1.RenderTypeAssociationsParametersItem)
				renderTypeAssociationsParametersItemModel.Name = core.StringPtr("testString")
				renderTypeAssociationsParametersItemModel.OptionsRefresh = core.BoolPtr(true)

				// Construct an instance of the RenderTypeAssociations model
				renderTypeAssociationsModel := new(catalogmanagementv1.RenderTypeAssociations)
				renderTypeAssociationsModel.Parameters = []catalogmanagementv1.RenderTypeAssociationsParametersItem{*renderTypeAssociationsParametersItemModel}

				// Construct an instance of the RenderType model
				renderTypeModel := new(catalogmanagementv1.RenderType)
				renderTypeModel.Type = core.StringPtr("testString")
				renderTypeModel.Grouping = core.StringPtr("testString")
				renderTypeModel.OriginalGrouping = core.StringPtr("testString")
				renderTypeModel.GroupingIndex = core.Int64Ptr(int64(38))
				renderTypeModel.ConfigConstraints = map[string]interface{}{"anyKey": "anyValue"}
				renderTypeModel.Associations = renderTypeAssociationsModel

				// Construct an instance of the Configuration model
				configurationModel := new(catalogmanagementv1.Configuration)
				configurationModel.Key = core.StringPtr("testString")
				configurationModel.Type = core.StringPtr("testString")
				configurationModel.DefaultValue = "testString"
				configurationModel.DisplayName = core.StringPtr("testString")
				configurationModel.ValueConstraint = core.StringPtr("testString")
				configurationModel.Description = core.StringPtr("testString")
				configurationModel.Required = core.BoolPtr(true)
				configurationModel.Options = []interface{}{"testString"}
				configurationModel.Hidden = core.BoolPtr(true)
				configurationModel.CustomConfig = renderTypeModel
				configurationModel.TypeMetadata = core.StringPtr("testString")

				// Construct an instance of the Output model
				outputModel := new(catalogmanagementv1.Output)
				outputModel.Key = core.StringPtr("testString")
				outputModel.Description = core.StringPtr("testString")

				// Construct an instance of the IamResource model
				iamResourceModel := new(catalogmanagementv1.IamResource)
				iamResourceModel.Name = core.StringPtr("testString")
				iamResourceModel.Description = core.StringPtr("testString")
				iamResourceModel.RoleCrns = []string{"testString"}

				// Construct an instance of the IamPermission model
				iamPermissionModel := new(catalogmanagementv1.IamPermission)
				iamPermissionModel.ServiceName = core.StringPtr("testString")
				iamPermissionModel.RoleCrns = []string{"testString"}
				iamPermissionModel.Resources = []catalogmanagementv1.IamResource{*iamResourceModel}

				// Construct an instance of the Validation model
				validationModel := new(catalogmanagementv1.Validation)
				validationModel.Validated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				validationModel.Requested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				validationModel.State = core.StringPtr("testString")
				validationModel.LastOperation = core.StringPtr("testString")
				validationModel.Target = map[string]interface{}{"anyKey": "anyValue"}
				validationModel.Message = core.StringPtr("testString")

				// Construct an instance of the Resource model
				resourceModel := new(catalogmanagementv1.Resource)
				resourceModel.Type = core.StringPtr("mem")
				resourceModel.Value = "testString"

				// Construct an instance of the SchematicsEnvValues model
				schematicsEnvValuesModel := new(catalogmanagementv1.SchematicsEnvValues)
				schematicsEnvValuesModel.Value = core.StringPtr("[{\"name\": \"TF_LOG\",\"value\": \"TRACE\",\"secure\": false,\"hidden\": false}]")
				schematicsEnvValuesModel.SmRef = core.StringPtr("cmsm_v1:{\"name\": \"envVarSecret\",\"id\":\"1234567890\",\"service_id\":\"crn:v1:bluemix:public:secrets-manager:eu-gb:a/1234567890:1234567890::\",\"service_name\":\"My SM Instance\",\"group_id\":\"1234567890\",\"group_name\":\"My SM Group\",\"resource_group_id\":\"1234567890\",\"region\":\"eu-gb\",\"type\":\"arbitrary\"}")

				// Construct an instance of the Script model
				scriptModel := new(catalogmanagementv1.Script)
				scriptModel.Instructions = core.StringPtr("testString")
				scriptModel.InstructionsI18n = map[string]string{"key1": "testString"}
				scriptModel.Script = core.StringPtr("testString")
				scriptModel.ScriptPermission = core.StringPtr("testString")
				scriptModel.DeleteScript = core.StringPtr("testString")
				scriptModel.Scope = core.StringPtr("testString")

				// Construct an instance of the ScriptRef model
				scriptRefModel := new(catalogmanagementv1.ScriptRef)
				scriptRefModel.ShortDescription = core.StringPtr("testString")
				scriptRefModel.Type = core.StringPtr("ansible")
				scriptRefModel.Path = core.StringPtr("scripts/validate-post-ansible-playbook.yaml")
				scriptRefModel.Stage = core.StringPtr("pre")
				scriptRefModel.Action = core.StringPtr("validate")

				// Construct an instance of the VersionEntitlement model
				versionEntitlementModel := new(catalogmanagementv1.VersionEntitlement)
				versionEntitlementModel.ProviderName = core.StringPtr("testString")
				versionEntitlementModel.ProviderID = core.StringPtr("testString")
				versionEntitlementModel.ProductID = core.StringPtr("testString")
				versionEntitlementModel.PartNumbers = []string{"testString"}
				versionEntitlementModel.ImageRepoName = core.StringPtr("testString")

				// Construct an instance of the License model
				licenseModel := new(catalogmanagementv1.License)
				licenseModel.ID = core.StringPtr("testString")
				licenseModel.Name = core.StringPtr("testString")
				licenseModel.Type = core.StringPtr("testString")
				licenseModel.URL = core.StringPtr("testString")
				licenseModel.Description = core.StringPtr("testString")

				// Construct an instance of the State model
				stateModel := new(catalogmanagementv1.State)
				stateModel.Current = core.StringPtr("testString")
				stateModel.CurrentEntered = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Pending = core.StringPtr("testString")
				stateModel.PendingRequested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Previous = core.StringPtr("testString")

				// Construct an instance of the DeprecatePending model
				deprecatePendingModel := new(catalogmanagementv1.DeprecatePending)
				deprecatePendingModel.DeprecateDate = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				deprecatePendingModel.DeprecateState = core.StringPtr("testString")
				deprecatePendingModel.Description = core.StringPtr("testString")

				// Construct an instance of the URLProxy model
				urlProxyModel := new(catalogmanagementv1.URLProxy)
				urlProxyModel.URL = core.StringPtr("testString")
				urlProxyModel.Sha = core.StringPtr("testString")

				// Construct an instance of the MediaItem model
				mediaItemModel := new(catalogmanagementv1.MediaItem)
				mediaItemModel.URL = core.StringPtr("testString")
				mediaItemModel.APIURL = core.StringPtr("testString")
				mediaItemModel.URLProxy = urlProxyModel
				mediaItemModel.Caption = core.StringPtr("testString")
				mediaItemModel.CaptionI18n = map[string]string{"key1": "testString"}
				mediaItemModel.Type = core.StringPtr("testString")
				mediaItemModel.ThumbnailURL = core.StringPtr("testString")

				// Construct an instance of the ArchitectureDiagram model
				architectureDiagramModel := new(catalogmanagementv1.ArchitectureDiagram)
				architectureDiagramModel.Diagram = mediaItemModel
				architectureDiagramModel.Description = core.StringPtr("testString")
				architectureDiagramModel.DescriptionI18n = map[string]string{"key1": "testString"}

				// Construct an instance of the CostComponent model
				costComponentModel := new(catalogmanagementv1.CostComponent)
				costComponentModel.Name = core.StringPtr("testString")
				costComponentModel.Unit = core.StringPtr("testString")
				costComponentModel.HourlyQuantity = core.StringPtr("testString")
				costComponentModel.MonthlyQuantity = core.StringPtr("testString")
				costComponentModel.Price = core.StringPtr("testString")
				costComponentModel.HourlyCost = core.StringPtr("testString")
				costComponentModel.MonthlyCost = core.StringPtr("testString")

				// Construct an instance of the CostResource model
				costResourceModel := new(catalogmanagementv1.CostResource)
				costResourceModel.Name = core.StringPtr("testString")
				costResourceModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				costResourceModel.HourlyCost = core.StringPtr("testString")
				costResourceModel.MonthlyCost = core.StringPtr("testString")
				costResourceModel.CostComponents = []catalogmanagementv1.CostComponent{*costComponentModel}

				// Construct an instance of the CostBreakdown model
				costBreakdownModel := new(catalogmanagementv1.CostBreakdown)
				costBreakdownModel.TotalHourlyCost = core.StringPtr("testString")
				costBreakdownModel.TotalMonthlyCost = core.StringPtr("testString")
				costBreakdownModel.Resources = []catalogmanagementv1.CostResource{*costResourceModel}

				// Construct an instance of the CostSummary model
				costSummaryModel := new(catalogmanagementv1.CostSummary)
				costSummaryModel.TotalDetectedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalSupportedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalUnsupportedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalUsageBasedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalNoPriceResources = core.Int64Ptr(int64(38))
				costSummaryModel.UnsupportedResourceCounts = map[string]int64{"key1": int64(38)}
				costSummaryModel.NoPriceResourceCounts = map[string]int64{"key1": int64(38)}

				// Construct an instance of the Project model
				projectModel := new(catalogmanagementv1.Project)
				projectModel.Name = core.StringPtr("testString")
				projectModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				projectModel.PastBreakdown = costBreakdownModel
				projectModel.Breakdown = costBreakdownModel
				projectModel.Diff = costBreakdownModel
				projectModel.Summary = costSummaryModel

				// Construct an instance of the CostEstimate model
				costEstimateModel := new(catalogmanagementv1.CostEstimate)
				costEstimateModel.Version = core.StringPtr("testString")
				costEstimateModel.Currency = core.StringPtr("testString")
				costEstimateModel.Projects = []catalogmanagementv1.Project{*projectModel}
				costEstimateModel.Summary = costSummaryModel
				costEstimateModel.TotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.TotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.PastTotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.PastTotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.DiffTotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.DiffTotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.TimeGenerated = CreateMockDateTime("2019-01-01T12:00:00.000Z")

				// Construct an instance of the OfferingReference model
				offeringReferenceModel := new(catalogmanagementv1.OfferingReference)
				offeringReferenceModel.CatalogID = core.StringPtr("testString")
				offeringReferenceModel.ID = core.StringPtr("testString")
				offeringReferenceModel.Name = core.StringPtr("testString")
				offeringReferenceModel.Kind = core.StringPtr("testString")
				offeringReferenceModel.Version = core.StringPtr("testString")
				offeringReferenceModel.Description = core.StringPtr("testString")
				offeringReferenceModel.DefaultFlavor = core.StringPtr("testString")
				offeringReferenceModel.Flavors = []string{"testString"}
				offeringReferenceModel.Optional = core.BoolPtr(true)
				offeringReferenceModel.OnByDefault = core.BoolPtr(true)

				// Construct an instance of the SolutionInfo model
				solutionInfoModel := new(catalogmanagementv1.SolutionInfo)
				solutionInfoModel.ArchitectureDiagrams = []catalogmanagementv1.ArchitectureDiagram{*architectureDiagramModel}
				solutionInfoModel.Features = []catalogmanagementv1.Feature{*featureModel}
				solutionInfoModel.CostEstimate = costEstimateModel
				solutionInfoModel.Dependencies = []catalogmanagementv1.OfferingReference{*offeringReferenceModel}
				solutionInfoModel.InstallType = core.StringPtr("testString")

				// Construct an instance of the SccProfile model
				sccProfileModel := new(catalogmanagementv1.SccProfile)
				sccProfileModel.ID = core.StringPtr("testString")
				sccProfileModel.Name = core.StringPtr("testString")
				sccProfileModel.Version = core.StringPtr("testString")
				sccProfileModel.Description = core.StringPtr("testString")
				sccProfileModel.Type = core.StringPtr("testString")
				sccProfileModel.UIHref = core.StringPtr("testString")

				// Construct an instance of the ClaimedControl model
				claimedControlModel := new(catalogmanagementv1.ClaimedControl)
				claimedControlModel.Profile = sccProfileModel
				claimedControlModel.Names = []string{"testString"}

				// Construct an instance of the Claims model
				claimsModel := new(catalogmanagementv1.Claims)
				claimsModel.Profiles = []catalogmanagementv1.SccProfile{*sccProfileModel}
				claimsModel.Controls = []catalogmanagementv1.ClaimedControl{*claimedControlModel}

				// Construct an instance of the Result model
				resultModel := new(catalogmanagementv1.Result)
				resultModel.FailureCount = core.Int64Ptr(int64(38))
				resultModel.ScanTime = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				resultModel.ErrorMessage = core.StringPtr("testString")
				resultModel.CompleteScan = core.BoolPtr(true)
				resultModel.UnscannedResources = []string{"testString"}

				// Construct an instance of the SccAssessment model
				sccAssessmentModel := new(catalogmanagementv1.SccAssessment)
				sccAssessmentModel.ID = core.StringPtr("testString")
				sccAssessmentModel.Description = core.StringPtr("testString")
				sccAssessmentModel.Version = core.StringPtr("testString")
				sccAssessmentModel.Type = core.StringPtr("testString")
				sccAssessmentModel.Method = core.StringPtr("testString")
				sccAssessmentModel.UIHref = core.StringPtr("testString")

				// Construct an instance of the SccSpecification model
				sccSpecificationModel := new(catalogmanagementv1.SccSpecification)
				sccSpecificationModel.ID = core.StringPtr("testString")
				sccSpecificationModel.Description = core.StringPtr("testString")
				sccSpecificationModel.ComponentName = core.StringPtr("testString")
				sccSpecificationModel.Assessments = []catalogmanagementv1.SccAssessment{*sccAssessmentModel}
				sccSpecificationModel.UIHref = core.StringPtr("testString")

				// Construct an instance of the SccControl model
				sccControlModel := new(catalogmanagementv1.SccControl)
				sccControlModel.ID = core.StringPtr("testString")
				sccControlModel.Name = core.StringPtr("testString")
				sccControlModel.Version = core.StringPtr("testString")
				sccControlModel.Description = core.StringPtr("testString")
				sccControlModel.Profile = sccProfileModel
				sccControlModel.ParentName = core.StringPtr("testString")
				sccControlModel.Specifications = []catalogmanagementv1.SccSpecification{*sccSpecificationModel}
				sccControlModel.UIHref = core.StringPtr("testString")

				// Construct an instance of the EvaluatedControl model
				evaluatedControlModel := new(catalogmanagementv1.EvaluatedControl)
				evaluatedControlModel.ID = core.StringPtr("testString")
				evaluatedControlModel.Name = core.StringPtr("testString")
				evaluatedControlModel.Description = core.StringPtr("testString")
				evaluatedControlModel.Specifications = []catalogmanagementv1.SccSpecification{*sccSpecificationModel}
				evaluatedControlModel.FailureCount = core.Int64Ptr(int64(38))
				evaluatedControlModel.PassCount = core.Int64Ptr(int64(38))
				evaluatedControlModel.Parent = sccControlModel
				evaluatedControlModel.UIHref = core.StringPtr("testString")

				// Construct an instance of the Evaluation model
				evaluationModel := new(catalogmanagementv1.Evaluation)
				evaluationModel.ScanID = core.StringPtr("testString")
				evaluationModel.AccountID = core.StringPtr("testString")
				evaluationModel.Profile = sccProfileModel
				evaluationModel.Result = resultModel
				evaluationModel.Controls = []catalogmanagementv1.EvaluatedControl{*evaluatedControlModel}

				// Construct an instance of the Compliance model
				complianceModel := new(catalogmanagementv1.Compliance)
				complianceModel.Authority = core.StringPtr("testString")
				complianceModel.Claims = claimsModel
				complianceModel.Evaluations = []catalogmanagementv1.Evaluation{*evaluationModel}

				// Construct an instance of the ChangeNotices model
				changeNoticesModel := new(catalogmanagementv1.ChangeNotices)
				changeNoticesModel.Breaking = []catalogmanagementv1.Feature{*featureModel}
				changeNoticesModel.New = []catalogmanagementv1.Feature{*featureModel}
				changeNoticesModel.Update = []catalogmanagementv1.Feature{*featureModel}

				// Construct an instance of the Version model
				versionModel := new(catalogmanagementv1.Version)
				versionModel.CRN = core.StringPtr("testString")
				versionModel.Version = core.StringPtr("testString")
				versionModel.Flavor = flavorModel
				versionModel.Sha = core.StringPtr("testString")
				versionModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				versionModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				versionModel.OfferingID = core.StringPtr("testString")
				versionModel.CatalogID = core.StringPtr("testString")
				versionModel.KindID = core.StringPtr("testString")
				versionModel.Tags = []string{"testString"}
				versionModel.RepoURL = core.StringPtr("testString")
				versionModel.SourceURL = core.StringPtr("testString")
				versionModel.TgzURL = core.StringPtr("testString")
				versionModel.Configuration = []catalogmanagementv1.Configuration{*configurationModel}
				versionModel.Outputs = []catalogmanagementv1.Output{*outputModel}
				versionModel.IamPermissions = []catalogmanagementv1.IamPermission{*iamPermissionModel}
				versionModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				versionModel.Validation = validationModel
				versionModel.RequiredResources = []catalogmanagementv1.Resource{*resourceModel}
				versionModel.SingleInstance = core.BoolPtr(true)
				versionModel.SchematicsEnvValues = schematicsEnvValuesModel
				versionModel.Install = scriptModel
				versionModel.PreInstall = []catalogmanagementv1.Script{*scriptModel}
				versionModel.Scripts = map[string]catalogmanagementv1.ScriptRef{"key1": *scriptRefModel}
				versionModel.Entitlement = versionEntitlementModel
				versionModel.Licenses = []catalogmanagementv1.License{*licenseModel}
				versionModel.ImageManifestURL = core.StringPtr("testString")
				versionModel.Deprecated = core.BoolPtr(true)
				versionModel.PackageVersion = core.StringPtr("testString")
				versionModel.State = stateModel
				versionModel.VersionLocator = core.StringPtr("testString")
				versionModel.LongDescription = core.StringPtr("testString")
				versionModel.LongDescriptionI18n = map[string]string{"key1": "testString"}
				versionModel.WhitelistedAccounts = []string{"testString"}
				versionModel.ImagePullKeyName = core.StringPtr("testString")
				versionModel.DeprecatePending = deprecatePendingModel
				versionModel.SolutionInfo = solutionInfoModel
				versionModel.IsConsumable = core.BoolPtr(true)
				versionModel.ComplianceV3 = complianceModel
				versionModel.ChangeNotices = changeNoticesModel
				versionModel.PlanIds = []string{"testString"}
				versionModel.Stack = map[string]interface{}{"anyKey": "anyValue"}
				versionModel.MinimumCompatibleVersion = core.StringPtr("testString")
				versionModel.Scripts["foo"] = *scriptRefModel

				// Construct an instance of the PaginationTokenLink model
				paginationTokenLinkModel := new(catalogmanagementv1.PaginationTokenLink)
				paginationTokenLinkModel.Href = core.StringPtr("testString")
				paginationTokenLinkModel.Start = core.StringPtr("testString")

				// Construct an instance of the KindAllVersions model
				kindAllVersionsModel := new(catalogmanagementv1.KindAllVersions)
				kindAllVersionsModel.First = paginationTokenLinkModel
				kindAllVersionsModel.Next = paginationTokenLinkModel

				// Construct an instance of the Kind model
				kindModel := new(catalogmanagementv1.Kind)
				kindModel.ID = core.StringPtr("testString")
				kindModel.FormatKind = core.StringPtr("testString")
				kindModel.FormatKindLabel = core.StringPtr("testString")
				kindModel.InstallKind = core.StringPtr("testString")
				kindModel.InstallKindLabel = core.StringPtr("testString")
				kindModel.TargetKind = core.StringPtr("testString")
				kindModel.TargetKindLabel = core.StringPtr("testString")
				kindModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				kindModel.Tags = []string{"testString"}
				kindModel.AdditionalFeatures = []catalogmanagementv1.Feature{*featureModel}
				kindModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				kindModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				kindModel.Versions = []catalogmanagementv1.Version{*versionModel}
				kindModel.AllVersions = kindAllVersionsModel

				// Construct an instance of the PublishObject model
				publishObjectModel := new(catalogmanagementv1.PublishObject)
				publishObjectModel.PcManaged = core.BoolPtr(true)
				publishObjectModel.ApprovalType = core.StringPtr("testString")
				publishObjectModel.PublishApproved = core.BoolPtr(true)
				publishObjectModel.ShareWithAll = core.BoolPtr(true)
				publishObjectModel.ShareWithIBM = core.BoolPtr(true)
				publishObjectModel.ShareEnabled = core.BoolPtr(true)
				publishObjectModel.OriginalCRN = core.StringPtr("testString")
				publishObjectModel.PublicCRN = core.StringPtr("testString")
				publishObjectModel.ApprovalRecord = map[string]interface{}{"anyKey": "anyValue"}
				publishObjectModel.PermitIBMPublicPublish = core.BoolPtr(true)
				publishObjectModel.IBMApproved = core.BoolPtr(true)
				publishObjectModel.PublicApproved = core.BoolPtr(true)

				// Construct an instance of the ProviderInfo model
				providerInfoModel := new(catalogmanagementv1.ProviderInfo)
				providerInfoModel.ID = core.StringPtr("testString")
				providerInfoModel.Name = core.StringPtr("testString")

				// Construct an instance of the RepoInfo model
				repoInfoModel := new(catalogmanagementv1.RepoInfo)
				repoInfoModel.Token = core.StringPtr("testString")
				repoInfoModel.Type = core.StringPtr("testString")

				// Construct an instance of the ImagePullKey model
				imagePullKeyModel := new(catalogmanagementv1.ImagePullKey)
				imagePullKeyModel.Name = core.StringPtr("testString")
				imagePullKeyModel.Value = core.StringPtr("testString")
				imagePullKeyModel.Description = core.StringPtr("testString")

				// Construct an instance of the SupportWaitTime model
				supportWaitTimeModel := new(catalogmanagementv1.SupportWaitTime)
				supportWaitTimeModel.Value = core.Int64Ptr(int64(38))
				supportWaitTimeModel.Type = core.StringPtr("testString")

				// Construct an instance of the SupportTime model
				supportTimeModel := new(catalogmanagementv1.SupportTime)
				supportTimeModel.Day = core.Int64Ptr(int64(38))
				supportTimeModel.StartTime = core.StringPtr("testString")
				supportTimeModel.EndTime = core.StringPtr("testString")

				// Construct an instance of the SupportAvailability model
				supportAvailabilityModel := new(catalogmanagementv1.SupportAvailability)
				supportAvailabilityModel.Times = []catalogmanagementv1.SupportTime{*supportTimeModel}
				supportAvailabilityModel.Timezone = core.StringPtr("testString")
				supportAvailabilityModel.AlwaysAvailable = core.BoolPtr(true)

				// Construct an instance of the SupportDetail model
				supportDetailModel := new(catalogmanagementv1.SupportDetail)
				supportDetailModel.Type = core.StringPtr("testString")
				supportDetailModel.Contact = core.StringPtr("testString")
				supportDetailModel.ResponseWaitTime = supportWaitTimeModel
				supportDetailModel.Availability = supportAvailabilityModel

				// Construct an instance of the SupportEscalation model
				supportEscalationModel := new(catalogmanagementv1.SupportEscalation)
				supportEscalationModel.EscalationWaitTime = supportWaitTimeModel
				supportEscalationModel.ResponseWaitTime = supportWaitTimeModel
				supportEscalationModel.Contact = core.StringPtr("testString")

				// Construct an instance of the Support model
				supportModel := new(catalogmanagementv1.Support)
				supportModel.URL = core.StringPtr("testString")
				supportModel.Process = core.StringPtr("testString")
				supportModel.ProcessI18n = map[string]string{"key1": "testString"}
				supportModel.Locations = []string{"testString"}
				supportModel.SupportDetails = []catalogmanagementv1.SupportDetail{*supportDetailModel}
				supportModel.SupportEscalation = supportEscalationModel
				supportModel.SupportType = core.StringPtr("testString")

				// Construct an instance of the LearnMoreLinks model
				learnMoreLinksModel := new(catalogmanagementv1.LearnMoreLinks)
				learnMoreLinksModel.FirstParty = core.StringPtr("testString")
				learnMoreLinksModel.ThirdParty = core.StringPtr("testString")

				// Construct an instance of the Constraint model
				constraintModel := new(catalogmanagementv1.Constraint)
				constraintModel.Type = core.StringPtr("testString")
				constraintModel.Rule = "testString"

				// Construct an instance of the Badge model
				badgeModel := new(catalogmanagementv1.Badge)
				badgeModel.ID = core.StringPtr("testString")
				badgeModel.Label = core.StringPtr("testString")
				badgeModel.LabelI18n = map[string]string{"key1": "testString"}
				badgeModel.Description = core.StringPtr("testString")
				badgeModel.DescriptionI18n = map[string]string{"key1": "testString"}
				badgeModel.Icon = core.StringPtr("testString")
				badgeModel.Authority = core.StringPtr("testString")
				badgeModel.Tag = core.StringPtr("testString")
				badgeModel.LearnMoreLinks = learnMoreLinksModel
				badgeModel.Constraints = []catalogmanagementv1.Constraint{*constraintModel}

				// Construct an instance of the VersionRange model
				versionRangeModel := new(catalogmanagementv1.VersionRange)
				versionRangeModel.Kinds = []string{"testString"}
				versionRangeModel.Version = core.StringPtr("testString")
				versionRangeModel.Flavors = []string{"testString"}

				// Construct an instance of the Plan model
				planModel := new(catalogmanagementv1.Plan)
				planModel.URL = core.StringPtr("testString")
				planModel.CRN = core.StringPtr("testString")
				planModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				planModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				planModel.OfferingID = core.StringPtr("testString")
				planModel.CatalogID = core.StringPtr("testString")
				planModel.Label = core.StringPtr("testString")
				planModel.LabelI18n = map[string]string{"key1": "testString"}
				planModel.Name = core.StringPtr("testString")
				planModel.ShortDescription = core.StringPtr("testString")
				planModel.ShortDescriptionI18n = map[string]string{"key1": "testString"}
				planModel.PricingTags = []string{"testString"}
				planModel.VersionRange = versionRangeModel
				planModel.Features = []catalogmanagementv1.Feature{*featureModel}
				planModel.State = stateModel
				planModel.DeprecatePending = deprecatePendingModel
				planModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				planModel.PublishApproved = core.BoolPtr(true)

				// Construct an instance of the UpdateVersionOptions model
				updateVersionOptionsModel := new(catalogmanagementv1.UpdateVersionOptions)
				updateVersionOptionsModel.VersionLocID = core.StringPtr("testString")
				updateVersionOptionsModel.ID = core.StringPtr("testString")
				updateVersionOptionsModel.Rev = core.StringPtr("testString")
				updateVersionOptionsModel.URL = core.StringPtr("testString")
				updateVersionOptionsModel.CRN = core.StringPtr("testString")
				updateVersionOptionsModel.Label = core.StringPtr("testString")
				updateVersionOptionsModel.LabelI18n = map[string]string{"key1": "testString"}
				updateVersionOptionsModel.Name = core.StringPtr("testString")
				updateVersionOptionsModel.OfferingIconURL = core.StringPtr("testString")
				updateVersionOptionsModel.OfferingDocsURL = core.StringPtr("testString")
				updateVersionOptionsModel.OfferingSupportURL = core.StringPtr("testString")
				updateVersionOptionsModel.Tags = []string{"testString"}
				updateVersionOptionsModel.Keywords = []string{"testString"}
				updateVersionOptionsModel.Rating = ratingModel
				updateVersionOptionsModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				updateVersionOptionsModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				updateVersionOptionsModel.ShortDescription = core.StringPtr("testString")
				updateVersionOptionsModel.ShortDescriptionI18n = map[string]string{"key1": "testString"}
				updateVersionOptionsModel.LongDescription = core.StringPtr("testString")
				updateVersionOptionsModel.LongDescriptionI18n = map[string]string{"key1": "testString"}
				updateVersionOptionsModel.Features = []catalogmanagementv1.Feature{*featureModel}
				updateVersionOptionsModel.Kinds = []catalogmanagementv1.Kind{*kindModel}
				updateVersionOptionsModel.Publish = publishObjectModel
				updateVersionOptionsModel.PcManaged = core.BoolPtr(true)
				updateVersionOptionsModel.PublishApproved = core.BoolPtr(true)
				updateVersionOptionsModel.ShareWithAll = core.BoolPtr(true)
				updateVersionOptionsModel.ShareWithIBM = core.BoolPtr(true)
				updateVersionOptionsModel.ShareEnabled = core.BoolPtr(true)
				updateVersionOptionsModel.PublicOriginalCRN = core.StringPtr("testString")
				updateVersionOptionsModel.PublishPublicCRN = core.StringPtr("testString")
				updateVersionOptionsModel.PortalApprovalRecord = core.StringPtr("testString")
				updateVersionOptionsModel.PortalUIURL = core.StringPtr("testString")
				updateVersionOptionsModel.CatalogID = core.StringPtr("testString")
				updateVersionOptionsModel.CatalogName = core.StringPtr("testString")
				updateVersionOptionsModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				updateVersionOptionsModel.Disclaimer = core.StringPtr("testString")
				updateVersionOptionsModel.Hidden = core.BoolPtr(true)
				updateVersionOptionsModel.Provider = core.StringPtr("testString")
				updateVersionOptionsModel.ProviderInfo = providerInfoModel
				updateVersionOptionsModel.RepoInfo = repoInfoModel
				updateVersionOptionsModel.ImagePullKeys = []catalogmanagementv1.ImagePullKey{*imagePullKeyModel}
				updateVersionOptionsModel.Support = supportModel
				updateVersionOptionsModel.Media = []catalogmanagementv1.MediaItem{*mediaItemModel}
				updateVersionOptionsModel.DeprecatePending = deprecatePendingModel
				updateVersionOptionsModel.ProductKind = core.StringPtr("testString")
				updateVersionOptionsModel.Badges = []catalogmanagementv1.Badge{*badgeModel}
				updateVersionOptionsModel.Plans = []catalogmanagementv1.Plan{*planModel}
				updateVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.UpdateVersion(updateVersionOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the UpdateVersionOptions model with no property values
				updateVersionOptionsModelNew := new(catalogmanagementv1.UpdateVersionOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.UpdateVersion(updateVersionOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke UpdateVersion successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the Rating model
				ratingModel := new(catalogmanagementv1.Rating)
				ratingModel.OneStarCount = core.Int64Ptr(int64(38))
				ratingModel.TwoStarCount = core.Int64Ptr(int64(38))
				ratingModel.ThreeStarCount = core.Int64Ptr(int64(38))
				ratingModel.FourStarCount = core.Int64Ptr(int64(38))

				// Construct an instance of the Feature model
				featureModel := new(catalogmanagementv1.Feature)
				featureModel.Title = core.StringPtr("testString")
				featureModel.TitleI18n = map[string]string{"key1": "testString"}
				featureModel.Description = core.StringPtr("testString")
				featureModel.DescriptionI18n = map[string]string{"key1": "testString"}

				// Construct an instance of the Flavor model
				flavorModel := new(catalogmanagementv1.Flavor)
				flavorModel.Name = core.StringPtr("testString")
				flavorModel.Label = core.StringPtr("testString")
				flavorModel.LabelI18n = map[string]string{"key1": "testString"}
				flavorModel.Index = core.Int64Ptr(int64(38))

				// Construct an instance of the RenderTypeAssociationsParametersItem model
				renderTypeAssociationsParametersItemModel := new(catalogmanagementv1.RenderTypeAssociationsParametersItem)
				renderTypeAssociationsParametersItemModel.Name = core.StringPtr("testString")
				renderTypeAssociationsParametersItemModel.OptionsRefresh = core.BoolPtr(true)

				// Construct an instance of the RenderTypeAssociations model
				renderTypeAssociationsModel := new(catalogmanagementv1.RenderTypeAssociations)
				renderTypeAssociationsModel.Parameters = []catalogmanagementv1.RenderTypeAssociationsParametersItem{*renderTypeAssociationsParametersItemModel}

				// Construct an instance of the RenderType model
				renderTypeModel := new(catalogmanagementv1.RenderType)
				renderTypeModel.Type = core.StringPtr("testString")
				renderTypeModel.Grouping = core.StringPtr("testString")
				renderTypeModel.OriginalGrouping = core.StringPtr("testString")
				renderTypeModel.GroupingIndex = core.Int64Ptr(int64(38))
				renderTypeModel.ConfigConstraints = map[string]interface{}{"anyKey": "anyValue"}
				renderTypeModel.Associations = renderTypeAssociationsModel

				// Construct an instance of the Configuration model
				configurationModel := new(catalogmanagementv1.Configuration)
				configurationModel.Key = core.StringPtr("testString")
				configurationModel.Type = core.StringPtr("testString")
				configurationModel.DefaultValue = "testString"
				configurationModel.DisplayName = core.StringPtr("testString")
				configurationModel.ValueConstraint = core.StringPtr("testString")
				configurationModel.Description = core.StringPtr("testString")
				configurationModel.Required = core.BoolPtr(true)
				configurationModel.Options = []interface{}{"testString"}
				configurationModel.Hidden = core.BoolPtr(true)
				configurationModel.CustomConfig = renderTypeModel
				configurationModel.TypeMetadata = core.StringPtr("testString")

				// Construct an instance of the Output model
				outputModel := new(catalogmanagementv1.Output)
				outputModel.Key = core.StringPtr("testString")
				outputModel.Description = core.StringPtr("testString")

				// Construct an instance of the IamResource model
				iamResourceModel := new(catalogmanagementv1.IamResource)
				iamResourceModel.Name = core.StringPtr("testString")
				iamResourceModel.Description = core.StringPtr("testString")
				iamResourceModel.RoleCrns = []string{"testString"}

				// Construct an instance of the IamPermission model
				iamPermissionModel := new(catalogmanagementv1.IamPermission)
				iamPermissionModel.ServiceName = core.StringPtr("testString")
				iamPermissionModel.RoleCrns = []string{"testString"}
				iamPermissionModel.Resources = []catalogmanagementv1.IamResource{*iamResourceModel}

				// Construct an instance of the Validation model
				validationModel := new(catalogmanagementv1.Validation)
				validationModel.Validated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				validationModel.Requested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				validationModel.State = core.StringPtr("testString")
				validationModel.LastOperation = core.StringPtr("testString")
				validationModel.Target = map[string]interface{}{"anyKey": "anyValue"}
				validationModel.Message = core.StringPtr("testString")

				// Construct an instance of the Resource model
				resourceModel := new(catalogmanagementv1.Resource)
				resourceModel.Type = core.StringPtr("mem")
				resourceModel.Value = "testString"

				// Construct an instance of the SchematicsEnvValues model
				schematicsEnvValuesModel := new(catalogmanagementv1.SchematicsEnvValues)
				schematicsEnvValuesModel.Value = core.StringPtr("[{\"name\": \"TF_LOG\",\"value\": \"TRACE\",\"secure\": false,\"hidden\": false}]")
				schematicsEnvValuesModel.SmRef = core.StringPtr("cmsm_v1:{\"name\": \"envVarSecret\",\"id\":\"1234567890\",\"service_id\":\"crn:v1:bluemix:public:secrets-manager:eu-gb:a/1234567890:1234567890::\",\"service_name\":\"My SM Instance\",\"group_id\":\"1234567890\",\"group_name\":\"My SM Group\",\"resource_group_id\":\"1234567890\",\"region\":\"eu-gb\",\"type\":\"arbitrary\"}")

				// Construct an instance of the Script model
				scriptModel := new(catalogmanagementv1.Script)
				scriptModel.Instructions = core.StringPtr("testString")
				scriptModel.InstructionsI18n = map[string]string{"key1": "testString"}
				scriptModel.Script = core.StringPtr("testString")
				scriptModel.ScriptPermission = core.StringPtr("testString")
				scriptModel.DeleteScript = core.StringPtr("testString")
				scriptModel.Scope = core.StringPtr("testString")

				// Construct an instance of the ScriptRef model
				scriptRefModel := new(catalogmanagementv1.ScriptRef)
				scriptRefModel.ShortDescription = core.StringPtr("testString")
				scriptRefModel.Type = core.StringPtr("ansible")
				scriptRefModel.Path = core.StringPtr("scripts/validate-post-ansible-playbook.yaml")
				scriptRefModel.Stage = core.StringPtr("pre")
				scriptRefModel.Action = core.StringPtr("validate")

				// Construct an instance of the VersionEntitlement model
				versionEntitlementModel := new(catalogmanagementv1.VersionEntitlement)
				versionEntitlementModel.ProviderName = core.StringPtr("testString")
				versionEntitlementModel.ProviderID = core.StringPtr("testString")
				versionEntitlementModel.ProductID = core.StringPtr("testString")
				versionEntitlementModel.PartNumbers = []string{"testString"}
				versionEntitlementModel.ImageRepoName = core.StringPtr("testString")

				// Construct an instance of the License model
				licenseModel := new(catalogmanagementv1.License)
				licenseModel.ID = core.StringPtr("testString")
				licenseModel.Name = core.StringPtr("testString")
				licenseModel.Type = core.StringPtr("testString")
				licenseModel.URL = core.StringPtr("testString")
				licenseModel.Description = core.StringPtr("testString")

				// Construct an instance of the State model
				stateModel := new(catalogmanagementv1.State)
				stateModel.Current = core.StringPtr("testString")
				stateModel.CurrentEntered = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Pending = core.StringPtr("testString")
				stateModel.PendingRequested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Previous = core.StringPtr("testString")

				// Construct an instance of the DeprecatePending model
				deprecatePendingModel := new(catalogmanagementv1.DeprecatePending)
				deprecatePendingModel.DeprecateDate = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				deprecatePendingModel.DeprecateState = core.StringPtr("testString")
				deprecatePendingModel.Description = core.StringPtr("testString")

				// Construct an instance of the URLProxy model
				urlProxyModel := new(catalogmanagementv1.URLProxy)
				urlProxyModel.URL = core.StringPtr("testString")
				urlProxyModel.Sha = core.StringPtr("testString")

				// Construct an instance of the MediaItem model
				mediaItemModel := new(catalogmanagementv1.MediaItem)
				mediaItemModel.URL = core.StringPtr("testString")
				mediaItemModel.APIURL = core.StringPtr("testString")
				mediaItemModel.URLProxy = urlProxyModel
				mediaItemModel.Caption = core.StringPtr("testString")
				mediaItemModel.CaptionI18n = map[string]string{"key1": "testString"}
				mediaItemModel.Type = core.StringPtr("testString")
				mediaItemModel.ThumbnailURL = core.StringPtr("testString")

				// Construct an instance of the ArchitectureDiagram model
				architectureDiagramModel := new(catalogmanagementv1.ArchitectureDiagram)
				architectureDiagramModel.Diagram = mediaItemModel
				architectureDiagramModel.Description = core.StringPtr("testString")
				architectureDiagramModel.DescriptionI18n = map[string]string{"key1": "testString"}

				// Construct an instance of the CostComponent model
				costComponentModel := new(catalogmanagementv1.CostComponent)
				costComponentModel.Name = core.StringPtr("testString")
				costComponentModel.Unit = core.StringPtr("testString")
				costComponentModel.HourlyQuantity = core.StringPtr("testString")
				costComponentModel.MonthlyQuantity = core.StringPtr("testString")
				costComponentModel.Price = core.StringPtr("testString")
				costComponentModel.HourlyCost = core.StringPtr("testString")
				costComponentModel.MonthlyCost = core.StringPtr("testString")

				// Construct an instance of the CostResource model
				costResourceModel := new(catalogmanagementv1.CostResource)
				costResourceModel.Name = core.StringPtr("testString")
				costResourceModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				costResourceModel.HourlyCost = core.StringPtr("testString")
				costResourceModel.MonthlyCost = core.StringPtr("testString")
				costResourceModel.CostComponents = []catalogmanagementv1.CostComponent{*costComponentModel}

				// Construct an instance of the CostBreakdown model
				costBreakdownModel := new(catalogmanagementv1.CostBreakdown)
				costBreakdownModel.TotalHourlyCost = core.StringPtr("testString")
				costBreakdownModel.TotalMonthlyCost = core.StringPtr("testString")
				costBreakdownModel.Resources = []catalogmanagementv1.CostResource{*costResourceModel}

				// Construct an instance of the CostSummary model
				costSummaryModel := new(catalogmanagementv1.CostSummary)
				costSummaryModel.TotalDetectedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalSupportedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalUnsupportedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalUsageBasedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalNoPriceResources = core.Int64Ptr(int64(38))
				costSummaryModel.UnsupportedResourceCounts = map[string]int64{"key1": int64(38)}
				costSummaryModel.NoPriceResourceCounts = map[string]int64{"key1": int64(38)}

				// Construct an instance of the Project model
				projectModel := new(catalogmanagementv1.Project)
				projectModel.Name = core.StringPtr("testString")
				projectModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				projectModel.PastBreakdown = costBreakdownModel
				projectModel.Breakdown = costBreakdownModel
				projectModel.Diff = costBreakdownModel
				projectModel.Summary = costSummaryModel

				// Construct an instance of the CostEstimate model
				costEstimateModel := new(catalogmanagementv1.CostEstimate)
				costEstimateModel.Version = core.StringPtr("testString")
				costEstimateModel.Currency = core.StringPtr("testString")
				costEstimateModel.Projects = []catalogmanagementv1.Project{*projectModel}
				costEstimateModel.Summary = costSummaryModel
				costEstimateModel.TotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.TotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.PastTotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.PastTotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.DiffTotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.DiffTotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.TimeGenerated = CreateMockDateTime("2019-01-01T12:00:00.000Z")

				// Construct an instance of the OfferingReference model
				offeringReferenceModel := new(catalogmanagementv1.OfferingReference)
				offeringReferenceModel.CatalogID = core.StringPtr("testString")
				offeringReferenceModel.ID = core.StringPtr("testString")
				offeringReferenceModel.Name = core.StringPtr("testString")
				offeringReferenceModel.Kind = core.StringPtr("testString")
				offeringReferenceModel.Version = core.StringPtr("testString")
				offeringReferenceModel.Description = core.StringPtr("testString")
				offeringReferenceModel.DefaultFlavor = core.StringPtr("testString")
				offeringReferenceModel.Flavors = []string{"testString"}
				offeringReferenceModel.Optional = core.BoolPtr(true)
				offeringReferenceModel.OnByDefault = core.BoolPtr(true)

				// Construct an instance of the SolutionInfo model
				solutionInfoModel := new(catalogmanagementv1.SolutionInfo)
				solutionInfoModel.ArchitectureDiagrams = []catalogmanagementv1.ArchitectureDiagram{*architectureDiagramModel}
				solutionInfoModel.Features = []catalogmanagementv1.Feature{*featureModel}
				solutionInfoModel.CostEstimate = costEstimateModel
				solutionInfoModel.Dependencies = []catalogmanagementv1.OfferingReference{*offeringReferenceModel}
				solutionInfoModel.InstallType = core.StringPtr("testString")

				// Construct an instance of the SccProfile model
				sccProfileModel := new(catalogmanagementv1.SccProfile)
				sccProfileModel.ID = core.StringPtr("testString")
				sccProfileModel.Name = core.StringPtr("testString")
				sccProfileModel.Version = core.StringPtr("testString")
				sccProfileModel.Description = core.StringPtr("testString")
				sccProfileModel.Type = core.StringPtr("testString")
				sccProfileModel.UIHref = core.StringPtr("testString")

				// Construct an instance of the ClaimedControl model
				claimedControlModel := new(catalogmanagementv1.ClaimedControl)
				claimedControlModel.Profile = sccProfileModel
				claimedControlModel.Names = []string{"testString"}

				// Construct an instance of the Claims model
				claimsModel := new(catalogmanagementv1.Claims)
				claimsModel.Profiles = []catalogmanagementv1.SccProfile{*sccProfileModel}
				claimsModel.Controls = []catalogmanagementv1.ClaimedControl{*claimedControlModel}

				// Construct an instance of the Result model
				resultModel := new(catalogmanagementv1.Result)
				resultModel.FailureCount = core.Int64Ptr(int64(38))
				resultModel.ScanTime = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				resultModel.ErrorMessage = core.StringPtr("testString")
				resultModel.CompleteScan = core.BoolPtr(true)
				resultModel.UnscannedResources = []string{"testString"}

				// Construct an instance of the SccAssessment model
				sccAssessmentModel := new(catalogmanagementv1.SccAssessment)
				sccAssessmentModel.ID = core.StringPtr("testString")
				sccAssessmentModel.Description = core.StringPtr("testString")
				sccAssessmentModel.Version = core.StringPtr("testString")
				sccAssessmentModel.Type = core.StringPtr("testString")
				sccAssessmentModel.Method = core.StringPtr("testString")
				sccAssessmentModel.UIHref = core.StringPtr("testString")

				// Construct an instance of the SccSpecification model
				sccSpecificationModel := new(catalogmanagementv1.SccSpecification)
				sccSpecificationModel.ID = core.StringPtr("testString")
				sccSpecificationModel.Description = core.StringPtr("testString")
				sccSpecificationModel.ComponentName = core.StringPtr("testString")
				sccSpecificationModel.Assessments = []catalogmanagementv1.SccAssessment{*sccAssessmentModel}
				sccSpecificationModel.UIHref = core.StringPtr("testString")

				// Construct an instance of the SccControl model
				sccControlModel := new(catalogmanagementv1.SccControl)
				sccControlModel.ID = core.StringPtr("testString")
				sccControlModel.Name = core.StringPtr("testString")
				sccControlModel.Version = core.StringPtr("testString")
				sccControlModel.Description = core.StringPtr("testString")
				sccControlModel.Profile = sccProfileModel
				sccControlModel.ParentName = core.StringPtr("testString")
				sccControlModel.Specifications = []catalogmanagementv1.SccSpecification{*sccSpecificationModel}
				sccControlModel.UIHref = core.StringPtr("testString")

				// Construct an instance of the EvaluatedControl model
				evaluatedControlModel := new(catalogmanagementv1.EvaluatedControl)
				evaluatedControlModel.ID = core.StringPtr("testString")
				evaluatedControlModel.Name = core.StringPtr("testString")
				evaluatedControlModel.Description = core.StringPtr("testString")
				evaluatedControlModel.Specifications = []catalogmanagementv1.SccSpecification{*sccSpecificationModel}
				evaluatedControlModel.FailureCount = core.Int64Ptr(int64(38))
				evaluatedControlModel.PassCount = core.Int64Ptr(int64(38))
				evaluatedControlModel.Parent = sccControlModel
				evaluatedControlModel.UIHref = core.StringPtr("testString")

				// Construct an instance of the Evaluation model
				evaluationModel := new(catalogmanagementv1.Evaluation)
				evaluationModel.ScanID = core.StringPtr("testString")
				evaluationModel.AccountID = core.StringPtr("testString")
				evaluationModel.Profile = sccProfileModel
				evaluationModel.Result = resultModel
				evaluationModel.Controls = []catalogmanagementv1.EvaluatedControl{*evaluatedControlModel}

				// Construct an instance of the Compliance model
				complianceModel := new(catalogmanagementv1.Compliance)
				complianceModel.Authority = core.StringPtr("testString")
				complianceModel.Claims = claimsModel
				complianceModel.Evaluations = []catalogmanagementv1.Evaluation{*evaluationModel}

				// Construct an instance of the ChangeNotices model
				changeNoticesModel := new(catalogmanagementv1.ChangeNotices)
				changeNoticesModel.Breaking = []catalogmanagementv1.Feature{*featureModel}
				changeNoticesModel.New = []catalogmanagementv1.Feature{*featureModel}
				changeNoticesModel.Update = []catalogmanagementv1.Feature{*featureModel}

				// Construct an instance of the Version model
				versionModel := new(catalogmanagementv1.Version)
				versionModel.CRN = core.StringPtr("testString")
				versionModel.Version = core.StringPtr("testString")
				versionModel.Flavor = flavorModel
				versionModel.Sha = core.StringPtr("testString")
				versionModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				versionModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				versionModel.OfferingID = core.StringPtr("testString")
				versionModel.CatalogID = core.StringPtr("testString")
				versionModel.KindID = core.StringPtr("testString")
				versionModel.Tags = []string{"testString"}
				versionModel.RepoURL = core.StringPtr("testString")
				versionModel.SourceURL = core.StringPtr("testString")
				versionModel.TgzURL = core.StringPtr("testString")
				versionModel.Configuration = []catalogmanagementv1.Configuration{*configurationModel}
				versionModel.Outputs = []catalogmanagementv1.Output{*outputModel}
				versionModel.IamPermissions = []catalogmanagementv1.IamPermission{*iamPermissionModel}
				versionModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				versionModel.Validation = validationModel
				versionModel.RequiredResources = []catalogmanagementv1.Resource{*resourceModel}
				versionModel.SingleInstance = core.BoolPtr(true)
				versionModel.SchematicsEnvValues = schematicsEnvValuesModel
				versionModel.Install = scriptModel
				versionModel.PreInstall = []catalogmanagementv1.Script{*scriptModel}
				versionModel.Scripts = map[string]catalogmanagementv1.ScriptRef{"key1": *scriptRefModel}
				versionModel.Entitlement = versionEntitlementModel
				versionModel.Licenses = []catalogmanagementv1.License{*licenseModel}
				versionModel.ImageManifestURL = core.StringPtr("testString")
				versionModel.Deprecated = core.BoolPtr(true)
				versionModel.PackageVersion = core.StringPtr("testString")
				versionModel.State = stateModel
				versionModel.VersionLocator = core.StringPtr("testString")
				versionModel.LongDescription = core.StringPtr("testString")
				versionModel.LongDescriptionI18n = map[string]string{"key1": "testString"}
				versionModel.WhitelistedAccounts = []string{"testString"}
				versionModel.ImagePullKeyName = core.StringPtr("testString")
				versionModel.DeprecatePending = deprecatePendingModel
				versionModel.SolutionInfo = solutionInfoModel
				versionModel.IsConsumable = core.BoolPtr(true)
				versionModel.ComplianceV3 = complianceModel
				versionModel.ChangeNotices = changeNoticesModel
				versionModel.PlanIds = []string{"testString"}
				versionModel.Stack = map[string]interface{}{"anyKey": "anyValue"}
				versionModel.MinimumCompatibleVersion = core.StringPtr("testString")
				versionModel.Scripts["foo"] = *scriptRefModel

				// Construct an instance of the PaginationTokenLink model
				paginationTokenLinkModel := new(catalogmanagementv1.PaginationTokenLink)
				paginationTokenLinkModel.Href = core.StringPtr("testString")
				paginationTokenLinkModel.Start = core.StringPtr("testString")

				// Construct an instance of the KindAllVersions model
				kindAllVersionsModel := new(catalogmanagementv1.KindAllVersions)
				kindAllVersionsModel.First = paginationTokenLinkModel
				kindAllVersionsModel.Next = paginationTokenLinkModel

				// Construct an instance of the Kind model
				kindModel := new(catalogmanagementv1.Kind)
				kindModel.ID = core.StringPtr("testString")
				kindModel.FormatKind = core.StringPtr("testString")
				kindModel.FormatKindLabel = core.StringPtr("testString")
				kindModel.InstallKind = core.StringPtr("testString")
				kindModel.InstallKindLabel = core.StringPtr("testString")
				kindModel.TargetKind = core.StringPtr("testString")
				kindModel.TargetKindLabel = core.StringPtr("testString")
				kindModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				kindModel.Tags = []string{"testString"}
				kindModel.AdditionalFeatures = []catalogmanagementv1.Feature{*featureModel}
				kindModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				kindModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				kindModel.Versions = []catalogmanagementv1.Version{*versionModel}
				kindModel.AllVersions = kindAllVersionsModel

				// Construct an instance of the PublishObject model
				publishObjectModel := new(catalogmanagementv1.PublishObject)
				publishObjectModel.PcManaged = core.BoolPtr(true)
				publishObjectModel.ApprovalType = core.StringPtr("testString")
				publishObjectModel.PublishApproved = core.BoolPtr(true)
				publishObjectModel.ShareWithAll = core.BoolPtr(true)
				publishObjectModel.ShareWithIBM = core.BoolPtr(true)
				publishObjectModel.ShareEnabled = core.BoolPtr(true)
				publishObjectModel.OriginalCRN = core.StringPtr("testString")
				publishObjectModel.PublicCRN = core.StringPtr("testString")
				publishObjectModel.ApprovalRecord = map[string]interface{}{"anyKey": "anyValue"}
				publishObjectModel.PermitIBMPublicPublish = core.BoolPtr(true)
				publishObjectModel.IBMApproved = core.BoolPtr(true)
				publishObjectModel.PublicApproved = core.BoolPtr(true)

				// Construct an instance of the ProviderInfo model
				providerInfoModel := new(catalogmanagementv1.ProviderInfo)
				providerInfoModel.ID = core.StringPtr("testString")
				providerInfoModel.Name = core.StringPtr("testString")

				// Construct an instance of the RepoInfo model
				repoInfoModel := new(catalogmanagementv1.RepoInfo)
				repoInfoModel.Token = core.StringPtr("testString")
				repoInfoModel.Type = core.StringPtr("testString")

				// Construct an instance of the ImagePullKey model
				imagePullKeyModel := new(catalogmanagementv1.ImagePullKey)
				imagePullKeyModel.Name = core.StringPtr("testString")
				imagePullKeyModel.Value = core.StringPtr("testString")
				imagePullKeyModel.Description = core.StringPtr("testString")

				// Construct an instance of the SupportWaitTime model
				supportWaitTimeModel := new(catalogmanagementv1.SupportWaitTime)
				supportWaitTimeModel.Value = core.Int64Ptr(int64(38))
				supportWaitTimeModel.Type = core.StringPtr("testString")

				// Construct an instance of the SupportTime model
				supportTimeModel := new(catalogmanagementv1.SupportTime)
				supportTimeModel.Day = core.Int64Ptr(int64(38))
				supportTimeModel.StartTime = core.StringPtr("testString")
				supportTimeModel.EndTime = core.StringPtr("testString")

				// Construct an instance of the SupportAvailability model
				supportAvailabilityModel := new(catalogmanagementv1.SupportAvailability)
				supportAvailabilityModel.Times = []catalogmanagementv1.SupportTime{*supportTimeModel}
				supportAvailabilityModel.Timezone = core.StringPtr("testString")
				supportAvailabilityModel.AlwaysAvailable = core.BoolPtr(true)

				// Construct an instance of the SupportDetail model
				supportDetailModel := new(catalogmanagementv1.SupportDetail)
				supportDetailModel.Type = core.StringPtr("testString")
				supportDetailModel.Contact = core.StringPtr("testString")
				supportDetailModel.ResponseWaitTime = supportWaitTimeModel
				supportDetailModel.Availability = supportAvailabilityModel

				// Construct an instance of the SupportEscalation model
				supportEscalationModel := new(catalogmanagementv1.SupportEscalation)
				supportEscalationModel.EscalationWaitTime = supportWaitTimeModel
				supportEscalationModel.ResponseWaitTime = supportWaitTimeModel
				supportEscalationModel.Contact = core.StringPtr("testString")

				// Construct an instance of the Support model
				supportModel := new(catalogmanagementv1.Support)
				supportModel.URL = core.StringPtr("testString")
				supportModel.Process = core.StringPtr("testString")
				supportModel.ProcessI18n = map[string]string{"key1": "testString"}
				supportModel.Locations = []string{"testString"}
				supportModel.SupportDetails = []catalogmanagementv1.SupportDetail{*supportDetailModel}
				supportModel.SupportEscalation = supportEscalationModel
				supportModel.SupportType = core.StringPtr("testString")

				// Construct an instance of the LearnMoreLinks model
				learnMoreLinksModel := new(catalogmanagementv1.LearnMoreLinks)
				learnMoreLinksModel.FirstParty = core.StringPtr("testString")
				learnMoreLinksModel.ThirdParty = core.StringPtr("testString")

				// Construct an instance of the Constraint model
				constraintModel := new(catalogmanagementv1.Constraint)
				constraintModel.Type = core.StringPtr("testString")
				constraintModel.Rule = "testString"

				// Construct an instance of the Badge model
				badgeModel := new(catalogmanagementv1.Badge)
				badgeModel.ID = core.StringPtr("testString")
				badgeModel.Label = core.StringPtr("testString")
				badgeModel.LabelI18n = map[string]string{"key1": "testString"}
				badgeModel.Description = core.StringPtr("testString")
				badgeModel.DescriptionI18n = map[string]string{"key1": "testString"}
				badgeModel.Icon = core.StringPtr("testString")
				badgeModel.Authority = core.StringPtr("testString")
				badgeModel.Tag = core.StringPtr("testString")
				badgeModel.LearnMoreLinks = learnMoreLinksModel
				badgeModel.Constraints = []catalogmanagementv1.Constraint{*constraintModel}

				// Construct an instance of the VersionRange model
				versionRangeModel := new(catalogmanagementv1.VersionRange)
				versionRangeModel.Kinds = []string{"testString"}
				versionRangeModel.Version = core.StringPtr("testString")
				versionRangeModel.Flavors = []string{"testString"}

				// Construct an instance of the Plan model
				planModel := new(catalogmanagementv1.Plan)
				planModel.URL = core.StringPtr("testString")
				planModel.CRN = core.StringPtr("testString")
				planModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				planModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				planModel.OfferingID = core.StringPtr("testString")
				planModel.CatalogID = core.StringPtr("testString")
				planModel.Label = core.StringPtr("testString")
				planModel.LabelI18n = map[string]string{"key1": "testString"}
				planModel.Name = core.StringPtr("testString")
				planModel.ShortDescription = core.StringPtr("testString")
				planModel.ShortDescriptionI18n = map[string]string{"key1": "testString"}
				planModel.PricingTags = []string{"testString"}
				planModel.VersionRange = versionRangeModel
				planModel.Features = []catalogmanagementv1.Feature{*featureModel}
				planModel.State = stateModel
				planModel.DeprecatePending = deprecatePendingModel
				planModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				planModel.PublishApproved = core.BoolPtr(true)

				// Construct an instance of the UpdateVersionOptions model
				updateVersionOptionsModel := new(catalogmanagementv1.UpdateVersionOptions)
				updateVersionOptionsModel.VersionLocID = core.StringPtr("testString")
				updateVersionOptionsModel.ID = core.StringPtr("testString")
				updateVersionOptionsModel.Rev = core.StringPtr("testString")
				updateVersionOptionsModel.URL = core.StringPtr("testString")
				updateVersionOptionsModel.CRN = core.StringPtr("testString")
				updateVersionOptionsModel.Label = core.StringPtr("testString")
				updateVersionOptionsModel.LabelI18n = map[string]string{"key1": "testString"}
				updateVersionOptionsModel.Name = core.StringPtr("testString")
				updateVersionOptionsModel.OfferingIconURL = core.StringPtr("testString")
				updateVersionOptionsModel.OfferingDocsURL = core.StringPtr("testString")
				updateVersionOptionsModel.OfferingSupportURL = core.StringPtr("testString")
				updateVersionOptionsModel.Tags = []string{"testString"}
				updateVersionOptionsModel.Keywords = []string{"testString"}
				updateVersionOptionsModel.Rating = ratingModel
				updateVersionOptionsModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				updateVersionOptionsModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				updateVersionOptionsModel.ShortDescription = core.StringPtr("testString")
				updateVersionOptionsModel.ShortDescriptionI18n = map[string]string{"key1": "testString"}
				updateVersionOptionsModel.LongDescription = core.StringPtr("testString")
				updateVersionOptionsModel.LongDescriptionI18n = map[string]string{"key1": "testString"}
				updateVersionOptionsModel.Features = []catalogmanagementv1.Feature{*featureModel}
				updateVersionOptionsModel.Kinds = []catalogmanagementv1.Kind{*kindModel}
				updateVersionOptionsModel.Publish = publishObjectModel
				updateVersionOptionsModel.PcManaged = core.BoolPtr(true)
				updateVersionOptionsModel.PublishApproved = core.BoolPtr(true)
				updateVersionOptionsModel.ShareWithAll = core.BoolPtr(true)
				updateVersionOptionsModel.ShareWithIBM = core.BoolPtr(true)
				updateVersionOptionsModel.ShareEnabled = core.BoolPtr(true)
				updateVersionOptionsModel.PublicOriginalCRN = core.StringPtr("testString")
				updateVersionOptionsModel.PublishPublicCRN = core.StringPtr("testString")
				updateVersionOptionsModel.PortalApprovalRecord = core.StringPtr("testString")
				updateVersionOptionsModel.PortalUIURL = core.StringPtr("testString")
				updateVersionOptionsModel.CatalogID = core.StringPtr("testString")
				updateVersionOptionsModel.CatalogName = core.StringPtr("testString")
				updateVersionOptionsModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				updateVersionOptionsModel.Disclaimer = core.StringPtr("testString")
				updateVersionOptionsModel.Hidden = core.BoolPtr(true)
				updateVersionOptionsModel.Provider = core.StringPtr("testString")
				updateVersionOptionsModel.ProviderInfo = providerInfoModel
				updateVersionOptionsModel.RepoInfo = repoInfoModel
				updateVersionOptionsModel.ImagePullKeys = []catalogmanagementv1.ImagePullKey{*imagePullKeyModel}
				updateVersionOptionsModel.Support = supportModel
				updateVersionOptionsModel.Media = []catalogmanagementv1.MediaItem{*mediaItemModel}
				updateVersionOptionsModel.DeprecatePending = deprecatePendingModel
				updateVersionOptionsModel.ProductKind = core.StringPtr("testString")
				updateVersionOptionsModel.Badges = []catalogmanagementv1.Badge{*badgeModel}
				updateVersionOptionsModel.Plans = []catalogmanagementv1.Plan{*planModel}
				updateVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.UpdateVersion(updateVersionOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`PatchUpdateVersion(patchUpdateVersionOptions *PatchUpdateVersionOptions) - Operation response error`, func() {
		patchUpdateVersionPath := "/versions/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(patchUpdateVersionPath))
					Expect(req.Method).To(Equal("PATCH"))
					Expect(req.Header["If-Match"]).ToNot(BeNil())
					Expect(req.Header["If-Match"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke PatchUpdateVersion with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the JSONPatchOperation model
				jsonPatchOperationModel := new(catalogmanagementv1.JSONPatchOperation)
				jsonPatchOperationModel.Op = core.StringPtr("add")
				jsonPatchOperationModel.Path = core.StringPtr("testString")
				jsonPatchOperationModel.Value = "testString"
				jsonPatchOperationModel.From = core.StringPtr("testString")

				// Construct an instance of the PatchUpdateVersionOptions model
				patchUpdateVersionOptionsModel := new(catalogmanagementv1.PatchUpdateVersionOptions)
				patchUpdateVersionOptionsModel.VersionLocID = core.StringPtr("testString")
				patchUpdateVersionOptionsModel.IfMatch = core.StringPtr("testString")
				patchUpdateVersionOptionsModel.Updates = []catalogmanagementv1.JSONPatchOperation{*jsonPatchOperationModel}
				patchUpdateVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.PatchUpdateVersion(patchUpdateVersionOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.PatchUpdateVersion(patchUpdateVersionOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`PatchUpdateVersion(patchUpdateVersionOptions *PatchUpdateVersionOptions)`, func() {
		patchUpdateVersionPath := "/versions/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(patchUpdateVersionPath))
					Expect(req.Method).To(Equal("PATCH"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["If-Match"]).ToNot(BeNil())
					Expect(req.Header["If-Match"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "name": "Name", "offering_icon_url": "OfferingIconURL", "offering_docs_url": "OfferingDocsURL", "offering_support_url": "OfferingSupportURL", "tags": ["Tags"], "keywords": ["Keywords"], "rating": {"one_star_count": 12, "two_star_count": 12, "three_star_count": 14, "four_star_count": 13}, "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "kinds": [{"id": "ID", "format_kind": "FormatKind", "format_kind_label": "FormatKindLabel", "install_kind": "InstallKind", "install_kind_label": "InstallKindLabel", "target_kind": "TargetKind", "target_kind_label": "TargetKindLabel", "metadata": {"anyKey": "anyValue"}, "tags": ["Tags"], "additional_features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "versions": [{"id": "ID", "_rev": "Rev", "crn": "CRN", "version": "Version", "flavor": {"name": "Name", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "index": 5}, "sha": "Sha", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "offering_id": "OfferingID", "catalog_id": "CatalogID", "kind_id": "KindID", "tags": ["Tags"], "repo_url": "RepoURL", "source_url": "SourceURL", "tgz_url": "TgzURL", "configuration": [{"key": "Key", "type": "Type", "default_value": "anyValue", "display_name": "DisplayName", "value_constraint": "ValueConstraint", "description": "Description", "required": true, "options": ["anyValue"], "hidden": true, "custom_config": {"type": "Type", "grouping": "Grouping", "original_grouping": "OriginalGrouping", "grouping_index": 13, "config_constraints": {"anyKey": "anyValue"}, "associations": {"parameters": [{"name": "Name", "optionsRefresh": true}]}}, "type_metadata": "TypeMetadata"}], "outputs": [{"key": "Key", "description": "Description"}], "iam_permissions": [{"service_name": "ServiceName", "role_crns": ["RoleCrns"], "resources": [{"name": "Name", "description": "Description", "role_crns": ["RoleCrns"]}]}], "metadata": {"anyKey": "anyValue"}, "validation": {"validated": "2019-01-01T12:00:00.000Z", "requested": "2019-01-01T12:00:00.000Z", "state": "State", "last_operation": "LastOperation", "target": {"anyKey": "anyValue"}, "message": "Message"}, "required_resources": [{"type": "mem", "value": "anyValue"}], "single_instance": true, "schematics_env_values": {"value": "[{\"name\": \"TF_LOG\",\"value\": \"TRACE\",\"secure\": false,\"hidden\": false}]", "sm_ref": "cmsm_v1:{\"name\": \"envVarSecret\",\"id\":\"1234567890\",\"service_id\":\"crn:v1:bluemix:public:secrets-manager:eu-gb:a/1234567890:1234567890::\",\"service_name\":\"My SM Instance\",\"group_id\":\"1234567890\",\"group_name\":\"My SM Group\",\"resource_group_id\":\"1234567890\",\"region\":\"eu-gb\",\"type\":\"arbitrary\"}"}, "install": {"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}, "pre_install": [{"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}], "scripts": {"mapKey": {"short_description": "ShortDescription", "type": "ansible", "path": "scripts/validate-post-ansible-playbook.yaml", "stage": "pre", "action": "validate"}}, "entitlement": {"provider_name": "ProviderName", "provider_id": "ProviderID", "product_id": "ProductID", "part_numbers": ["PartNumbers"], "image_repo_name": "ImageRepoName"}, "licenses": [{"id": "ID", "name": "Name", "type": "Type", "url": "URL", "description": "Description"}], "image_manifest_url": "ImageManifestURL", "deprecated": true, "package_version": "PackageVersion", "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "version_locator": "VersionLocator", "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "whitelisted_accounts": ["WhitelistedAccounts"], "image_pull_key_name": "ImagePullKeyName", "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "solution_info": {"architecture_diagrams": [{"diagram": {"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "cost_estimate": {"version": "Version", "currency": "Currency", "projects": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "pastBreakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "breakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "diff": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}}], "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}, "totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "pastTotalHourlyCost": "PastTotalHourlyCost", "pastTotalMonthlyCost": "PastTotalMonthlyCost", "diffTotalHourlyCost": "DiffTotalHourlyCost", "diffTotalMonthlyCost": "DiffTotalMonthlyCost", "timeGenerated": "2019-01-01T12:00:00.000Z"}, "dependencies": [{"catalog_id": "CatalogID", "id": "ID", "name": "Name", "kind": "Kind", "version": "Version", "description": "Description", "default_flavor": "DefaultFlavor", "flavors": ["Flavors"], "optional": true, "on_by_default": false}], "install_type": "InstallType"}, "is_consumable": true, "compliance_v3": {"authority": "Authority", "claims": {"profiles": [{"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}], "controls": [{"profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "names": ["Names"]}]}, "evaluations": [{"scan_id": "ScanID", "account_id": "AccountID", "profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "result": {"failure_count": 12, "scan_time": "2019-01-01T12:00:00.000Z", "error_message": "ErrorMessage", "complete_scan": true, "unscanned_resources": ["UnscannedResources"]}, "controls": [{"id": "ID", "name": "Name", "description": "Description", "specifications": [{"id": "ID", "description": "Description", "component_name": "ComponentName", "assessments": [{"id": "ID", "description": "Description", "version": "Version", "type": "Type", "method": "Method", "ui_href": "UIHref"}], "ui_href": "UIHref"}], "failure_count": 12, "pass_count": 9, "parent": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "parent_name": "ParentName", "specifications": [{"id": "ID", "description": "Description", "component_name": "ComponentName", "assessments": [{"id": "ID", "description": "Description", "version": "Version", "type": "Type", "method": "Method", "ui_href": "UIHref"}], "ui_href": "UIHref"}], "ui_href": "UIHref"}, "ui_href": "UIHref"}]}]}, "change_notices": {"breaking": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "new": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "update": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}]}, "plan_ids": ["PlanIds"], "stack": {"anyKey": "anyValue"}, "minimum_compatible_version": "MinimumCompatibleVersion"}], "all_versions": {"first": {"href": "Href", "start": "Start"}, "next": {"href": "Href", "start": "Start"}}}], "publish": {"pc_managed": false, "approval_type": "ApprovalType", "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "original_crn": "OriginalCRN", "public_crn": "PublicCRN", "approval_record": {"anyKey": "anyValue"}, "permit_ibm_public_publish": true, "ibm_approved": false, "public_approved": true}, "pc_managed": false, "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "public_original_crn": "PublicOriginalCRN", "publish_public_crn": "PublishPublicCRN", "portal_approval_record": "PortalApprovalRecord", "portal_ui_url": "PortalUIURL", "catalog_id": "CatalogID", "catalog_name": "CatalogName", "metadata": {"anyKey": "anyValue"}, "disclaimer": "Disclaimer", "hidden": true, "provider": "Provider", "provider_info": {"id": "ID", "name": "Name"}, "repo_info": {"token": "Token", "type": "Type"}, "image_pull_keys": [{"name": "Name", "value": "Value", "description": "Description"}], "support": {"url": "URL", "process": "Process", "process_i18n": {"mapKey": "Inner"}, "locations": ["Locations"], "support_details": [{"type": "Type", "contact": "Contact", "response_wait_time": {"value": 5, "type": "Type"}, "availability": {"times": [{"day": 3, "start_time": "StartTime", "end_time": "EndTime"}], "timezone": "Timezone", "always_available": false}}], "support_escalation": {"escalation_wait_time": {"value": 5, "type": "Type"}, "response_wait_time": {"value": 5, "type": "Type"}, "contact": "Contact"}, "support_type": "SupportType"}, "media": [{"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}], "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "product_kind": "ProductKind", "badges": [{"id": "ID", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}, "icon": "Icon", "authority": "Authority", "tag": "Tag", "learn_more_links": {"first_party": "FirstParty", "third_party": "ThirdParty"}, "constraints": [{"type": "Type", "rule": "anyValue"}]}], "plans": [{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "offering_id": "OfferingID", "catalog_id": "CatalogID", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "name": "Name", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "pricing_tags": ["PricingTags"], "version_range": {"kinds": ["Kinds"], "version": "Version", "flavors": ["Flavors"]}, "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "metadata": {"anyKey": "anyValue"}, "publish_approved": false}]}`)
				}))
			})
			It(`Invoke PatchUpdateVersion successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the JSONPatchOperation model
				jsonPatchOperationModel := new(catalogmanagementv1.JSONPatchOperation)
				jsonPatchOperationModel.Op = core.StringPtr("add")
				jsonPatchOperationModel.Path = core.StringPtr("testString")
				jsonPatchOperationModel.Value = "testString"
				jsonPatchOperationModel.From = core.StringPtr("testString")

				// Construct an instance of the PatchUpdateVersionOptions model
				patchUpdateVersionOptionsModel := new(catalogmanagementv1.PatchUpdateVersionOptions)
				patchUpdateVersionOptionsModel.VersionLocID = core.StringPtr("testString")
				patchUpdateVersionOptionsModel.IfMatch = core.StringPtr("testString")
				patchUpdateVersionOptionsModel.Updates = []catalogmanagementv1.JSONPatchOperation{*jsonPatchOperationModel}
				patchUpdateVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.PatchUpdateVersionWithContext(ctx, patchUpdateVersionOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.PatchUpdateVersion(patchUpdateVersionOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.PatchUpdateVersionWithContext(ctx, patchUpdateVersionOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(patchUpdateVersionPath))
					Expect(req.Method).To(Equal("PATCH"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["If-Match"]).ToNot(BeNil())
					Expect(req.Header["If-Match"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "name": "Name", "offering_icon_url": "OfferingIconURL", "offering_docs_url": "OfferingDocsURL", "offering_support_url": "OfferingSupportURL", "tags": ["Tags"], "keywords": ["Keywords"], "rating": {"one_star_count": 12, "two_star_count": 12, "three_star_count": 14, "four_star_count": 13}, "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "kinds": [{"id": "ID", "format_kind": "FormatKind", "format_kind_label": "FormatKindLabel", "install_kind": "InstallKind", "install_kind_label": "InstallKindLabel", "target_kind": "TargetKind", "target_kind_label": "TargetKindLabel", "metadata": {"anyKey": "anyValue"}, "tags": ["Tags"], "additional_features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "versions": [{"id": "ID", "_rev": "Rev", "crn": "CRN", "version": "Version", "flavor": {"name": "Name", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "index": 5}, "sha": "Sha", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "offering_id": "OfferingID", "catalog_id": "CatalogID", "kind_id": "KindID", "tags": ["Tags"], "repo_url": "RepoURL", "source_url": "SourceURL", "tgz_url": "TgzURL", "configuration": [{"key": "Key", "type": "Type", "default_value": "anyValue", "display_name": "DisplayName", "value_constraint": "ValueConstraint", "description": "Description", "required": true, "options": ["anyValue"], "hidden": true, "custom_config": {"type": "Type", "grouping": "Grouping", "original_grouping": "OriginalGrouping", "grouping_index": 13, "config_constraints": {"anyKey": "anyValue"}, "associations": {"parameters": [{"name": "Name", "optionsRefresh": true}]}}, "type_metadata": "TypeMetadata"}], "outputs": [{"key": "Key", "description": "Description"}], "iam_permissions": [{"service_name": "ServiceName", "role_crns": ["RoleCrns"], "resources": [{"name": "Name", "description": "Description", "role_crns": ["RoleCrns"]}]}], "metadata": {"anyKey": "anyValue"}, "validation": {"validated": "2019-01-01T12:00:00.000Z", "requested": "2019-01-01T12:00:00.000Z", "state": "State", "last_operation": "LastOperation", "target": {"anyKey": "anyValue"}, "message": "Message"}, "required_resources": [{"type": "mem", "value": "anyValue"}], "single_instance": true, "schematics_env_values": {"value": "[{\"name\": \"TF_LOG\",\"value\": \"TRACE\",\"secure\": false,\"hidden\": false}]", "sm_ref": "cmsm_v1:{\"name\": \"envVarSecret\",\"id\":\"1234567890\",\"service_id\":\"crn:v1:bluemix:public:secrets-manager:eu-gb:a/1234567890:1234567890::\",\"service_name\":\"My SM Instance\",\"group_id\":\"1234567890\",\"group_name\":\"My SM Group\",\"resource_group_id\":\"1234567890\",\"region\":\"eu-gb\",\"type\":\"arbitrary\"}"}, "install": {"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}, "pre_install": [{"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}], "scripts": {"mapKey": {"short_description": "ShortDescription", "type": "ansible", "path": "scripts/validate-post-ansible-playbook.yaml", "stage": "pre", "action": "validate"}}, "entitlement": {"provider_name": "ProviderName", "provider_id": "ProviderID", "product_id": "ProductID", "part_numbers": ["PartNumbers"], "image_repo_name": "ImageRepoName"}, "licenses": [{"id": "ID", "name": "Name", "type": "Type", "url": "URL", "description": "Description"}], "image_manifest_url": "ImageManifestURL", "deprecated": true, "package_version": "PackageVersion", "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "version_locator": "VersionLocator", "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "whitelisted_accounts": ["WhitelistedAccounts"], "image_pull_key_name": "ImagePullKeyName", "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "solution_info": {"architecture_diagrams": [{"diagram": {"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "cost_estimate": {"version": "Version", "currency": "Currency", "projects": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "pastBreakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "breakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "diff": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}}], "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}, "totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "pastTotalHourlyCost": "PastTotalHourlyCost", "pastTotalMonthlyCost": "PastTotalMonthlyCost", "diffTotalHourlyCost": "DiffTotalHourlyCost", "diffTotalMonthlyCost": "DiffTotalMonthlyCost", "timeGenerated": "2019-01-01T12:00:00.000Z"}, "dependencies": [{"catalog_id": "CatalogID", "id": "ID", "name": "Name", "kind": "Kind", "version": "Version", "description": "Description", "default_flavor": "DefaultFlavor", "flavors": ["Flavors"], "optional": true, "on_by_default": false}], "install_type": "InstallType"}, "is_consumable": true, "compliance_v3": {"authority": "Authority", "claims": {"profiles": [{"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}], "controls": [{"profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "names": ["Names"]}]}, "evaluations": [{"scan_id": "ScanID", "account_id": "AccountID", "profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "result": {"failure_count": 12, "scan_time": "2019-01-01T12:00:00.000Z", "error_message": "ErrorMessage", "complete_scan": true, "unscanned_resources": ["UnscannedResources"]}, "controls": [{"id": "ID", "name": "Name", "description": "Description", "specifications": [{"id": "ID", "description": "Description", "component_name": "ComponentName", "assessments": [{"id": "ID", "description": "Description", "version": "Version", "type": "Type", "method": "Method", "ui_href": "UIHref"}], "ui_href": "UIHref"}], "failure_count": 12, "pass_count": 9, "parent": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "parent_name": "ParentName", "specifications": [{"id": "ID", "description": "Description", "component_name": "ComponentName", "assessments": [{"id": "ID", "description": "Description", "version": "Version", "type": "Type", "method": "Method", "ui_href": "UIHref"}], "ui_href": "UIHref"}], "ui_href": "UIHref"}, "ui_href": "UIHref"}]}]}, "change_notices": {"breaking": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "new": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "update": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}]}, "plan_ids": ["PlanIds"], "stack": {"anyKey": "anyValue"}, "minimum_compatible_version": "MinimumCompatibleVersion"}], "all_versions": {"first": {"href": "Href", "start": "Start"}, "next": {"href": "Href", "start": "Start"}}}], "publish": {"pc_managed": false, "approval_type": "ApprovalType", "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "original_crn": "OriginalCRN", "public_crn": "PublicCRN", "approval_record": {"anyKey": "anyValue"}, "permit_ibm_public_publish": true, "ibm_approved": false, "public_approved": true}, "pc_managed": false, "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "public_original_crn": "PublicOriginalCRN", "publish_public_crn": "PublishPublicCRN", "portal_approval_record": "PortalApprovalRecord", "portal_ui_url": "PortalUIURL", "catalog_id": "CatalogID", "catalog_name": "CatalogName", "metadata": {"anyKey": "anyValue"}, "disclaimer": "Disclaimer", "hidden": true, "provider": "Provider", "provider_info": {"id": "ID", "name": "Name"}, "repo_info": {"token": "Token", "type": "Type"}, "image_pull_keys": [{"name": "Name", "value": "Value", "description": "Description"}], "support": {"url": "URL", "process": "Process", "process_i18n": {"mapKey": "Inner"}, "locations": ["Locations"], "support_details": [{"type": "Type", "contact": "Contact", "response_wait_time": {"value": 5, "type": "Type"}, "availability": {"times": [{"day": 3, "start_time": "StartTime", "end_time": "EndTime"}], "timezone": "Timezone", "always_available": false}}], "support_escalation": {"escalation_wait_time": {"value": 5, "type": "Type"}, "response_wait_time": {"value": 5, "type": "Type"}, "contact": "Contact"}, "support_type": "SupportType"}, "media": [{"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}], "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "product_kind": "ProductKind", "badges": [{"id": "ID", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}, "icon": "Icon", "authority": "Authority", "tag": "Tag", "learn_more_links": {"first_party": "FirstParty", "third_party": "ThirdParty"}, "constraints": [{"type": "Type", "rule": "anyValue"}]}], "plans": [{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "offering_id": "OfferingID", "catalog_id": "CatalogID", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "name": "Name", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "pricing_tags": ["PricingTags"], "version_range": {"kinds": ["Kinds"], "version": "Version", "flavors": ["Flavors"]}, "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "metadata": {"anyKey": "anyValue"}, "publish_approved": false}]}`)
				}))
			})
			It(`Invoke PatchUpdateVersion successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.PatchUpdateVersion(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the JSONPatchOperation model
				jsonPatchOperationModel := new(catalogmanagementv1.JSONPatchOperation)
				jsonPatchOperationModel.Op = core.StringPtr("add")
				jsonPatchOperationModel.Path = core.StringPtr("testString")
				jsonPatchOperationModel.Value = "testString"
				jsonPatchOperationModel.From = core.StringPtr("testString")

				// Construct an instance of the PatchUpdateVersionOptions model
				patchUpdateVersionOptionsModel := new(catalogmanagementv1.PatchUpdateVersionOptions)
				patchUpdateVersionOptionsModel.VersionLocID = core.StringPtr("testString")
				patchUpdateVersionOptionsModel.IfMatch = core.StringPtr("testString")
				patchUpdateVersionOptionsModel.Updates = []catalogmanagementv1.JSONPatchOperation{*jsonPatchOperationModel}
				patchUpdateVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.PatchUpdateVersion(patchUpdateVersionOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke PatchUpdateVersion with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the JSONPatchOperation model
				jsonPatchOperationModel := new(catalogmanagementv1.JSONPatchOperation)
				jsonPatchOperationModel.Op = core.StringPtr("add")
				jsonPatchOperationModel.Path = core.StringPtr("testString")
				jsonPatchOperationModel.Value = "testString"
				jsonPatchOperationModel.From = core.StringPtr("testString")

				// Construct an instance of the PatchUpdateVersionOptions model
				patchUpdateVersionOptionsModel := new(catalogmanagementv1.PatchUpdateVersionOptions)
				patchUpdateVersionOptionsModel.VersionLocID = core.StringPtr("testString")
				patchUpdateVersionOptionsModel.IfMatch = core.StringPtr("testString")
				patchUpdateVersionOptionsModel.Updates = []catalogmanagementv1.JSONPatchOperation{*jsonPatchOperationModel}
				patchUpdateVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.PatchUpdateVersion(patchUpdateVersionOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the PatchUpdateVersionOptions model with no property values
				patchUpdateVersionOptionsModelNew := new(catalogmanagementv1.PatchUpdateVersionOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.PatchUpdateVersion(patchUpdateVersionOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke PatchUpdateVersion successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the JSONPatchOperation model
				jsonPatchOperationModel := new(catalogmanagementv1.JSONPatchOperation)
				jsonPatchOperationModel.Op = core.StringPtr("add")
				jsonPatchOperationModel.Path = core.StringPtr("testString")
				jsonPatchOperationModel.Value = "testString"
				jsonPatchOperationModel.From = core.StringPtr("testString")

				// Construct an instance of the PatchUpdateVersionOptions model
				patchUpdateVersionOptionsModel := new(catalogmanagementv1.PatchUpdateVersionOptions)
				patchUpdateVersionOptionsModel.VersionLocID = core.StringPtr("testString")
				patchUpdateVersionOptionsModel.IfMatch = core.StringPtr("testString")
				patchUpdateVersionOptionsModel.Updates = []catalogmanagementv1.JSONPatchOperation{*jsonPatchOperationModel}
				patchUpdateVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.PatchUpdateVersion(patchUpdateVersionOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`DeleteVersion(deleteVersionOptions *DeleteVersionOptions)`, func() {
		deleteVersionPath := "/versions/testString"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deleteVersionPath))
					Expect(req.Method).To(Equal("DELETE"))

					res.WriteHeader(200)
				}))
			})
			It(`Invoke DeleteVersion successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := catalogManagementService.DeleteVersion(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the DeleteVersionOptions model
				deleteVersionOptionsModel := new(catalogmanagementv1.DeleteVersionOptions)
				deleteVersionOptionsModel.VersionLocID = core.StringPtr("testString")
				deleteVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = catalogManagementService.DeleteVersion(deleteVersionOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke DeleteVersion with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the DeleteVersionOptions model
				deleteVersionOptionsModel := new(catalogmanagementv1.DeleteVersionOptions)
				deleteVersionOptionsModel.VersionLocID = core.StringPtr("testString")
				deleteVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := catalogManagementService.DeleteVersion(deleteVersionOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the DeleteVersionOptions model with no property values
				deleteVersionOptionsModelNew := new(catalogmanagementv1.DeleteVersionOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = catalogManagementService.DeleteVersion(deleteVersionOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetVersionDependencies(getVersionDependenciesOptions *GetVersionDependenciesOptions) - Operation response error`, func() {
		getVersionDependenciesPath := "/versions/testString/dependencies"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getVersionDependenciesPath))
					Expect(req.Method).To(Equal("GET"))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetVersionDependencies with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetVersionDependenciesOptions model
				getVersionDependenciesOptionsModel := new(catalogmanagementv1.GetVersionDependenciesOptions)
				getVersionDependenciesOptionsModel.VersionLocID = core.StringPtr("testString")
				getVersionDependenciesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.GetVersionDependencies(getVersionDependenciesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.GetVersionDependencies(getVersionDependenciesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetVersionDependencies(getVersionDependenciesOptions *GetVersionDependenciesOptions)`, func() {
		getVersionDependenciesPath := "/versions/testString/dependencies"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getVersionDependenciesPath))
					Expect(req.Method).To(Equal("GET"))

					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"start": "Start", "limit": 5, "total_count": 10, "resource_count": 13, "version": {"account_id": "AccountID", "catalog_id": "CatalogID", "offering_id": "OfferingID", "version_id": "VersionID", "version": "Version", "flavor": "Flavor", "semver": "Semver"}, "first": {"href": "Href", "start": "Start"}, "next": {"href": "Href", "start": "Start"}, "prev": {"href": "Href", "start": "Start"}, "last": {"href": "Href", "start": "Start"}}`)
				}))
			})
			It(`Invoke GetVersionDependencies successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the GetVersionDependenciesOptions model
				getVersionDependenciesOptionsModel := new(catalogmanagementv1.GetVersionDependenciesOptions)
				getVersionDependenciesOptionsModel.VersionLocID = core.StringPtr("testString")
				getVersionDependenciesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.GetVersionDependenciesWithContext(ctx, getVersionDependenciesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.GetVersionDependencies(getVersionDependenciesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.GetVersionDependenciesWithContext(ctx, getVersionDependenciesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getVersionDependenciesPath))
					Expect(req.Method).To(Equal("GET"))

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"start": "Start", "limit": 5, "total_count": 10, "resource_count": 13, "version": {"account_id": "AccountID", "catalog_id": "CatalogID", "offering_id": "OfferingID", "version_id": "VersionID", "version": "Version", "flavor": "Flavor", "semver": "Semver"}, "first": {"href": "Href", "start": "Start"}, "next": {"href": "Href", "start": "Start"}, "prev": {"href": "Href", "start": "Start"}, "last": {"href": "Href", "start": "Start"}}`)
				}))
			})
			It(`Invoke GetVersionDependencies successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.GetVersionDependencies(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetVersionDependenciesOptions model
				getVersionDependenciesOptionsModel := new(catalogmanagementv1.GetVersionDependenciesOptions)
				getVersionDependenciesOptionsModel.VersionLocID = core.StringPtr("testString")
				getVersionDependenciesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.GetVersionDependencies(getVersionDependenciesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetVersionDependencies with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetVersionDependenciesOptions model
				getVersionDependenciesOptionsModel := new(catalogmanagementv1.GetVersionDependenciesOptions)
				getVersionDependenciesOptionsModel.VersionLocID = core.StringPtr("testString")
				getVersionDependenciesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.GetVersionDependencies(getVersionDependenciesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetVersionDependenciesOptions model with no property values
				getVersionDependenciesOptionsModelNew := new(catalogmanagementv1.GetVersionDependenciesOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.GetVersionDependencies(getVersionDependenciesOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetVersionDependencies successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetVersionDependenciesOptions model
				getVersionDependenciesOptionsModel := new(catalogmanagementv1.GetVersionDependenciesOptions)
				getVersionDependenciesOptionsModel.VersionLocID = core.StringPtr("testString")
				getVersionDependenciesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.GetVersionDependencies(getVersionDependenciesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`DeprecateVersion(deprecateVersionOptions *DeprecateVersionOptions)`, func() {
		deprecateVersionPath := "/versions/testString/deprecate"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deprecateVersionPath))
					Expect(req.Method).To(Equal("POST"))

					res.WriteHeader(202)
				}))
			})
			It(`Invoke DeprecateVersion successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := catalogManagementService.DeprecateVersion(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the DeprecateVersionOptions model
				deprecateVersionOptionsModel := new(catalogmanagementv1.DeprecateVersionOptions)
				deprecateVersionOptionsModel.VersionLocID = core.StringPtr("testString")
				deprecateVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = catalogManagementService.DeprecateVersion(deprecateVersionOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke DeprecateVersion with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the DeprecateVersionOptions model
				deprecateVersionOptionsModel := new(catalogmanagementv1.DeprecateVersionOptions)
				deprecateVersionOptionsModel.VersionLocID = core.StringPtr("testString")
				deprecateVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := catalogManagementService.DeprecateVersion(deprecateVersionOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the DeprecateVersionOptions model with no property values
				deprecateVersionOptionsModelNew := new(catalogmanagementv1.DeprecateVersionOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = catalogManagementService.DeprecateVersion(deprecateVersionOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetCluster(getClusterOptions *GetClusterOptions) - Operation response error`, func() {
		getClusterPath := "/deploy/kubernetes/clusters/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getClusterPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["X-Auth-Refresh-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Refresh-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["region"]).To(Equal([]string{"testString"}))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetCluster with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetClusterOptions model
				getClusterOptionsModel := new(catalogmanagementv1.GetClusterOptions)
				getClusterOptionsModel.ClusterID = core.StringPtr("testString")
				getClusterOptionsModel.Region = core.StringPtr("testString")
				getClusterOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				getClusterOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.GetCluster(getClusterOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.GetCluster(getClusterOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetCluster(getClusterOptions *GetClusterOptions)`, func() {
		getClusterPath := "/deploy/kubernetes/clusters/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getClusterPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["X-Auth-Refresh-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Refresh-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["region"]).To(Equal([]string{"testString"}))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"resource_group_id": "ResourceGroupID", "resource_group_name": "ResourceGroupName", "id": "ID", "name": "Name", "region": "Region", "ingress_hostname": "IngressHostname", "provider": "Provider", "status": "Status"}`)
				}))
			})
			It(`Invoke GetCluster successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the GetClusterOptions model
				getClusterOptionsModel := new(catalogmanagementv1.GetClusterOptions)
				getClusterOptionsModel.ClusterID = core.StringPtr("testString")
				getClusterOptionsModel.Region = core.StringPtr("testString")
				getClusterOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				getClusterOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.GetClusterWithContext(ctx, getClusterOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.GetCluster(getClusterOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.GetClusterWithContext(ctx, getClusterOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getClusterPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["X-Auth-Refresh-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Refresh-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["region"]).To(Equal([]string{"testString"}))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"resource_group_id": "ResourceGroupID", "resource_group_name": "ResourceGroupName", "id": "ID", "name": "Name", "region": "Region", "ingress_hostname": "IngressHostname", "provider": "Provider", "status": "Status"}`)
				}))
			})
			It(`Invoke GetCluster successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.GetCluster(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetClusterOptions model
				getClusterOptionsModel := new(catalogmanagementv1.GetClusterOptions)
				getClusterOptionsModel.ClusterID = core.StringPtr("testString")
				getClusterOptionsModel.Region = core.StringPtr("testString")
				getClusterOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				getClusterOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.GetCluster(getClusterOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetCluster with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetClusterOptions model
				getClusterOptionsModel := new(catalogmanagementv1.GetClusterOptions)
				getClusterOptionsModel.ClusterID = core.StringPtr("testString")
				getClusterOptionsModel.Region = core.StringPtr("testString")
				getClusterOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				getClusterOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.GetCluster(getClusterOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetClusterOptions model with no property values
				getClusterOptionsModelNew := new(catalogmanagementv1.GetClusterOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.GetCluster(getClusterOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetCluster successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetClusterOptions model
				getClusterOptionsModel := new(catalogmanagementv1.GetClusterOptions)
				getClusterOptionsModel.ClusterID = core.StringPtr("testString")
				getClusterOptionsModel.Region = core.StringPtr("testString")
				getClusterOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				getClusterOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.GetCluster(getClusterOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetNamespaces(getNamespacesOptions *GetNamespacesOptions) - Operation response error`, func() {
		getNamespacesPath := "/deploy/kubernetes/clusters/testString/namespaces"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getNamespacesPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["X-Auth-Refresh-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Refresh-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["region"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(10))}))
					Expect(req.URL.Query()["offset"]).To(Equal([]string{fmt.Sprint(int64(0))}))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetNamespaces with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetNamespacesOptions model
				getNamespacesOptionsModel := new(catalogmanagementv1.GetNamespacesOptions)
				getNamespacesOptionsModel.ClusterID = core.StringPtr("testString")
				getNamespacesOptionsModel.Region = core.StringPtr("testString")
				getNamespacesOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				getNamespacesOptionsModel.Limit = core.Int64Ptr(int64(10))
				getNamespacesOptionsModel.Offset = core.Int64Ptr(int64(0))
				getNamespacesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.GetNamespaces(getNamespacesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.GetNamespaces(getNamespacesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetNamespaces(getNamespacesOptions *GetNamespacesOptions)`, func() {
		getNamespacesPath := "/deploy/kubernetes/clusters/testString/namespaces"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getNamespacesPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["X-Auth-Refresh-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Refresh-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["region"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(10))}))
					Expect(req.URL.Query()["offset"]).To(Equal([]string{fmt.Sprint(int64(0))}))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"offset": 6, "limit": 5, "total_count": 10, "resource_count": 13, "first": "First", "last": "Last", "prev": "Prev", "next": "Next", "resources": ["Resources"]}`)
				}))
			})
			It(`Invoke GetNamespaces successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the GetNamespacesOptions model
				getNamespacesOptionsModel := new(catalogmanagementv1.GetNamespacesOptions)
				getNamespacesOptionsModel.ClusterID = core.StringPtr("testString")
				getNamespacesOptionsModel.Region = core.StringPtr("testString")
				getNamespacesOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				getNamespacesOptionsModel.Limit = core.Int64Ptr(int64(10))
				getNamespacesOptionsModel.Offset = core.Int64Ptr(int64(0))
				getNamespacesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.GetNamespacesWithContext(ctx, getNamespacesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.GetNamespaces(getNamespacesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.GetNamespacesWithContext(ctx, getNamespacesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getNamespacesPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["X-Auth-Refresh-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Refresh-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["region"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(10))}))
					Expect(req.URL.Query()["offset"]).To(Equal([]string{fmt.Sprint(int64(0))}))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"offset": 6, "limit": 5, "total_count": 10, "resource_count": 13, "first": "First", "last": "Last", "prev": "Prev", "next": "Next", "resources": ["Resources"]}`)
				}))
			})
			It(`Invoke GetNamespaces successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.GetNamespaces(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetNamespacesOptions model
				getNamespacesOptionsModel := new(catalogmanagementv1.GetNamespacesOptions)
				getNamespacesOptionsModel.ClusterID = core.StringPtr("testString")
				getNamespacesOptionsModel.Region = core.StringPtr("testString")
				getNamespacesOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				getNamespacesOptionsModel.Limit = core.Int64Ptr(int64(10))
				getNamespacesOptionsModel.Offset = core.Int64Ptr(int64(0))
				getNamespacesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.GetNamespaces(getNamespacesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetNamespaces with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetNamespacesOptions model
				getNamespacesOptionsModel := new(catalogmanagementv1.GetNamespacesOptions)
				getNamespacesOptionsModel.ClusterID = core.StringPtr("testString")
				getNamespacesOptionsModel.Region = core.StringPtr("testString")
				getNamespacesOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				getNamespacesOptionsModel.Limit = core.Int64Ptr(int64(10))
				getNamespacesOptionsModel.Offset = core.Int64Ptr(int64(0))
				getNamespacesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.GetNamespaces(getNamespacesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetNamespacesOptions model with no property values
				getNamespacesOptionsModelNew := new(catalogmanagementv1.GetNamespacesOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.GetNamespaces(getNamespacesOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetNamespaces successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetNamespacesOptions model
				getNamespacesOptionsModel := new(catalogmanagementv1.GetNamespacesOptions)
				getNamespacesOptionsModel.ClusterID = core.StringPtr("testString")
				getNamespacesOptionsModel.Region = core.StringPtr("testString")
				getNamespacesOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				getNamespacesOptionsModel.Limit = core.Int64Ptr(int64(10))
				getNamespacesOptionsModel.Offset = core.Int64Ptr(int64(0))
				getNamespacesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.GetNamespaces(getNamespacesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Test pagination helper method on response`, func() {
			It(`Invoke GetNextOffset successfully`, func() {
				responseObject := new(catalogmanagementv1.NamespaceSearchResult)
				responseObject.Next = core.StringPtr("ibm.com?offset=135")

				value, err := responseObject.GetNextOffset()
				Expect(err).To(BeNil())
				Expect(value).To(Equal(core.Int64Ptr(int64(135))))
			})
			It(`Invoke GetNextOffset without a "Next" property in the response`, func() {
				responseObject := new(catalogmanagementv1.NamespaceSearchResult)

				value, err := responseObject.GetNextOffset()
				Expect(err).To(BeNil())
				Expect(value).To(BeNil())
			})
			It(`Invoke GetNextOffset without any query params in the "Next" URL`, func() {
				responseObject := new(catalogmanagementv1.NamespaceSearchResult)
				responseObject.Next = core.StringPtr("ibm.com")

				value, err := responseObject.GetNextOffset()
				Expect(err).To(BeNil())
				Expect(value).To(BeNil())
			})
			It(`Invoke GetNextOffset with a non-integer query param in the "Next" URL`, func() {
				responseObject := new(catalogmanagementv1.NamespaceSearchResult)
				responseObject.Next = core.StringPtr("ibm.com?offset=tiger")

				value, err := responseObject.GetNextOffset()
				Expect(err).NotTo(BeNil())
				Expect(value).To(BeNil())
			})
		})
		Context(`Using mock server endpoint - paginated response`, func() {
			BeforeEach(func() {
				var requestNumber int = 0
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getNamespacesPath))
					Expect(req.Method).To(Equal("GET"))

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					requestNumber++
					if requestNumber == 1 {
						fmt.Fprintf(res, "%s", `{"next":"https://myhost.com/somePath?offset=1","total_count":2,"limit":1,"resources":["Resources"]}`)
					} else if requestNumber == 2 {
						fmt.Fprintf(res, "%s", `{"total_count":2,"limit":1,"resources":["Resources"]}`)
					} else {
						res.WriteHeader(400)
					}
				}))
			})
			It(`Use GetNamespacesPager.GetNext successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				getNamespacesOptionsModel := &catalogmanagementv1.GetNamespacesOptions{
					ClusterID:         core.StringPtr("testString"),
					Region:            core.StringPtr("testString"),
					XAuthRefreshToken: core.StringPtr("testString"),
					Limit:             core.Int64Ptr(int64(10)),
				}

				pager, err := catalogManagementService.NewGetNamespacesPager(getNamespacesOptionsModel)
				Expect(err).To(BeNil())
				Expect(pager).ToNot(BeNil())

				var allResults []string
				for pager.HasNext() {
					nextPage, err := pager.GetNext()
					Expect(err).To(BeNil())
					Expect(nextPage).ToNot(BeNil())
					allResults = append(allResults, nextPage...)
				}
				Expect(len(allResults)).To(Equal(2))
			})
			It(`Use GetNamespacesPager.GetAll successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				getNamespacesOptionsModel := &catalogmanagementv1.GetNamespacesOptions{
					ClusterID:         core.StringPtr("testString"),
					Region:            core.StringPtr("testString"),
					XAuthRefreshToken: core.StringPtr("testString"),
					Limit:             core.Int64Ptr(int64(10)),
				}

				pager, err := catalogManagementService.NewGetNamespacesPager(getNamespacesOptionsModel)
				Expect(err).To(BeNil())
				Expect(pager).ToNot(BeNil())

				allResults, err := pager.GetAll()
				Expect(err).To(BeNil())
				Expect(allResults).ToNot(BeNil())
				Expect(len(allResults)).To(Equal(2))
			})
		})
	})
	Describe(`DeployOperators(deployOperatorsOptions *DeployOperatorsOptions) - Operation response error`, func() {
		deployOperatorsPath := "/deploy/kubernetes/olm/operator"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deployOperatorsPath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["X-Auth-Refresh-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Refresh-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke DeployOperators with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the DeployOperatorsOptions model
				deployOperatorsOptionsModel := new(catalogmanagementv1.DeployOperatorsOptions)
				deployOperatorsOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				deployOperatorsOptionsModel.ClusterID = core.StringPtr("testString")
				deployOperatorsOptionsModel.Region = core.StringPtr("testString")
				deployOperatorsOptionsModel.Namespaces = []string{"testString"}
				deployOperatorsOptionsModel.AllNamespaces = core.BoolPtr(true)
				deployOperatorsOptionsModel.VersionLocatorID = core.StringPtr("testString")
				deployOperatorsOptionsModel.Channel = core.StringPtr("testString")
				deployOperatorsOptionsModel.InstallPlan = core.StringPtr("testString")
				deployOperatorsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.DeployOperators(deployOperatorsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.DeployOperators(deployOperatorsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`DeployOperators(deployOperatorsOptions *DeployOperatorsOptions)`, func() {
		deployOperatorsPath := "/deploy/kubernetes/olm/operator"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deployOperatorsPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["X-Auth-Refresh-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Refresh-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `[{"phase": "Phase", "message": "Message", "link": "Link", "name": "Name", "version": "Version", "namespace": "Namespace", "package_name": "PackageName", "catalog_id": "CatalogID"}]`)
				}))
			})
			It(`Invoke DeployOperators successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the DeployOperatorsOptions model
				deployOperatorsOptionsModel := new(catalogmanagementv1.DeployOperatorsOptions)
				deployOperatorsOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				deployOperatorsOptionsModel.ClusterID = core.StringPtr("testString")
				deployOperatorsOptionsModel.Region = core.StringPtr("testString")
				deployOperatorsOptionsModel.Namespaces = []string{"testString"}
				deployOperatorsOptionsModel.AllNamespaces = core.BoolPtr(true)
				deployOperatorsOptionsModel.VersionLocatorID = core.StringPtr("testString")
				deployOperatorsOptionsModel.Channel = core.StringPtr("testString")
				deployOperatorsOptionsModel.InstallPlan = core.StringPtr("testString")
				deployOperatorsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.DeployOperatorsWithContext(ctx, deployOperatorsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.DeployOperators(deployOperatorsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.DeployOperatorsWithContext(ctx, deployOperatorsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deployOperatorsPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["X-Auth-Refresh-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Refresh-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `[{"phase": "Phase", "message": "Message", "link": "Link", "name": "Name", "version": "Version", "namespace": "Namespace", "package_name": "PackageName", "catalog_id": "CatalogID"}]`)
				}))
			})
			It(`Invoke DeployOperators successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.DeployOperators(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the DeployOperatorsOptions model
				deployOperatorsOptionsModel := new(catalogmanagementv1.DeployOperatorsOptions)
				deployOperatorsOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				deployOperatorsOptionsModel.ClusterID = core.StringPtr("testString")
				deployOperatorsOptionsModel.Region = core.StringPtr("testString")
				deployOperatorsOptionsModel.Namespaces = []string{"testString"}
				deployOperatorsOptionsModel.AllNamespaces = core.BoolPtr(true)
				deployOperatorsOptionsModel.VersionLocatorID = core.StringPtr("testString")
				deployOperatorsOptionsModel.Channel = core.StringPtr("testString")
				deployOperatorsOptionsModel.InstallPlan = core.StringPtr("testString")
				deployOperatorsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.DeployOperators(deployOperatorsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke DeployOperators with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the DeployOperatorsOptions model
				deployOperatorsOptionsModel := new(catalogmanagementv1.DeployOperatorsOptions)
				deployOperatorsOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				deployOperatorsOptionsModel.ClusterID = core.StringPtr("testString")
				deployOperatorsOptionsModel.Region = core.StringPtr("testString")
				deployOperatorsOptionsModel.Namespaces = []string{"testString"}
				deployOperatorsOptionsModel.AllNamespaces = core.BoolPtr(true)
				deployOperatorsOptionsModel.VersionLocatorID = core.StringPtr("testString")
				deployOperatorsOptionsModel.Channel = core.StringPtr("testString")
				deployOperatorsOptionsModel.InstallPlan = core.StringPtr("testString")
				deployOperatorsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.DeployOperators(deployOperatorsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the DeployOperatorsOptions model with no property values
				deployOperatorsOptionsModelNew := new(catalogmanagementv1.DeployOperatorsOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.DeployOperators(deployOperatorsOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke DeployOperators successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the DeployOperatorsOptions model
				deployOperatorsOptionsModel := new(catalogmanagementv1.DeployOperatorsOptions)
				deployOperatorsOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				deployOperatorsOptionsModel.ClusterID = core.StringPtr("testString")
				deployOperatorsOptionsModel.Region = core.StringPtr("testString")
				deployOperatorsOptionsModel.Namespaces = []string{"testString"}
				deployOperatorsOptionsModel.AllNamespaces = core.BoolPtr(true)
				deployOperatorsOptionsModel.VersionLocatorID = core.StringPtr("testString")
				deployOperatorsOptionsModel.Channel = core.StringPtr("testString")
				deployOperatorsOptionsModel.InstallPlan = core.StringPtr("testString")
				deployOperatorsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.DeployOperators(deployOperatorsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListOperators(listOperatorsOptions *ListOperatorsOptions) - Operation response error`, func() {
		listOperatorsPath := "/deploy/kubernetes/olm/operator"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listOperatorsPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["X-Auth-Refresh-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Refresh-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["cluster_id"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["region"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["version_locator_id"]).To(Equal([]string{"testString"}))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ListOperators with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ListOperatorsOptions model
				listOperatorsOptionsModel := new(catalogmanagementv1.ListOperatorsOptions)
				listOperatorsOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				listOperatorsOptionsModel.ClusterID = core.StringPtr("testString")
				listOperatorsOptionsModel.Region = core.StringPtr("testString")
				listOperatorsOptionsModel.VersionLocatorID = core.StringPtr("testString")
				listOperatorsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.ListOperators(listOperatorsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.ListOperators(listOperatorsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListOperators(listOperatorsOptions *ListOperatorsOptions)`, func() {
		listOperatorsPath := "/deploy/kubernetes/olm/operator"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listOperatorsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["X-Auth-Refresh-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Refresh-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["cluster_id"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["region"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["version_locator_id"]).To(Equal([]string{"testString"}))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `[{"phase": "Phase", "message": "Message", "link": "Link", "name": "Name", "version": "Version", "namespace": "Namespace", "package_name": "PackageName", "catalog_id": "CatalogID"}]`)
				}))
			})
			It(`Invoke ListOperators successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the ListOperatorsOptions model
				listOperatorsOptionsModel := new(catalogmanagementv1.ListOperatorsOptions)
				listOperatorsOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				listOperatorsOptionsModel.ClusterID = core.StringPtr("testString")
				listOperatorsOptionsModel.Region = core.StringPtr("testString")
				listOperatorsOptionsModel.VersionLocatorID = core.StringPtr("testString")
				listOperatorsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.ListOperatorsWithContext(ctx, listOperatorsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.ListOperators(listOperatorsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.ListOperatorsWithContext(ctx, listOperatorsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listOperatorsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["X-Auth-Refresh-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Refresh-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["cluster_id"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["region"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["version_locator_id"]).To(Equal([]string{"testString"}))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `[{"phase": "Phase", "message": "Message", "link": "Link", "name": "Name", "version": "Version", "namespace": "Namespace", "package_name": "PackageName", "catalog_id": "CatalogID"}]`)
				}))
			})
			It(`Invoke ListOperators successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.ListOperators(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ListOperatorsOptions model
				listOperatorsOptionsModel := new(catalogmanagementv1.ListOperatorsOptions)
				listOperatorsOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				listOperatorsOptionsModel.ClusterID = core.StringPtr("testString")
				listOperatorsOptionsModel.Region = core.StringPtr("testString")
				listOperatorsOptionsModel.VersionLocatorID = core.StringPtr("testString")
				listOperatorsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.ListOperators(listOperatorsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ListOperators with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ListOperatorsOptions model
				listOperatorsOptionsModel := new(catalogmanagementv1.ListOperatorsOptions)
				listOperatorsOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				listOperatorsOptionsModel.ClusterID = core.StringPtr("testString")
				listOperatorsOptionsModel.Region = core.StringPtr("testString")
				listOperatorsOptionsModel.VersionLocatorID = core.StringPtr("testString")
				listOperatorsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.ListOperators(listOperatorsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the ListOperatorsOptions model with no property values
				listOperatorsOptionsModelNew := new(catalogmanagementv1.ListOperatorsOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.ListOperators(listOperatorsOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ListOperators successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ListOperatorsOptions model
				listOperatorsOptionsModel := new(catalogmanagementv1.ListOperatorsOptions)
				listOperatorsOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				listOperatorsOptionsModel.ClusterID = core.StringPtr("testString")
				listOperatorsOptionsModel.Region = core.StringPtr("testString")
				listOperatorsOptionsModel.VersionLocatorID = core.StringPtr("testString")
				listOperatorsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.ListOperators(listOperatorsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ReplaceOperators(replaceOperatorsOptions *ReplaceOperatorsOptions) - Operation response error`, func() {
		replaceOperatorsPath := "/deploy/kubernetes/olm/operator"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(replaceOperatorsPath))
					Expect(req.Method).To(Equal("PUT"))
					Expect(req.Header["X-Auth-Refresh-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Refresh-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ReplaceOperators with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ReplaceOperatorsOptions model
				replaceOperatorsOptionsModel := new(catalogmanagementv1.ReplaceOperatorsOptions)
				replaceOperatorsOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				replaceOperatorsOptionsModel.ClusterID = core.StringPtr("testString")
				replaceOperatorsOptionsModel.Region = core.StringPtr("testString")
				replaceOperatorsOptionsModel.Namespaces = []string{"testString"}
				replaceOperatorsOptionsModel.AllNamespaces = core.BoolPtr(true)
				replaceOperatorsOptionsModel.VersionLocatorID = core.StringPtr("testString")
				replaceOperatorsOptionsModel.Channel = core.StringPtr("testString")
				replaceOperatorsOptionsModel.InstallPlan = core.StringPtr("testString")
				replaceOperatorsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.ReplaceOperators(replaceOperatorsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.ReplaceOperators(replaceOperatorsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ReplaceOperators(replaceOperatorsOptions *ReplaceOperatorsOptions)`, func() {
		replaceOperatorsPath := "/deploy/kubernetes/olm/operator"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(replaceOperatorsPath))
					Expect(req.Method).To(Equal("PUT"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["X-Auth-Refresh-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Refresh-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `[{"phase": "Phase", "message": "Message", "link": "Link", "name": "Name", "version": "Version", "namespace": "Namespace", "package_name": "PackageName", "catalog_id": "CatalogID"}]`)
				}))
			})
			It(`Invoke ReplaceOperators successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the ReplaceOperatorsOptions model
				replaceOperatorsOptionsModel := new(catalogmanagementv1.ReplaceOperatorsOptions)
				replaceOperatorsOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				replaceOperatorsOptionsModel.ClusterID = core.StringPtr("testString")
				replaceOperatorsOptionsModel.Region = core.StringPtr("testString")
				replaceOperatorsOptionsModel.Namespaces = []string{"testString"}
				replaceOperatorsOptionsModel.AllNamespaces = core.BoolPtr(true)
				replaceOperatorsOptionsModel.VersionLocatorID = core.StringPtr("testString")
				replaceOperatorsOptionsModel.Channel = core.StringPtr("testString")
				replaceOperatorsOptionsModel.InstallPlan = core.StringPtr("testString")
				replaceOperatorsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.ReplaceOperatorsWithContext(ctx, replaceOperatorsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.ReplaceOperators(replaceOperatorsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.ReplaceOperatorsWithContext(ctx, replaceOperatorsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(replaceOperatorsPath))
					Expect(req.Method).To(Equal("PUT"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["X-Auth-Refresh-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Refresh-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `[{"phase": "Phase", "message": "Message", "link": "Link", "name": "Name", "version": "Version", "namespace": "Namespace", "package_name": "PackageName", "catalog_id": "CatalogID"}]`)
				}))
			})
			It(`Invoke ReplaceOperators successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.ReplaceOperators(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ReplaceOperatorsOptions model
				replaceOperatorsOptionsModel := new(catalogmanagementv1.ReplaceOperatorsOptions)
				replaceOperatorsOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				replaceOperatorsOptionsModel.ClusterID = core.StringPtr("testString")
				replaceOperatorsOptionsModel.Region = core.StringPtr("testString")
				replaceOperatorsOptionsModel.Namespaces = []string{"testString"}
				replaceOperatorsOptionsModel.AllNamespaces = core.BoolPtr(true)
				replaceOperatorsOptionsModel.VersionLocatorID = core.StringPtr("testString")
				replaceOperatorsOptionsModel.Channel = core.StringPtr("testString")
				replaceOperatorsOptionsModel.InstallPlan = core.StringPtr("testString")
				replaceOperatorsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.ReplaceOperators(replaceOperatorsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ReplaceOperators with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ReplaceOperatorsOptions model
				replaceOperatorsOptionsModel := new(catalogmanagementv1.ReplaceOperatorsOptions)
				replaceOperatorsOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				replaceOperatorsOptionsModel.ClusterID = core.StringPtr("testString")
				replaceOperatorsOptionsModel.Region = core.StringPtr("testString")
				replaceOperatorsOptionsModel.Namespaces = []string{"testString"}
				replaceOperatorsOptionsModel.AllNamespaces = core.BoolPtr(true)
				replaceOperatorsOptionsModel.VersionLocatorID = core.StringPtr("testString")
				replaceOperatorsOptionsModel.Channel = core.StringPtr("testString")
				replaceOperatorsOptionsModel.InstallPlan = core.StringPtr("testString")
				replaceOperatorsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.ReplaceOperators(replaceOperatorsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the ReplaceOperatorsOptions model with no property values
				replaceOperatorsOptionsModelNew := new(catalogmanagementv1.ReplaceOperatorsOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.ReplaceOperators(replaceOperatorsOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ReplaceOperators successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ReplaceOperatorsOptions model
				replaceOperatorsOptionsModel := new(catalogmanagementv1.ReplaceOperatorsOptions)
				replaceOperatorsOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				replaceOperatorsOptionsModel.ClusterID = core.StringPtr("testString")
				replaceOperatorsOptionsModel.Region = core.StringPtr("testString")
				replaceOperatorsOptionsModel.Namespaces = []string{"testString"}
				replaceOperatorsOptionsModel.AllNamespaces = core.BoolPtr(true)
				replaceOperatorsOptionsModel.VersionLocatorID = core.StringPtr("testString")
				replaceOperatorsOptionsModel.Channel = core.StringPtr("testString")
				replaceOperatorsOptionsModel.InstallPlan = core.StringPtr("testString")
				replaceOperatorsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.ReplaceOperators(replaceOperatorsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`DeleteOperators(deleteOperatorsOptions *DeleteOperatorsOptions)`, func() {
		deleteOperatorsPath := "/deploy/kubernetes/olm/operator"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deleteOperatorsPath))
					Expect(req.Method).To(Equal("DELETE"))

					Expect(req.Header["X-Auth-Refresh-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Refresh-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["cluster_id"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["region"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["version_locator_id"]).To(Equal([]string{"testString"}))
					res.WriteHeader(200)
				}))
			})
			It(`Invoke DeleteOperators successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := catalogManagementService.DeleteOperators(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the DeleteOperatorsOptions model
				deleteOperatorsOptionsModel := new(catalogmanagementv1.DeleteOperatorsOptions)
				deleteOperatorsOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				deleteOperatorsOptionsModel.ClusterID = core.StringPtr("testString")
				deleteOperatorsOptionsModel.Region = core.StringPtr("testString")
				deleteOperatorsOptionsModel.VersionLocatorID = core.StringPtr("testString")
				deleteOperatorsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = catalogManagementService.DeleteOperators(deleteOperatorsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke DeleteOperators with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the DeleteOperatorsOptions model
				deleteOperatorsOptionsModel := new(catalogmanagementv1.DeleteOperatorsOptions)
				deleteOperatorsOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				deleteOperatorsOptionsModel.ClusterID = core.StringPtr("testString")
				deleteOperatorsOptionsModel.Region = core.StringPtr("testString")
				deleteOperatorsOptionsModel.VersionLocatorID = core.StringPtr("testString")
				deleteOperatorsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := catalogManagementService.DeleteOperators(deleteOperatorsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the DeleteOperatorsOptions model with no property values
				deleteOperatorsOptionsModelNew := new(catalogmanagementv1.DeleteOperatorsOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = catalogManagementService.DeleteOperators(deleteOperatorsOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`InstallVersion(installVersionOptions *InstallVersionOptions)`, func() {
		installVersionPath := "/versions/testString/install"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(installVersionPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["X-Auth-Refresh-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Refresh-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.WriteHeader(202)
				}))
			})
			It(`Invoke InstallVersion successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := catalogManagementService.InstallVersion(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the DeployRequestBodyOverrideValues model
				deployRequestBodyOverrideValuesModel := new(catalogmanagementv1.DeployRequestBodyOverrideValues)
				deployRequestBodyOverrideValuesModel.VsiInstanceName = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.VPCProfile = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.SubnetID = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.VPCID = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.SubnetZone = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.SSHKeyID = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.VPCRegion = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.SetProperty("foo", "testString")

				// Construct an instance of the DeployRequestBodyEnvironmentVariablesItem model
				deployRequestBodyEnvironmentVariablesItemModel := new(catalogmanagementv1.DeployRequestBodyEnvironmentVariablesItem)
				deployRequestBodyEnvironmentVariablesItemModel.Name = core.StringPtr("testString")
				deployRequestBodyEnvironmentVariablesItemModel.Value = "testString"
				deployRequestBodyEnvironmentVariablesItemModel.Secure = core.BoolPtr(true)
				deployRequestBodyEnvironmentVariablesItemModel.Hidden = core.BoolPtr(true)

				// Construct an instance of the DeployRequestBodySchematics model
				deployRequestBodySchematicsModel := new(catalogmanagementv1.DeployRequestBodySchematics)
				deployRequestBodySchematicsModel.Name = core.StringPtr("testString")
				deployRequestBodySchematicsModel.Description = core.StringPtr("testString")
				deployRequestBodySchematicsModel.Tags = []string{"testString"}
				deployRequestBodySchematicsModel.ResourceGroupID = core.StringPtr("testString")
				deployRequestBodySchematicsModel.TerraformVersion = core.StringPtr("testString")
				deployRequestBodySchematicsModel.Region = core.StringPtr("testString")

				// Construct an instance of the InstallVersionOptions model
				installVersionOptionsModel := new(catalogmanagementv1.InstallVersionOptions)
				installVersionOptionsModel.VersionLocID = core.StringPtr("testString")
				installVersionOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				installVersionOptionsModel.ClusterID = core.StringPtr("testString")
				installVersionOptionsModel.Region = core.StringPtr("testString")
				installVersionOptionsModel.Namespace = core.StringPtr("testString")
				installVersionOptionsModel.Namespaces = []string{"testString"}
				installVersionOptionsModel.AllNamespaces = core.BoolPtr(true)
				installVersionOptionsModel.OverrideValues = deployRequestBodyOverrideValuesModel
				installVersionOptionsModel.DependencyConfigs = []string{"testString"}
				installVersionOptionsModel.EnvironmentVariables = []catalogmanagementv1.DeployRequestBodyEnvironmentVariablesItem{*deployRequestBodyEnvironmentVariablesItemModel}
				installVersionOptionsModel.EntitlementApikey = core.StringPtr("testString")
				installVersionOptionsModel.Schematics = deployRequestBodySchematicsModel
				installVersionOptionsModel.Script = core.StringPtr("testString")
				installVersionOptionsModel.ScriptID = core.StringPtr("testString")
				installVersionOptionsModel.VersionLocatorID = core.StringPtr("testString")
				installVersionOptionsModel.VcenterID = core.StringPtr("testString")
				installVersionOptionsModel.VcenterLocation = core.StringPtr("testString")
				installVersionOptionsModel.VcenterUser = core.StringPtr("testString")
				installVersionOptionsModel.VcenterPassword = core.StringPtr("testString")
				installVersionOptionsModel.VcenterDatastore = core.StringPtr("testString")
				installVersionOptionsModel.PlanID = core.StringPtr("testString")
				installVersionOptionsModel.Channel = core.StringPtr("testString")
				installVersionOptionsModel.InstallPlan = core.StringPtr("testString")
				installVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = catalogManagementService.InstallVersion(installVersionOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke InstallVersion with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the DeployRequestBodyOverrideValues model
				deployRequestBodyOverrideValuesModel := new(catalogmanagementv1.DeployRequestBodyOverrideValues)
				deployRequestBodyOverrideValuesModel.VsiInstanceName = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.VPCProfile = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.SubnetID = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.VPCID = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.SubnetZone = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.SSHKeyID = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.VPCRegion = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.SetProperty("foo", "testString")

				// Construct an instance of the DeployRequestBodyEnvironmentVariablesItem model
				deployRequestBodyEnvironmentVariablesItemModel := new(catalogmanagementv1.DeployRequestBodyEnvironmentVariablesItem)
				deployRequestBodyEnvironmentVariablesItemModel.Name = core.StringPtr("testString")
				deployRequestBodyEnvironmentVariablesItemModel.Value = "testString"
				deployRequestBodyEnvironmentVariablesItemModel.Secure = core.BoolPtr(true)
				deployRequestBodyEnvironmentVariablesItemModel.Hidden = core.BoolPtr(true)

				// Construct an instance of the DeployRequestBodySchematics model
				deployRequestBodySchematicsModel := new(catalogmanagementv1.DeployRequestBodySchematics)
				deployRequestBodySchematicsModel.Name = core.StringPtr("testString")
				deployRequestBodySchematicsModel.Description = core.StringPtr("testString")
				deployRequestBodySchematicsModel.Tags = []string{"testString"}
				deployRequestBodySchematicsModel.ResourceGroupID = core.StringPtr("testString")
				deployRequestBodySchematicsModel.TerraformVersion = core.StringPtr("testString")
				deployRequestBodySchematicsModel.Region = core.StringPtr("testString")

				// Construct an instance of the InstallVersionOptions model
				installVersionOptionsModel := new(catalogmanagementv1.InstallVersionOptions)
				installVersionOptionsModel.VersionLocID = core.StringPtr("testString")
				installVersionOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				installVersionOptionsModel.ClusterID = core.StringPtr("testString")
				installVersionOptionsModel.Region = core.StringPtr("testString")
				installVersionOptionsModel.Namespace = core.StringPtr("testString")
				installVersionOptionsModel.Namespaces = []string{"testString"}
				installVersionOptionsModel.AllNamespaces = core.BoolPtr(true)
				installVersionOptionsModel.OverrideValues = deployRequestBodyOverrideValuesModel
				installVersionOptionsModel.DependencyConfigs = []string{"testString"}
				installVersionOptionsModel.EnvironmentVariables = []catalogmanagementv1.DeployRequestBodyEnvironmentVariablesItem{*deployRequestBodyEnvironmentVariablesItemModel}
				installVersionOptionsModel.EntitlementApikey = core.StringPtr("testString")
				installVersionOptionsModel.Schematics = deployRequestBodySchematicsModel
				installVersionOptionsModel.Script = core.StringPtr("testString")
				installVersionOptionsModel.ScriptID = core.StringPtr("testString")
				installVersionOptionsModel.VersionLocatorID = core.StringPtr("testString")
				installVersionOptionsModel.VcenterID = core.StringPtr("testString")
				installVersionOptionsModel.VcenterLocation = core.StringPtr("testString")
				installVersionOptionsModel.VcenterUser = core.StringPtr("testString")
				installVersionOptionsModel.VcenterPassword = core.StringPtr("testString")
				installVersionOptionsModel.VcenterDatastore = core.StringPtr("testString")
				installVersionOptionsModel.PlanID = core.StringPtr("testString")
				installVersionOptionsModel.Channel = core.StringPtr("testString")
				installVersionOptionsModel.InstallPlan = core.StringPtr("testString")
				installVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := catalogManagementService.InstallVersion(installVersionOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the InstallVersionOptions model with no property values
				installVersionOptionsModelNew := new(catalogmanagementv1.InstallVersionOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = catalogManagementService.InstallVersion(installVersionOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`PreinstallVersion(preinstallVersionOptions *PreinstallVersionOptions)`, func() {
		preinstallVersionPath := "/versions/testString/preinstall"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(preinstallVersionPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["X-Auth-Refresh-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Refresh-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.WriteHeader(202)
				}))
			})
			It(`Invoke PreinstallVersion successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := catalogManagementService.PreinstallVersion(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the DeployRequestBodyOverrideValues model
				deployRequestBodyOverrideValuesModel := new(catalogmanagementv1.DeployRequestBodyOverrideValues)
				deployRequestBodyOverrideValuesModel.VsiInstanceName = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.VPCProfile = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.SubnetID = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.VPCID = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.SubnetZone = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.SSHKeyID = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.VPCRegion = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.SetProperty("foo", "testString")

				// Construct an instance of the DeployRequestBodyEnvironmentVariablesItem model
				deployRequestBodyEnvironmentVariablesItemModel := new(catalogmanagementv1.DeployRequestBodyEnvironmentVariablesItem)
				deployRequestBodyEnvironmentVariablesItemModel.Name = core.StringPtr("testString")
				deployRequestBodyEnvironmentVariablesItemModel.Value = "testString"
				deployRequestBodyEnvironmentVariablesItemModel.Secure = core.BoolPtr(true)
				deployRequestBodyEnvironmentVariablesItemModel.Hidden = core.BoolPtr(true)

				// Construct an instance of the DeployRequestBodySchematics model
				deployRequestBodySchematicsModel := new(catalogmanagementv1.DeployRequestBodySchematics)
				deployRequestBodySchematicsModel.Name = core.StringPtr("testString")
				deployRequestBodySchematicsModel.Description = core.StringPtr("testString")
				deployRequestBodySchematicsModel.Tags = []string{"testString"}
				deployRequestBodySchematicsModel.ResourceGroupID = core.StringPtr("testString")
				deployRequestBodySchematicsModel.TerraformVersion = core.StringPtr("testString")
				deployRequestBodySchematicsModel.Region = core.StringPtr("testString")

				// Construct an instance of the PreinstallVersionOptions model
				preinstallVersionOptionsModel := new(catalogmanagementv1.PreinstallVersionOptions)
				preinstallVersionOptionsModel.VersionLocID = core.StringPtr("testString")
				preinstallVersionOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				preinstallVersionOptionsModel.ClusterID = core.StringPtr("testString")
				preinstallVersionOptionsModel.Region = core.StringPtr("testString")
				preinstallVersionOptionsModel.Namespace = core.StringPtr("testString")
				preinstallVersionOptionsModel.Namespaces = []string{"testString"}
				preinstallVersionOptionsModel.AllNamespaces = core.BoolPtr(true)
				preinstallVersionOptionsModel.OverrideValues = deployRequestBodyOverrideValuesModel
				preinstallVersionOptionsModel.DependencyConfigs = []string{"testString"}
				preinstallVersionOptionsModel.EnvironmentVariables = []catalogmanagementv1.DeployRequestBodyEnvironmentVariablesItem{*deployRequestBodyEnvironmentVariablesItemModel}
				preinstallVersionOptionsModel.EntitlementApikey = core.StringPtr("testString")
				preinstallVersionOptionsModel.Schematics = deployRequestBodySchematicsModel
				preinstallVersionOptionsModel.Script = core.StringPtr("testString")
				preinstallVersionOptionsModel.ScriptID = core.StringPtr("testString")
				preinstallVersionOptionsModel.VersionLocatorID = core.StringPtr("testString")
				preinstallVersionOptionsModel.VcenterID = core.StringPtr("testString")
				preinstallVersionOptionsModel.VcenterLocation = core.StringPtr("testString")
				preinstallVersionOptionsModel.VcenterUser = core.StringPtr("testString")
				preinstallVersionOptionsModel.VcenterPassword = core.StringPtr("testString")
				preinstallVersionOptionsModel.VcenterDatastore = core.StringPtr("testString")
				preinstallVersionOptionsModel.PlanID = core.StringPtr("testString")
				preinstallVersionOptionsModel.Channel = core.StringPtr("testString")
				preinstallVersionOptionsModel.InstallPlan = core.StringPtr("testString")
				preinstallVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = catalogManagementService.PreinstallVersion(preinstallVersionOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke PreinstallVersion with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the DeployRequestBodyOverrideValues model
				deployRequestBodyOverrideValuesModel := new(catalogmanagementv1.DeployRequestBodyOverrideValues)
				deployRequestBodyOverrideValuesModel.VsiInstanceName = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.VPCProfile = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.SubnetID = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.VPCID = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.SubnetZone = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.SSHKeyID = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.VPCRegion = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.SetProperty("foo", "testString")

				// Construct an instance of the DeployRequestBodyEnvironmentVariablesItem model
				deployRequestBodyEnvironmentVariablesItemModel := new(catalogmanagementv1.DeployRequestBodyEnvironmentVariablesItem)
				deployRequestBodyEnvironmentVariablesItemModel.Name = core.StringPtr("testString")
				deployRequestBodyEnvironmentVariablesItemModel.Value = "testString"
				deployRequestBodyEnvironmentVariablesItemModel.Secure = core.BoolPtr(true)
				deployRequestBodyEnvironmentVariablesItemModel.Hidden = core.BoolPtr(true)

				// Construct an instance of the DeployRequestBodySchematics model
				deployRequestBodySchematicsModel := new(catalogmanagementv1.DeployRequestBodySchematics)
				deployRequestBodySchematicsModel.Name = core.StringPtr("testString")
				deployRequestBodySchematicsModel.Description = core.StringPtr("testString")
				deployRequestBodySchematicsModel.Tags = []string{"testString"}
				deployRequestBodySchematicsModel.ResourceGroupID = core.StringPtr("testString")
				deployRequestBodySchematicsModel.TerraformVersion = core.StringPtr("testString")
				deployRequestBodySchematicsModel.Region = core.StringPtr("testString")

				// Construct an instance of the PreinstallVersionOptions model
				preinstallVersionOptionsModel := new(catalogmanagementv1.PreinstallVersionOptions)
				preinstallVersionOptionsModel.VersionLocID = core.StringPtr("testString")
				preinstallVersionOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				preinstallVersionOptionsModel.ClusterID = core.StringPtr("testString")
				preinstallVersionOptionsModel.Region = core.StringPtr("testString")
				preinstallVersionOptionsModel.Namespace = core.StringPtr("testString")
				preinstallVersionOptionsModel.Namespaces = []string{"testString"}
				preinstallVersionOptionsModel.AllNamespaces = core.BoolPtr(true)
				preinstallVersionOptionsModel.OverrideValues = deployRequestBodyOverrideValuesModel
				preinstallVersionOptionsModel.DependencyConfigs = []string{"testString"}
				preinstallVersionOptionsModel.EnvironmentVariables = []catalogmanagementv1.DeployRequestBodyEnvironmentVariablesItem{*deployRequestBodyEnvironmentVariablesItemModel}
				preinstallVersionOptionsModel.EntitlementApikey = core.StringPtr("testString")
				preinstallVersionOptionsModel.Schematics = deployRequestBodySchematicsModel
				preinstallVersionOptionsModel.Script = core.StringPtr("testString")
				preinstallVersionOptionsModel.ScriptID = core.StringPtr("testString")
				preinstallVersionOptionsModel.VersionLocatorID = core.StringPtr("testString")
				preinstallVersionOptionsModel.VcenterID = core.StringPtr("testString")
				preinstallVersionOptionsModel.VcenterLocation = core.StringPtr("testString")
				preinstallVersionOptionsModel.VcenterUser = core.StringPtr("testString")
				preinstallVersionOptionsModel.VcenterPassword = core.StringPtr("testString")
				preinstallVersionOptionsModel.VcenterDatastore = core.StringPtr("testString")
				preinstallVersionOptionsModel.PlanID = core.StringPtr("testString")
				preinstallVersionOptionsModel.Channel = core.StringPtr("testString")
				preinstallVersionOptionsModel.InstallPlan = core.StringPtr("testString")
				preinstallVersionOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := catalogManagementService.PreinstallVersion(preinstallVersionOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the PreinstallVersionOptions model with no property values
				preinstallVersionOptionsModelNew := new(catalogmanagementv1.PreinstallVersionOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = catalogManagementService.PreinstallVersion(preinstallVersionOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetPreinstall(getPreinstallOptions *GetPreinstallOptions) - Operation response error`, func() {
		getPreinstallPath := "/versions/testString/preinstall"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getPreinstallPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["X-Auth-Refresh-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Refresh-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["cluster_id"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["region"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["namespace"]).To(Equal([]string{"testString"}))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetPreinstall with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetPreinstallOptions model
				getPreinstallOptionsModel := new(catalogmanagementv1.GetPreinstallOptions)
				getPreinstallOptionsModel.VersionLocID = core.StringPtr("testString")
				getPreinstallOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				getPreinstallOptionsModel.ClusterID = core.StringPtr("testString")
				getPreinstallOptionsModel.Region = core.StringPtr("testString")
				getPreinstallOptionsModel.Namespace = core.StringPtr("testString")
				getPreinstallOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.GetPreinstall(getPreinstallOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.GetPreinstall(getPreinstallOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetPreinstall(getPreinstallOptions *GetPreinstallOptions)`, func() {
		getPreinstallPath := "/versions/testString/preinstall"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getPreinstallPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["X-Auth-Refresh-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Refresh-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["cluster_id"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["region"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["namespace"]).To(Equal([]string{"testString"}))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"metadata": {"cluster_id": "ClusterID", "region": "Region", "namespace": "Namespace", "workspace_id": "WorkspaceID", "workspace_name": "WorkspaceName"}, "release": {"deployments": [{"anyKey": "anyValue"}], "replicasets": [{"anyKey": "anyValue"}], "statefulsets": [{"anyKey": "anyValue"}], "pods": [{"anyKey": "anyValue"}], "errors": [{"mapKey": "Inner"}]}, "content_mgmt": {"pods": [{"mapKey": "Inner"}], "errors": [{"mapKey": "Inner"}]}}`)
				}))
			})
			It(`Invoke GetPreinstall successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the GetPreinstallOptions model
				getPreinstallOptionsModel := new(catalogmanagementv1.GetPreinstallOptions)
				getPreinstallOptionsModel.VersionLocID = core.StringPtr("testString")
				getPreinstallOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				getPreinstallOptionsModel.ClusterID = core.StringPtr("testString")
				getPreinstallOptionsModel.Region = core.StringPtr("testString")
				getPreinstallOptionsModel.Namespace = core.StringPtr("testString")
				getPreinstallOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.GetPreinstallWithContext(ctx, getPreinstallOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.GetPreinstall(getPreinstallOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.GetPreinstallWithContext(ctx, getPreinstallOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getPreinstallPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["X-Auth-Refresh-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Refresh-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["cluster_id"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["region"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["namespace"]).To(Equal([]string{"testString"}))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"metadata": {"cluster_id": "ClusterID", "region": "Region", "namespace": "Namespace", "workspace_id": "WorkspaceID", "workspace_name": "WorkspaceName"}, "release": {"deployments": [{"anyKey": "anyValue"}], "replicasets": [{"anyKey": "anyValue"}], "statefulsets": [{"anyKey": "anyValue"}], "pods": [{"anyKey": "anyValue"}], "errors": [{"mapKey": "Inner"}]}, "content_mgmt": {"pods": [{"mapKey": "Inner"}], "errors": [{"mapKey": "Inner"}]}}`)
				}))
			})
			It(`Invoke GetPreinstall successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.GetPreinstall(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetPreinstallOptions model
				getPreinstallOptionsModel := new(catalogmanagementv1.GetPreinstallOptions)
				getPreinstallOptionsModel.VersionLocID = core.StringPtr("testString")
				getPreinstallOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				getPreinstallOptionsModel.ClusterID = core.StringPtr("testString")
				getPreinstallOptionsModel.Region = core.StringPtr("testString")
				getPreinstallOptionsModel.Namespace = core.StringPtr("testString")
				getPreinstallOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.GetPreinstall(getPreinstallOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetPreinstall with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetPreinstallOptions model
				getPreinstallOptionsModel := new(catalogmanagementv1.GetPreinstallOptions)
				getPreinstallOptionsModel.VersionLocID = core.StringPtr("testString")
				getPreinstallOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				getPreinstallOptionsModel.ClusterID = core.StringPtr("testString")
				getPreinstallOptionsModel.Region = core.StringPtr("testString")
				getPreinstallOptionsModel.Namespace = core.StringPtr("testString")
				getPreinstallOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.GetPreinstall(getPreinstallOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetPreinstallOptions model with no property values
				getPreinstallOptionsModelNew := new(catalogmanagementv1.GetPreinstallOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.GetPreinstall(getPreinstallOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetPreinstall successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetPreinstallOptions model
				getPreinstallOptionsModel := new(catalogmanagementv1.GetPreinstallOptions)
				getPreinstallOptionsModel.VersionLocID = core.StringPtr("testString")
				getPreinstallOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				getPreinstallOptionsModel.ClusterID = core.StringPtr("testString")
				getPreinstallOptionsModel.Region = core.StringPtr("testString")
				getPreinstallOptionsModel.Namespace = core.StringPtr("testString")
				getPreinstallOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.GetPreinstall(getPreinstallOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ValidateInstall(validateInstallOptions *ValidateInstallOptions)`, func() {
		validateInstallPath := "/versions/testString/validation/install"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(validateInstallPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["X-Auth-Refresh-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Refresh-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["targetContextName"]).To(Equal([]string{"testString"}))
					res.WriteHeader(202)
				}))
			})
			It(`Invoke ValidateInstall successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := catalogManagementService.ValidateInstall(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the DeployRequestBodyOverrideValues model
				deployRequestBodyOverrideValuesModel := new(catalogmanagementv1.DeployRequestBodyOverrideValues)
				deployRequestBodyOverrideValuesModel.VsiInstanceName = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.VPCProfile = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.SubnetID = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.VPCID = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.SubnetZone = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.SSHKeyID = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.VPCRegion = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.SetProperty("foo", "testString")

				// Construct an instance of the DeployRequestBodyEnvironmentVariablesItem model
				deployRequestBodyEnvironmentVariablesItemModel := new(catalogmanagementv1.DeployRequestBodyEnvironmentVariablesItem)
				deployRequestBodyEnvironmentVariablesItemModel.Name = core.StringPtr("testString")
				deployRequestBodyEnvironmentVariablesItemModel.Value = "testString"
				deployRequestBodyEnvironmentVariablesItemModel.Secure = core.BoolPtr(true)
				deployRequestBodyEnvironmentVariablesItemModel.Hidden = core.BoolPtr(true)

				// Construct an instance of the DeployRequestBodySchematics model
				deployRequestBodySchematicsModel := new(catalogmanagementv1.DeployRequestBodySchematics)
				deployRequestBodySchematicsModel.Name = core.StringPtr("testString")
				deployRequestBodySchematicsModel.Description = core.StringPtr("testString")
				deployRequestBodySchematicsModel.Tags = []string{"testString"}
				deployRequestBodySchematicsModel.ResourceGroupID = core.StringPtr("testString")
				deployRequestBodySchematicsModel.TerraformVersion = core.StringPtr("testString")
				deployRequestBodySchematicsModel.Region = core.StringPtr("testString")

				// Construct an instance of the ValidateInstallOptions model
				validateInstallOptionsModel := new(catalogmanagementv1.ValidateInstallOptions)
				validateInstallOptionsModel.VersionLocID = core.StringPtr("testString")
				validateInstallOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				validateInstallOptionsModel.ClusterID = core.StringPtr("testString")
				validateInstallOptionsModel.Region = core.StringPtr("testString")
				validateInstallOptionsModel.Namespace = core.StringPtr("testString")
				validateInstallOptionsModel.Namespaces = []string{"testString"}
				validateInstallOptionsModel.AllNamespaces = core.BoolPtr(true)
				validateInstallOptionsModel.OverrideValues = deployRequestBodyOverrideValuesModel
				validateInstallOptionsModel.DependencyConfigs = []string{"testString"}
				validateInstallOptionsModel.EnvironmentVariables = []catalogmanagementv1.DeployRequestBodyEnvironmentVariablesItem{*deployRequestBodyEnvironmentVariablesItemModel}
				validateInstallOptionsModel.EntitlementApikey = core.StringPtr("testString")
				validateInstallOptionsModel.Schematics = deployRequestBodySchematicsModel
				validateInstallOptionsModel.Script = core.StringPtr("testString")
				validateInstallOptionsModel.ScriptID = core.StringPtr("testString")
				validateInstallOptionsModel.VersionLocatorID = core.StringPtr("testString")
				validateInstallOptionsModel.VcenterID = core.StringPtr("testString")
				validateInstallOptionsModel.VcenterLocation = core.StringPtr("testString")
				validateInstallOptionsModel.VcenterUser = core.StringPtr("testString")
				validateInstallOptionsModel.VcenterPassword = core.StringPtr("testString")
				validateInstallOptionsModel.VcenterDatastore = core.StringPtr("testString")
				validateInstallOptionsModel.PlanID = core.StringPtr("testString")
				validateInstallOptionsModel.Channel = core.StringPtr("testString")
				validateInstallOptionsModel.InstallPlan = core.StringPtr("testString")
				validateInstallOptionsModel.TargetContextName = core.StringPtr("testString")
				validateInstallOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = catalogManagementService.ValidateInstall(validateInstallOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke ValidateInstall with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the DeployRequestBodyOverrideValues model
				deployRequestBodyOverrideValuesModel := new(catalogmanagementv1.DeployRequestBodyOverrideValues)
				deployRequestBodyOverrideValuesModel.VsiInstanceName = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.VPCProfile = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.SubnetID = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.VPCID = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.SubnetZone = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.SSHKeyID = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.VPCRegion = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.SetProperty("foo", "testString")

				// Construct an instance of the DeployRequestBodyEnvironmentVariablesItem model
				deployRequestBodyEnvironmentVariablesItemModel := new(catalogmanagementv1.DeployRequestBodyEnvironmentVariablesItem)
				deployRequestBodyEnvironmentVariablesItemModel.Name = core.StringPtr("testString")
				deployRequestBodyEnvironmentVariablesItemModel.Value = "testString"
				deployRequestBodyEnvironmentVariablesItemModel.Secure = core.BoolPtr(true)
				deployRequestBodyEnvironmentVariablesItemModel.Hidden = core.BoolPtr(true)

				// Construct an instance of the DeployRequestBodySchematics model
				deployRequestBodySchematicsModel := new(catalogmanagementv1.DeployRequestBodySchematics)
				deployRequestBodySchematicsModel.Name = core.StringPtr("testString")
				deployRequestBodySchematicsModel.Description = core.StringPtr("testString")
				deployRequestBodySchematicsModel.Tags = []string{"testString"}
				deployRequestBodySchematicsModel.ResourceGroupID = core.StringPtr("testString")
				deployRequestBodySchematicsModel.TerraformVersion = core.StringPtr("testString")
				deployRequestBodySchematicsModel.Region = core.StringPtr("testString")

				// Construct an instance of the ValidateInstallOptions model
				validateInstallOptionsModel := new(catalogmanagementv1.ValidateInstallOptions)
				validateInstallOptionsModel.VersionLocID = core.StringPtr("testString")
				validateInstallOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				validateInstallOptionsModel.ClusterID = core.StringPtr("testString")
				validateInstallOptionsModel.Region = core.StringPtr("testString")
				validateInstallOptionsModel.Namespace = core.StringPtr("testString")
				validateInstallOptionsModel.Namespaces = []string{"testString"}
				validateInstallOptionsModel.AllNamespaces = core.BoolPtr(true)
				validateInstallOptionsModel.OverrideValues = deployRequestBodyOverrideValuesModel
				validateInstallOptionsModel.DependencyConfigs = []string{"testString"}
				validateInstallOptionsModel.EnvironmentVariables = []catalogmanagementv1.DeployRequestBodyEnvironmentVariablesItem{*deployRequestBodyEnvironmentVariablesItemModel}
				validateInstallOptionsModel.EntitlementApikey = core.StringPtr("testString")
				validateInstallOptionsModel.Schematics = deployRequestBodySchematicsModel
				validateInstallOptionsModel.Script = core.StringPtr("testString")
				validateInstallOptionsModel.ScriptID = core.StringPtr("testString")
				validateInstallOptionsModel.VersionLocatorID = core.StringPtr("testString")
				validateInstallOptionsModel.VcenterID = core.StringPtr("testString")
				validateInstallOptionsModel.VcenterLocation = core.StringPtr("testString")
				validateInstallOptionsModel.VcenterUser = core.StringPtr("testString")
				validateInstallOptionsModel.VcenterPassword = core.StringPtr("testString")
				validateInstallOptionsModel.VcenterDatastore = core.StringPtr("testString")
				validateInstallOptionsModel.PlanID = core.StringPtr("testString")
				validateInstallOptionsModel.Channel = core.StringPtr("testString")
				validateInstallOptionsModel.InstallPlan = core.StringPtr("testString")
				validateInstallOptionsModel.TargetContextName = core.StringPtr("testString")
				validateInstallOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := catalogManagementService.ValidateInstall(validateInstallOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the ValidateInstallOptions model with no property values
				validateInstallOptionsModelNew := new(catalogmanagementv1.ValidateInstallOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = catalogManagementService.ValidateInstall(validateInstallOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetValidationStatus(getValidationStatusOptions *GetValidationStatusOptions) - Operation response error`, func() {
		getValidationStatusPath := "/versions/testString/validation/install"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getValidationStatusPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["X-Auth-Refresh-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Refresh-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["targetContextName"]).To(Equal([]string{"testString"}))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetValidationStatus with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetValidationStatusOptions model
				getValidationStatusOptionsModel := new(catalogmanagementv1.GetValidationStatusOptions)
				getValidationStatusOptionsModel.VersionLocID = core.StringPtr("testString")
				getValidationStatusOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				getValidationStatusOptionsModel.TargetContextName = core.StringPtr("testString")
				getValidationStatusOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.GetValidationStatus(getValidationStatusOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.GetValidationStatus(getValidationStatusOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetValidationStatus(getValidationStatusOptions *GetValidationStatusOptions)`, func() {
		getValidationStatusPath := "/versions/testString/validation/install"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getValidationStatusPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["X-Auth-Refresh-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Refresh-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["targetContextName"]).To(Equal([]string{"testString"}))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"validated": "2019-01-01T12:00:00.000Z", "requested": "2019-01-01T12:00:00.000Z", "state": "State", "last_operation": "LastOperation", "target": {"anyKey": "anyValue"}, "message": "Message"}`)
				}))
			})
			It(`Invoke GetValidationStatus successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the GetValidationStatusOptions model
				getValidationStatusOptionsModel := new(catalogmanagementv1.GetValidationStatusOptions)
				getValidationStatusOptionsModel.VersionLocID = core.StringPtr("testString")
				getValidationStatusOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				getValidationStatusOptionsModel.TargetContextName = core.StringPtr("testString")
				getValidationStatusOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.GetValidationStatusWithContext(ctx, getValidationStatusOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.GetValidationStatus(getValidationStatusOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.GetValidationStatusWithContext(ctx, getValidationStatusOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getValidationStatusPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["X-Auth-Refresh-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Refresh-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["targetContextName"]).To(Equal([]string{"testString"}))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"validated": "2019-01-01T12:00:00.000Z", "requested": "2019-01-01T12:00:00.000Z", "state": "State", "last_operation": "LastOperation", "target": {"anyKey": "anyValue"}, "message": "Message"}`)
				}))
			})
			It(`Invoke GetValidationStatus successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.GetValidationStatus(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetValidationStatusOptions model
				getValidationStatusOptionsModel := new(catalogmanagementv1.GetValidationStatusOptions)
				getValidationStatusOptionsModel.VersionLocID = core.StringPtr("testString")
				getValidationStatusOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				getValidationStatusOptionsModel.TargetContextName = core.StringPtr("testString")
				getValidationStatusOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.GetValidationStatus(getValidationStatusOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetValidationStatus with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetValidationStatusOptions model
				getValidationStatusOptionsModel := new(catalogmanagementv1.GetValidationStatusOptions)
				getValidationStatusOptionsModel.VersionLocID = core.StringPtr("testString")
				getValidationStatusOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				getValidationStatusOptionsModel.TargetContextName = core.StringPtr("testString")
				getValidationStatusOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.GetValidationStatus(getValidationStatusOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetValidationStatusOptions model with no property values
				getValidationStatusOptionsModelNew := new(catalogmanagementv1.GetValidationStatusOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.GetValidationStatus(getValidationStatusOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetValidationStatus successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetValidationStatusOptions model
				getValidationStatusOptionsModel := new(catalogmanagementv1.GetValidationStatusOptions)
				getValidationStatusOptionsModel.VersionLocID = core.StringPtr("testString")
				getValidationStatusOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				getValidationStatusOptionsModel.TargetContextName = core.StringPtr("testString")
				getValidationStatusOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.GetValidationStatus(getValidationStatusOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`SearchObjects(searchObjectsOptions *SearchObjectsOptions) - Operation response error`, func() {
		searchObjectsPath := "/objects"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(searchObjectsPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.URL.Query()["query"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["kind"]).To(Equal([]string{"vpe"}))
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(10))}))
					Expect(req.URL.Query()["offset"]).To(Equal([]string{fmt.Sprint(int64(0))}))
					// TODO: Add check for collapse query parameter
					// TODO: Add check for digest query parameter
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke SearchObjects with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the SearchObjectsOptions model
				searchObjectsOptionsModel := new(catalogmanagementv1.SearchObjectsOptions)
				searchObjectsOptionsModel.Query = core.StringPtr("testString")
				searchObjectsOptionsModel.Kind = core.StringPtr("vpe")
				searchObjectsOptionsModel.Limit = core.Int64Ptr(int64(10))
				searchObjectsOptionsModel.Offset = core.Int64Ptr(int64(0))
				searchObjectsOptionsModel.Collapse = core.BoolPtr(true)
				searchObjectsOptionsModel.Digest = core.BoolPtr(true)
				searchObjectsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.SearchObjects(searchObjectsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.SearchObjects(searchObjectsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`SearchObjects(searchObjectsOptions *SearchObjectsOptions)`, func() {
		searchObjectsPath := "/objects"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(searchObjectsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.URL.Query()["query"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["kind"]).To(Equal([]string{"vpe"}))
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(10))}))
					Expect(req.URL.Query()["offset"]).To(Equal([]string{fmt.Sprint(int64(0))}))
					// TODO: Add check for collapse query parameter
					// TODO: Add check for digest query parameter
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"offset": 6, "limit": 5, "total_count": 10, "resource_count": 13, "first": "First", "last": "Last", "prev": "Prev", "next": "Next", "resources": [{"id": "ID", "_rev": "Rev", "name": "Name", "crn": "CRN", "url": "URL", "parent_id": "ParentID", "label_i18n": {"mapKey": "Inner"}, "label": "Label", "tags": ["Tags"], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "kind": "Kind", "publish": {"pc_managed": false, "approval_type": "ApprovalType", "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "original_crn": "OriginalCRN", "public_crn": "PublicCRN", "approval_record": {"anyKey": "anyValue"}, "permit_ibm_public_publish": true, "ibm_approved": false, "public_approved": true}, "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "catalog_id": "CatalogID", "catalog_name": "CatalogName", "data": {"anyKey": "anyValue"}}]}`)
				}))
			})
			It(`Invoke SearchObjects successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the SearchObjectsOptions model
				searchObjectsOptionsModel := new(catalogmanagementv1.SearchObjectsOptions)
				searchObjectsOptionsModel.Query = core.StringPtr("testString")
				searchObjectsOptionsModel.Kind = core.StringPtr("vpe")
				searchObjectsOptionsModel.Limit = core.Int64Ptr(int64(10))
				searchObjectsOptionsModel.Offset = core.Int64Ptr(int64(0))
				searchObjectsOptionsModel.Collapse = core.BoolPtr(true)
				searchObjectsOptionsModel.Digest = core.BoolPtr(true)
				searchObjectsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.SearchObjectsWithContext(ctx, searchObjectsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.SearchObjects(searchObjectsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.SearchObjectsWithContext(ctx, searchObjectsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(searchObjectsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.URL.Query()["query"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["kind"]).To(Equal([]string{"vpe"}))
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(10))}))
					Expect(req.URL.Query()["offset"]).To(Equal([]string{fmt.Sprint(int64(0))}))
					// TODO: Add check for collapse query parameter
					// TODO: Add check for digest query parameter
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"offset": 6, "limit": 5, "total_count": 10, "resource_count": 13, "first": "First", "last": "Last", "prev": "Prev", "next": "Next", "resources": [{"id": "ID", "_rev": "Rev", "name": "Name", "crn": "CRN", "url": "URL", "parent_id": "ParentID", "label_i18n": {"mapKey": "Inner"}, "label": "Label", "tags": ["Tags"], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "kind": "Kind", "publish": {"pc_managed": false, "approval_type": "ApprovalType", "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "original_crn": "OriginalCRN", "public_crn": "PublicCRN", "approval_record": {"anyKey": "anyValue"}, "permit_ibm_public_publish": true, "ibm_approved": false, "public_approved": true}, "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "catalog_id": "CatalogID", "catalog_name": "CatalogName", "data": {"anyKey": "anyValue"}}]}`)
				}))
			})
			It(`Invoke SearchObjects successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.SearchObjects(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the SearchObjectsOptions model
				searchObjectsOptionsModel := new(catalogmanagementv1.SearchObjectsOptions)
				searchObjectsOptionsModel.Query = core.StringPtr("testString")
				searchObjectsOptionsModel.Kind = core.StringPtr("vpe")
				searchObjectsOptionsModel.Limit = core.Int64Ptr(int64(10))
				searchObjectsOptionsModel.Offset = core.Int64Ptr(int64(0))
				searchObjectsOptionsModel.Collapse = core.BoolPtr(true)
				searchObjectsOptionsModel.Digest = core.BoolPtr(true)
				searchObjectsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.SearchObjects(searchObjectsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke SearchObjects with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the SearchObjectsOptions model
				searchObjectsOptionsModel := new(catalogmanagementv1.SearchObjectsOptions)
				searchObjectsOptionsModel.Query = core.StringPtr("testString")
				searchObjectsOptionsModel.Kind = core.StringPtr("vpe")
				searchObjectsOptionsModel.Limit = core.Int64Ptr(int64(10))
				searchObjectsOptionsModel.Offset = core.Int64Ptr(int64(0))
				searchObjectsOptionsModel.Collapse = core.BoolPtr(true)
				searchObjectsOptionsModel.Digest = core.BoolPtr(true)
				searchObjectsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.SearchObjects(searchObjectsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the SearchObjectsOptions model with no property values
				searchObjectsOptionsModelNew := new(catalogmanagementv1.SearchObjectsOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.SearchObjects(searchObjectsOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke SearchObjects successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the SearchObjectsOptions model
				searchObjectsOptionsModel := new(catalogmanagementv1.SearchObjectsOptions)
				searchObjectsOptionsModel.Query = core.StringPtr("testString")
				searchObjectsOptionsModel.Kind = core.StringPtr("vpe")
				searchObjectsOptionsModel.Limit = core.Int64Ptr(int64(10))
				searchObjectsOptionsModel.Offset = core.Int64Ptr(int64(0))
				searchObjectsOptionsModel.Collapse = core.BoolPtr(true)
				searchObjectsOptionsModel.Digest = core.BoolPtr(true)
				searchObjectsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.SearchObjects(searchObjectsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Test pagination helper method on response`, func() {
			It(`Invoke GetNextOffset successfully`, func() {
				responseObject := new(catalogmanagementv1.ObjectSearchResult)
				responseObject.Next = core.StringPtr("ibm.com?offset=135")

				value, err := responseObject.GetNextOffset()
				Expect(err).To(BeNil())
				Expect(value).To(Equal(core.Int64Ptr(int64(135))))
			})
			It(`Invoke GetNextOffset without a "Next" property in the response`, func() {
				responseObject := new(catalogmanagementv1.ObjectSearchResult)

				value, err := responseObject.GetNextOffset()
				Expect(err).To(BeNil())
				Expect(value).To(BeNil())
			})
			It(`Invoke GetNextOffset without any query params in the "Next" URL`, func() {
				responseObject := new(catalogmanagementv1.ObjectSearchResult)
				responseObject.Next = core.StringPtr("ibm.com")

				value, err := responseObject.GetNextOffset()
				Expect(err).To(BeNil())
				Expect(value).To(BeNil())
			})
			It(`Invoke GetNextOffset with a non-integer query param in the "Next" URL`, func() {
				responseObject := new(catalogmanagementv1.ObjectSearchResult)
				responseObject.Next = core.StringPtr("ibm.com?offset=tiger")

				value, err := responseObject.GetNextOffset()
				Expect(err).NotTo(BeNil())
				Expect(value).To(BeNil())
			})
		})
		Context(`Using mock server endpoint - paginated response`, func() {
			BeforeEach(func() {
				var requestNumber int = 0
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(searchObjectsPath))
					Expect(req.Method).To(Equal("GET"))

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					requestNumber++
					if requestNumber == 1 {
						fmt.Fprintf(res, "%s", `{"next":"https://myhost.com/somePath?offset=1","total_count":2,"limit":1,"resources":[{"id":"ID","_rev":"Rev","name":"Name","crn":"CRN","url":"URL","parent_id":"ParentID","label_i18n":{"mapKey":"Inner"},"label":"Label","tags":["Tags"],"created":"2019-01-01T12:00:00.000Z","updated":"2019-01-01T12:00:00.000Z","short_description":"ShortDescription","short_description_i18n":{"mapKey":"Inner"},"kind":"Kind","publish":{"pc_managed":false,"approval_type":"ApprovalType","publish_approved":false,"share_with_all":true,"share_with_ibm":true,"share_enabled":true,"original_crn":"OriginalCRN","public_crn":"PublicCRN","approval_record":{"anyKey":"anyValue"},"permit_ibm_public_publish":true,"ibm_approved":false,"public_approved":true},"state":{"current":"Current","current_entered":"2019-01-01T12:00:00.000Z","pending":"Pending","pending_requested":"2019-01-01T12:00:00.000Z","previous":"Previous"},"catalog_id":"CatalogID","catalog_name":"CatalogName","data":{"anyKey":"anyValue"}}]}`)
					} else if requestNumber == 2 {
						fmt.Fprintf(res, "%s", `{"total_count":2,"limit":1,"resources":[{"id":"ID","_rev":"Rev","name":"Name","crn":"CRN","url":"URL","parent_id":"ParentID","label_i18n":{"mapKey":"Inner"},"label":"Label","tags":["Tags"],"created":"2019-01-01T12:00:00.000Z","updated":"2019-01-01T12:00:00.000Z","short_description":"ShortDescription","short_description_i18n":{"mapKey":"Inner"},"kind":"Kind","publish":{"pc_managed":false,"approval_type":"ApprovalType","publish_approved":false,"share_with_all":true,"share_with_ibm":true,"share_enabled":true,"original_crn":"OriginalCRN","public_crn":"PublicCRN","approval_record":{"anyKey":"anyValue"},"permit_ibm_public_publish":true,"ibm_approved":false,"public_approved":true},"state":{"current":"Current","current_entered":"2019-01-01T12:00:00.000Z","pending":"Pending","pending_requested":"2019-01-01T12:00:00.000Z","previous":"Previous"},"catalog_id":"CatalogID","catalog_name":"CatalogName","data":{"anyKey":"anyValue"}}]}`)
					} else {
						res.WriteHeader(400)
					}
				}))
			})
			It(`Use SearchObjectsPager.GetNext successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				searchObjectsOptionsModel := &catalogmanagementv1.SearchObjectsOptions{
					Query:    core.StringPtr("testString"),
					Kind:     core.StringPtr("vpe"),
					Limit:    core.Int64Ptr(int64(10)),
					Collapse: core.BoolPtr(true),
					Digest:   core.BoolPtr(true),
				}

				pager, err := catalogManagementService.NewSearchObjectsPager(searchObjectsOptionsModel)
				Expect(err).To(BeNil())
				Expect(pager).ToNot(BeNil())

				var allResults []catalogmanagementv1.CatalogObject
				for pager.HasNext() {
					nextPage, err := pager.GetNext()
					Expect(err).To(BeNil())
					Expect(nextPage).ToNot(BeNil())
					allResults = append(allResults, nextPage...)
				}
				Expect(len(allResults)).To(Equal(2))
			})
			It(`Use SearchObjectsPager.GetAll successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				searchObjectsOptionsModel := &catalogmanagementv1.SearchObjectsOptions{
					Query:    core.StringPtr("testString"),
					Kind:     core.StringPtr("vpe"),
					Limit:    core.Int64Ptr(int64(10)),
					Collapse: core.BoolPtr(true),
					Digest:   core.BoolPtr(true),
				}

				pager, err := catalogManagementService.NewSearchObjectsPager(searchObjectsOptionsModel)
				Expect(err).To(BeNil())
				Expect(pager).ToNot(BeNil())

				allResults, err := pager.GetAll()
				Expect(err).To(BeNil())
				Expect(allResults).ToNot(BeNil())
				Expect(len(allResults)).To(Equal(2))
			})
		})
	})
	Describe(`ListObjects(listObjectsOptions *ListObjectsOptions) - Operation response error`, func() {
		listObjectsPath := "/catalogs/testString/objects"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listObjectsPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(10))}))
					Expect(req.URL.Query()["offset"]).To(Equal([]string{fmt.Sprint(int64(0))}))
					Expect(req.URL.Query()["name"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["sort"]).To(Equal([]string{"testString"}))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ListObjects with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ListObjectsOptions model
				listObjectsOptionsModel := new(catalogmanagementv1.ListObjectsOptions)
				listObjectsOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				listObjectsOptionsModel.Limit = core.Int64Ptr(int64(10))
				listObjectsOptionsModel.Offset = core.Int64Ptr(int64(0))
				listObjectsOptionsModel.Name = core.StringPtr("testString")
				listObjectsOptionsModel.Sort = core.StringPtr("testString")
				listObjectsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.ListObjects(listObjectsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.ListObjects(listObjectsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListObjects(listObjectsOptions *ListObjectsOptions)`, func() {
		listObjectsPath := "/catalogs/testString/objects"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listObjectsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(10))}))
					Expect(req.URL.Query()["offset"]).To(Equal([]string{fmt.Sprint(int64(0))}))
					Expect(req.URL.Query()["name"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["sort"]).To(Equal([]string{"testString"}))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"offset": 6, "limit": 5, "total_count": 10, "resource_count": 13, "first": "First", "last": "Last", "prev": "Prev", "next": "Next", "resources": [{"id": "ID", "_rev": "Rev", "name": "Name", "crn": "CRN", "url": "URL", "parent_id": "ParentID", "label_i18n": {"mapKey": "Inner"}, "label": "Label", "tags": ["Tags"], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "kind": "Kind", "publish": {"pc_managed": false, "approval_type": "ApprovalType", "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "original_crn": "OriginalCRN", "public_crn": "PublicCRN", "approval_record": {"anyKey": "anyValue"}, "permit_ibm_public_publish": true, "ibm_approved": false, "public_approved": true}, "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "catalog_id": "CatalogID", "catalog_name": "CatalogName", "data": {"anyKey": "anyValue"}}]}`)
				}))
			})
			It(`Invoke ListObjects successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the ListObjectsOptions model
				listObjectsOptionsModel := new(catalogmanagementv1.ListObjectsOptions)
				listObjectsOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				listObjectsOptionsModel.Limit = core.Int64Ptr(int64(10))
				listObjectsOptionsModel.Offset = core.Int64Ptr(int64(0))
				listObjectsOptionsModel.Name = core.StringPtr("testString")
				listObjectsOptionsModel.Sort = core.StringPtr("testString")
				listObjectsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.ListObjectsWithContext(ctx, listObjectsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.ListObjects(listObjectsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.ListObjectsWithContext(ctx, listObjectsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listObjectsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(10))}))
					Expect(req.URL.Query()["offset"]).To(Equal([]string{fmt.Sprint(int64(0))}))
					Expect(req.URL.Query()["name"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["sort"]).To(Equal([]string{"testString"}))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"offset": 6, "limit": 5, "total_count": 10, "resource_count": 13, "first": "First", "last": "Last", "prev": "Prev", "next": "Next", "resources": [{"id": "ID", "_rev": "Rev", "name": "Name", "crn": "CRN", "url": "URL", "parent_id": "ParentID", "label_i18n": {"mapKey": "Inner"}, "label": "Label", "tags": ["Tags"], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "kind": "Kind", "publish": {"pc_managed": false, "approval_type": "ApprovalType", "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "original_crn": "OriginalCRN", "public_crn": "PublicCRN", "approval_record": {"anyKey": "anyValue"}, "permit_ibm_public_publish": true, "ibm_approved": false, "public_approved": true}, "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "catalog_id": "CatalogID", "catalog_name": "CatalogName", "data": {"anyKey": "anyValue"}}]}`)
				}))
			})
			It(`Invoke ListObjects successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.ListObjects(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ListObjectsOptions model
				listObjectsOptionsModel := new(catalogmanagementv1.ListObjectsOptions)
				listObjectsOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				listObjectsOptionsModel.Limit = core.Int64Ptr(int64(10))
				listObjectsOptionsModel.Offset = core.Int64Ptr(int64(0))
				listObjectsOptionsModel.Name = core.StringPtr("testString")
				listObjectsOptionsModel.Sort = core.StringPtr("testString")
				listObjectsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.ListObjects(listObjectsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ListObjects with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ListObjectsOptions model
				listObjectsOptionsModel := new(catalogmanagementv1.ListObjectsOptions)
				listObjectsOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				listObjectsOptionsModel.Limit = core.Int64Ptr(int64(10))
				listObjectsOptionsModel.Offset = core.Int64Ptr(int64(0))
				listObjectsOptionsModel.Name = core.StringPtr("testString")
				listObjectsOptionsModel.Sort = core.StringPtr("testString")
				listObjectsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.ListObjects(listObjectsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the ListObjectsOptions model with no property values
				listObjectsOptionsModelNew := new(catalogmanagementv1.ListObjectsOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.ListObjects(listObjectsOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ListObjects successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ListObjectsOptions model
				listObjectsOptionsModel := new(catalogmanagementv1.ListObjectsOptions)
				listObjectsOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				listObjectsOptionsModel.Limit = core.Int64Ptr(int64(10))
				listObjectsOptionsModel.Offset = core.Int64Ptr(int64(0))
				listObjectsOptionsModel.Name = core.StringPtr("testString")
				listObjectsOptionsModel.Sort = core.StringPtr("testString")
				listObjectsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.ListObjects(listObjectsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Test pagination helper method on response`, func() {
			It(`Invoke GetNextOffset successfully`, func() {
				responseObject := new(catalogmanagementv1.ObjectListResult)
				responseObject.Next = core.StringPtr("ibm.com?offset=135")

				value, err := responseObject.GetNextOffset()
				Expect(err).To(BeNil())
				Expect(value).To(Equal(core.Int64Ptr(int64(135))))
			})
			It(`Invoke GetNextOffset without a "Next" property in the response`, func() {
				responseObject := new(catalogmanagementv1.ObjectListResult)

				value, err := responseObject.GetNextOffset()
				Expect(err).To(BeNil())
				Expect(value).To(BeNil())
			})
			It(`Invoke GetNextOffset without any query params in the "Next" URL`, func() {
				responseObject := new(catalogmanagementv1.ObjectListResult)
				responseObject.Next = core.StringPtr("ibm.com")

				value, err := responseObject.GetNextOffset()
				Expect(err).To(BeNil())
				Expect(value).To(BeNil())
			})
			It(`Invoke GetNextOffset with a non-integer query param in the "Next" URL`, func() {
				responseObject := new(catalogmanagementv1.ObjectListResult)
				responseObject.Next = core.StringPtr("ibm.com?offset=tiger")

				value, err := responseObject.GetNextOffset()
				Expect(err).NotTo(BeNil())
				Expect(value).To(BeNil())
			})
		})
		Context(`Using mock server endpoint - paginated response`, func() {
			BeforeEach(func() {
				var requestNumber int = 0
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listObjectsPath))
					Expect(req.Method).To(Equal("GET"))

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					requestNumber++
					if requestNumber == 1 {
						fmt.Fprintf(res, "%s", `{"next":"https://myhost.com/somePath?offset=1","total_count":2,"limit":1,"resources":[{"id":"ID","_rev":"Rev","name":"Name","crn":"CRN","url":"URL","parent_id":"ParentID","label_i18n":{"mapKey":"Inner"},"label":"Label","tags":["Tags"],"created":"2019-01-01T12:00:00.000Z","updated":"2019-01-01T12:00:00.000Z","short_description":"ShortDescription","short_description_i18n":{"mapKey":"Inner"},"kind":"Kind","publish":{"pc_managed":false,"approval_type":"ApprovalType","publish_approved":false,"share_with_all":true,"share_with_ibm":true,"share_enabled":true,"original_crn":"OriginalCRN","public_crn":"PublicCRN","approval_record":{"anyKey":"anyValue"},"permit_ibm_public_publish":true,"ibm_approved":false,"public_approved":true},"state":{"current":"Current","current_entered":"2019-01-01T12:00:00.000Z","pending":"Pending","pending_requested":"2019-01-01T12:00:00.000Z","previous":"Previous"},"catalog_id":"CatalogID","catalog_name":"CatalogName","data":{"anyKey":"anyValue"}}]}`)
					} else if requestNumber == 2 {
						fmt.Fprintf(res, "%s", `{"total_count":2,"limit":1,"resources":[{"id":"ID","_rev":"Rev","name":"Name","crn":"CRN","url":"URL","parent_id":"ParentID","label_i18n":{"mapKey":"Inner"},"label":"Label","tags":["Tags"],"created":"2019-01-01T12:00:00.000Z","updated":"2019-01-01T12:00:00.000Z","short_description":"ShortDescription","short_description_i18n":{"mapKey":"Inner"},"kind":"Kind","publish":{"pc_managed":false,"approval_type":"ApprovalType","publish_approved":false,"share_with_all":true,"share_with_ibm":true,"share_enabled":true,"original_crn":"OriginalCRN","public_crn":"PublicCRN","approval_record":{"anyKey":"anyValue"},"permit_ibm_public_publish":true,"ibm_approved":false,"public_approved":true},"state":{"current":"Current","current_entered":"2019-01-01T12:00:00.000Z","pending":"Pending","pending_requested":"2019-01-01T12:00:00.000Z","previous":"Previous"},"catalog_id":"CatalogID","catalog_name":"CatalogName","data":{"anyKey":"anyValue"}}]}`)
					} else {
						res.WriteHeader(400)
					}
				}))
			})
			It(`Use ObjectsPager.GetNext successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				listObjectsOptionsModel := &catalogmanagementv1.ListObjectsOptions{
					CatalogIdentifier: core.StringPtr("testString"),
					Limit:             core.Int64Ptr(int64(10)),
					Name:              core.StringPtr("testString"),
					Sort:              core.StringPtr("testString"),
				}

				pager, err := catalogManagementService.NewObjectsPager(listObjectsOptionsModel)
				Expect(err).To(BeNil())
				Expect(pager).ToNot(BeNil())

				var allResults []catalogmanagementv1.CatalogObject
				for pager.HasNext() {
					nextPage, err := pager.GetNext()
					Expect(err).To(BeNil())
					Expect(nextPage).ToNot(BeNil())
					allResults = append(allResults, nextPage...)
				}
				Expect(len(allResults)).To(Equal(2))
			})
			It(`Use ObjectsPager.GetAll successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				listObjectsOptionsModel := &catalogmanagementv1.ListObjectsOptions{
					CatalogIdentifier: core.StringPtr("testString"),
					Limit:             core.Int64Ptr(int64(10)),
					Name:              core.StringPtr("testString"),
					Sort:              core.StringPtr("testString"),
				}

				pager, err := catalogManagementService.NewObjectsPager(listObjectsOptionsModel)
				Expect(err).To(BeNil())
				Expect(pager).ToNot(BeNil())

				allResults, err := pager.GetAll()
				Expect(err).To(BeNil())
				Expect(allResults).ToNot(BeNil())
				Expect(len(allResults)).To(Equal(2))
			})
		})
	})
	Describe(`CreateObject(createObjectOptions *CreateObjectOptions) - Operation response error`, func() {
		createObjectPath := "/catalogs/testString/objects"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createObjectPath))
					Expect(req.Method).To(Equal("POST"))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke CreateObject with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the PublishObject model
				publishObjectModel := new(catalogmanagementv1.PublishObject)
				publishObjectModel.PcManaged = core.BoolPtr(true)
				publishObjectModel.ApprovalType = core.StringPtr("testString")
				publishObjectModel.PublishApproved = core.BoolPtr(true)
				publishObjectModel.ShareWithAll = core.BoolPtr(true)
				publishObjectModel.ShareWithIBM = core.BoolPtr(true)
				publishObjectModel.ShareEnabled = core.BoolPtr(true)
				publishObjectModel.OriginalCRN = core.StringPtr("testString")
				publishObjectModel.PublicCRN = core.StringPtr("testString")
				publishObjectModel.ApprovalRecord = map[string]interface{}{"anyKey": "anyValue"}
				publishObjectModel.PermitIBMPublicPublish = core.BoolPtr(true)
				publishObjectModel.IBMApproved = core.BoolPtr(true)
				publishObjectModel.PublicApproved = core.BoolPtr(true)

				// Construct an instance of the State model
				stateModel := new(catalogmanagementv1.State)
				stateModel.Current = core.StringPtr("testString")
				stateModel.CurrentEntered = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Pending = core.StringPtr("testString")
				stateModel.PendingRequested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Previous = core.StringPtr("testString")

				// Construct an instance of the CreateObjectOptions model
				createObjectOptionsModel := new(catalogmanagementv1.CreateObjectOptions)
				createObjectOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				createObjectOptionsModel.Name = core.StringPtr("testString")
				createObjectOptionsModel.CRN = core.StringPtr("testString")
				createObjectOptionsModel.URL = core.StringPtr("testString")
				createObjectOptionsModel.ParentID = core.StringPtr("testString")
				createObjectOptionsModel.LabelI18n = map[string]string{"key1": "testString"}
				createObjectOptionsModel.Label = core.StringPtr("testString")
				createObjectOptionsModel.Tags = []string{"testString"}
				createObjectOptionsModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				createObjectOptionsModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				createObjectOptionsModel.ShortDescription = core.StringPtr("testString")
				createObjectOptionsModel.ShortDescriptionI18n = map[string]string{"key1": "testString"}
				createObjectOptionsModel.Kind = core.StringPtr("testString")
				createObjectOptionsModel.Publish = publishObjectModel
				createObjectOptionsModel.State = stateModel
				createObjectOptionsModel.CatalogID = core.StringPtr("testString")
				createObjectOptionsModel.CatalogName = core.StringPtr("testString")
				createObjectOptionsModel.Data = map[string]interface{}{"anyKey": "anyValue"}
				createObjectOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.CreateObject(createObjectOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.CreateObject(createObjectOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateObject(createObjectOptions *CreateObjectOptions)`, func() {
		createObjectPath := "/catalogs/testString/objects"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createObjectPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "name": "Name", "crn": "CRN", "url": "URL", "parent_id": "ParentID", "label_i18n": {"mapKey": "Inner"}, "label": "Label", "tags": ["Tags"], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "kind": "Kind", "publish": {"pc_managed": false, "approval_type": "ApprovalType", "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "original_crn": "OriginalCRN", "public_crn": "PublicCRN", "approval_record": {"anyKey": "anyValue"}, "permit_ibm_public_publish": true, "ibm_approved": false, "public_approved": true}, "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "catalog_id": "CatalogID", "catalog_name": "CatalogName", "data": {"anyKey": "anyValue"}}`)
				}))
			})
			It(`Invoke CreateObject successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the PublishObject model
				publishObjectModel := new(catalogmanagementv1.PublishObject)
				publishObjectModel.PcManaged = core.BoolPtr(true)
				publishObjectModel.ApprovalType = core.StringPtr("testString")
				publishObjectModel.PublishApproved = core.BoolPtr(true)
				publishObjectModel.ShareWithAll = core.BoolPtr(true)
				publishObjectModel.ShareWithIBM = core.BoolPtr(true)
				publishObjectModel.ShareEnabled = core.BoolPtr(true)
				publishObjectModel.OriginalCRN = core.StringPtr("testString")
				publishObjectModel.PublicCRN = core.StringPtr("testString")
				publishObjectModel.ApprovalRecord = map[string]interface{}{"anyKey": "anyValue"}
				publishObjectModel.PermitIBMPublicPublish = core.BoolPtr(true)
				publishObjectModel.IBMApproved = core.BoolPtr(true)
				publishObjectModel.PublicApproved = core.BoolPtr(true)

				// Construct an instance of the State model
				stateModel := new(catalogmanagementv1.State)
				stateModel.Current = core.StringPtr("testString")
				stateModel.CurrentEntered = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Pending = core.StringPtr("testString")
				stateModel.PendingRequested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Previous = core.StringPtr("testString")

				// Construct an instance of the CreateObjectOptions model
				createObjectOptionsModel := new(catalogmanagementv1.CreateObjectOptions)
				createObjectOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				createObjectOptionsModel.Name = core.StringPtr("testString")
				createObjectOptionsModel.CRN = core.StringPtr("testString")
				createObjectOptionsModel.URL = core.StringPtr("testString")
				createObjectOptionsModel.ParentID = core.StringPtr("testString")
				createObjectOptionsModel.LabelI18n = map[string]string{"key1": "testString"}
				createObjectOptionsModel.Label = core.StringPtr("testString")
				createObjectOptionsModel.Tags = []string{"testString"}
				createObjectOptionsModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				createObjectOptionsModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				createObjectOptionsModel.ShortDescription = core.StringPtr("testString")
				createObjectOptionsModel.ShortDescriptionI18n = map[string]string{"key1": "testString"}
				createObjectOptionsModel.Kind = core.StringPtr("testString")
				createObjectOptionsModel.Publish = publishObjectModel
				createObjectOptionsModel.State = stateModel
				createObjectOptionsModel.CatalogID = core.StringPtr("testString")
				createObjectOptionsModel.CatalogName = core.StringPtr("testString")
				createObjectOptionsModel.Data = map[string]interface{}{"anyKey": "anyValue"}
				createObjectOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.CreateObjectWithContext(ctx, createObjectOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.CreateObject(createObjectOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.CreateObjectWithContext(ctx, createObjectOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createObjectPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "name": "Name", "crn": "CRN", "url": "URL", "parent_id": "ParentID", "label_i18n": {"mapKey": "Inner"}, "label": "Label", "tags": ["Tags"], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "kind": "Kind", "publish": {"pc_managed": false, "approval_type": "ApprovalType", "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "original_crn": "OriginalCRN", "public_crn": "PublicCRN", "approval_record": {"anyKey": "anyValue"}, "permit_ibm_public_publish": true, "ibm_approved": false, "public_approved": true}, "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "catalog_id": "CatalogID", "catalog_name": "CatalogName", "data": {"anyKey": "anyValue"}}`)
				}))
			})
			It(`Invoke CreateObject successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.CreateObject(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the PublishObject model
				publishObjectModel := new(catalogmanagementv1.PublishObject)
				publishObjectModel.PcManaged = core.BoolPtr(true)
				publishObjectModel.ApprovalType = core.StringPtr("testString")
				publishObjectModel.PublishApproved = core.BoolPtr(true)
				publishObjectModel.ShareWithAll = core.BoolPtr(true)
				publishObjectModel.ShareWithIBM = core.BoolPtr(true)
				publishObjectModel.ShareEnabled = core.BoolPtr(true)
				publishObjectModel.OriginalCRN = core.StringPtr("testString")
				publishObjectModel.PublicCRN = core.StringPtr("testString")
				publishObjectModel.ApprovalRecord = map[string]interface{}{"anyKey": "anyValue"}
				publishObjectModel.PermitIBMPublicPublish = core.BoolPtr(true)
				publishObjectModel.IBMApproved = core.BoolPtr(true)
				publishObjectModel.PublicApproved = core.BoolPtr(true)

				// Construct an instance of the State model
				stateModel := new(catalogmanagementv1.State)
				stateModel.Current = core.StringPtr("testString")
				stateModel.CurrentEntered = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Pending = core.StringPtr("testString")
				stateModel.PendingRequested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Previous = core.StringPtr("testString")

				// Construct an instance of the CreateObjectOptions model
				createObjectOptionsModel := new(catalogmanagementv1.CreateObjectOptions)
				createObjectOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				createObjectOptionsModel.Name = core.StringPtr("testString")
				createObjectOptionsModel.CRN = core.StringPtr("testString")
				createObjectOptionsModel.URL = core.StringPtr("testString")
				createObjectOptionsModel.ParentID = core.StringPtr("testString")
				createObjectOptionsModel.LabelI18n = map[string]string{"key1": "testString"}
				createObjectOptionsModel.Label = core.StringPtr("testString")
				createObjectOptionsModel.Tags = []string{"testString"}
				createObjectOptionsModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				createObjectOptionsModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				createObjectOptionsModel.ShortDescription = core.StringPtr("testString")
				createObjectOptionsModel.ShortDescriptionI18n = map[string]string{"key1": "testString"}
				createObjectOptionsModel.Kind = core.StringPtr("testString")
				createObjectOptionsModel.Publish = publishObjectModel
				createObjectOptionsModel.State = stateModel
				createObjectOptionsModel.CatalogID = core.StringPtr("testString")
				createObjectOptionsModel.CatalogName = core.StringPtr("testString")
				createObjectOptionsModel.Data = map[string]interface{}{"anyKey": "anyValue"}
				createObjectOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.CreateObject(createObjectOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke CreateObject with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the PublishObject model
				publishObjectModel := new(catalogmanagementv1.PublishObject)
				publishObjectModel.PcManaged = core.BoolPtr(true)
				publishObjectModel.ApprovalType = core.StringPtr("testString")
				publishObjectModel.PublishApproved = core.BoolPtr(true)
				publishObjectModel.ShareWithAll = core.BoolPtr(true)
				publishObjectModel.ShareWithIBM = core.BoolPtr(true)
				publishObjectModel.ShareEnabled = core.BoolPtr(true)
				publishObjectModel.OriginalCRN = core.StringPtr("testString")
				publishObjectModel.PublicCRN = core.StringPtr("testString")
				publishObjectModel.ApprovalRecord = map[string]interface{}{"anyKey": "anyValue"}
				publishObjectModel.PermitIBMPublicPublish = core.BoolPtr(true)
				publishObjectModel.IBMApproved = core.BoolPtr(true)
				publishObjectModel.PublicApproved = core.BoolPtr(true)

				// Construct an instance of the State model
				stateModel := new(catalogmanagementv1.State)
				stateModel.Current = core.StringPtr("testString")
				stateModel.CurrentEntered = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Pending = core.StringPtr("testString")
				stateModel.PendingRequested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Previous = core.StringPtr("testString")

				// Construct an instance of the CreateObjectOptions model
				createObjectOptionsModel := new(catalogmanagementv1.CreateObjectOptions)
				createObjectOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				createObjectOptionsModel.Name = core.StringPtr("testString")
				createObjectOptionsModel.CRN = core.StringPtr("testString")
				createObjectOptionsModel.URL = core.StringPtr("testString")
				createObjectOptionsModel.ParentID = core.StringPtr("testString")
				createObjectOptionsModel.LabelI18n = map[string]string{"key1": "testString"}
				createObjectOptionsModel.Label = core.StringPtr("testString")
				createObjectOptionsModel.Tags = []string{"testString"}
				createObjectOptionsModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				createObjectOptionsModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				createObjectOptionsModel.ShortDescription = core.StringPtr("testString")
				createObjectOptionsModel.ShortDescriptionI18n = map[string]string{"key1": "testString"}
				createObjectOptionsModel.Kind = core.StringPtr("testString")
				createObjectOptionsModel.Publish = publishObjectModel
				createObjectOptionsModel.State = stateModel
				createObjectOptionsModel.CatalogID = core.StringPtr("testString")
				createObjectOptionsModel.CatalogName = core.StringPtr("testString")
				createObjectOptionsModel.Data = map[string]interface{}{"anyKey": "anyValue"}
				createObjectOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.CreateObject(createObjectOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the CreateObjectOptions model with no property values
				createObjectOptionsModelNew := new(catalogmanagementv1.CreateObjectOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.CreateObject(createObjectOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(201)
				}))
			})
			It(`Invoke CreateObject successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the PublishObject model
				publishObjectModel := new(catalogmanagementv1.PublishObject)
				publishObjectModel.PcManaged = core.BoolPtr(true)
				publishObjectModel.ApprovalType = core.StringPtr("testString")
				publishObjectModel.PublishApproved = core.BoolPtr(true)
				publishObjectModel.ShareWithAll = core.BoolPtr(true)
				publishObjectModel.ShareWithIBM = core.BoolPtr(true)
				publishObjectModel.ShareEnabled = core.BoolPtr(true)
				publishObjectModel.OriginalCRN = core.StringPtr("testString")
				publishObjectModel.PublicCRN = core.StringPtr("testString")
				publishObjectModel.ApprovalRecord = map[string]interface{}{"anyKey": "anyValue"}
				publishObjectModel.PermitIBMPublicPublish = core.BoolPtr(true)
				publishObjectModel.IBMApproved = core.BoolPtr(true)
				publishObjectModel.PublicApproved = core.BoolPtr(true)

				// Construct an instance of the State model
				stateModel := new(catalogmanagementv1.State)
				stateModel.Current = core.StringPtr("testString")
				stateModel.CurrentEntered = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Pending = core.StringPtr("testString")
				stateModel.PendingRequested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Previous = core.StringPtr("testString")

				// Construct an instance of the CreateObjectOptions model
				createObjectOptionsModel := new(catalogmanagementv1.CreateObjectOptions)
				createObjectOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				createObjectOptionsModel.Name = core.StringPtr("testString")
				createObjectOptionsModel.CRN = core.StringPtr("testString")
				createObjectOptionsModel.URL = core.StringPtr("testString")
				createObjectOptionsModel.ParentID = core.StringPtr("testString")
				createObjectOptionsModel.LabelI18n = map[string]string{"key1": "testString"}
				createObjectOptionsModel.Label = core.StringPtr("testString")
				createObjectOptionsModel.Tags = []string{"testString"}
				createObjectOptionsModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				createObjectOptionsModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				createObjectOptionsModel.ShortDescription = core.StringPtr("testString")
				createObjectOptionsModel.ShortDescriptionI18n = map[string]string{"key1": "testString"}
				createObjectOptionsModel.Kind = core.StringPtr("testString")
				createObjectOptionsModel.Publish = publishObjectModel
				createObjectOptionsModel.State = stateModel
				createObjectOptionsModel.CatalogID = core.StringPtr("testString")
				createObjectOptionsModel.CatalogName = core.StringPtr("testString")
				createObjectOptionsModel.Data = map[string]interface{}{"anyKey": "anyValue"}
				createObjectOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.CreateObject(createObjectOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetObject(getObjectOptions *GetObjectOptions) - Operation response error`, func() {
		getObjectPath := "/catalogs/testString/objects/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getObjectPath))
					Expect(req.Method).To(Equal("GET"))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetObject with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetObjectOptions model
				getObjectOptionsModel := new(catalogmanagementv1.GetObjectOptions)
				getObjectOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getObjectOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				getObjectOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.GetObject(getObjectOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.GetObject(getObjectOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetObject(getObjectOptions *GetObjectOptions)`, func() {
		getObjectPath := "/catalogs/testString/objects/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getObjectPath))
					Expect(req.Method).To(Equal("GET"))

					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "name": "Name", "crn": "CRN", "url": "URL", "parent_id": "ParentID", "label_i18n": {"mapKey": "Inner"}, "label": "Label", "tags": ["Tags"], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "kind": "Kind", "publish": {"pc_managed": false, "approval_type": "ApprovalType", "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "original_crn": "OriginalCRN", "public_crn": "PublicCRN", "approval_record": {"anyKey": "anyValue"}, "permit_ibm_public_publish": true, "ibm_approved": false, "public_approved": true}, "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "catalog_id": "CatalogID", "catalog_name": "CatalogName", "data": {"anyKey": "anyValue"}}`)
				}))
			})
			It(`Invoke GetObject successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the GetObjectOptions model
				getObjectOptionsModel := new(catalogmanagementv1.GetObjectOptions)
				getObjectOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getObjectOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				getObjectOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.GetObjectWithContext(ctx, getObjectOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.GetObject(getObjectOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.GetObjectWithContext(ctx, getObjectOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getObjectPath))
					Expect(req.Method).To(Equal("GET"))

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "name": "Name", "crn": "CRN", "url": "URL", "parent_id": "ParentID", "label_i18n": {"mapKey": "Inner"}, "label": "Label", "tags": ["Tags"], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "kind": "Kind", "publish": {"pc_managed": false, "approval_type": "ApprovalType", "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "original_crn": "OriginalCRN", "public_crn": "PublicCRN", "approval_record": {"anyKey": "anyValue"}, "permit_ibm_public_publish": true, "ibm_approved": false, "public_approved": true}, "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "catalog_id": "CatalogID", "catalog_name": "CatalogName", "data": {"anyKey": "anyValue"}}`)
				}))
			})
			It(`Invoke GetObject successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.GetObject(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetObjectOptions model
				getObjectOptionsModel := new(catalogmanagementv1.GetObjectOptions)
				getObjectOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getObjectOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				getObjectOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.GetObject(getObjectOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetObject with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetObjectOptions model
				getObjectOptionsModel := new(catalogmanagementv1.GetObjectOptions)
				getObjectOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getObjectOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				getObjectOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.GetObject(getObjectOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetObjectOptions model with no property values
				getObjectOptionsModelNew := new(catalogmanagementv1.GetObjectOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.GetObject(getObjectOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetObject successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetObjectOptions model
				getObjectOptionsModel := new(catalogmanagementv1.GetObjectOptions)
				getObjectOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getObjectOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				getObjectOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.GetObject(getObjectOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ReplaceObject(replaceObjectOptions *ReplaceObjectOptions) - Operation response error`, func() {
		replaceObjectPath := "/catalogs/testString/objects/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(replaceObjectPath))
					Expect(req.Method).To(Equal("PUT"))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ReplaceObject with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the PublishObject model
				publishObjectModel := new(catalogmanagementv1.PublishObject)
				publishObjectModel.PcManaged = core.BoolPtr(true)
				publishObjectModel.ApprovalType = core.StringPtr("testString")
				publishObjectModel.PublishApproved = core.BoolPtr(true)
				publishObjectModel.ShareWithAll = core.BoolPtr(true)
				publishObjectModel.ShareWithIBM = core.BoolPtr(true)
				publishObjectModel.ShareEnabled = core.BoolPtr(true)
				publishObjectModel.OriginalCRN = core.StringPtr("testString")
				publishObjectModel.PublicCRN = core.StringPtr("testString")
				publishObjectModel.ApprovalRecord = map[string]interface{}{"anyKey": "anyValue"}
				publishObjectModel.PermitIBMPublicPublish = core.BoolPtr(true)
				publishObjectModel.IBMApproved = core.BoolPtr(true)
				publishObjectModel.PublicApproved = core.BoolPtr(true)

				// Construct an instance of the State model
				stateModel := new(catalogmanagementv1.State)
				stateModel.Current = core.StringPtr("testString")
				stateModel.CurrentEntered = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Pending = core.StringPtr("testString")
				stateModel.PendingRequested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Previous = core.StringPtr("testString")

				// Construct an instance of the ReplaceObjectOptions model
				replaceObjectOptionsModel := new(catalogmanagementv1.ReplaceObjectOptions)
				replaceObjectOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				replaceObjectOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				replaceObjectOptionsModel.ID = core.StringPtr("testString")
				replaceObjectOptionsModel.Rev = core.StringPtr("testString")
				replaceObjectOptionsModel.Name = core.StringPtr("testString")
				replaceObjectOptionsModel.CRN = core.StringPtr("testString")
				replaceObjectOptionsModel.URL = core.StringPtr("testString")
				replaceObjectOptionsModel.ParentID = core.StringPtr("testString")
				replaceObjectOptionsModel.LabelI18n = map[string]string{"key1": "testString"}
				replaceObjectOptionsModel.Label = core.StringPtr("testString")
				replaceObjectOptionsModel.Tags = []string{"testString"}
				replaceObjectOptionsModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				replaceObjectOptionsModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				replaceObjectOptionsModel.ShortDescription = core.StringPtr("testString")
				replaceObjectOptionsModel.ShortDescriptionI18n = map[string]string{"key1": "testString"}
				replaceObjectOptionsModel.Kind = core.StringPtr("testString")
				replaceObjectOptionsModel.Publish = publishObjectModel
				replaceObjectOptionsModel.State = stateModel
				replaceObjectOptionsModel.CatalogID = core.StringPtr("testString")
				replaceObjectOptionsModel.CatalogName = core.StringPtr("testString")
				replaceObjectOptionsModel.Data = map[string]interface{}{"anyKey": "anyValue"}
				replaceObjectOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.ReplaceObject(replaceObjectOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.ReplaceObject(replaceObjectOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ReplaceObject(replaceObjectOptions *ReplaceObjectOptions)`, func() {
		replaceObjectPath := "/catalogs/testString/objects/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(replaceObjectPath))
					Expect(req.Method).To(Equal("PUT"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "name": "Name", "crn": "CRN", "url": "URL", "parent_id": "ParentID", "label_i18n": {"mapKey": "Inner"}, "label": "Label", "tags": ["Tags"], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "kind": "Kind", "publish": {"pc_managed": false, "approval_type": "ApprovalType", "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "original_crn": "OriginalCRN", "public_crn": "PublicCRN", "approval_record": {"anyKey": "anyValue"}, "permit_ibm_public_publish": true, "ibm_approved": false, "public_approved": true}, "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "catalog_id": "CatalogID", "catalog_name": "CatalogName", "data": {"anyKey": "anyValue"}}`)
				}))
			})
			It(`Invoke ReplaceObject successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the PublishObject model
				publishObjectModel := new(catalogmanagementv1.PublishObject)
				publishObjectModel.PcManaged = core.BoolPtr(true)
				publishObjectModel.ApprovalType = core.StringPtr("testString")
				publishObjectModel.PublishApproved = core.BoolPtr(true)
				publishObjectModel.ShareWithAll = core.BoolPtr(true)
				publishObjectModel.ShareWithIBM = core.BoolPtr(true)
				publishObjectModel.ShareEnabled = core.BoolPtr(true)
				publishObjectModel.OriginalCRN = core.StringPtr("testString")
				publishObjectModel.PublicCRN = core.StringPtr("testString")
				publishObjectModel.ApprovalRecord = map[string]interface{}{"anyKey": "anyValue"}
				publishObjectModel.PermitIBMPublicPublish = core.BoolPtr(true)
				publishObjectModel.IBMApproved = core.BoolPtr(true)
				publishObjectModel.PublicApproved = core.BoolPtr(true)

				// Construct an instance of the State model
				stateModel := new(catalogmanagementv1.State)
				stateModel.Current = core.StringPtr("testString")
				stateModel.CurrentEntered = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Pending = core.StringPtr("testString")
				stateModel.PendingRequested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Previous = core.StringPtr("testString")

				// Construct an instance of the ReplaceObjectOptions model
				replaceObjectOptionsModel := new(catalogmanagementv1.ReplaceObjectOptions)
				replaceObjectOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				replaceObjectOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				replaceObjectOptionsModel.ID = core.StringPtr("testString")
				replaceObjectOptionsModel.Rev = core.StringPtr("testString")
				replaceObjectOptionsModel.Name = core.StringPtr("testString")
				replaceObjectOptionsModel.CRN = core.StringPtr("testString")
				replaceObjectOptionsModel.URL = core.StringPtr("testString")
				replaceObjectOptionsModel.ParentID = core.StringPtr("testString")
				replaceObjectOptionsModel.LabelI18n = map[string]string{"key1": "testString"}
				replaceObjectOptionsModel.Label = core.StringPtr("testString")
				replaceObjectOptionsModel.Tags = []string{"testString"}
				replaceObjectOptionsModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				replaceObjectOptionsModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				replaceObjectOptionsModel.ShortDescription = core.StringPtr("testString")
				replaceObjectOptionsModel.ShortDescriptionI18n = map[string]string{"key1": "testString"}
				replaceObjectOptionsModel.Kind = core.StringPtr("testString")
				replaceObjectOptionsModel.Publish = publishObjectModel
				replaceObjectOptionsModel.State = stateModel
				replaceObjectOptionsModel.CatalogID = core.StringPtr("testString")
				replaceObjectOptionsModel.CatalogName = core.StringPtr("testString")
				replaceObjectOptionsModel.Data = map[string]interface{}{"anyKey": "anyValue"}
				replaceObjectOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.ReplaceObjectWithContext(ctx, replaceObjectOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.ReplaceObject(replaceObjectOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.ReplaceObjectWithContext(ctx, replaceObjectOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(replaceObjectPath))
					Expect(req.Method).To(Equal("PUT"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "name": "Name", "crn": "CRN", "url": "URL", "parent_id": "ParentID", "label_i18n": {"mapKey": "Inner"}, "label": "Label", "tags": ["Tags"], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "kind": "Kind", "publish": {"pc_managed": false, "approval_type": "ApprovalType", "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "original_crn": "OriginalCRN", "public_crn": "PublicCRN", "approval_record": {"anyKey": "anyValue"}, "permit_ibm_public_publish": true, "ibm_approved": false, "public_approved": true}, "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "catalog_id": "CatalogID", "catalog_name": "CatalogName", "data": {"anyKey": "anyValue"}}`)
				}))
			})
			It(`Invoke ReplaceObject successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.ReplaceObject(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the PublishObject model
				publishObjectModel := new(catalogmanagementv1.PublishObject)
				publishObjectModel.PcManaged = core.BoolPtr(true)
				publishObjectModel.ApprovalType = core.StringPtr("testString")
				publishObjectModel.PublishApproved = core.BoolPtr(true)
				publishObjectModel.ShareWithAll = core.BoolPtr(true)
				publishObjectModel.ShareWithIBM = core.BoolPtr(true)
				publishObjectModel.ShareEnabled = core.BoolPtr(true)
				publishObjectModel.OriginalCRN = core.StringPtr("testString")
				publishObjectModel.PublicCRN = core.StringPtr("testString")
				publishObjectModel.ApprovalRecord = map[string]interface{}{"anyKey": "anyValue"}
				publishObjectModel.PermitIBMPublicPublish = core.BoolPtr(true)
				publishObjectModel.IBMApproved = core.BoolPtr(true)
				publishObjectModel.PublicApproved = core.BoolPtr(true)

				// Construct an instance of the State model
				stateModel := new(catalogmanagementv1.State)
				stateModel.Current = core.StringPtr("testString")
				stateModel.CurrentEntered = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Pending = core.StringPtr("testString")
				stateModel.PendingRequested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Previous = core.StringPtr("testString")

				// Construct an instance of the ReplaceObjectOptions model
				replaceObjectOptionsModel := new(catalogmanagementv1.ReplaceObjectOptions)
				replaceObjectOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				replaceObjectOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				replaceObjectOptionsModel.ID = core.StringPtr("testString")
				replaceObjectOptionsModel.Rev = core.StringPtr("testString")
				replaceObjectOptionsModel.Name = core.StringPtr("testString")
				replaceObjectOptionsModel.CRN = core.StringPtr("testString")
				replaceObjectOptionsModel.URL = core.StringPtr("testString")
				replaceObjectOptionsModel.ParentID = core.StringPtr("testString")
				replaceObjectOptionsModel.LabelI18n = map[string]string{"key1": "testString"}
				replaceObjectOptionsModel.Label = core.StringPtr("testString")
				replaceObjectOptionsModel.Tags = []string{"testString"}
				replaceObjectOptionsModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				replaceObjectOptionsModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				replaceObjectOptionsModel.ShortDescription = core.StringPtr("testString")
				replaceObjectOptionsModel.ShortDescriptionI18n = map[string]string{"key1": "testString"}
				replaceObjectOptionsModel.Kind = core.StringPtr("testString")
				replaceObjectOptionsModel.Publish = publishObjectModel
				replaceObjectOptionsModel.State = stateModel
				replaceObjectOptionsModel.CatalogID = core.StringPtr("testString")
				replaceObjectOptionsModel.CatalogName = core.StringPtr("testString")
				replaceObjectOptionsModel.Data = map[string]interface{}{"anyKey": "anyValue"}
				replaceObjectOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.ReplaceObject(replaceObjectOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ReplaceObject with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the PublishObject model
				publishObjectModel := new(catalogmanagementv1.PublishObject)
				publishObjectModel.PcManaged = core.BoolPtr(true)
				publishObjectModel.ApprovalType = core.StringPtr("testString")
				publishObjectModel.PublishApproved = core.BoolPtr(true)
				publishObjectModel.ShareWithAll = core.BoolPtr(true)
				publishObjectModel.ShareWithIBM = core.BoolPtr(true)
				publishObjectModel.ShareEnabled = core.BoolPtr(true)
				publishObjectModel.OriginalCRN = core.StringPtr("testString")
				publishObjectModel.PublicCRN = core.StringPtr("testString")
				publishObjectModel.ApprovalRecord = map[string]interface{}{"anyKey": "anyValue"}
				publishObjectModel.PermitIBMPublicPublish = core.BoolPtr(true)
				publishObjectModel.IBMApproved = core.BoolPtr(true)
				publishObjectModel.PublicApproved = core.BoolPtr(true)

				// Construct an instance of the State model
				stateModel := new(catalogmanagementv1.State)
				stateModel.Current = core.StringPtr("testString")
				stateModel.CurrentEntered = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Pending = core.StringPtr("testString")
				stateModel.PendingRequested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Previous = core.StringPtr("testString")

				// Construct an instance of the ReplaceObjectOptions model
				replaceObjectOptionsModel := new(catalogmanagementv1.ReplaceObjectOptions)
				replaceObjectOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				replaceObjectOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				replaceObjectOptionsModel.ID = core.StringPtr("testString")
				replaceObjectOptionsModel.Rev = core.StringPtr("testString")
				replaceObjectOptionsModel.Name = core.StringPtr("testString")
				replaceObjectOptionsModel.CRN = core.StringPtr("testString")
				replaceObjectOptionsModel.URL = core.StringPtr("testString")
				replaceObjectOptionsModel.ParentID = core.StringPtr("testString")
				replaceObjectOptionsModel.LabelI18n = map[string]string{"key1": "testString"}
				replaceObjectOptionsModel.Label = core.StringPtr("testString")
				replaceObjectOptionsModel.Tags = []string{"testString"}
				replaceObjectOptionsModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				replaceObjectOptionsModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				replaceObjectOptionsModel.ShortDescription = core.StringPtr("testString")
				replaceObjectOptionsModel.ShortDescriptionI18n = map[string]string{"key1": "testString"}
				replaceObjectOptionsModel.Kind = core.StringPtr("testString")
				replaceObjectOptionsModel.Publish = publishObjectModel
				replaceObjectOptionsModel.State = stateModel
				replaceObjectOptionsModel.CatalogID = core.StringPtr("testString")
				replaceObjectOptionsModel.CatalogName = core.StringPtr("testString")
				replaceObjectOptionsModel.Data = map[string]interface{}{"anyKey": "anyValue"}
				replaceObjectOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.ReplaceObject(replaceObjectOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the ReplaceObjectOptions model with no property values
				replaceObjectOptionsModelNew := new(catalogmanagementv1.ReplaceObjectOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.ReplaceObject(replaceObjectOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ReplaceObject successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the PublishObject model
				publishObjectModel := new(catalogmanagementv1.PublishObject)
				publishObjectModel.PcManaged = core.BoolPtr(true)
				publishObjectModel.ApprovalType = core.StringPtr("testString")
				publishObjectModel.PublishApproved = core.BoolPtr(true)
				publishObjectModel.ShareWithAll = core.BoolPtr(true)
				publishObjectModel.ShareWithIBM = core.BoolPtr(true)
				publishObjectModel.ShareEnabled = core.BoolPtr(true)
				publishObjectModel.OriginalCRN = core.StringPtr("testString")
				publishObjectModel.PublicCRN = core.StringPtr("testString")
				publishObjectModel.ApprovalRecord = map[string]interface{}{"anyKey": "anyValue"}
				publishObjectModel.PermitIBMPublicPublish = core.BoolPtr(true)
				publishObjectModel.IBMApproved = core.BoolPtr(true)
				publishObjectModel.PublicApproved = core.BoolPtr(true)

				// Construct an instance of the State model
				stateModel := new(catalogmanagementv1.State)
				stateModel.Current = core.StringPtr("testString")
				stateModel.CurrentEntered = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Pending = core.StringPtr("testString")
				stateModel.PendingRequested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Previous = core.StringPtr("testString")

				// Construct an instance of the ReplaceObjectOptions model
				replaceObjectOptionsModel := new(catalogmanagementv1.ReplaceObjectOptions)
				replaceObjectOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				replaceObjectOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				replaceObjectOptionsModel.ID = core.StringPtr("testString")
				replaceObjectOptionsModel.Rev = core.StringPtr("testString")
				replaceObjectOptionsModel.Name = core.StringPtr("testString")
				replaceObjectOptionsModel.CRN = core.StringPtr("testString")
				replaceObjectOptionsModel.URL = core.StringPtr("testString")
				replaceObjectOptionsModel.ParentID = core.StringPtr("testString")
				replaceObjectOptionsModel.LabelI18n = map[string]string{"key1": "testString"}
				replaceObjectOptionsModel.Label = core.StringPtr("testString")
				replaceObjectOptionsModel.Tags = []string{"testString"}
				replaceObjectOptionsModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				replaceObjectOptionsModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				replaceObjectOptionsModel.ShortDescription = core.StringPtr("testString")
				replaceObjectOptionsModel.ShortDescriptionI18n = map[string]string{"key1": "testString"}
				replaceObjectOptionsModel.Kind = core.StringPtr("testString")
				replaceObjectOptionsModel.Publish = publishObjectModel
				replaceObjectOptionsModel.State = stateModel
				replaceObjectOptionsModel.CatalogID = core.StringPtr("testString")
				replaceObjectOptionsModel.CatalogName = core.StringPtr("testString")
				replaceObjectOptionsModel.Data = map[string]interface{}{"anyKey": "anyValue"}
				replaceObjectOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.ReplaceObject(replaceObjectOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`DeleteObject(deleteObjectOptions *DeleteObjectOptions)`, func() {
		deleteObjectPath := "/catalogs/testString/objects/testString"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deleteObjectPath))
					Expect(req.Method).To(Equal("DELETE"))

					res.WriteHeader(200)
				}))
			})
			It(`Invoke DeleteObject successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := catalogManagementService.DeleteObject(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the DeleteObjectOptions model
				deleteObjectOptionsModel := new(catalogmanagementv1.DeleteObjectOptions)
				deleteObjectOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				deleteObjectOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				deleteObjectOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = catalogManagementService.DeleteObject(deleteObjectOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke DeleteObject with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the DeleteObjectOptions model
				deleteObjectOptionsModel := new(catalogmanagementv1.DeleteObjectOptions)
				deleteObjectOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				deleteObjectOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				deleteObjectOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := catalogManagementService.DeleteObject(deleteObjectOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the DeleteObjectOptions model with no property values
				deleteObjectOptionsModelNew := new(catalogmanagementv1.DeleteObjectOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = catalogManagementService.DeleteObject(deleteObjectOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListObjectAudits(listObjectAuditsOptions *ListObjectAuditsOptions) - Operation response error`, func() {
		listObjectAuditsPath := "/catalogs/testString/objects/testString/audits"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listObjectAuditsPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.URL.Query()["start"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(10))}))
					// TODO: Add check for lookupnames query parameter
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ListObjectAudits with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ListObjectAuditsOptions model
				listObjectAuditsOptionsModel := new(catalogmanagementv1.ListObjectAuditsOptions)
				listObjectAuditsOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				listObjectAuditsOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				listObjectAuditsOptionsModel.Start = core.StringPtr("testString")
				listObjectAuditsOptionsModel.Limit = core.Int64Ptr(int64(10))
				listObjectAuditsOptionsModel.Lookupnames = core.BoolPtr(true)
				listObjectAuditsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.ListObjectAudits(listObjectAuditsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.ListObjectAudits(listObjectAuditsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListObjectAudits(listObjectAuditsOptions *ListObjectAuditsOptions)`, func() {
		listObjectAuditsPath := "/catalogs/testString/objects/testString/audits"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listObjectAuditsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.URL.Query()["start"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(10))}))
					// TODO: Add check for lookupnames query parameter
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"start": "Start", "limit": 5, "total_count": 10, "resource_count": 13, "first": {"href": "Href", "start": "Start"}, "next": {"href": "Href", "start": "Start"}, "prev": {"href": "Href", "start": "Start"}, "last": {"href": "Href", "start": "Start"}, "audits": [{"id": "ID", "_rev": "Rev", "created": "2019-01-01T12:00:00.000Z", "change_type": "ChangeType", "target_type": "TargetType", "target_id": "TargetID", "who_email": "WhoEmail", "who_delegate_email": "WhoDelegateEmail", "message": "Message"}]}`)
				}))
			})
			It(`Invoke ListObjectAudits successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the ListObjectAuditsOptions model
				listObjectAuditsOptionsModel := new(catalogmanagementv1.ListObjectAuditsOptions)
				listObjectAuditsOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				listObjectAuditsOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				listObjectAuditsOptionsModel.Start = core.StringPtr("testString")
				listObjectAuditsOptionsModel.Limit = core.Int64Ptr(int64(10))
				listObjectAuditsOptionsModel.Lookupnames = core.BoolPtr(true)
				listObjectAuditsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.ListObjectAuditsWithContext(ctx, listObjectAuditsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.ListObjectAudits(listObjectAuditsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.ListObjectAuditsWithContext(ctx, listObjectAuditsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listObjectAuditsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.URL.Query()["start"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(10))}))
					// TODO: Add check for lookupnames query parameter
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"start": "Start", "limit": 5, "total_count": 10, "resource_count": 13, "first": {"href": "Href", "start": "Start"}, "next": {"href": "Href", "start": "Start"}, "prev": {"href": "Href", "start": "Start"}, "last": {"href": "Href", "start": "Start"}, "audits": [{"id": "ID", "_rev": "Rev", "created": "2019-01-01T12:00:00.000Z", "change_type": "ChangeType", "target_type": "TargetType", "target_id": "TargetID", "who_email": "WhoEmail", "who_delegate_email": "WhoDelegateEmail", "message": "Message"}]}`)
				}))
			})
			It(`Invoke ListObjectAudits successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.ListObjectAudits(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ListObjectAuditsOptions model
				listObjectAuditsOptionsModel := new(catalogmanagementv1.ListObjectAuditsOptions)
				listObjectAuditsOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				listObjectAuditsOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				listObjectAuditsOptionsModel.Start = core.StringPtr("testString")
				listObjectAuditsOptionsModel.Limit = core.Int64Ptr(int64(10))
				listObjectAuditsOptionsModel.Lookupnames = core.BoolPtr(true)
				listObjectAuditsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.ListObjectAudits(listObjectAuditsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ListObjectAudits with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ListObjectAuditsOptions model
				listObjectAuditsOptionsModel := new(catalogmanagementv1.ListObjectAuditsOptions)
				listObjectAuditsOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				listObjectAuditsOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				listObjectAuditsOptionsModel.Start = core.StringPtr("testString")
				listObjectAuditsOptionsModel.Limit = core.Int64Ptr(int64(10))
				listObjectAuditsOptionsModel.Lookupnames = core.BoolPtr(true)
				listObjectAuditsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.ListObjectAudits(listObjectAuditsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the ListObjectAuditsOptions model with no property values
				listObjectAuditsOptionsModelNew := new(catalogmanagementv1.ListObjectAuditsOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.ListObjectAudits(listObjectAuditsOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ListObjectAudits successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ListObjectAuditsOptions model
				listObjectAuditsOptionsModel := new(catalogmanagementv1.ListObjectAuditsOptions)
				listObjectAuditsOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				listObjectAuditsOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				listObjectAuditsOptionsModel.Start = core.StringPtr("testString")
				listObjectAuditsOptionsModel.Limit = core.Int64Ptr(int64(10))
				listObjectAuditsOptionsModel.Lookupnames = core.BoolPtr(true)
				listObjectAuditsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.ListObjectAudits(listObjectAuditsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Test pagination helper method on response`, func() {
			It(`Invoke GetNextStart successfully`, func() {
				responseObject := new(catalogmanagementv1.AuditLogs)
				nextObject := new(catalogmanagementv1.PaginationTokenLink)
				nextObject.Start = core.StringPtr("abc-123")
				responseObject.Next = nextObject

				value, err := responseObject.GetNextStart()
				Expect(err).To(BeNil())
				Expect(value).To(Equal(core.StringPtr("abc-123")))
			})
			It(`Invoke GetNextStart without a "Next" property in the response`, func() {
				responseObject := new(catalogmanagementv1.AuditLogs)

				value, err := responseObject.GetNextStart()
				Expect(err).To(BeNil())
				Expect(value).To(BeNil())
			})
		})
		Context(`Using mock server endpoint - paginated response`, func() {
			BeforeEach(func() {
				var requestNumber int = 0
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listObjectAuditsPath))
					Expect(req.Method).To(Equal("GET"))

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					requestNumber++
					if requestNumber == 1 {
						fmt.Fprintf(res, "%s", `{"next":{"start":"1"},"total_count":2,"limit":1,"audits":[{"id":"ID","_rev":"Rev","created":"2019-01-01T12:00:00.000Z","change_type":"ChangeType","target_type":"TargetType","target_id":"TargetID","who_email":"WhoEmail","who_delegate_email":"WhoDelegateEmail","message":"Message"}]}`)
					} else if requestNumber == 2 {
						fmt.Fprintf(res, "%s", `{"total_count":2,"limit":1,"audits":[{"id":"ID","_rev":"Rev","created":"2019-01-01T12:00:00.000Z","change_type":"ChangeType","target_type":"TargetType","target_id":"TargetID","who_email":"WhoEmail","who_delegate_email":"WhoDelegateEmail","message":"Message"}]}`)
					} else {
						res.WriteHeader(400)
					}
				}))
			})
			It(`Use ObjectAuditsPager.GetNext successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				listObjectAuditsOptionsModel := &catalogmanagementv1.ListObjectAuditsOptions{
					CatalogIdentifier: core.StringPtr("testString"),
					ObjectIdentifier:  core.StringPtr("testString"),
					Limit:             core.Int64Ptr(int64(10)),
					Lookupnames:       core.BoolPtr(true),
				}

				pager, err := catalogManagementService.NewObjectAuditsPager(listObjectAuditsOptionsModel)
				Expect(err).To(BeNil())
				Expect(pager).ToNot(BeNil())

				var allResults []catalogmanagementv1.AuditLogDigest
				for pager.HasNext() {
					nextPage, err := pager.GetNext()
					Expect(err).To(BeNil())
					Expect(nextPage).ToNot(BeNil())
					allResults = append(allResults, nextPage...)
				}
				Expect(len(allResults)).To(Equal(2))
			})
			It(`Use ObjectAuditsPager.GetAll successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				listObjectAuditsOptionsModel := &catalogmanagementv1.ListObjectAuditsOptions{
					CatalogIdentifier: core.StringPtr("testString"),
					ObjectIdentifier:  core.StringPtr("testString"),
					Limit:             core.Int64Ptr(int64(10)),
					Lookupnames:       core.BoolPtr(true),
				}

				pager, err := catalogManagementService.NewObjectAuditsPager(listObjectAuditsOptionsModel)
				Expect(err).To(BeNil())
				Expect(pager).ToNot(BeNil())

				allResults, err := pager.GetAll()
				Expect(err).To(BeNil())
				Expect(allResults).ToNot(BeNil())
				Expect(len(allResults)).To(Equal(2))
			})
		})
	})
	Describe(`GetObjectAudit(getObjectAuditOptions *GetObjectAuditOptions) - Operation response error`, func() {
		getObjectAuditPath := "/catalogs/testString/objects/testString/audits/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getObjectAuditPath))
					Expect(req.Method).To(Equal("GET"))
					// TODO: Add check for lookupnames query parameter
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetObjectAudit with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetObjectAuditOptions model
				getObjectAuditOptionsModel := new(catalogmanagementv1.GetObjectAuditOptions)
				getObjectAuditOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getObjectAuditOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				getObjectAuditOptionsModel.AuditlogIdentifier = core.StringPtr("testString")
				getObjectAuditOptionsModel.Lookupnames = core.BoolPtr(true)
				getObjectAuditOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.GetObjectAudit(getObjectAuditOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.GetObjectAudit(getObjectAuditOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetObjectAudit(getObjectAuditOptions *GetObjectAuditOptions)`, func() {
		getObjectAuditPath := "/catalogs/testString/objects/testString/audits/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getObjectAuditPath))
					Expect(req.Method).To(Equal("GET"))

					// TODO: Add check for lookupnames query parameter
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "created": "2019-01-01T12:00:00.000Z", "change_type": "ChangeType", "target_type": "TargetType", "target_id": "TargetID", "who_email": "WhoEmail", "who_delegate_email": "WhoDelegateEmail", "message": "Message", "gid": "Gid", "who_id": "WhoID", "who_name": "WhoName", "who_delegate_id": "WhoDelegateID", "who_delegate_name": "WhoDelegateName", "data": "anyValue"}`)
				}))
			})
			It(`Invoke GetObjectAudit successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the GetObjectAuditOptions model
				getObjectAuditOptionsModel := new(catalogmanagementv1.GetObjectAuditOptions)
				getObjectAuditOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getObjectAuditOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				getObjectAuditOptionsModel.AuditlogIdentifier = core.StringPtr("testString")
				getObjectAuditOptionsModel.Lookupnames = core.BoolPtr(true)
				getObjectAuditOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.GetObjectAuditWithContext(ctx, getObjectAuditOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.GetObjectAudit(getObjectAuditOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.GetObjectAuditWithContext(ctx, getObjectAuditOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getObjectAuditPath))
					Expect(req.Method).To(Equal("GET"))

					// TODO: Add check for lookupnames query parameter
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "created": "2019-01-01T12:00:00.000Z", "change_type": "ChangeType", "target_type": "TargetType", "target_id": "TargetID", "who_email": "WhoEmail", "who_delegate_email": "WhoDelegateEmail", "message": "Message", "gid": "Gid", "who_id": "WhoID", "who_name": "WhoName", "who_delegate_id": "WhoDelegateID", "who_delegate_name": "WhoDelegateName", "data": "anyValue"}`)
				}))
			})
			It(`Invoke GetObjectAudit successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.GetObjectAudit(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetObjectAuditOptions model
				getObjectAuditOptionsModel := new(catalogmanagementv1.GetObjectAuditOptions)
				getObjectAuditOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getObjectAuditOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				getObjectAuditOptionsModel.AuditlogIdentifier = core.StringPtr("testString")
				getObjectAuditOptionsModel.Lookupnames = core.BoolPtr(true)
				getObjectAuditOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.GetObjectAudit(getObjectAuditOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetObjectAudit with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetObjectAuditOptions model
				getObjectAuditOptionsModel := new(catalogmanagementv1.GetObjectAuditOptions)
				getObjectAuditOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getObjectAuditOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				getObjectAuditOptionsModel.AuditlogIdentifier = core.StringPtr("testString")
				getObjectAuditOptionsModel.Lookupnames = core.BoolPtr(true)
				getObjectAuditOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.GetObjectAudit(getObjectAuditOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetObjectAuditOptions model with no property values
				getObjectAuditOptionsModelNew := new(catalogmanagementv1.GetObjectAuditOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.GetObjectAudit(getObjectAuditOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetObjectAudit successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetObjectAuditOptions model
				getObjectAuditOptionsModel := new(catalogmanagementv1.GetObjectAuditOptions)
				getObjectAuditOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getObjectAuditOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				getObjectAuditOptionsModel.AuditlogIdentifier = core.StringPtr("testString")
				getObjectAuditOptionsModel.Lookupnames = core.BoolPtr(true)
				getObjectAuditOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.GetObjectAudit(getObjectAuditOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ConsumableShareObject(consumableShareObjectOptions *ConsumableShareObjectOptions)`, func() {
		consumableShareObjectPath := "/catalogs/testString/objects/testString/consume-publish"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(consumableShareObjectPath))
					Expect(req.Method).To(Equal("POST"))

					res.WriteHeader(202)
				}))
			})
			It(`Invoke ConsumableShareObject successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := catalogManagementService.ConsumableShareObject(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the ConsumableShareObjectOptions model
				consumableShareObjectOptionsModel := new(catalogmanagementv1.ConsumableShareObjectOptions)
				consumableShareObjectOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				consumableShareObjectOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				consumableShareObjectOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = catalogManagementService.ConsumableShareObject(consumableShareObjectOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke ConsumableShareObject with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ConsumableShareObjectOptions model
				consumableShareObjectOptionsModel := new(catalogmanagementv1.ConsumableShareObjectOptions)
				consumableShareObjectOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				consumableShareObjectOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				consumableShareObjectOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := catalogManagementService.ConsumableShareObject(consumableShareObjectOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the ConsumableShareObjectOptions model with no property values
				consumableShareObjectOptionsModelNew := new(catalogmanagementv1.ConsumableShareObjectOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = catalogManagementService.ConsumableShareObject(consumableShareObjectOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ShareObject(shareObjectOptions *ShareObjectOptions) - Operation response error`, func() {
		shareObjectPath := "/catalogs/testString/objects/testString/share"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(shareObjectPath))
					Expect(req.Method).To(Equal("POST"))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ShareObject with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ShareObjectOptions model
				shareObjectOptionsModel := new(catalogmanagementv1.ShareObjectOptions)
				shareObjectOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				shareObjectOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				shareObjectOptionsModel.IBM = core.BoolPtr(true)
				shareObjectOptionsModel.Public = core.BoolPtr(true)
				shareObjectOptionsModel.Enabled = core.BoolPtr(true)
				shareObjectOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.ShareObject(shareObjectOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.ShareObject(shareObjectOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ShareObject(shareObjectOptions *ShareObjectOptions)`, func() {
		shareObjectPath := "/catalogs/testString/objects/testString/share"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(shareObjectPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"ibm": false, "public": true, "enabled": false}`)
				}))
			})
			It(`Invoke ShareObject successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the ShareObjectOptions model
				shareObjectOptionsModel := new(catalogmanagementv1.ShareObjectOptions)
				shareObjectOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				shareObjectOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				shareObjectOptionsModel.IBM = core.BoolPtr(true)
				shareObjectOptionsModel.Public = core.BoolPtr(true)
				shareObjectOptionsModel.Enabled = core.BoolPtr(true)
				shareObjectOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.ShareObjectWithContext(ctx, shareObjectOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.ShareObject(shareObjectOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.ShareObjectWithContext(ctx, shareObjectOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(shareObjectPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"ibm": false, "public": true, "enabled": false}`)
				}))
			})
			It(`Invoke ShareObject successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.ShareObject(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ShareObjectOptions model
				shareObjectOptionsModel := new(catalogmanagementv1.ShareObjectOptions)
				shareObjectOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				shareObjectOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				shareObjectOptionsModel.IBM = core.BoolPtr(true)
				shareObjectOptionsModel.Public = core.BoolPtr(true)
				shareObjectOptionsModel.Enabled = core.BoolPtr(true)
				shareObjectOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.ShareObject(shareObjectOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ShareObject with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ShareObjectOptions model
				shareObjectOptionsModel := new(catalogmanagementv1.ShareObjectOptions)
				shareObjectOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				shareObjectOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				shareObjectOptionsModel.IBM = core.BoolPtr(true)
				shareObjectOptionsModel.Public = core.BoolPtr(true)
				shareObjectOptionsModel.Enabled = core.BoolPtr(true)
				shareObjectOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.ShareObject(shareObjectOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the ShareObjectOptions model with no property values
				shareObjectOptionsModelNew := new(catalogmanagementv1.ShareObjectOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.ShareObject(shareObjectOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ShareObject successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ShareObjectOptions model
				shareObjectOptionsModel := new(catalogmanagementv1.ShareObjectOptions)
				shareObjectOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				shareObjectOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				shareObjectOptionsModel.IBM = core.BoolPtr(true)
				shareObjectOptionsModel.Public = core.BoolPtr(true)
				shareObjectOptionsModel.Enabled = core.BoolPtr(true)
				shareObjectOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.ShareObject(shareObjectOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetObjectAccessList(getObjectAccessListOptions *GetObjectAccessListOptions) - Operation response error`, func() {
		getObjectAccessListPath := "/catalogs/testString/objects/testString/accessv1"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getObjectAccessListPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.URL.Query()["start"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(10))}))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetObjectAccessList with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetObjectAccessListOptions model
				getObjectAccessListOptionsModel := new(catalogmanagementv1.GetObjectAccessListOptions)
				getObjectAccessListOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getObjectAccessListOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				getObjectAccessListOptionsModel.Start = core.StringPtr("testString")
				getObjectAccessListOptionsModel.Limit = core.Int64Ptr(int64(10))
				getObjectAccessListOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.GetObjectAccessList(getObjectAccessListOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.GetObjectAccessList(getObjectAccessListOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetObjectAccessList(getObjectAccessListOptions *GetObjectAccessListOptions)`, func() {
		getObjectAccessListPath := "/catalogs/testString/objects/testString/accessv1"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getObjectAccessListPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.URL.Query()["start"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(10))}))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"start": "Start", "limit": 5, "total_count": 10, "resource_count": 13, "first": {"href": "Href", "start": "Start"}, "next": {"href": "Href", "start": "Start"}, "prev": {"href": "Href", "start": "Start"}, "last": {"href": "Href", "start": "Start"}, "resources": [{"id": "ID", "account": "Account", "account_type": 11, "catalog_id": "CatalogID", "target_id": "TargetID", "target_account": "TargetAccount", "target_kind": "TargetKind", "created": "2019-01-01T12:00:00.000Z", "approval_state": "ApprovalState", "visible_states": ["VisibleStates"]}]}`)
				}))
			})
			It(`Invoke GetObjectAccessList successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the GetObjectAccessListOptions model
				getObjectAccessListOptionsModel := new(catalogmanagementv1.GetObjectAccessListOptions)
				getObjectAccessListOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getObjectAccessListOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				getObjectAccessListOptionsModel.Start = core.StringPtr("testString")
				getObjectAccessListOptionsModel.Limit = core.Int64Ptr(int64(10))
				getObjectAccessListOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.GetObjectAccessListWithContext(ctx, getObjectAccessListOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.GetObjectAccessList(getObjectAccessListOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.GetObjectAccessListWithContext(ctx, getObjectAccessListOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getObjectAccessListPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.URL.Query()["start"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(10))}))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"start": "Start", "limit": 5, "total_count": 10, "resource_count": 13, "first": {"href": "Href", "start": "Start"}, "next": {"href": "Href", "start": "Start"}, "prev": {"href": "Href", "start": "Start"}, "last": {"href": "Href", "start": "Start"}, "resources": [{"id": "ID", "account": "Account", "account_type": 11, "catalog_id": "CatalogID", "target_id": "TargetID", "target_account": "TargetAccount", "target_kind": "TargetKind", "created": "2019-01-01T12:00:00.000Z", "approval_state": "ApprovalState", "visible_states": ["VisibleStates"]}]}`)
				}))
			})
			It(`Invoke GetObjectAccessList successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.GetObjectAccessList(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetObjectAccessListOptions model
				getObjectAccessListOptionsModel := new(catalogmanagementv1.GetObjectAccessListOptions)
				getObjectAccessListOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getObjectAccessListOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				getObjectAccessListOptionsModel.Start = core.StringPtr("testString")
				getObjectAccessListOptionsModel.Limit = core.Int64Ptr(int64(10))
				getObjectAccessListOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.GetObjectAccessList(getObjectAccessListOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetObjectAccessList with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetObjectAccessListOptions model
				getObjectAccessListOptionsModel := new(catalogmanagementv1.GetObjectAccessListOptions)
				getObjectAccessListOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getObjectAccessListOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				getObjectAccessListOptionsModel.Start = core.StringPtr("testString")
				getObjectAccessListOptionsModel.Limit = core.Int64Ptr(int64(10))
				getObjectAccessListOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.GetObjectAccessList(getObjectAccessListOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetObjectAccessListOptions model with no property values
				getObjectAccessListOptionsModelNew := new(catalogmanagementv1.GetObjectAccessListOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.GetObjectAccessList(getObjectAccessListOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetObjectAccessList successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetObjectAccessListOptions model
				getObjectAccessListOptionsModel := new(catalogmanagementv1.GetObjectAccessListOptions)
				getObjectAccessListOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getObjectAccessListOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				getObjectAccessListOptionsModel.Start = core.StringPtr("testString")
				getObjectAccessListOptionsModel.Limit = core.Int64Ptr(int64(10))
				getObjectAccessListOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.GetObjectAccessList(getObjectAccessListOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Test pagination helper method on response`, func() {
			It(`Invoke GetNextStart successfully`, func() {
				responseObject := new(catalogmanagementv1.AccessListResult)
				nextObject := new(catalogmanagementv1.PaginationTokenLink)
				nextObject.Start = core.StringPtr("abc-123")
				responseObject.Next = nextObject

				value, err := responseObject.GetNextStart()
				Expect(err).To(BeNil())
				Expect(value).To(Equal(core.StringPtr("abc-123")))
			})
			It(`Invoke GetNextStart without a "Next" property in the response`, func() {
				responseObject := new(catalogmanagementv1.AccessListResult)

				value, err := responseObject.GetNextStart()
				Expect(err).To(BeNil())
				Expect(value).To(BeNil())
			})
		})
		Context(`Using mock server endpoint - paginated response`, func() {
			BeforeEach(func() {
				var requestNumber int = 0
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getObjectAccessListPath))
					Expect(req.Method).To(Equal("GET"))

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					requestNumber++
					if requestNumber == 1 {
						fmt.Fprintf(res, "%s", `{"next":{"start":"1"},"total_count":2,"limit":1,"resources":[{"id":"ID","account":"Account","account_type":11,"catalog_id":"CatalogID","target_id":"TargetID","target_account":"TargetAccount","target_kind":"TargetKind","created":"2019-01-01T12:00:00.000Z","approval_state":"ApprovalState","visible_states":["VisibleStates"]}]}`)
					} else if requestNumber == 2 {
						fmt.Fprintf(res, "%s", `{"total_count":2,"limit":1,"resources":[{"id":"ID","account":"Account","account_type":11,"catalog_id":"CatalogID","target_id":"TargetID","target_account":"TargetAccount","target_kind":"TargetKind","created":"2019-01-01T12:00:00.000Z","approval_state":"ApprovalState","visible_states":["VisibleStates"]}]}`)
					} else {
						res.WriteHeader(400)
					}
				}))
			})
			It(`Use GetObjectAccessListPager.GetNext successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				getObjectAccessListOptionsModel := &catalogmanagementv1.GetObjectAccessListOptions{
					CatalogIdentifier: core.StringPtr("testString"),
					ObjectIdentifier:  core.StringPtr("testString"),
					Limit:             core.Int64Ptr(int64(10)),
				}

				pager, err := catalogManagementService.NewGetObjectAccessListPager(getObjectAccessListOptionsModel)
				Expect(err).To(BeNil())
				Expect(pager).ToNot(BeNil())

				var allResults []catalogmanagementv1.Access
				for pager.HasNext() {
					nextPage, err := pager.GetNext()
					Expect(err).To(BeNil())
					Expect(nextPage).ToNot(BeNil())
					allResults = append(allResults, nextPage...)
				}
				Expect(len(allResults)).To(Equal(2))
			})
			It(`Use GetObjectAccessListPager.GetAll successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				getObjectAccessListOptionsModel := &catalogmanagementv1.GetObjectAccessListOptions{
					CatalogIdentifier: core.StringPtr("testString"),
					ObjectIdentifier:  core.StringPtr("testString"),
					Limit:             core.Int64Ptr(int64(10)),
				}

				pager, err := catalogManagementService.NewGetObjectAccessListPager(getObjectAccessListOptionsModel)
				Expect(err).To(BeNil())
				Expect(pager).ToNot(BeNil())

				allResults, err := pager.GetAll()
				Expect(err).To(BeNil())
				Expect(allResults).ToNot(BeNil())
				Expect(len(allResults)).To(Equal(2))
			})
		})
	})
	Describe(`GetObjectAccess(getObjectAccessOptions *GetObjectAccessOptions) - Operation response error`, func() {
		getObjectAccessPath := "/catalogs/testString/objects/testString/access/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getObjectAccessPath))
					Expect(req.Method).To(Equal("GET"))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetObjectAccess with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetObjectAccessOptions model
				getObjectAccessOptionsModel := new(catalogmanagementv1.GetObjectAccessOptions)
				getObjectAccessOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getObjectAccessOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				getObjectAccessOptionsModel.AccessIdentifier = core.StringPtr("testString")
				getObjectAccessOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.GetObjectAccess(getObjectAccessOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.GetObjectAccess(getObjectAccessOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetObjectAccess(getObjectAccessOptions *GetObjectAccessOptions)`, func() {
		getObjectAccessPath := "/catalogs/testString/objects/testString/access/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getObjectAccessPath))
					Expect(req.Method).To(Equal("GET"))

					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "account": "Account", "account_type": 11, "catalog_id": "CatalogID", "target_id": "TargetID", "target_account": "TargetAccount", "target_kind": "TargetKind", "created": "2019-01-01T12:00:00.000Z", "approval_state": "ApprovalState", "visible_states": ["VisibleStates"]}`)
				}))
			})
			It(`Invoke GetObjectAccess successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the GetObjectAccessOptions model
				getObjectAccessOptionsModel := new(catalogmanagementv1.GetObjectAccessOptions)
				getObjectAccessOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getObjectAccessOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				getObjectAccessOptionsModel.AccessIdentifier = core.StringPtr("testString")
				getObjectAccessOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.GetObjectAccessWithContext(ctx, getObjectAccessOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.GetObjectAccess(getObjectAccessOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.GetObjectAccessWithContext(ctx, getObjectAccessOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getObjectAccessPath))
					Expect(req.Method).To(Equal("GET"))

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "account": "Account", "account_type": 11, "catalog_id": "CatalogID", "target_id": "TargetID", "target_account": "TargetAccount", "target_kind": "TargetKind", "created": "2019-01-01T12:00:00.000Z", "approval_state": "ApprovalState", "visible_states": ["VisibleStates"]}`)
				}))
			})
			It(`Invoke GetObjectAccess successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.GetObjectAccess(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetObjectAccessOptions model
				getObjectAccessOptionsModel := new(catalogmanagementv1.GetObjectAccessOptions)
				getObjectAccessOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getObjectAccessOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				getObjectAccessOptionsModel.AccessIdentifier = core.StringPtr("testString")
				getObjectAccessOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.GetObjectAccess(getObjectAccessOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetObjectAccess with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetObjectAccessOptions model
				getObjectAccessOptionsModel := new(catalogmanagementv1.GetObjectAccessOptions)
				getObjectAccessOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getObjectAccessOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				getObjectAccessOptionsModel.AccessIdentifier = core.StringPtr("testString")
				getObjectAccessOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.GetObjectAccess(getObjectAccessOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetObjectAccessOptions model with no property values
				getObjectAccessOptionsModelNew := new(catalogmanagementv1.GetObjectAccessOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.GetObjectAccess(getObjectAccessOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetObjectAccess successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetObjectAccessOptions model
				getObjectAccessOptionsModel := new(catalogmanagementv1.GetObjectAccessOptions)
				getObjectAccessOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getObjectAccessOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				getObjectAccessOptionsModel.AccessIdentifier = core.StringPtr("testString")
				getObjectAccessOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.GetObjectAccess(getObjectAccessOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateObjectAccess(createObjectAccessOptions *CreateObjectAccessOptions)`, func() {
		createObjectAccessPath := "/catalogs/testString/objects/testString/access/testString"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createObjectAccessPath))
					Expect(req.Method).To(Equal("POST"))

					res.WriteHeader(201)
				}))
			})
			It(`Invoke CreateObjectAccess successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := catalogManagementService.CreateObjectAccess(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the CreateObjectAccessOptions model
				createObjectAccessOptionsModel := new(catalogmanagementv1.CreateObjectAccessOptions)
				createObjectAccessOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				createObjectAccessOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				createObjectAccessOptionsModel.AccessIdentifier = core.StringPtr("testString")
				createObjectAccessOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = catalogManagementService.CreateObjectAccess(createObjectAccessOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke CreateObjectAccess with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the CreateObjectAccessOptions model
				createObjectAccessOptionsModel := new(catalogmanagementv1.CreateObjectAccessOptions)
				createObjectAccessOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				createObjectAccessOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				createObjectAccessOptionsModel.AccessIdentifier = core.StringPtr("testString")
				createObjectAccessOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := catalogManagementService.CreateObjectAccess(createObjectAccessOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the CreateObjectAccessOptions model with no property values
				createObjectAccessOptionsModelNew := new(catalogmanagementv1.CreateObjectAccessOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = catalogManagementService.CreateObjectAccess(createObjectAccessOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`DeleteObjectAccess(deleteObjectAccessOptions *DeleteObjectAccessOptions)`, func() {
		deleteObjectAccessPath := "/catalogs/testString/objects/testString/access/testString"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deleteObjectAccessPath))
					Expect(req.Method).To(Equal("DELETE"))

					res.WriteHeader(200)
				}))
			})
			It(`Invoke DeleteObjectAccess successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := catalogManagementService.DeleteObjectAccess(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the DeleteObjectAccessOptions model
				deleteObjectAccessOptionsModel := new(catalogmanagementv1.DeleteObjectAccessOptions)
				deleteObjectAccessOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				deleteObjectAccessOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				deleteObjectAccessOptionsModel.AccessIdentifier = core.StringPtr("testString")
				deleteObjectAccessOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = catalogManagementService.DeleteObjectAccess(deleteObjectAccessOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke DeleteObjectAccess with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the DeleteObjectAccessOptions model
				deleteObjectAccessOptionsModel := new(catalogmanagementv1.DeleteObjectAccessOptions)
				deleteObjectAccessOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				deleteObjectAccessOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				deleteObjectAccessOptionsModel.AccessIdentifier = core.StringPtr("testString")
				deleteObjectAccessOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := catalogManagementService.DeleteObjectAccess(deleteObjectAccessOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the DeleteObjectAccessOptions model with no property values
				deleteObjectAccessOptionsModelNew := new(catalogmanagementv1.DeleteObjectAccessOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = catalogManagementService.DeleteObjectAccess(deleteObjectAccessOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetObjectAccessListDeprecated(getObjectAccessListDeprecatedOptions *GetObjectAccessListDeprecatedOptions) - Operation response error`, func() {
		getObjectAccessListDeprecatedPath := "/catalogs/testString/objects/testString/access"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getObjectAccessListDeprecatedPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(10))}))
					Expect(req.URL.Query()["offset"]).To(Equal([]string{fmt.Sprint(int64(0))}))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetObjectAccessListDeprecated with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetObjectAccessListDeprecatedOptions model
				getObjectAccessListDeprecatedOptionsModel := new(catalogmanagementv1.GetObjectAccessListDeprecatedOptions)
				getObjectAccessListDeprecatedOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getObjectAccessListDeprecatedOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				getObjectAccessListDeprecatedOptionsModel.Limit = core.Int64Ptr(int64(10))
				getObjectAccessListDeprecatedOptionsModel.Offset = core.Int64Ptr(int64(0))
				getObjectAccessListDeprecatedOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.GetObjectAccessListDeprecated(getObjectAccessListDeprecatedOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.GetObjectAccessListDeprecated(getObjectAccessListDeprecatedOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetObjectAccessListDeprecated(getObjectAccessListDeprecatedOptions *GetObjectAccessListDeprecatedOptions)`, func() {
		getObjectAccessListDeprecatedPath := "/catalogs/testString/objects/testString/access"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getObjectAccessListDeprecatedPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(10))}))
					Expect(req.URL.Query()["offset"]).To(Equal([]string{fmt.Sprint(int64(0))}))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"offset": 6, "limit": 5, "total_count": 10, "resource_count": 13, "first": "First", "last": "Last", "prev": "Prev", "next": "Next", "resources": [{"id": "ID", "account": "Account", "account_type": 11, "catalog_id": "CatalogID", "target_id": "TargetID", "target_account": "TargetAccount", "target_kind": "TargetKind", "created": "2019-01-01T12:00:00.000Z", "approval_state": "ApprovalState", "visible_states": ["VisibleStates"]}]}`)
				}))
			})
			It(`Invoke GetObjectAccessListDeprecated successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the GetObjectAccessListDeprecatedOptions model
				getObjectAccessListDeprecatedOptionsModel := new(catalogmanagementv1.GetObjectAccessListDeprecatedOptions)
				getObjectAccessListDeprecatedOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getObjectAccessListDeprecatedOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				getObjectAccessListDeprecatedOptionsModel.Limit = core.Int64Ptr(int64(10))
				getObjectAccessListDeprecatedOptionsModel.Offset = core.Int64Ptr(int64(0))
				getObjectAccessListDeprecatedOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.GetObjectAccessListDeprecatedWithContext(ctx, getObjectAccessListDeprecatedOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.GetObjectAccessListDeprecated(getObjectAccessListDeprecatedOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.GetObjectAccessListDeprecatedWithContext(ctx, getObjectAccessListDeprecatedOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getObjectAccessListDeprecatedPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(10))}))
					Expect(req.URL.Query()["offset"]).To(Equal([]string{fmt.Sprint(int64(0))}))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"offset": 6, "limit": 5, "total_count": 10, "resource_count": 13, "first": "First", "last": "Last", "prev": "Prev", "next": "Next", "resources": [{"id": "ID", "account": "Account", "account_type": 11, "catalog_id": "CatalogID", "target_id": "TargetID", "target_account": "TargetAccount", "target_kind": "TargetKind", "created": "2019-01-01T12:00:00.000Z", "approval_state": "ApprovalState", "visible_states": ["VisibleStates"]}]}`)
				}))
			})
			It(`Invoke GetObjectAccessListDeprecated successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.GetObjectAccessListDeprecated(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetObjectAccessListDeprecatedOptions model
				getObjectAccessListDeprecatedOptionsModel := new(catalogmanagementv1.GetObjectAccessListDeprecatedOptions)
				getObjectAccessListDeprecatedOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getObjectAccessListDeprecatedOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				getObjectAccessListDeprecatedOptionsModel.Limit = core.Int64Ptr(int64(10))
				getObjectAccessListDeprecatedOptionsModel.Offset = core.Int64Ptr(int64(0))
				getObjectAccessListDeprecatedOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.GetObjectAccessListDeprecated(getObjectAccessListDeprecatedOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetObjectAccessListDeprecated with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetObjectAccessListDeprecatedOptions model
				getObjectAccessListDeprecatedOptionsModel := new(catalogmanagementv1.GetObjectAccessListDeprecatedOptions)
				getObjectAccessListDeprecatedOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getObjectAccessListDeprecatedOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				getObjectAccessListDeprecatedOptionsModel.Limit = core.Int64Ptr(int64(10))
				getObjectAccessListDeprecatedOptionsModel.Offset = core.Int64Ptr(int64(0))
				getObjectAccessListDeprecatedOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.GetObjectAccessListDeprecated(getObjectAccessListDeprecatedOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetObjectAccessListDeprecatedOptions model with no property values
				getObjectAccessListDeprecatedOptionsModelNew := new(catalogmanagementv1.GetObjectAccessListDeprecatedOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.GetObjectAccessListDeprecated(getObjectAccessListDeprecatedOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetObjectAccessListDeprecated successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetObjectAccessListDeprecatedOptions model
				getObjectAccessListDeprecatedOptionsModel := new(catalogmanagementv1.GetObjectAccessListDeprecatedOptions)
				getObjectAccessListDeprecatedOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				getObjectAccessListDeprecatedOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				getObjectAccessListDeprecatedOptionsModel.Limit = core.Int64Ptr(int64(10))
				getObjectAccessListDeprecatedOptionsModel.Offset = core.Int64Ptr(int64(0))
				getObjectAccessListDeprecatedOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.GetObjectAccessListDeprecated(getObjectAccessListDeprecatedOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Test pagination helper method on response`, func() {
			It(`Invoke GetNextOffset successfully`, func() {
				responseObject := new(catalogmanagementv1.ObjectAccessListResult)
				responseObject.Next = core.StringPtr("ibm.com?offset=135")

				value, err := responseObject.GetNextOffset()
				Expect(err).To(BeNil())
				Expect(value).To(Equal(core.Int64Ptr(int64(135))))
			})
			It(`Invoke GetNextOffset without a "Next" property in the response`, func() {
				responseObject := new(catalogmanagementv1.ObjectAccessListResult)

				value, err := responseObject.GetNextOffset()
				Expect(err).To(BeNil())
				Expect(value).To(BeNil())
			})
			It(`Invoke GetNextOffset without any query params in the "Next" URL`, func() {
				responseObject := new(catalogmanagementv1.ObjectAccessListResult)
				responseObject.Next = core.StringPtr("ibm.com")

				value, err := responseObject.GetNextOffset()
				Expect(err).To(BeNil())
				Expect(value).To(BeNil())
			})
			It(`Invoke GetNextOffset with a non-integer query param in the "Next" URL`, func() {
				responseObject := new(catalogmanagementv1.ObjectAccessListResult)
				responseObject.Next = core.StringPtr("ibm.com?offset=tiger")

				value, err := responseObject.GetNextOffset()
				Expect(err).NotTo(BeNil())
				Expect(value).To(BeNil())
			})
		})
		Context(`Using mock server endpoint - paginated response`, func() {
			BeforeEach(func() {
				var requestNumber int = 0
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getObjectAccessListDeprecatedPath))
					Expect(req.Method).To(Equal("GET"))

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					requestNumber++
					if requestNumber == 1 {
						fmt.Fprintf(res, "%s", `{"next":"https://myhost.com/somePath?offset=1","total_count":2,"limit":1,"resources":[{"id":"ID","account":"Account","account_type":11,"catalog_id":"CatalogID","target_id":"TargetID","target_account":"TargetAccount","target_kind":"TargetKind","created":"2019-01-01T12:00:00.000Z","approval_state":"ApprovalState","visible_states":["VisibleStates"]}]}`)
					} else if requestNumber == 2 {
						fmt.Fprintf(res, "%s", `{"total_count":2,"limit":1,"resources":[{"id":"ID","account":"Account","account_type":11,"catalog_id":"CatalogID","target_id":"TargetID","target_account":"TargetAccount","target_kind":"TargetKind","created":"2019-01-01T12:00:00.000Z","approval_state":"ApprovalState","visible_states":["VisibleStates"]}]}`)
					} else {
						res.WriteHeader(400)
					}
				}))
			})
			It(`Use GetObjectAccessListDeprecatedPager.GetNext successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				getObjectAccessListDeprecatedOptionsModel := &catalogmanagementv1.GetObjectAccessListDeprecatedOptions{
					CatalogIdentifier: core.StringPtr("testString"),
					ObjectIdentifier:  core.StringPtr("testString"),
					Limit:             core.Int64Ptr(int64(10)),
				}

				pager, err := catalogManagementService.NewGetObjectAccessListDeprecatedPager(getObjectAccessListDeprecatedOptionsModel)
				Expect(err).To(BeNil())
				Expect(pager).ToNot(BeNil())

				var allResults []catalogmanagementv1.Access
				for pager.HasNext() {
					nextPage, err := pager.GetNext()
					Expect(err).To(BeNil())
					Expect(nextPage).ToNot(BeNil())
					allResults = append(allResults, nextPage...)
				}
				Expect(len(allResults)).To(Equal(2))
			})
			It(`Use GetObjectAccessListDeprecatedPager.GetAll successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				getObjectAccessListDeprecatedOptionsModel := &catalogmanagementv1.GetObjectAccessListDeprecatedOptions{
					CatalogIdentifier: core.StringPtr("testString"),
					ObjectIdentifier:  core.StringPtr("testString"),
					Limit:             core.Int64Ptr(int64(10)),
				}

				pager, err := catalogManagementService.NewGetObjectAccessListDeprecatedPager(getObjectAccessListDeprecatedOptionsModel)
				Expect(err).To(BeNil())
				Expect(pager).ToNot(BeNil())

				allResults, err := pager.GetAll()
				Expect(err).To(BeNil())
				Expect(allResults).ToNot(BeNil())
				Expect(len(allResults)).To(Equal(2))
			})
		})
	})
	Describe(`DeleteObjectAccessList(deleteObjectAccessListOptions *DeleteObjectAccessListOptions) - Operation response error`, func() {
		deleteObjectAccessListPath := "/catalogs/testString/objects/testString/access"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deleteObjectAccessListPath))
					Expect(req.Method).To(Equal("DELETE"))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke DeleteObjectAccessList with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the DeleteObjectAccessListOptions model
				deleteObjectAccessListOptionsModel := new(catalogmanagementv1.DeleteObjectAccessListOptions)
				deleteObjectAccessListOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				deleteObjectAccessListOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				deleteObjectAccessListOptionsModel.Accesses = []string{"testString"}
				deleteObjectAccessListOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.DeleteObjectAccessList(deleteObjectAccessListOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.DeleteObjectAccessList(deleteObjectAccessListOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`DeleteObjectAccessList(deleteObjectAccessListOptions *DeleteObjectAccessListOptions)`, func() {
		deleteObjectAccessListPath := "/catalogs/testString/objects/testString/access"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deleteObjectAccessListPath))
					Expect(req.Method).To(Equal("DELETE"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"errors": {"mapKey": "Inner"}}`)
				}))
			})
			It(`Invoke DeleteObjectAccessList successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the DeleteObjectAccessListOptions model
				deleteObjectAccessListOptionsModel := new(catalogmanagementv1.DeleteObjectAccessListOptions)
				deleteObjectAccessListOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				deleteObjectAccessListOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				deleteObjectAccessListOptionsModel.Accesses = []string{"testString"}
				deleteObjectAccessListOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.DeleteObjectAccessListWithContext(ctx, deleteObjectAccessListOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.DeleteObjectAccessList(deleteObjectAccessListOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.DeleteObjectAccessListWithContext(ctx, deleteObjectAccessListOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deleteObjectAccessListPath))
					Expect(req.Method).To(Equal("DELETE"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"errors": {"mapKey": "Inner"}}`)
				}))
			})
			It(`Invoke DeleteObjectAccessList successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.DeleteObjectAccessList(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the DeleteObjectAccessListOptions model
				deleteObjectAccessListOptionsModel := new(catalogmanagementv1.DeleteObjectAccessListOptions)
				deleteObjectAccessListOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				deleteObjectAccessListOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				deleteObjectAccessListOptionsModel.Accesses = []string{"testString"}
				deleteObjectAccessListOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.DeleteObjectAccessList(deleteObjectAccessListOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke DeleteObjectAccessList with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the DeleteObjectAccessListOptions model
				deleteObjectAccessListOptionsModel := new(catalogmanagementv1.DeleteObjectAccessListOptions)
				deleteObjectAccessListOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				deleteObjectAccessListOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				deleteObjectAccessListOptionsModel.Accesses = []string{"testString"}
				deleteObjectAccessListOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.DeleteObjectAccessList(deleteObjectAccessListOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the DeleteObjectAccessListOptions model with no property values
				deleteObjectAccessListOptionsModelNew := new(catalogmanagementv1.DeleteObjectAccessListOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.DeleteObjectAccessList(deleteObjectAccessListOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke DeleteObjectAccessList successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the DeleteObjectAccessListOptions model
				deleteObjectAccessListOptionsModel := new(catalogmanagementv1.DeleteObjectAccessListOptions)
				deleteObjectAccessListOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				deleteObjectAccessListOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				deleteObjectAccessListOptionsModel.Accesses = []string{"testString"}
				deleteObjectAccessListOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.DeleteObjectAccessList(deleteObjectAccessListOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`AddObjectAccessList(addObjectAccessListOptions *AddObjectAccessListOptions) - Operation response error`, func() {
		addObjectAccessListPath := "/catalogs/testString/objects/testString/access"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(addObjectAccessListPath))
					Expect(req.Method).To(Equal("POST"))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke AddObjectAccessList with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the AddObjectAccessListOptions model
				addObjectAccessListOptionsModel := new(catalogmanagementv1.AddObjectAccessListOptions)
				addObjectAccessListOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				addObjectAccessListOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				addObjectAccessListOptionsModel.Accesses = []string{"testString"}
				addObjectAccessListOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.AddObjectAccessList(addObjectAccessListOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.AddObjectAccessList(addObjectAccessListOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`AddObjectAccessList(addObjectAccessListOptions *AddObjectAccessListOptions)`, func() {
		addObjectAccessListPath := "/catalogs/testString/objects/testString/access"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(addObjectAccessListPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"errors": {"mapKey": "Inner"}}`)
				}))
			})
			It(`Invoke AddObjectAccessList successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the AddObjectAccessListOptions model
				addObjectAccessListOptionsModel := new(catalogmanagementv1.AddObjectAccessListOptions)
				addObjectAccessListOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				addObjectAccessListOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				addObjectAccessListOptionsModel.Accesses = []string{"testString"}
				addObjectAccessListOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.AddObjectAccessListWithContext(ctx, addObjectAccessListOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.AddObjectAccessList(addObjectAccessListOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.AddObjectAccessListWithContext(ctx, addObjectAccessListOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(addObjectAccessListPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"errors": {"mapKey": "Inner"}}`)
				}))
			})
			It(`Invoke AddObjectAccessList successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.AddObjectAccessList(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the AddObjectAccessListOptions model
				addObjectAccessListOptionsModel := new(catalogmanagementv1.AddObjectAccessListOptions)
				addObjectAccessListOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				addObjectAccessListOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				addObjectAccessListOptionsModel.Accesses = []string{"testString"}
				addObjectAccessListOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.AddObjectAccessList(addObjectAccessListOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke AddObjectAccessList with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the AddObjectAccessListOptions model
				addObjectAccessListOptionsModel := new(catalogmanagementv1.AddObjectAccessListOptions)
				addObjectAccessListOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				addObjectAccessListOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				addObjectAccessListOptionsModel.Accesses = []string{"testString"}
				addObjectAccessListOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.AddObjectAccessList(addObjectAccessListOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the AddObjectAccessListOptions model with no property values
				addObjectAccessListOptionsModelNew := new(catalogmanagementv1.AddObjectAccessListOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.AddObjectAccessList(addObjectAccessListOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(201)
				}))
			})
			It(`Invoke AddObjectAccessList successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the AddObjectAccessListOptions model
				addObjectAccessListOptionsModel := new(catalogmanagementv1.AddObjectAccessListOptions)
				addObjectAccessListOptionsModel.CatalogIdentifier = core.StringPtr("testString")
				addObjectAccessListOptionsModel.ObjectIdentifier = core.StringPtr("testString")
				addObjectAccessListOptionsModel.Accesses = []string{"testString"}
				addObjectAccessListOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.AddObjectAccessList(addObjectAccessListOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateOfferingInstance(createOfferingInstanceOptions *CreateOfferingInstanceOptions) - Operation response error`, func() {
		createOfferingInstancePath := "/instances/offerings"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createOfferingInstancePath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["X-Auth-Refresh-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Refresh-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke CreateOfferingInstance with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the OfferingInstanceLastOperation model
				offeringInstanceLastOperationModel := new(catalogmanagementv1.OfferingInstanceLastOperation)
				offeringInstanceLastOperationModel.Operation = core.StringPtr("testString")
				offeringInstanceLastOperationModel.State = core.StringPtr("testString")
				offeringInstanceLastOperationModel.Message = core.StringPtr("testString")
				offeringInstanceLastOperationModel.TransactionID = core.StringPtr("testString")
				offeringInstanceLastOperationModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				offeringInstanceLastOperationModel.Code = core.StringPtr("testString")

				// Construct an instance of the CreateOfferingInstanceOptions model
				createOfferingInstanceOptionsModel := new(catalogmanagementv1.CreateOfferingInstanceOptions)
				createOfferingInstanceOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.ID = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Rev = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.URL = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.CRN = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Label = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.CatalogID = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.OfferingID = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.KindFormat = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.KindFormatLabel = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Version = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.VersionID = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.ClusterID = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.ClusterRegion = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.ClusterNamespaces = []string{"testString"}
				createOfferingInstanceOptionsModel.ClusterAllNamespaces = core.BoolPtr(true)
				createOfferingInstanceOptionsModel.SchematicsWorkspaceID = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.InstallPlan = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Channel = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				createOfferingInstanceOptionsModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				createOfferingInstanceOptionsModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				createOfferingInstanceOptionsModel.ResourceGroupID = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Location = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Disabled = core.BoolPtr(true)
				createOfferingInstanceOptionsModel.Account = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.LastOperation = offeringInstanceLastOperationModel
				createOfferingInstanceOptionsModel.KindTarget = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.KindTargetLabel = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Sha = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.PlanID = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.ParentCRN = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.CreateOfferingInstance(createOfferingInstanceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.CreateOfferingInstance(createOfferingInstanceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateOfferingInstance(createOfferingInstanceOptions *CreateOfferingInstanceOptions)`, func() {
		createOfferingInstancePath := "/instances/offerings"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createOfferingInstancePath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["X-Auth-Refresh-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Refresh-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "label": "Label", "catalog_id": "CatalogID", "offering_id": "OfferingID", "kind_format": "KindFormat", "kind_format_label": "KindFormatLabel", "version": "Version", "version_id": "VersionID", "cluster_id": "ClusterID", "cluster_region": "ClusterRegion", "cluster_namespaces": ["ClusterNamespaces"], "cluster_all_namespaces": true, "schematics_workspace_id": "SchematicsWorkspaceID", "install_plan": "InstallPlan", "channel": "Channel", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "metadata": {"anyKey": "anyValue"}, "resource_group_id": "ResourceGroupID", "location": "Location", "disabled": true, "account": "Account", "last_operation": {"operation": "Operation", "state": "State", "message": "Message", "transaction_id": "TransactionID", "updated": "2019-01-01T12:00:00.000Z", "code": "Code"}, "kind_target": "KindTarget", "kind_target_label": "KindTargetLabel", "sha": "Sha", "plan_id": "PlanID", "parent_crn": "ParentCRN"}`)
				}))
			})
			It(`Invoke CreateOfferingInstance successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the OfferingInstanceLastOperation model
				offeringInstanceLastOperationModel := new(catalogmanagementv1.OfferingInstanceLastOperation)
				offeringInstanceLastOperationModel.Operation = core.StringPtr("testString")
				offeringInstanceLastOperationModel.State = core.StringPtr("testString")
				offeringInstanceLastOperationModel.Message = core.StringPtr("testString")
				offeringInstanceLastOperationModel.TransactionID = core.StringPtr("testString")
				offeringInstanceLastOperationModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				offeringInstanceLastOperationModel.Code = core.StringPtr("testString")

				// Construct an instance of the CreateOfferingInstanceOptions model
				createOfferingInstanceOptionsModel := new(catalogmanagementv1.CreateOfferingInstanceOptions)
				createOfferingInstanceOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.ID = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Rev = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.URL = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.CRN = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Label = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.CatalogID = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.OfferingID = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.KindFormat = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.KindFormatLabel = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Version = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.VersionID = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.ClusterID = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.ClusterRegion = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.ClusterNamespaces = []string{"testString"}
				createOfferingInstanceOptionsModel.ClusterAllNamespaces = core.BoolPtr(true)
				createOfferingInstanceOptionsModel.SchematicsWorkspaceID = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.InstallPlan = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Channel = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				createOfferingInstanceOptionsModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				createOfferingInstanceOptionsModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				createOfferingInstanceOptionsModel.ResourceGroupID = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Location = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Disabled = core.BoolPtr(true)
				createOfferingInstanceOptionsModel.Account = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.LastOperation = offeringInstanceLastOperationModel
				createOfferingInstanceOptionsModel.KindTarget = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.KindTargetLabel = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Sha = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.PlanID = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.ParentCRN = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.CreateOfferingInstanceWithContext(ctx, createOfferingInstanceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.CreateOfferingInstance(createOfferingInstanceOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.CreateOfferingInstanceWithContext(ctx, createOfferingInstanceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createOfferingInstancePath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["X-Auth-Refresh-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Refresh-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "label": "Label", "catalog_id": "CatalogID", "offering_id": "OfferingID", "kind_format": "KindFormat", "kind_format_label": "KindFormatLabel", "version": "Version", "version_id": "VersionID", "cluster_id": "ClusterID", "cluster_region": "ClusterRegion", "cluster_namespaces": ["ClusterNamespaces"], "cluster_all_namespaces": true, "schematics_workspace_id": "SchematicsWorkspaceID", "install_plan": "InstallPlan", "channel": "Channel", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "metadata": {"anyKey": "anyValue"}, "resource_group_id": "ResourceGroupID", "location": "Location", "disabled": true, "account": "Account", "last_operation": {"operation": "Operation", "state": "State", "message": "Message", "transaction_id": "TransactionID", "updated": "2019-01-01T12:00:00.000Z", "code": "Code"}, "kind_target": "KindTarget", "kind_target_label": "KindTargetLabel", "sha": "Sha", "plan_id": "PlanID", "parent_crn": "ParentCRN"}`)
				}))
			})
			It(`Invoke CreateOfferingInstance successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.CreateOfferingInstance(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the OfferingInstanceLastOperation model
				offeringInstanceLastOperationModel := new(catalogmanagementv1.OfferingInstanceLastOperation)
				offeringInstanceLastOperationModel.Operation = core.StringPtr("testString")
				offeringInstanceLastOperationModel.State = core.StringPtr("testString")
				offeringInstanceLastOperationModel.Message = core.StringPtr("testString")
				offeringInstanceLastOperationModel.TransactionID = core.StringPtr("testString")
				offeringInstanceLastOperationModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				offeringInstanceLastOperationModel.Code = core.StringPtr("testString")

				// Construct an instance of the CreateOfferingInstanceOptions model
				createOfferingInstanceOptionsModel := new(catalogmanagementv1.CreateOfferingInstanceOptions)
				createOfferingInstanceOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.ID = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Rev = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.URL = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.CRN = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Label = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.CatalogID = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.OfferingID = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.KindFormat = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.KindFormatLabel = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Version = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.VersionID = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.ClusterID = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.ClusterRegion = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.ClusterNamespaces = []string{"testString"}
				createOfferingInstanceOptionsModel.ClusterAllNamespaces = core.BoolPtr(true)
				createOfferingInstanceOptionsModel.SchematicsWorkspaceID = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.InstallPlan = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Channel = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				createOfferingInstanceOptionsModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				createOfferingInstanceOptionsModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				createOfferingInstanceOptionsModel.ResourceGroupID = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Location = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Disabled = core.BoolPtr(true)
				createOfferingInstanceOptionsModel.Account = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.LastOperation = offeringInstanceLastOperationModel
				createOfferingInstanceOptionsModel.KindTarget = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.KindTargetLabel = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Sha = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.PlanID = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.ParentCRN = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.CreateOfferingInstance(createOfferingInstanceOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke CreateOfferingInstance with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the OfferingInstanceLastOperation model
				offeringInstanceLastOperationModel := new(catalogmanagementv1.OfferingInstanceLastOperation)
				offeringInstanceLastOperationModel.Operation = core.StringPtr("testString")
				offeringInstanceLastOperationModel.State = core.StringPtr("testString")
				offeringInstanceLastOperationModel.Message = core.StringPtr("testString")
				offeringInstanceLastOperationModel.TransactionID = core.StringPtr("testString")
				offeringInstanceLastOperationModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				offeringInstanceLastOperationModel.Code = core.StringPtr("testString")

				// Construct an instance of the CreateOfferingInstanceOptions model
				createOfferingInstanceOptionsModel := new(catalogmanagementv1.CreateOfferingInstanceOptions)
				createOfferingInstanceOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.ID = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Rev = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.URL = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.CRN = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Label = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.CatalogID = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.OfferingID = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.KindFormat = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.KindFormatLabel = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Version = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.VersionID = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.ClusterID = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.ClusterRegion = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.ClusterNamespaces = []string{"testString"}
				createOfferingInstanceOptionsModel.ClusterAllNamespaces = core.BoolPtr(true)
				createOfferingInstanceOptionsModel.SchematicsWorkspaceID = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.InstallPlan = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Channel = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				createOfferingInstanceOptionsModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				createOfferingInstanceOptionsModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				createOfferingInstanceOptionsModel.ResourceGroupID = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Location = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Disabled = core.BoolPtr(true)
				createOfferingInstanceOptionsModel.Account = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.LastOperation = offeringInstanceLastOperationModel
				createOfferingInstanceOptionsModel.KindTarget = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.KindTargetLabel = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Sha = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.PlanID = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.ParentCRN = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.CreateOfferingInstance(createOfferingInstanceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the CreateOfferingInstanceOptions model with no property values
				createOfferingInstanceOptionsModelNew := new(catalogmanagementv1.CreateOfferingInstanceOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.CreateOfferingInstance(createOfferingInstanceOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(201)
				}))
			})
			It(`Invoke CreateOfferingInstance successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the OfferingInstanceLastOperation model
				offeringInstanceLastOperationModel := new(catalogmanagementv1.OfferingInstanceLastOperation)
				offeringInstanceLastOperationModel.Operation = core.StringPtr("testString")
				offeringInstanceLastOperationModel.State = core.StringPtr("testString")
				offeringInstanceLastOperationModel.Message = core.StringPtr("testString")
				offeringInstanceLastOperationModel.TransactionID = core.StringPtr("testString")
				offeringInstanceLastOperationModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				offeringInstanceLastOperationModel.Code = core.StringPtr("testString")

				// Construct an instance of the CreateOfferingInstanceOptions model
				createOfferingInstanceOptionsModel := new(catalogmanagementv1.CreateOfferingInstanceOptions)
				createOfferingInstanceOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.ID = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Rev = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.URL = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.CRN = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Label = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.CatalogID = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.OfferingID = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.KindFormat = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.KindFormatLabel = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Version = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.VersionID = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.ClusterID = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.ClusterRegion = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.ClusterNamespaces = []string{"testString"}
				createOfferingInstanceOptionsModel.ClusterAllNamespaces = core.BoolPtr(true)
				createOfferingInstanceOptionsModel.SchematicsWorkspaceID = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.InstallPlan = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Channel = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				createOfferingInstanceOptionsModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				createOfferingInstanceOptionsModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				createOfferingInstanceOptionsModel.ResourceGroupID = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Location = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Disabled = core.BoolPtr(true)
				createOfferingInstanceOptionsModel.Account = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.LastOperation = offeringInstanceLastOperationModel
				createOfferingInstanceOptionsModel.KindTarget = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.KindTargetLabel = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Sha = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.PlanID = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.ParentCRN = core.StringPtr("testString")
				createOfferingInstanceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.CreateOfferingInstance(createOfferingInstanceOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetOfferingInstance(getOfferingInstanceOptions *GetOfferingInstanceOptions) - Operation response error`, func() {
		getOfferingInstancePath := "/instances/offerings/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingInstancePath))
					Expect(req.Method).To(Equal("GET"))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetOfferingInstance with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOfferingInstanceOptions model
				getOfferingInstanceOptionsModel := new(catalogmanagementv1.GetOfferingInstanceOptions)
				getOfferingInstanceOptionsModel.InstanceIdentifier = core.StringPtr("testString")
				getOfferingInstanceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.GetOfferingInstance(getOfferingInstanceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.GetOfferingInstance(getOfferingInstanceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetOfferingInstance(getOfferingInstanceOptions *GetOfferingInstanceOptions)`, func() {
		getOfferingInstancePath := "/instances/offerings/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingInstancePath))
					Expect(req.Method).To(Equal("GET"))

					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "label": "Label", "catalog_id": "CatalogID", "offering_id": "OfferingID", "kind_format": "KindFormat", "kind_format_label": "KindFormatLabel", "version": "Version", "version_id": "VersionID", "cluster_id": "ClusterID", "cluster_region": "ClusterRegion", "cluster_namespaces": ["ClusterNamespaces"], "cluster_all_namespaces": true, "schematics_workspace_id": "SchematicsWorkspaceID", "install_plan": "InstallPlan", "channel": "Channel", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "metadata": {"anyKey": "anyValue"}, "resource_group_id": "ResourceGroupID", "location": "Location", "disabled": true, "account": "Account", "last_operation": {"operation": "Operation", "state": "State", "message": "Message", "transaction_id": "TransactionID", "updated": "2019-01-01T12:00:00.000Z", "code": "Code"}, "kind_target": "KindTarget", "kind_target_label": "KindTargetLabel", "sha": "Sha", "plan_id": "PlanID", "parent_crn": "ParentCRN"}`)
				}))
			})
			It(`Invoke GetOfferingInstance successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the GetOfferingInstanceOptions model
				getOfferingInstanceOptionsModel := new(catalogmanagementv1.GetOfferingInstanceOptions)
				getOfferingInstanceOptionsModel.InstanceIdentifier = core.StringPtr("testString")
				getOfferingInstanceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.GetOfferingInstanceWithContext(ctx, getOfferingInstanceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.GetOfferingInstance(getOfferingInstanceOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.GetOfferingInstanceWithContext(ctx, getOfferingInstanceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingInstancePath))
					Expect(req.Method).To(Equal("GET"))

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "label": "Label", "catalog_id": "CatalogID", "offering_id": "OfferingID", "kind_format": "KindFormat", "kind_format_label": "KindFormatLabel", "version": "Version", "version_id": "VersionID", "cluster_id": "ClusterID", "cluster_region": "ClusterRegion", "cluster_namespaces": ["ClusterNamespaces"], "cluster_all_namespaces": true, "schematics_workspace_id": "SchematicsWorkspaceID", "install_plan": "InstallPlan", "channel": "Channel", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "metadata": {"anyKey": "anyValue"}, "resource_group_id": "ResourceGroupID", "location": "Location", "disabled": true, "account": "Account", "last_operation": {"operation": "Operation", "state": "State", "message": "Message", "transaction_id": "TransactionID", "updated": "2019-01-01T12:00:00.000Z", "code": "Code"}, "kind_target": "KindTarget", "kind_target_label": "KindTargetLabel", "sha": "Sha", "plan_id": "PlanID", "parent_crn": "ParentCRN"}`)
				}))
			})
			It(`Invoke GetOfferingInstance successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.GetOfferingInstance(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetOfferingInstanceOptions model
				getOfferingInstanceOptionsModel := new(catalogmanagementv1.GetOfferingInstanceOptions)
				getOfferingInstanceOptionsModel.InstanceIdentifier = core.StringPtr("testString")
				getOfferingInstanceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.GetOfferingInstance(getOfferingInstanceOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetOfferingInstance with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOfferingInstanceOptions model
				getOfferingInstanceOptionsModel := new(catalogmanagementv1.GetOfferingInstanceOptions)
				getOfferingInstanceOptionsModel.InstanceIdentifier = core.StringPtr("testString")
				getOfferingInstanceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.GetOfferingInstance(getOfferingInstanceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetOfferingInstanceOptions model with no property values
				getOfferingInstanceOptionsModelNew := new(catalogmanagementv1.GetOfferingInstanceOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.GetOfferingInstance(getOfferingInstanceOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetOfferingInstance successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOfferingInstanceOptions model
				getOfferingInstanceOptionsModel := new(catalogmanagementv1.GetOfferingInstanceOptions)
				getOfferingInstanceOptionsModel.InstanceIdentifier = core.StringPtr("testString")
				getOfferingInstanceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.GetOfferingInstance(getOfferingInstanceOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`PutOfferingInstance(putOfferingInstanceOptions *PutOfferingInstanceOptions) - Operation response error`, func() {
		putOfferingInstancePath := "/instances/offerings/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(putOfferingInstancePath))
					Expect(req.Method).To(Equal("PUT"))
					Expect(req.Header["X-Auth-Refresh-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Refresh-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke PutOfferingInstance with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the OfferingInstanceLastOperation model
				offeringInstanceLastOperationModel := new(catalogmanagementv1.OfferingInstanceLastOperation)
				offeringInstanceLastOperationModel.Operation = core.StringPtr("testString")
				offeringInstanceLastOperationModel.State = core.StringPtr("testString")
				offeringInstanceLastOperationModel.Message = core.StringPtr("testString")
				offeringInstanceLastOperationModel.TransactionID = core.StringPtr("testString")
				offeringInstanceLastOperationModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				offeringInstanceLastOperationModel.Code = core.StringPtr("testString")

				// Construct an instance of the PutOfferingInstanceOptions model
				putOfferingInstanceOptionsModel := new(catalogmanagementv1.PutOfferingInstanceOptions)
				putOfferingInstanceOptionsModel.InstanceIdentifier = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.ID = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Rev = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.URL = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.CRN = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Label = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.CatalogID = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.OfferingID = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.KindFormat = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.KindFormatLabel = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Version = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.VersionID = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.ClusterID = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.ClusterRegion = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.ClusterNamespaces = []string{"testString"}
				putOfferingInstanceOptionsModel.ClusterAllNamespaces = core.BoolPtr(true)
				putOfferingInstanceOptionsModel.SchematicsWorkspaceID = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.InstallPlan = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Channel = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				putOfferingInstanceOptionsModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				putOfferingInstanceOptionsModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				putOfferingInstanceOptionsModel.ResourceGroupID = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Location = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Disabled = core.BoolPtr(true)
				putOfferingInstanceOptionsModel.Account = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.LastOperation = offeringInstanceLastOperationModel
				putOfferingInstanceOptionsModel.KindTarget = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.KindTargetLabel = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Sha = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.PlanID = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.ParentCRN = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.PutOfferingInstance(putOfferingInstanceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.PutOfferingInstance(putOfferingInstanceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`PutOfferingInstance(putOfferingInstanceOptions *PutOfferingInstanceOptions)`, func() {
		putOfferingInstancePath := "/instances/offerings/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(putOfferingInstancePath))
					Expect(req.Method).To(Equal("PUT"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["X-Auth-Refresh-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Refresh-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "label": "Label", "catalog_id": "CatalogID", "offering_id": "OfferingID", "kind_format": "KindFormat", "kind_format_label": "KindFormatLabel", "version": "Version", "version_id": "VersionID", "cluster_id": "ClusterID", "cluster_region": "ClusterRegion", "cluster_namespaces": ["ClusterNamespaces"], "cluster_all_namespaces": true, "schematics_workspace_id": "SchematicsWorkspaceID", "install_plan": "InstallPlan", "channel": "Channel", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "metadata": {"anyKey": "anyValue"}, "resource_group_id": "ResourceGroupID", "location": "Location", "disabled": true, "account": "Account", "last_operation": {"operation": "Operation", "state": "State", "message": "Message", "transaction_id": "TransactionID", "updated": "2019-01-01T12:00:00.000Z", "code": "Code"}, "kind_target": "KindTarget", "kind_target_label": "KindTargetLabel", "sha": "Sha", "plan_id": "PlanID", "parent_crn": "ParentCRN"}`)
				}))
			})
			It(`Invoke PutOfferingInstance successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the OfferingInstanceLastOperation model
				offeringInstanceLastOperationModel := new(catalogmanagementv1.OfferingInstanceLastOperation)
				offeringInstanceLastOperationModel.Operation = core.StringPtr("testString")
				offeringInstanceLastOperationModel.State = core.StringPtr("testString")
				offeringInstanceLastOperationModel.Message = core.StringPtr("testString")
				offeringInstanceLastOperationModel.TransactionID = core.StringPtr("testString")
				offeringInstanceLastOperationModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				offeringInstanceLastOperationModel.Code = core.StringPtr("testString")

				// Construct an instance of the PutOfferingInstanceOptions model
				putOfferingInstanceOptionsModel := new(catalogmanagementv1.PutOfferingInstanceOptions)
				putOfferingInstanceOptionsModel.InstanceIdentifier = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.ID = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Rev = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.URL = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.CRN = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Label = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.CatalogID = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.OfferingID = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.KindFormat = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.KindFormatLabel = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Version = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.VersionID = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.ClusterID = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.ClusterRegion = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.ClusterNamespaces = []string{"testString"}
				putOfferingInstanceOptionsModel.ClusterAllNamespaces = core.BoolPtr(true)
				putOfferingInstanceOptionsModel.SchematicsWorkspaceID = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.InstallPlan = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Channel = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				putOfferingInstanceOptionsModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				putOfferingInstanceOptionsModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				putOfferingInstanceOptionsModel.ResourceGroupID = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Location = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Disabled = core.BoolPtr(true)
				putOfferingInstanceOptionsModel.Account = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.LastOperation = offeringInstanceLastOperationModel
				putOfferingInstanceOptionsModel.KindTarget = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.KindTargetLabel = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Sha = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.PlanID = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.ParentCRN = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.PutOfferingInstanceWithContext(ctx, putOfferingInstanceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.PutOfferingInstance(putOfferingInstanceOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.PutOfferingInstanceWithContext(ctx, putOfferingInstanceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(putOfferingInstancePath))
					Expect(req.Method).To(Equal("PUT"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["X-Auth-Refresh-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Refresh-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "label": "Label", "catalog_id": "CatalogID", "offering_id": "OfferingID", "kind_format": "KindFormat", "kind_format_label": "KindFormatLabel", "version": "Version", "version_id": "VersionID", "cluster_id": "ClusterID", "cluster_region": "ClusterRegion", "cluster_namespaces": ["ClusterNamespaces"], "cluster_all_namespaces": true, "schematics_workspace_id": "SchematicsWorkspaceID", "install_plan": "InstallPlan", "channel": "Channel", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "metadata": {"anyKey": "anyValue"}, "resource_group_id": "ResourceGroupID", "location": "Location", "disabled": true, "account": "Account", "last_operation": {"operation": "Operation", "state": "State", "message": "Message", "transaction_id": "TransactionID", "updated": "2019-01-01T12:00:00.000Z", "code": "Code"}, "kind_target": "KindTarget", "kind_target_label": "KindTargetLabel", "sha": "Sha", "plan_id": "PlanID", "parent_crn": "ParentCRN"}`)
				}))
			})
			It(`Invoke PutOfferingInstance successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.PutOfferingInstance(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the OfferingInstanceLastOperation model
				offeringInstanceLastOperationModel := new(catalogmanagementv1.OfferingInstanceLastOperation)
				offeringInstanceLastOperationModel.Operation = core.StringPtr("testString")
				offeringInstanceLastOperationModel.State = core.StringPtr("testString")
				offeringInstanceLastOperationModel.Message = core.StringPtr("testString")
				offeringInstanceLastOperationModel.TransactionID = core.StringPtr("testString")
				offeringInstanceLastOperationModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				offeringInstanceLastOperationModel.Code = core.StringPtr("testString")

				// Construct an instance of the PutOfferingInstanceOptions model
				putOfferingInstanceOptionsModel := new(catalogmanagementv1.PutOfferingInstanceOptions)
				putOfferingInstanceOptionsModel.InstanceIdentifier = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.ID = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Rev = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.URL = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.CRN = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Label = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.CatalogID = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.OfferingID = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.KindFormat = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.KindFormatLabel = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Version = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.VersionID = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.ClusterID = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.ClusterRegion = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.ClusterNamespaces = []string{"testString"}
				putOfferingInstanceOptionsModel.ClusterAllNamespaces = core.BoolPtr(true)
				putOfferingInstanceOptionsModel.SchematicsWorkspaceID = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.InstallPlan = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Channel = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				putOfferingInstanceOptionsModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				putOfferingInstanceOptionsModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				putOfferingInstanceOptionsModel.ResourceGroupID = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Location = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Disabled = core.BoolPtr(true)
				putOfferingInstanceOptionsModel.Account = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.LastOperation = offeringInstanceLastOperationModel
				putOfferingInstanceOptionsModel.KindTarget = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.KindTargetLabel = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Sha = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.PlanID = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.ParentCRN = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.PutOfferingInstance(putOfferingInstanceOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke PutOfferingInstance with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the OfferingInstanceLastOperation model
				offeringInstanceLastOperationModel := new(catalogmanagementv1.OfferingInstanceLastOperation)
				offeringInstanceLastOperationModel.Operation = core.StringPtr("testString")
				offeringInstanceLastOperationModel.State = core.StringPtr("testString")
				offeringInstanceLastOperationModel.Message = core.StringPtr("testString")
				offeringInstanceLastOperationModel.TransactionID = core.StringPtr("testString")
				offeringInstanceLastOperationModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				offeringInstanceLastOperationModel.Code = core.StringPtr("testString")

				// Construct an instance of the PutOfferingInstanceOptions model
				putOfferingInstanceOptionsModel := new(catalogmanagementv1.PutOfferingInstanceOptions)
				putOfferingInstanceOptionsModel.InstanceIdentifier = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.ID = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Rev = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.URL = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.CRN = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Label = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.CatalogID = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.OfferingID = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.KindFormat = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.KindFormatLabel = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Version = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.VersionID = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.ClusterID = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.ClusterRegion = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.ClusterNamespaces = []string{"testString"}
				putOfferingInstanceOptionsModel.ClusterAllNamespaces = core.BoolPtr(true)
				putOfferingInstanceOptionsModel.SchematicsWorkspaceID = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.InstallPlan = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Channel = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				putOfferingInstanceOptionsModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				putOfferingInstanceOptionsModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				putOfferingInstanceOptionsModel.ResourceGroupID = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Location = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Disabled = core.BoolPtr(true)
				putOfferingInstanceOptionsModel.Account = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.LastOperation = offeringInstanceLastOperationModel
				putOfferingInstanceOptionsModel.KindTarget = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.KindTargetLabel = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Sha = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.PlanID = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.ParentCRN = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.PutOfferingInstance(putOfferingInstanceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the PutOfferingInstanceOptions model with no property values
				putOfferingInstanceOptionsModelNew := new(catalogmanagementv1.PutOfferingInstanceOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.PutOfferingInstance(putOfferingInstanceOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke PutOfferingInstance successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the OfferingInstanceLastOperation model
				offeringInstanceLastOperationModel := new(catalogmanagementv1.OfferingInstanceLastOperation)
				offeringInstanceLastOperationModel.Operation = core.StringPtr("testString")
				offeringInstanceLastOperationModel.State = core.StringPtr("testString")
				offeringInstanceLastOperationModel.Message = core.StringPtr("testString")
				offeringInstanceLastOperationModel.TransactionID = core.StringPtr("testString")
				offeringInstanceLastOperationModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				offeringInstanceLastOperationModel.Code = core.StringPtr("testString")

				// Construct an instance of the PutOfferingInstanceOptions model
				putOfferingInstanceOptionsModel := new(catalogmanagementv1.PutOfferingInstanceOptions)
				putOfferingInstanceOptionsModel.InstanceIdentifier = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.ID = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Rev = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.URL = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.CRN = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Label = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.CatalogID = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.OfferingID = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.KindFormat = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.KindFormatLabel = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Version = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.VersionID = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.ClusterID = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.ClusterRegion = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.ClusterNamespaces = []string{"testString"}
				putOfferingInstanceOptionsModel.ClusterAllNamespaces = core.BoolPtr(true)
				putOfferingInstanceOptionsModel.SchematicsWorkspaceID = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.InstallPlan = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Channel = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				putOfferingInstanceOptionsModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				putOfferingInstanceOptionsModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				putOfferingInstanceOptionsModel.ResourceGroupID = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Location = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Disabled = core.BoolPtr(true)
				putOfferingInstanceOptionsModel.Account = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.LastOperation = offeringInstanceLastOperationModel
				putOfferingInstanceOptionsModel.KindTarget = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.KindTargetLabel = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Sha = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.PlanID = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.ParentCRN = core.StringPtr("testString")
				putOfferingInstanceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.PutOfferingInstance(putOfferingInstanceOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`DeleteOfferingInstance(deleteOfferingInstanceOptions *DeleteOfferingInstanceOptions)`, func() {
		deleteOfferingInstancePath := "/instances/offerings/testString"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deleteOfferingInstancePath))
					Expect(req.Method).To(Equal("DELETE"))

					Expect(req.Header["X-Auth-Refresh-Token"]).ToNot(BeNil())
					Expect(req.Header["X-Auth-Refresh-Token"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.WriteHeader(200)
				}))
			})
			It(`Invoke DeleteOfferingInstance successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := catalogManagementService.DeleteOfferingInstance(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the DeleteOfferingInstanceOptions model
				deleteOfferingInstanceOptionsModel := new(catalogmanagementv1.DeleteOfferingInstanceOptions)
				deleteOfferingInstanceOptionsModel.InstanceIdentifier = core.StringPtr("testString")
				deleteOfferingInstanceOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				deleteOfferingInstanceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = catalogManagementService.DeleteOfferingInstance(deleteOfferingInstanceOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke DeleteOfferingInstance with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the DeleteOfferingInstanceOptions model
				deleteOfferingInstanceOptionsModel := new(catalogmanagementv1.DeleteOfferingInstanceOptions)
				deleteOfferingInstanceOptionsModel.InstanceIdentifier = core.StringPtr("testString")
				deleteOfferingInstanceOptionsModel.XAuthRefreshToken = core.StringPtr("testString")
				deleteOfferingInstanceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := catalogManagementService.DeleteOfferingInstance(deleteOfferingInstanceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the DeleteOfferingInstanceOptions model with no property values
				deleteOfferingInstanceOptionsModelNew := new(catalogmanagementv1.DeleteOfferingInstanceOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = catalogManagementService.DeleteOfferingInstance(deleteOfferingInstanceOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListOfferingInstanceAudits(listOfferingInstanceAuditsOptions *ListOfferingInstanceAuditsOptions) - Operation response error`, func() {
		listOfferingInstanceAuditsPath := "/instances/offerings/testString/audits"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listOfferingInstanceAuditsPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.URL.Query()["start"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(10))}))
					// TODO: Add check for lookupnames query parameter
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ListOfferingInstanceAudits with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ListOfferingInstanceAuditsOptions model
				listOfferingInstanceAuditsOptionsModel := new(catalogmanagementv1.ListOfferingInstanceAuditsOptions)
				listOfferingInstanceAuditsOptionsModel.InstanceIdentifier = core.StringPtr("testString")
				listOfferingInstanceAuditsOptionsModel.Start = core.StringPtr("testString")
				listOfferingInstanceAuditsOptionsModel.Limit = core.Int64Ptr(int64(10))
				listOfferingInstanceAuditsOptionsModel.Lookupnames = core.BoolPtr(true)
				listOfferingInstanceAuditsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.ListOfferingInstanceAudits(listOfferingInstanceAuditsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.ListOfferingInstanceAudits(listOfferingInstanceAuditsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListOfferingInstanceAudits(listOfferingInstanceAuditsOptions *ListOfferingInstanceAuditsOptions)`, func() {
		listOfferingInstanceAuditsPath := "/instances/offerings/testString/audits"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listOfferingInstanceAuditsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.URL.Query()["start"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(10))}))
					// TODO: Add check for lookupnames query parameter
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"start": "Start", "limit": 5, "total_count": 10, "resource_count": 13, "first": {"href": "Href", "start": "Start"}, "next": {"href": "Href", "start": "Start"}, "prev": {"href": "Href", "start": "Start"}, "last": {"href": "Href", "start": "Start"}, "audits": [{"id": "ID", "_rev": "Rev", "created": "2019-01-01T12:00:00.000Z", "change_type": "ChangeType", "target_type": "TargetType", "target_id": "TargetID", "who_email": "WhoEmail", "who_delegate_email": "WhoDelegateEmail", "message": "Message"}]}`)
				}))
			})
			It(`Invoke ListOfferingInstanceAudits successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the ListOfferingInstanceAuditsOptions model
				listOfferingInstanceAuditsOptionsModel := new(catalogmanagementv1.ListOfferingInstanceAuditsOptions)
				listOfferingInstanceAuditsOptionsModel.InstanceIdentifier = core.StringPtr("testString")
				listOfferingInstanceAuditsOptionsModel.Start = core.StringPtr("testString")
				listOfferingInstanceAuditsOptionsModel.Limit = core.Int64Ptr(int64(10))
				listOfferingInstanceAuditsOptionsModel.Lookupnames = core.BoolPtr(true)
				listOfferingInstanceAuditsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.ListOfferingInstanceAuditsWithContext(ctx, listOfferingInstanceAuditsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.ListOfferingInstanceAudits(listOfferingInstanceAuditsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.ListOfferingInstanceAuditsWithContext(ctx, listOfferingInstanceAuditsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listOfferingInstanceAuditsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.URL.Query()["start"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(10))}))
					// TODO: Add check for lookupnames query parameter
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"start": "Start", "limit": 5, "total_count": 10, "resource_count": 13, "first": {"href": "Href", "start": "Start"}, "next": {"href": "Href", "start": "Start"}, "prev": {"href": "Href", "start": "Start"}, "last": {"href": "Href", "start": "Start"}, "audits": [{"id": "ID", "_rev": "Rev", "created": "2019-01-01T12:00:00.000Z", "change_type": "ChangeType", "target_type": "TargetType", "target_id": "TargetID", "who_email": "WhoEmail", "who_delegate_email": "WhoDelegateEmail", "message": "Message"}]}`)
				}))
			})
			It(`Invoke ListOfferingInstanceAudits successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.ListOfferingInstanceAudits(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ListOfferingInstanceAuditsOptions model
				listOfferingInstanceAuditsOptionsModel := new(catalogmanagementv1.ListOfferingInstanceAuditsOptions)
				listOfferingInstanceAuditsOptionsModel.InstanceIdentifier = core.StringPtr("testString")
				listOfferingInstanceAuditsOptionsModel.Start = core.StringPtr("testString")
				listOfferingInstanceAuditsOptionsModel.Limit = core.Int64Ptr(int64(10))
				listOfferingInstanceAuditsOptionsModel.Lookupnames = core.BoolPtr(true)
				listOfferingInstanceAuditsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.ListOfferingInstanceAudits(listOfferingInstanceAuditsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ListOfferingInstanceAudits with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ListOfferingInstanceAuditsOptions model
				listOfferingInstanceAuditsOptionsModel := new(catalogmanagementv1.ListOfferingInstanceAuditsOptions)
				listOfferingInstanceAuditsOptionsModel.InstanceIdentifier = core.StringPtr("testString")
				listOfferingInstanceAuditsOptionsModel.Start = core.StringPtr("testString")
				listOfferingInstanceAuditsOptionsModel.Limit = core.Int64Ptr(int64(10))
				listOfferingInstanceAuditsOptionsModel.Lookupnames = core.BoolPtr(true)
				listOfferingInstanceAuditsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.ListOfferingInstanceAudits(listOfferingInstanceAuditsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the ListOfferingInstanceAuditsOptions model with no property values
				listOfferingInstanceAuditsOptionsModelNew := new(catalogmanagementv1.ListOfferingInstanceAuditsOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.ListOfferingInstanceAudits(listOfferingInstanceAuditsOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ListOfferingInstanceAudits successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ListOfferingInstanceAuditsOptions model
				listOfferingInstanceAuditsOptionsModel := new(catalogmanagementv1.ListOfferingInstanceAuditsOptions)
				listOfferingInstanceAuditsOptionsModel.InstanceIdentifier = core.StringPtr("testString")
				listOfferingInstanceAuditsOptionsModel.Start = core.StringPtr("testString")
				listOfferingInstanceAuditsOptionsModel.Limit = core.Int64Ptr(int64(10))
				listOfferingInstanceAuditsOptionsModel.Lookupnames = core.BoolPtr(true)
				listOfferingInstanceAuditsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.ListOfferingInstanceAudits(listOfferingInstanceAuditsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Test pagination helper method on response`, func() {
			It(`Invoke GetNextStart successfully`, func() {
				responseObject := new(catalogmanagementv1.AuditLogs)
				nextObject := new(catalogmanagementv1.PaginationTokenLink)
				nextObject.Start = core.StringPtr("abc-123")
				responseObject.Next = nextObject

				value, err := responseObject.GetNextStart()
				Expect(err).To(BeNil())
				Expect(value).To(Equal(core.StringPtr("abc-123")))
			})
			It(`Invoke GetNextStart without a "Next" property in the response`, func() {
				responseObject := new(catalogmanagementv1.AuditLogs)

				value, err := responseObject.GetNextStart()
				Expect(err).To(BeNil())
				Expect(value).To(BeNil())
			})
		})
		Context(`Using mock server endpoint - paginated response`, func() {
			BeforeEach(func() {
				var requestNumber int = 0
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listOfferingInstanceAuditsPath))
					Expect(req.Method).To(Equal("GET"))

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					requestNumber++
					if requestNumber == 1 {
						fmt.Fprintf(res, "%s", `{"next":{"start":"1"},"total_count":2,"limit":1,"audits":[{"id":"ID","_rev":"Rev","created":"2019-01-01T12:00:00.000Z","change_type":"ChangeType","target_type":"TargetType","target_id":"TargetID","who_email":"WhoEmail","who_delegate_email":"WhoDelegateEmail","message":"Message"}]}`)
					} else if requestNumber == 2 {
						fmt.Fprintf(res, "%s", `{"total_count":2,"limit":1,"audits":[{"id":"ID","_rev":"Rev","created":"2019-01-01T12:00:00.000Z","change_type":"ChangeType","target_type":"TargetType","target_id":"TargetID","who_email":"WhoEmail","who_delegate_email":"WhoDelegateEmail","message":"Message"}]}`)
					} else {
						res.WriteHeader(400)
					}
				}))
			})
			It(`Use OfferingInstanceAuditsPager.GetNext successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				listOfferingInstanceAuditsOptionsModel := &catalogmanagementv1.ListOfferingInstanceAuditsOptions{
					InstanceIdentifier: core.StringPtr("testString"),
					Limit:              core.Int64Ptr(int64(10)),
					Lookupnames:        core.BoolPtr(true),
				}

				pager, err := catalogManagementService.NewOfferingInstanceAuditsPager(listOfferingInstanceAuditsOptionsModel)
				Expect(err).To(BeNil())
				Expect(pager).ToNot(BeNil())

				var allResults []catalogmanagementv1.AuditLogDigest
				for pager.HasNext() {
					nextPage, err := pager.GetNext()
					Expect(err).To(BeNil())
					Expect(nextPage).ToNot(BeNil())
					allResults = append(allResults, nextPage...)
				}
				Expect(len(allResults)).To(Equal(2))
			})
			It(`Use OfferingInstanceAuditsPager.GetAll successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				listOfferingInstanceAuditsOptionsModel := &catalogmanagementv1.ListOfferingInstanceAuditsOptions{
					InstanceIdentifier: core.StringPtr("testString"),
					Limit:              core.Int64Ptr(int64(10)),
					Lookupnames:        core.BoolPtr(true),
				}

				pager, err := catalogManagementService.NewOfferingInstanceAuditsPager(listOfferingInstanceAuditsOptionsModel)
				Expect(err).To(BeNil())
				Expect(pager).ToNot(BeNil())

				allResults, err := pager.GetAll()
				Expect(err).To(BeNil())
				Expect(allResults).ToNot(BeNil())
				Expect(len(allResults)).To(Equal(2))
			})
		})
	})
	Describe(`GetOfferingInstanceAudit(getOfferingInstanceAuditOptions *GetOfferingInstanceAuditOptions) - Operation response error`, func() {
		getOfferingInstanceAuditPath := "/instances/offerings/testString/audits/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingInstanceAuditPath))
					Expect(req.Method).To(Equal("GET"))
					// TODO: Add check for lookupnames query parameter
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetOfferingInstanceAudit with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOfferingInstanceAuditOptions model
				getOfferingInstanceAuditOptionsModel := new(catalogmanagementv1.GetOfferingInstanceAuditOptions)
				getOfferingInstanceAuditOptionsModel.InstanceIdentifier = core.StringPtr("testString")
				getOfferingInstanceAuditOptionsModel.AuditlogIdentifier = core.StringPtr("testString")
				getOfferingInstanceAuditOptionsModel.Lookupnames = core.BoolPtr(true)
				getOfferingInstanceAuditOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.GetOfferingInstanceAudit(getOfferingInstanceAuditOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.GetOfferingInstanceAudit(getOfferingInstanceAuditOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetOfferingInstanceAudit(getOfferingInstanceAuditOptions *GetOfferingInstanceAuditOptions)`, func() {
		getOfferingInstanceAuditPath := "/instances/offerings/testString/audits/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingInstanceAuditPath))
					Expect(req.Method).To(Equal("GET"))

					// TODO: Add check for lookupnames query parameter
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "created": "2019-01-01T12:00:00.000Z", "change_type": "ChangeType", "target_type": "TargetType", "target_id": "TargetID", "who_email": "WhoEmail", "who_delegate_email": "WhoDelegateEmail", "message": "Message", "gid": "Gid", "who_id": "WhoID", "who_name": "WhoName", "who_delegate_id": "WhoDelegateID", "who_delegate_name": "WhoDelegateName", "data": "anyValue"}`)
				}))
			})
			It(`Invoke GetOfferingInstanceAudit successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the GetOfferingInstanceAuditOptions model
				getOfferingInstanceAuditOptionsModel := new(catalogmanagementv1.GetOfferingInstanceAuditOptions)
				getOfferingInstanceAuditOptionsModel.InstanceIdentifier = core.StringPtr("testString")
				getOfferingInstanceAuditOptionsModel.AuditlogIdentifier = core.StringPtr("testString")
				getOfferingInstanceAuditOptionsModel.Lookupnames = core.BoolPtr(true)
				getOfferingInstanceAuditOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.GetOfferingInstanceAuditWithContext(ctx, getOfferingInstanceAuditOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.GetOfferingInstanceAudit(getOfferingInstanceAuditOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.GetOfferingInstanceAuditWithContext(ctx, getOfferingInstanceAuditOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getOfferingInstanceAuditPath))
					Expect(req.Method).To(Equal("GET"))

					// TODO: Add check for lookupnames query parameter
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "created": "2019-01-01T12:00:00.000Z", "change_type": "ChangeType", "target_type": "TargetType", "target_id": "TargetID", "who_email": "WhoEmail", "who_delegate_email": "WhoDelegateEmail", "message": "Message", "gid": "Gid", "who_id": "WhoID", "who_name": "WhoName", "who_delegate_id": "WhoDelegateID", "who_delegate_name": "WhoDelegateName", "data": "anyValue"}`)
				}))
			})
			It(`Invoke GetOfferingInstanceAudit successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.GetOfferingInstanceAudit(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetOfferingInstanceAuditOptions model
				getOfferingInstanceAuditOptionsModel := new(catalogmanagementv1.GetOfferingInstanceAuditOptions)
				getOfferingInstanceAuditOptionsModel.InstanceIdentifier = core.StringPtr("testString")
				getOfferingInstanceAuditOptionsModel.AuditlogIdentifier = core.StringPtr("testString")
				getOfferingInstanceAuditOptionsModel.Lookupnames = core.BoolPtr(true)
				getOfferingInstanceAuditOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.GetOfferingInstanceAudit(getOfferingInstanceAuditOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetOfferingInstanceAudit with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOfferingInstanceAuditOptions model
				getOfferingInstanceAuditOptionsModel := new(catalogmanagementv1.GetOfferingInstanceAuditOptions)
				getOfferingInstanceAuditOptionsModel.InstanceIdentifier = core.StringPtr("testString")
				getOfferingInstanceAuditOptionsModel.AuditlogIdentifier = core.StringPtr("testString")
				getOfferingInstanceAuditOptionsModel.Lookupnames = core.BoolPtr(true)
				getOfferingInstanceAuditOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.GetOfferingInstanceAudit(getOfferingInstanceAuditOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetOfferingInstanceAuditOptions model with no property values
				getOfferingInstanceAuditOptionsModelNew := new(catalogmanagementv1.GetOfferingInstanceAuditOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.GetOfferingInstanceAudit(getOfferingInstanceAuditOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetOfferingInstanceAudit successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetOfferingInstanceAuditOptions model
				getOfferingInstanceAuditOptionsModel := new(catalogmanagementv1.GetOfferingInstanceAuditOptions)
				getOfferingInstanceAuditOptionsModel.InstanceIdentifier = core.StringPtr("testString")
				getOfferingInstanceAuditOptionsModel.AuditlogIdentifier = core.StringPtr("testString")
				getOfferingInstanceAuditOptionsModel.Lookupnames = core.BoolPtr(true)
				getOfferingInstanceAuditOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.GetOfferingInstanceAudit(getOfferingInstanceAuditOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetPlan(getPlanOptions *GetPlanOptions) - Operation response error`, func() {
		getPlanPath := "/plans/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getPlanPath))
					Expect(req.Method).To(Equal("GET"))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetPlan with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetPlanOptions model
				getPlanOptionsModel := new(catalogmanagementv1.GetPlanOptions)
				getPlanOptionsModel.PlanLocID = core.StringPtr("testString")
				getPlanOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.GetPlan(getPlanOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.GetPlan(getPlanOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetPlan(getPlanOptions *GetPlanOptions)`, func() {
		getPlanPath := "/plans/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getPlanPath))
					Expect(req.Method).To(Equal("GET"))

					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "name": "Name", "offering_icon_url": "OfferingIconURL", "offering_docs_url": "OfferingDocsURL", "offering_support_url": "OfferingSupportURL", "tags": ["Tags"], "keywords": ["Keywords"], "rating": {"one_star_count": 12, "two_star_count": 12, "three_star_count": 14, "four_star_count": 13}, "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "kinds": [{"id": "ID", "format_kind": "FormatKind", "format_kind_label": "FormatKindLabel", "install_kind": "InstallKind", "install_kind_label": "InstallKindLabel", "target_kind": "TargetKind", "target_kind_label": "TargetKindLabel", "metadata": {"anyKey": "anyValue"}, "tags": ["Tags"], "additional_features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "versions": [{"id": "ID", "_rev": "Rev", "crn": "CRN", "version": "Version", "flavor": {"name": "Name", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "index": 5}, "sha": "Sha", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "offering_id": "OfferingID", "catalog_id": "CatalogID", "kind_id": "KindID", "tags": ["Tags"], "repo_url": "RepoURL", "source_url": "SourceURL", "tgz_url": "TgzURL", "configuration": [{"key": "Key", "type": "Type", "default_value": "anyValue", "display_name": "DisplayName", "value_constraint": "ValueConstraint", "description": "Description", "required": true, "options": ["anyValue"], "hidden": true, "custom_config": {"type": "Type", "grouping": "Grouping", "original_grouping": "OriginalGrouping", "grouping_index": 13, "config_constraints": {"anyKey": "anyValue"}, "associations": {"parameters": [{"name": "Name", "optionsRefresh": true}]}}, "type_metadata": "TypeMetadata"}], "outputs": [{"key": "Key", "description": "Description"}], "iam_permissions": [{"service_name": "ServiceName", "role_crns": ["RoleCrns"], "resources": [{"name": "Name", "description": "Description", "role_crns": ["RoleCrns"]}]}], "metadata": {"anyKey": "anyValue"}, "validation": {"validated": "2019-01-01T12:00:00.000Z", "requested": "2019-01-01T12:00:00.000Z", "state": "State", "last_operation": "LastOperation", "target": {"anyKey": "anyValue"}, "message": "Message"}, "required_resources": [{"type": "mem", "value": "anyValue"}], "single_instance": true, "schematics_env_values": {"value": "[{\"name\": \"TF_LOG\",\"value\": \"TRACE\",\"secure\": false,\"hidden\": false}]", "sm_ref": "cmsm_v1:{\"name\": \"envVarSecret\",\"id\":\"1234567890\",\"service_id\":\"crn:v1:bluemix:public:secrets-manager:eu-gb:a/1234567890:1234567890::\",\"service_name\":\"My SM Instance\",\"group_id\":\"1234567890\",\"group_name\":\"My SM Group\",\"resource_group_id\":\"1234567890\",\"region\":\"eu-gb\",\"type\":\"arbitrary\"}"}, "install": {"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}, "pre_install": [{"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}], "scripts": {"mapKey": {"short_description": "ShortDescription", "type": "ansible", "path": "scripts/validate-post-ansible-playbook.yaml", "stage": "pre", "action": "validate"}}, "entitlement": {"provider_name": "ProviderName", "provider_id": "ProviderID", "product_id": "ProductID", "part_numbers": ["PartNumbers"], "image_repo_name": "ImageRepoName"}, "licenses": [{"id": "ID", "name": "Name", "type": "Type", "url": "URL", "description": "Description"}], "image_manifest_url": "ImageManifestURL", "deprecated": true, "package_version": "PackageVersion", "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "version_locator": "VersionLocator", "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "whitelisted_accounts": ["WhitelistedAccounts"], "image_pull_key_name": "ImagePullKeyName", "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "solution_info": {"architecture_diagrams": [{"diagram": {"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "cost_estimate": {"version": "Version", "currency": "Currency", "projects": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "pastBreakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "breakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "diff": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}}], "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}, "totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "pastTotalHourlyCost": "PastTotalHourlyCost", "pastTotalMonthlyCost": "PastTotalMonthlyCost", "diffTotalHourlyCost": "DiffTotalHourlyCost", "diffTotalMonthlyCost": "DiffTotalMonthlyCost", "timeGenerated": "2019-01-01T12:00:00.000Z"}, "dependencies": [{"catalog_id": "CatalogID", "id": "ID", "name": "Name", "kind": "Kind", "version": "Version", "description": "Description", "default_flavor": "DefaultFlavor", "flavors": ["Flavors"], "optional": true, "on_by_default": false}], "install_type": "InstallType"}, "is_consumable": true, "compliance_v3": {"authority": "Authority", "claims": {"profiles": [{"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}], "controls": [{"profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "names": ["Names"]}]}, "evaluations": [{"scan_id": "ScanID", "account_id": "AccountID", "profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "result": {"failure_count": 12, "scan_time": "2019-01-01T12:00:00.000Z", "error_message": "ErrorMessage", "complete_scan": true, "unscanned_resources": ["UnscannedResources"]}, "controls": [{"id": "ID", "name": "Name", "description": "Description", "specifications": [{"id": "ID", "description": "Description", "component_name": "ComponentName", "assessments": [{"id": "ID", "description": "Description", "version": "Version", "type": "Type", "method": "Method", "ui_href": "UIHref"}], "ui_href": "UIHref"}], "failure_count": 12, "pass_count": 9, "parent": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "parent_name": "ParentName", "specifications": [{"id": "ID", "description": "Description", "component_name": "ComponentName", "assessments": [{"id": "ID", "description": "Description", "version": "Version", "type": "Type", "method": "Method", "ui_href": "UIHref"}], "ui_href": "UIHref"}], "ui_href": "UIHref"}, "ui_href": "UIHref"}]}]}, "change_notices": {"breaking": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "new": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "update": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}]}, "plan_ids": ["PlanIds"], "stack": {"anyKey": "anyValue"}, "minimum_compatible_version": "MinimumCompatibleVersion"}], "all_versions": {"first": {"href": "Href", "start": "Start"}, "next": {"href": "Href", "start": "Start"}}}], "publish": {"pc_managed": false, "approval_type": "ApprovalType", "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "original_crn": "OriginalCRN", "public_crn": "PublicCRN", "approval_record": {"anyKey": "anyValue"}, "permit_ibm_public_publish": true, "ibm_approved": false, "public_approved": true}, "pc_managed": false, "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "public_original_crn": "PublicOriginalCRN", "publish_public_crn": "PublishPublicCRN", "portal_approval_record": "PortalApprovalRecord", "portal_ui_url": "PortalUIURL", "catalog_id": "CatalogID", "catalog_name": "CatalogName", "metadata": {"anyKey": "anyValue"}, "disclaimer": "Disclaimer", "hidden": true, "provider": "Provider", "provider_info": {"id": "ID", "name": "Name"}, "repo_info": {"token": "Token", "type": "Type"}, "image_pull_keys": [{"name": "Name", "value": "Value", "description": "Description"}], "support": {"url": "URL", "process": "Process", "process_i18n": {"mapKey": "Inner"}, "locations": ["Locations"], "support_details": [{"type": "Type", "contact": "Contact", "response_wait_time": {"value": 5, "type": "Type"}, "availability": {"times": [{"day": 3, "start_time": "StartTime", "end_time": "EndTime"}], "timezone": "Timezone", "always_available": false}}], "support_escalation": {"escalation_wait_time": {"value": 5, "type": "Type"}, "response_wait_time": {"value": 5, "type": "Type"}, "contact": "Contact"}, "support_type": "SupportType"}, "media": [{"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}], "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "product_kind": "ProductKind", "badges": [{"id": "ID", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}, "icon": "Icon", "authority": "Authority", "tag": "Tag", "learn_more_links": {"first_party": "FirstParty", "third_party": "ThirdParty"}, "constraints": [{"type": "Type", "rule": "anyValue"}]}], "plans": [{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "offering_id": "OfferingID", "catalog_id": "CatalogID", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "name": "Name", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "pricing_tags": ["PricingTags"], "version_range": {"kinds": ["Kinds"], "version": "Version", "flavors": ["Flavors"]}, "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "metadata": {"anyKey": "anyValue"}, "publish_approved": false}]}`)
				}))
			})
			It(`Invoke GetPlan successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the GetPlanOptions model
				getPlanOptionsModel := new(catalogmanagementv1.GetPlanOptions)
				getPlanOptionsModel.PlanLocID = core.StringPtr("testString")
				getPlanOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.GetPlanWithContext(ctx, getPlanOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.GetPlan(getPlanOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.GetPlanWithContext(ctx, getPlanOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getPlanPath))
					Expect(req.Method).To(Equal("GET"))

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "name": "Name", "offering_icon_url": "OfferingIconURL", "offering_docs_url": "OfferingDocsURL", "offering_support_url": "OfferingSupportURL", "tags": ["Tags"], "keywords": ["Keywords"], "rating": {"one_star_count": 12, "two_star_count": 12, "three_star_count": 14, "four_star_count": 13}, "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "kinds": [{"id": "ID", "format_kind": "FormatKind", "format_kind_label": "FormatKindLabel", "install_kind": "InstallKind", "install_kind_label": "InstallKindLabel", "target_kind": "TargetKind", "target_kind_label": "TargetKindLabel", "metadata": {"anyKey": "anyValue"}, "tags": ["Tags"], "additional_features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "versions": [{"id": "ID", "_rev": "Rev", "crn": "CRN", "version": "Version", "flavor": {"name": "Name", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "index": 5}, "sha": "Sha", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "offering_id": "OfferingID", "catalog_id": "CatalogID", "kind_id": "KindID", "tags": ["Tags"], "repo_url": "RepoURL", "source_url": "SourceURL", "tgz_url": "TgzURL", "configuration": [{"key": "Key", "type": "Type", "default_value": "anyValue", "display_name": "DisplayName", "value_constraint": "ValueConstraint", "description": "Description", "required": true, "options": ["anyValue"], "hidden": true, "custom_config": {"type": "Type", "grouping": "Grouping", "original_grouping": "OriginalGrouping", "grouping_index": 13, "config_constraints": {"anyKey": "anyValue"}, "associations": {"parameters": [{"name": "Name", "optionsRefresh": true}]}}, "type_metadata": "TypeMetadata"}], "outputs": [{"key": "Key", "description": "Description"}], "iam_permissions": [{"service_name": "ServiceName", "role_crns": ["RoleCrns"], "resources": [{"name": "Name", "description": "Description", "role_crns": ["RoleCrns"]}]}], "metadata": {"anyKey": "anyValue"}, "validation": {"validated": "2019-01-01T12:00:00.000Z", "requested": "2019-01-01T12:00:00.000Z", "state": "State", "last_operation": "LastOperation", "target": {"anyKey": "anyValue"}, "message": "Message"}, "required_resources": [{"type": "mem", "value": "anyValue"}], "single_instance": true, "schematics_env_values": {"value": "[{\"name\": \"TF_LOG\",\"value\": \"TRACE\",\"secure\": false,\"hidden\": false}]", "sm_ref": "cmsm_v1:{\"name\": \"envVarSecret\",\"id\":\"1234567890\",\"service_id\":\"crn:v1:bluemix:public:secrets-manager:eu-gb:a/1234567890:1234567890::\",\"service_name\":\"My SM Instance\",\"group_id\":\"1234567890\",\"group_name\":\"My SM Group\",\"resource_group_id\":\"1234567890\",\"region\":\"eu-gb\",\"type\":\"arbitrary\"}"}, "install": {"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}, "pre_install": [{"instructions": "Instructions", "instructions_i18n": {"mapKey": "Inner"}, "script": "Script", "script_permission": "ScriptPermission", "delete_script": "DeleteScript", "scope": "Scope"}], "scripts": {"mapKey": {"short_description": "ShortDescription", "type": "ansible", "path": "scripts/validate-post-ansible-playbook.yaml", "stage": "pre", "action": "validate"}}, "entitlement": {"provider_name": "ProviderName", "provider_id": "ProviderID", "product_id": "ProductID", "part_numbers": ["PartNumbers"], "image_repo_name": "ImageRepoName"}, "licenses": [{"id": "ID", "name": "Name", "type": "Type", "url": "URL", "description": "Description"}], "image_manifest_url": "ImageManifestURL", "deprecated": true, "package_version": "PackageVersion", "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "version_locator": "VersionLocator", "long_description": "LongDescription", "long_description_i18n": {"mapKey": "Inner"}, "whitelisted_accounts": ["WhitelistedAccounts"], "image_pull_key_name": "ImagePullKeyName", "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "solution_info": {"architecture_diagrams": [{"diagram": {"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "cost_estimate": {"version": "Version", "currency": "Currency", "projects": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "pastBreakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "breakdown": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "diff": {"totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "resources": [{"name": "Name", "metadata": {"anyKey": "anyValue"}, "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost", "costComponents": [{"name": "Name", "unit": "Unit", "hourlyQuantity": "HourlyQuantity", "monthlyQuantity": "MonthlyQuantity", "price": "Price", "hourlyCost": "HourlyCost", "monthlyCost": "MonthlyCost"}]}]}, "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}}], "summary": {"totalDetectedResources": 22, "totalSupportedResources": 23, "totalUnsupportedResources": 25, "totalUsageBasedResources": 24, "totalNoPriceResources": 21, "unsupportedResourceCounts": {"mapKey": 5}, "noPriceResourceCounts": {"mapKey": 5}}, "totalHourlyCost": "TotalHourlyCost", "totalMonthlyCost": "TotalMonthlyCost", "pastTotalHourlyCost": "PastTotalHourlyCost", "pastTotalMonthlyCost": "PastTotalMonthlyCost", "diffTotalHourlyCost": "DiffTotalHourlyCost", "diffTotalMonthlyCost": "DiffTotalMonthlyCost", "timeGenerated": "2019-01-01T12:00:00.000Z"}, "dependencies": [{"catalog_id": "CatalogID", "id": "ID", "name": "Name", "kind": "Kind", "version": "Version", "description": "Description", "default_flavor": "DefaultFlavor", "flavors": ["Flavors"], "optional": true, "on_by_default": false}], "install_type": "InstallType"}, "is_consumable": true, "compliance_v3": {"authority": "Authority", "claims": {"profiles": [{"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}], "controls": [{"profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "names": ["Names"]}]}, "evaluations": [{"scan_id": "ScanID", "account_id": "AccountID", "profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "result": {"failure_count": 12, "scan_time": "2019-01-01T12:00:00.000Z", "error_message": "ErrorMessage", "complete_scan": true, "unscanned_resources": ["UnscannedResources"]}, "controls": [{"id": "ID", "name": "Name", "description": "Description", "specifications": [{"id": "ID", "description": "Description", "component_name": "ComponentName", "assessments": [{"id": "ID", "description": "Description", "version": "Version", "type": "Type", "method": "Method", "ui_href": "UIHref"}], "ui_href": "UIHref"}], "failure_count": 12, "pass_count": 9, "parent": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "profile": {"id": "ID", "name": "Name", "version": "Version", "description": "Description", "type": "Type", "ui_href": "UIHref"}, "parent_name": "ParentName", "specifications": [{"id": "ID", "description": "Description", "component_name": "ComponentName", "assessments": [{"id": "ID", "description": "Description", "version": "Version", "type": "Type", "method": "Method", "ui_href": "UIHref"}], "ui_href": "UIHref"}], "ui_href": "UIHref"}, "ui_href": "UIHref"}]}]}, "change_notices": {"breaking": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "new": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "update": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}]}, "plan_ids": ["PlanIds"], "stack": {"anyKey": "anyValue"}, "minimum_compatible_version": "MinimumCompatibleVersion"}], "all_versions": {"first": {"href": "Href", "start": "Start"}, "next": {"href": "Href", "start": "Start"}}}], "publish": {"pc_managed": false, "approval_type": "ApprovalType", "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "original_crn": "OriginalCRN", "public_crn": "PublicCRN", "approval_record": {"anyKey": "anyValue"}, "permit_ibm_public_publish": true, "ibm_approved": false, "public_approved": true}, "pc_managed": false, "publish_approved": false, "share_with_all": true, "share_with_ibm": true, "share_enabled": true, "public_original_crn": "PublicOriginalCRN", "publish_public_crn": "PublishPublicCRN", "portal_approval_record": "PortalApprovalRecord", "portal_ui_url": "PortalUIURL", "catalog_id": "CatalogID", "catalog_name": "CatalogName", "metadata": {"anyKey": "anyValue"}, "disclaimer": "Disclaimer", "hidden": true, "provider": "Provider", "provider_info": {"id": "ID", "name": "Name"}, "repo_info": {"token": "Token", "type": "Type"}, "image_pull_keys": [{"name": "Name", "value": "Value", "description": "Description"}], "support": {"url": "URL", "process": "Process", "process_i18n": {"mapKey": "Inner"}, "locations": ["Locations"], "support_details": [{"type": "Type", "contact": "Contact", "response_wait_time": {"value": 5, "type": "Type"}, "availability": {"times": [{"day": 3, "start_time": "StartTime", "end_time": "EndTime"}], "timezone": "Timezone", "always_available": false}}], "support_escalation": {"escalation_wait_time": {"value": 5, "type": "Type"}, "response_wait_time": {"value": 5, "type": "Type"}, "contact": "Contact"}, "support_type": "SupportType"}, "media": [{"url": "URL", "api_url": "APIURL", "url_proxy": {"url": "URL", "sha": "Sha"}, "caption": "Caption", "caption_i18n": {"mapKey": "Inner"}, "type": "Type", "thumbnail_url": "ThumbnailURL"}], "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "product_kind": "ProductKind", "badges": [{"id": "ID", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}, "icon": "Icon", "authority": "Authority", "tag": "Tag", "learn_more_links": {"first_party": "FirstParty", "third_party": "ThirdParty"}, "constraints": [{"type": "Type", "rule": "anyValue"}]}], "plans": [{"id": "ID", "_rev": "Rev", "url": "URL", "crn": "CRN", "created": "2019-01-01T12:00:00.000Z", "updated": "2019-01-01T12:00:00.000Z", "offering_id": "OfferingID", "catalog_id": "CatalogID", "label": "Label", "label_i18n": {"mapKey": "Inner"}, "name": "Name", "short_description": "ShortDescription", "short_description_i18n": {"mapKey": "Inner"}, "pricing_tags": ["PricingTags"], "version_range": {"kinds": ["Kinds"], "version": "Version", "flavors": ["Flavors"]}, "features": [{"title": "Title", "title_i18n": {"mapKey": "Inner"}, "description": "Description", "description_i18n": {"mapKey": "Inner"}}], "state": {"current": "Current", "current_entered": "2019-01-01T12:00:00.000Z", "pending": "Pending", "pending_requested": "2019-01-01T12:00:00.000Z", "previous": "Previous"}, "deprecate_pending": {"deprecate_date": "2019-01-01T12:00:00.000Z", "deprecate_state": "DeprecateState", "description": "Description"}, "metadata": {"anyKey": "anyValue"}, "publish_approved": false}]}`)
				}))
			})
			It(`Invoke GetPlan successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.GetPlan(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetPlanOptions model
				getPlanOptionsModel := new(catalogmanagementv1.GetPlanOptions)
				getPlanOptionsModel.PlanLocID = core.StringPtr("testString")
				getPlanOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.GetPlan(getPlanOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetPlan with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetPlanOptions model
				getPlanOptionsModel := new(catalogmanagementv1.GetPlanOptions)
				getPlanOptionsModel.PlanLocID = core.StringPtr("testString")
				getPlanOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.GetPlan(getPlanOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetPlanOptions model with no property values
				getPlanOptionsModelNew := new(catalogmanagementv1.GetPlanOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = catalogManagementService.GetPlan(getPlanOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetPlan successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the GetPlanOptions model
				getPlanOptionsModel := new(catalogmanagementv1.GetPlanOptions)
				getPlanOptionsModel.PlanLocID = core.StringPtr("testString")
				getPlanOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.GetPlan(getPlanOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`DeletePlan(deletePlanOptions *DeletePlanOptions)`, func() {
		deletePlanPath := "/plans/testString"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deletePlanPath))
					Expect(req.Method).To(Equal("DELETE"))

					res.WriteHeader(200)
				}))
			})
			It(`Invoke DeletePlan successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := catalogManagementService.DeletePlan(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the DeletePlanOptions model
				deletePlanOptionsModel := new(catalogmanagementv1.DeletePlanOptions)
				deletePlanOptionsModel.PlanLocID = core.StringPtr("testString")
				deletePlanOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = catalogManagementService.DeletePlan(deletePlanOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke DeletePlan with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the DeletePlanOptions model
				deletePlanOptionsModel := new(catalogmanagementv1.DeletePlanOptions)
				deletePlanOptionsModel.PlanLocID = core.StringPtr("testString")
				deletePlanOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := catalogManagementService.DeletePlan(deletePlanOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the DeletePlanOptions model with no property values
				deletePlanOptionsModelNew := new(catalogmanagementv1.DeletePlanOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = catalogManagementService.DeletePlan(deletePlanOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ConsumablePlan(consumablePlanOptions *ConsumablePlanOptions)`, func() {
		consumablePlanPath := "/plans/testString/consume-publish"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(consumablePlanPath))
					Expect(req.Method).To(Equal("POST"))

					res.WriteHeader(202)
				}))
			})
			It(`Invoke ConsumablePlan successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := catalogManagementService.ConsumablePlan(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the ConsumablePlanOptions model
				consumablePlanOptionsModel := new(catalogmanagementv1.ConsumablePlanOptions)
				consumablePlanOptionsModel.PlanLocID = core.StringPtr("testString")
				consumablePlanOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = catalogManagementService.ConsumablePlan(consumablePlanOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke ConsumablePlan with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ConsumablePlanOptions model
				consumablePlanOptionsModel := new(catalogmanagementv1.ConsumablePlanOptions)
				consumablePlanOptionsModel.PlanLocID = core.StringPtr("testString")
				consumablePlanOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := catalogManagementService.ConsumablePlan(consumablePlanOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the ConsumablePlanOptions model with no property values
				consumablePlanOptionsModelNew := new(catalogmanagementv1.ConsumablePlanOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = catalogManagementService.ConsumablePlan(consumablePlanOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`SetDeprecatePlan(setDeprecatePlanOptions *SetDeprecatePlanOptions)`, func() {
		setDeprecatePlanPath := "/plans/testString/deprecate/true"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(setDeprecatePlanPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					res.WriteHeader(202)
				}))
			})
			It(`Invoke SetDeprecatePlan successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := catalogManagementService.SetDeprecatePlan(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the SetDeprecatePlanOptions model
				setDeprecatePlanOptionsModel := new(catalogmanagementv1.SetDeprecatePlanOptions)
				setDeprecatePlanOptionsModel.PlanLocID = core.StringPtr("testString")
				setDeprecatePlanOptionsModel.Setting = core.StringPtr("true")
				setDeprecatePlanOptionsModel.Description = core.StringPtr("testString")
				setDeprecatePlanOptionsModel.DaysUntilDeprecate = core.Int64Ptr(int64(38))
				setDeprecatePlanOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = catalogManagementService.SetDeprecatePlan(setDeprecatePlanOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke SetDeprecatePlan with error: Operation validation and request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the SetDeprecatePlanOptions model
				setDeprecatePlanOptionsModel := new(catalogmanagementv1.SetDeprecatePlanOptions)
				setDeprecatePlanOptionsModel.PlanLocID = core.StringPtr("testString")
				setDeprecatePlanOptionsModel.Setting = core.StringPtr("true")
				setDeprecatePlanOptionsModel.Description = core.StringPtr("testString")
				setDeprecatePlanOptionsModel.DaysUntilDeprecate = core.Int64Ptr(int64(38))
				setDeprecatePlanOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := catalogManagementService.SetDeprecatePlan(setDeprecatePlanOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the SetDeprecatePlanOptions model with no property values
				setDeprecatePlanOptionsModelNew := new(catalogmanagementv1.SetDeprecatePlanOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = catalogManagementService.SetDeprecatePlan(setDeprecatePlanOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`PreviewRegions(previewRegionsOptions *PreviewRegionsOptions) - Operation response error`, func() {
		previewRegionsPath := "/regions"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(previewRegionsPath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.URL.Query()["filter"]).To(Equal([]string{"testString"}))
					// TODO: Add check for get_inactive query parameter
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(100))}))
					Expect(req.URL.Query()["offset"]).To(Equal([]string{fmt.Sprint(int64(0))}))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke PreviewRegions with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the PreviewRegionsOptions model
				previewRegionsOptionsModel := new(catalogmanagementv1.PreviewRegionsOptions)
				previewRegionsOptionsModel.Filter = core.StringPtr("testString")
				previewRegionsOptionsModel.GetInactive = core.BoolPtr(true)
				previewRegionsOptionsModel.Limit = core.Int64Ptr(int64(100))
				previewRegionsOptionsModel.Offset = core.Int64Ptr(int64(0))
				previewRegionsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.PreviewRegions(previewRegionsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.PreviewRegions(previewRegionsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`PreviewRegions(previewRegionsOptions *PreviewRegionsOptions)`, func() {
		previewRegionsPath := "/regions"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(previewRegionsPath))
					Expect(req.Method).To(Equal("POST"))

					Expect(req.URL.Query()["filter"]).To(Equal([]string{"testString"}))
					// TODO: Add check for get_inactive query parameter
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(100))}))
					Expect(req.URL.Query()["offset"]).To(Equal([]string{fmt.Sprint(int64(0))}))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"offset": 6, "limit": 5, "total_count": 10, "resource_count": 13, "first": {"href": "Href", "start": "Start"}, "last": {"href": "Href", "start": "Start"}, "regions": [{"id": "ID", "name": "Name", "catalog_crn": "CatalogCRN", "kind": "Kind", "public": true, "ui": {"_language_": {"description": "Description", "display_name": "DisplayName"}}, "icon": "Icon", "parent_id": "ParentID", "metro_id": "MetroID", "country_id": "CountryID", "geo_id": "GeoID", "authority": {"url": "URL", "crn": "CRN", "provider": "Provider"}, "tags": ["Tags"], "capabilities": "Capabilities", "created": "Created", "updated": "Updated", "active": true, "visibility": {"anyKey": "anyValue"}}]}`)
				}))
			})
			It(`Invoke PreviewRegions successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the PreviewRegionsOptions model
				previewRegionsOptionsModel := new(catalogmanagementv1.PreviewRegionsOptions)
				previewRegionsOptionsModel.Filter = core.StringPtr("testString")
				previewRegionsOptionsModel.GetInactive = core.BoolPtr(true)
				previewRegionsOptionsModel.Limit = core.Int64Ptr(int64(100))
				previewRegionsOptionsModel.Offset = core.Int64Ptr(int64(0))
				previewRegionsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.PreviewRegionsWithContext(ctx, previewRegionsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.PreviewRegions(previewRegionsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.PreviewRegionsWithContext(ctx, previewRegionsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(previewRegionsPath))
					Expect(req.Method).To(Equal("POST"))

					Expect(req.URL.Query()["filter"]).To(Equal([]string{"testString"}))
					// TODO: Add check for get_inactive query parameter
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(100))}))
					Expect(req.URL.Query()["offset"]).To(Equal([]string{fmt.Sprint(int64(0))}))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"offset": 6, "limit": 5, "total_count": 10, "resource_count": 13, "first": {"href": "Href", "start": "Start"}, "last": {"href": "Href", "start": "Start"}, "regions": [{"id": "ID", "name": "Name", "catalog_crn": "CatalogCRN", "kind": "Kind", "public": true, "ui": {"_language_": {"description": "Description", "display_name": "DisplayName"}}, "icon": "Icon", "parent_id": "ParentID", "metro_id": "MetroID", "country_id": "CountryID", "geo_id": "GeoID", "authority": {"url": "URL", "crn": "CRN", "provider": "Provider"}, "tags": ["Tags"], "capabilities": "Capabilities", "created": "Created", "updated": "Updated", "active": true, "visibility": {"anyKey": "anyValue"}}]}`)
				}))
			})
			It(`Invoke PreviewRegions successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.PreviewRegions(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the PreviewRegionsOptions model
				previewRegionsOptionsModel := new(catalogmanagementv1.PreviewRegionsOptions)
				previewRegionsOptionsModel.Filter = core.StringPtr("testString")
				previewRegionsOptionsModel.GetInactive = core.BoolPtr(true)
				previewRegionsOptionsModel.Limit = core.Int64Ptr(int64(100))
				previewRegionsOptionsModel.Offset = core.Int64Ptr(int64(0))
				previewRegionsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.PreviewRegions(previewRegionsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke PreviewRegions with error: Operation request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the PreviewRegionsOptions model
				previewRegionsOptionsModel := new(catalogmanagementv1.PreviewRegionsOptions)
				previewRegionsOptionsModel.Filter = core.StringPtr("testString")
				previewRegionsOptionsModel.GetInactive = core.BoolPtr(true)
				previewRegionsOptionsModel.Limit = core.Int64Ptr(int64(100))
				previewRegionsOptionsModel.Offset = core.Int64Ptr(int64(0))
				previewRegionsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.PreviewRegions(previewRegionsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke PreviewRegions successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the PreviewRegionsOptions model
				previewRegionsOptionsModel := new(catalogmanagementv1.PreviewRegionsOptions)
				previewRegionsOptionsModel.Filter = core.StringPtr("testString")
				previewRegionsOptionsModel.GetInactive = core.BoolPtr(true)
				previewRegionsOptionsModel.Limit = core.Int64Ptr(int64(100))
				previewRegionsOptionsModel.Offset = core.Int64Ptr(int64(0))
				previewRegionsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.PreviewRegions(previewRegionsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListRegions(listRegionsOptions *ListRegionsOptions) - Operation response error`, func() {
		listRegionsPath := "/regions"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listRegionsPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.URL.Query()["filter"]).To(Equal([]string{"testString"}))
					// TODO: Add check for get_inactive query parameter
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(100))}))
					Expect(req.URL.Query()["offset"]).To(Equal([]string{fmt.Sprint(int64(0))}))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ListRegions with error: Operation response processing error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ListRegionsOptions model
				listRegionsOptionsModel := new(catalogmanagementv1.ListRegionsOptions)
				listRegionsOptionsModel.Filter = core.StringPtr("testString")
				listRegionsOptionsModel.GetInactive = core.BoolPtr(true)
				listRegionsOptionsModel.Limit = core.Int64Ptr(int64(100))
				listRegionsOptionsModel.Offset = core.Int64Ptr(int64(0))
				listRegionsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := catalogManagementService.ListRegions(listRegionsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				catalogManagementService.EnableRetries(0, 0)
				result, response, operationErr = catalogManagementService.ListRegions(listRegionsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListRegions(listRegionsOptions *ListRegionsOptions)`, func() {
		listRegionsPath := "/regions"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listRegionsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.URL.Query()["filter"]).To(Equal([]string{"testString"}))
					// TODO: Add check for get_inactive query parameter
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(100))}))
					Expect(req.URL.Query()["offset"]).To(Equal([]string{fmt.Sprint(int64(0))}))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"offset": 6, "limit": 5, "total_count": 10, "resource_count": 13, "first": {"href": "Href", "start": "Start"}, "last": {"href": "Href", "start": "Start"}, "regions": [{"id": "ID", "name": "Name", "catalog_crn": "CatalogCRN", "kind": "Kind", "public": true, "ui": {"_language_": {"description": "Description", "display_name": "DisplayName"}}, "icon": "Icon", "parent_id": "ParentID", "metro_id": "MetroID", "country_id": "CountryID", "geo_id": "GeoID", "authority": {"url": "URL", "crn": "CRN", "provider": "Provider"}, "tags": ["Tags"], "capabilities": "Capabilities", "created": "Created", "updated": "Updated", "active": true, "visibility": {"anyKey": "anyValue"}}]}`)
				}))
			})
			It(`Invoke ListRegions successfully with retries`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())
				catalogManagementService.EnableRetries(0, 0)

				// Construct an instance of the ListRegionsOptions model
				listRegionsOptionsModel := new(catalogmanagementv1.ListRegionsOptions)
				listRegionsOptionsModel.Filter = core.StringPtr("testString")
				listRegionsOptionsModel.GetInactive = core.BoolPtr(true)
				listRegionsOptionsModel.Limit = core.Int64Ptr(int64(100))
				listRegionsOptionsModel.Offset = core.Int64Ptr(int64(0))
				listRegionsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := catalogManagementService.ListRegionsWithContext(ctx, listRegionsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				catalogManagementService.DisableRetries()
				result, response, operationErr := catalogManagementService.ListRegions(listRegionsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = catalogManagementService.ListRegionsWithContext(ctx, listRegionsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listRegionsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.URL.Query()["filter"]).To(Equal([]string{"testString"}))
					// TODO: Add check for get_inactive query parameter
					Expect(req.URL.Query()["limit"]).To(Equal([]string{fmt.Sprint(int64(100))}))
					Expect(req.URL.Query()["offset"]).To(Equal([]string{fmt.Sprint(int64(0))}))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"offset": 6, "limit": 5, "total_count": 10, "resource_count": 13, "first": {"href": "Href", "start": "Start"}, "last": {"href": "Href", "start": "Start"}, "regions": [{"id": "ID", "name": "Name", "catalog_crn": "CatalogCRN", "kind": "Kind", "public": true, "ui": {"_language_": {"description": "Description", "display_name": "DisplayName"}}, "icon": "Icon", "parent_id": "ParentID", "metro_id": "MetroID", "country_id": "CountryID", "geo_id": "GeoID", "authority": {"url": "URL", "crn": "CRN", "provider": "Provider"}, "tags": ["Tags"], "capabilities": "Capabilities", "created": "Created", "updated": "Updated", "active": true, "visibility": {"anyKey": "anyValue"}}]}`)
				}))
			})
			It(`Invoke ListRegions successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := catalogManagementService.ListRegions(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ListRegionsOptions model
				listRegionsOptionsModel := new(catalogmanagementv1.ListRegionsOptions)
				listRegionsOptionsModel.Filter = core.StringPtr("testString")
				listRegionsOptionsModel.GetInactive = core.BoolPtr(true)
				listRegionsOptionsModel.Limit = core.Int64Ptr(int64(100))
				listRegionsOptionsModel.Offset = core.Int64Ptr(int64(0))
				listRegionsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = catalogManagementService.ListRegions(listRegionsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ListRegions with error: Operation request error`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ListRegionsOptions model
				listRegionsOptionsModel := new(catalogmanagementv1.ListRegionsOptions)
				listRegionsOptionsModel.Filter = core.StringPtr("testString")
				listRegionsOptionsModel.GetInactive = core.BoolPtr(true)
				listRegionsOptionsModel.Limit = core.Int64Ptr(int64(100))
				listRegionsOptionsModel.Offset = core.Int64Ptr(int64(0))
				listRegionsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := catalogManagementService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := catalogManagementService.ListRegions(listRegionsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ListRegions successfully`, func() {
				catalogManagementService, serviceErr := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(catalogManagementService).ToNot(BeNil())

				// Construct an instance of the ListRegionsOptions model
				listRegionsOptionsModel := new(catalogmanagementv1.ListRegionsOptions)
				listRegionsOptionsModel.Filter = core.StringPtr("testString")
				listRegionsOptionsModel.GetInactive = core.BoolPtr(true)
				listRegionsOptionsModel.Limit = core.Int64Ptr(int64(100))
				listRegionsOptionsModel.Offset = core.Int64Ptr(int64(0))
				listRegionsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := catalogManagementService.ListRegions(listRegionsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`Model constructor tests`, func() {
		Context(`Using a service client instance`, func() {
			catalogManagementService, _ := catalogmanagementv1.NewCatalogManagementV1(&catalogmanagementv1.CatalogManagementV1Options{
				URL:           "http://catalogmanagementv1modelgenerator.com",
				Authenticator: &core.NoAuthAuthenticator{},
			})
			It(`Invoke NewAddObjectAccessListOptions successfully`, func() {
				// Construct an instance of the AddObjectAccessListOptions model
				catalogIdentifier := "testString"
				objectIdentifier := "testString"
				accesses := []string{"testString"}
				addObjectAccessListOptionsModel := catalogManagementService.NewAddObjectAccessListOptions(catalogIdentifier, objectIdentifier, accesses)
				addObjectAccessListOptionsModel.SetCatalogIdentifier("testString")
				addObjectAccessListOptionsModel.SetObjectIdentifier("testString")
				addObjectAccessListOptionsModel.SetAccesses([]string{"testString"})
				addObjectAccessListOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(addObjectAccessListOptionsModel).ToNot(BeNil())
				Expect(addObjectAccessListOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(addObjectAccessListOptionsModel.ObjectIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(addObjectAccessListOptionsModel.Accesses).To(Equal([]string{"testString"}))
				Expect(addObjectAccessListOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewAddOfferingAccessListOptions successfully`, func() {
				// Construct an instance of the AddOfferingAccessListOptions model
				catalogIdentifier := "testString"
				offeringID := "testString"
				accesses := []string{"testString"}
				addOfferingAccessListOptionsModel := catalogManagementService.NewAddOfferingAccessListOptions(catalogIdentifier, offeringID, accesses)
				addOfferingAccessListOptionsModel.SetCatalogIdentifier("testString")
				addOfferingAccessListOptionsModel.SetOfferingID("testString")
				addOfferingAccessListOptionsModel.SetAccesses([]string{"testString"})
				addOfferingAccessListOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(addOfferingAccessListOptionsModel).ToNot(BeNil())
				Expect(addOfferingAccessListOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(addOfferingAccessListOptionsModel.OfferingID).To(Equal(core.StringPtr("testString")))
				Expect(addOfferingAccessListOptionsModel.Accesses).To(Equal([]string{"testString"}))
				Expect(addOfferingAccessListOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewAddShareApprovalListOptions successfully`, func() {
				// Construct an instance of the AddShareApprovalListOptions model
				objectType := "offering"
				accesses := []string{"testString"}
				addShareApprovalListOptionsModel := catalogManagementService.NewAddShareApprovalListOptions(objectType, accesses)
				addShareApprovalListOptionsModel.SetObjectType("offering")
				addShareApprovalListOptionsModel.SetAccesses([]string{"testString"})
				addShareApprovalListOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(addShareApprovalListOptionsModel).ToNot(BeNil())
				Expect(addShareApprovalListOptionsModel.ObjectType).To(Equal(core.StringPtr("offering")))
				Expect(addShareApprovalListOptionsModel.Accesses).To(Equal([]string{"testString"}))
				Expect(addShareApprovalListOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewArchiveVersionOptions successfully`, func() {
				// Construct an instance of the ArchiveVersionOptions model
				versionLocID := "testString"
				archiveVersionOptionsModel := catalogManagementService.NewArchiveVersionOptions(versionLocID)
				archiveVersionOptionsModel.SetVersionLocID("testString")
				archiveVersionOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(archiveVersionOptionsModel).ToNot(BeNil())
				Expect(archiveVersionOptionsModel.VersionLocID).To(Equal(core.StringPtr("testString")))
				Expect(archiveVersionOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewCommitVersionOptions successfully`, func() {
				// Construct an instance of the CommitVersionOptions model
				versionLocID := "testString"
				commitVersionOptionsModel := catalogManagementService.NewCommitVersionOptions(versionLocID)
				commitVersionOptionsModel.SetVersionLocID("testString")
				commitVersionOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(commitVersionOptionsModel).ToNot(BeNil())
				Expect(commitVersionOptionsModel.VersionLocID).To(Equal(core.StringPtr("testString")))
				Expect(commitVersionOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewConsumablePlanOptions successfully`, func() {
				// Construct an instance of the ConsumablePlanOptions model
				planLocID := "testString"
				consumablePlanOptionsModel := catalogManagementService.NewConsumablePlanOptions(planLocID)
				consumablePlanOptionsModel.SetPlanLocID("testString")
				consumablePlanOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(consumablePlanOptionsModel).ToNot(BeNil())
				Expect(consumablePlanOptionsModel.PlanLocID).To(Equal(core.StringPtr("testString")))
				Expect(consumablePlanOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewConsumableShareObjectOptions successfully`, func() {
				// Construct an instance of the ConsumableShareObjectOptions model
				catalogIdentifier := "testString"
				objectIdentifier := "testString"
				consumableShareObjectOptionsModel := catalogManagementService.NewConsumableShareObjectOptions(catalogIdentifier, objectIdentifier)
				consumableShareObjectOptionsModel.SetCatalogIdentifier("testString")
				consumableShareObjectOptionsModel.SetObjectIdentifier("testString")
				consumableShareObjectOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(consumableShareObjectOptionsModel).ToNot(BeNil())
				Expect(consumableShareObjectOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(consumableShareObjectOptionsModel.ObjectIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(consumableShareObjectOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewConsumableVersionOptions successfully`, func() {
				// Construct an instance of the ConsumableVersionOptions model
				versionLocID := "testString"
				consumableVersionOptionsModel := catalogManagementService.NewConsumableVersionOptions(versionLocID)
				consumableVersionOptionsModel.SetVersionLocID("testString")
				consumableVersionOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(consumableVersionOptionsModel).ToNot(BeNil())
				Expect(consumableVersionOptionsModel.VersionLocID).To(Equal(core.StringPtr("testString")))
				Expect(consumableVersionOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewCopyFromPreviousVersionOptions successfully`, func() {
				// Construct an instance of the CopyFromPreviousVersionOptions model
				versionLocID := "testString"
				typeVar := "testString"
				versionLocIDToCopyFrom := "testString"
				copyFromPreviousVersionOptionsModel := catalogManagementService.NewCopyFromPreviousVersionOptions(versionLocID, typeVar, versionLocIDToCopyFrom)
				copyFromPreviousVersionOptionsModel.SetVersionLocID("testString")
				copyFromPreviousVersionOptionsModel.SetType("testString")
				copyFromPreviousVersionOptionsModel.SetVersionLocIDToCopyFrom("testString")
				copyFromPreviousVersionOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(copyFromPreviousVersionOptionsModel).ToNot(BeNil())
				Expect(copyFromPreviousVersionOptionsModel.VersionLocID).To(Equal(core.StringPtr("testString")))
				Expect(copyFromPreviousVersionOptionsModel.Type).To(Equal(core.StringPtr("testString")))
				Expect(copyFromPreviousVersionOptionsModel.VersionLocIDToCopyFrom).To(Equal(core.StringPtr("testString")))
				Expect(copyFromPreviousVersionOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewCopyVersionOptions successfully`, func() {
				// Construct an instance of the Flavor model
				flavorModel := new(catalogmanagementv1.Flavor)
				Expect(flavorModel).ToNot(BeNil())
				flavorModel.Name = core.StringPtr("testString")
				flavorModel.Label = core.StringPtr("testString")
				flavorModel.LabelI18n = map[string]string{"key1": "testString"}
				flavorModel.Index = core.Int64Ptr(int64(38))
				Expect(flavorModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(flavorModel.Label).To(Equal(core.StringPtr("testString")))
				Expect(flavorModel.LabelI18n).To(Equal(map[string]string{"key1": "testString"}))
				Expect(flavorModel.Index).To(Equal(core.Int64Ptr(int64(38))))

				// Construct an instance of the CopyVersionOptions model
				versionLocID := "testString"
				copyVersionOptionsModel := catalogManagementService.NewCopyVersionOptions(versionLocID)
				copyVersionOptionsModel.SetVersionLocID("testString")
				copyVersionOptionsModel.SetTags([]string{"testString"})
				copyVersionOptionsModel.SetContent(*CreateMockByteArray("VGhpcyBpcyBhIG1vY2sgYnl0ZSBhcnJheSB2YWx1ZS4="))
				copyVersionOptionsModel.SetTargetKinds([]string{"testString"})
				copyVersionOptionsModel.SetFormatKind("testString")
				copyVersionOptionsModel.SetFlavor(flavorModel)
				copyVersionOptionsModel.SetWorkingDirectory("testString")
				copyVersionOptionsModel.SetInstallType("testString")
				copyVersionOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(copyVersionOptionsModel).ToNot(BeNil())
				Expect(copyVersionOptionsModel.VersionLocID).To(Equal(core.StringPtr("testString")))
				Expect(copyVersionOptionsModel.Tags).To(Equal([]string{"testString"}))
				Expect(copyVersionOptionsModel.Content).To(Equal(CreateMockByteArray("VGhpcyBpcyBhIG1vY2sgYnl0ZSBhcnJheSB2YWx1ZS4=")))
				Expect(copyVersionOptionsModel.TargetKinds).To(Equal([]string{"testString"}))
				Expect(copyVersionOptionsModel.FormatKind).To(Equal(core.StringPtr("testString")))
				Expect(copyVersionOptionsModel.Flavor).To(Equal(flavorModel))
				Expect(copyVersionOptionsModel.WorkingDirectory).To(Equal(core.StringPtr("testString")))
				Expect(copyVersionOptionsModel.InstallType).To(Equal(core.StringPtr("testString")))
				Expect(copyVersionOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewCreateCatalogOptions successfully`, func() {
				// Construct an instance of the Feature model
				featureModel := new(catalogmanagementv1.Feature)
				Expect(featureModel).ToNot(BeNil())
				featureModel.Title = core.StringPtr("testString")
				featureModel.TitleI18n = map[string]string{"key1": "testString"}
				featureModel.Description = core.StringPtr("testString")
				featureModel.DescriptionI18n = map[string]string{"key1": "testString"}
				Expect(featureModel.Title).To(Equal(core.StringPtr("testString")))
				Expect(featureModel.TitleI18n).To(Equal(map[string]string{"key1": "testString"}))
				Expect(featureModel.Description).To(Equal(core.StringPtr("testString")))
				Expect(featureModel.DescriptionI18n).To(Equal(map[string]string{"key1": "testString"}))

				// Construct an instance of the FilterTerms model
				filterTermsModel := new(catalogmanagementv1.FilterTerms)
				Expect(filterTermsModel).ToNot(BeNil())
				filterTermsModel.FilterTerms = []string{"testString"}
				Expect(filterTermsModel.FilterTerms).To(Equal([]string{"testString"}))

				// Construct an instance of the CategoryFilter model
				categoryFilterModel := new(catalogmanagementv1.CategoryFilter)
				Expect(categoryFilterModel).ToNot(BeNil())
				categoryFilterModel.Include = core.BoolPtr(true)
				categoryFilterModel.Filter = filterTermsModel
				Expect(categoryFilterModel.Include).To(Equal(core.BoolPtr(true)))
				Expect(categoryFilterModel.Filter).To(Equal(filterTermsModel))

				// Construct an instance of the IDFilter model
				idFilterModel := new(catalogmanagementv1.IDFilter)
				Expect(idFilterModel).ToNot(BeNil())
				idFilterModel.Include = filterTermsModel
				idFilterModel.Exclude = filterTermsModel
				Expect(idFilterModel.Include).To(Equal(filterTermsModel))
				Expect(idFilterModel.Exclude).To(Equal(filterTermsModel))

				// Construct an instance of the Filters model
				filtersModel := new(catalogmanagementv1.Filters)
				Expect(filtersModel).ToNot(BeNil())
				filtersModel.IncludeAll = core.BoolPtr(true)
				filtersModel.CategoryFilters = map[string]catalogmanagementv1.CategoryFilter{"key1": *categoryFilterModel}
				filtersModel.IDFilters = idFilterModel
				filtersModel.CategoryFilters["foo"] = *categoryFilterModel
				Expect(filtersModel.IncludeAll).To(Equal(core.BoolPtr(true)))
				Expect(filtersModel.IDFilters).To(Equal(idFilterModel))
				Expect(filtersModel.CategoryFilters["foo"]).To(Equal(*categoryFilterModel))

				// Construct an instance of the TrustedProfileInfo model
				trustedProfileInfoModel := new(catalogmanagementv1.TrustedProfileInfo)
				Expect(trustedProfileInfoModel).ToNot(BeNil())
				trustedProfileInfoModel.TrustedProfileID = core.StringPtr("testString")
				trustedProfileInfoModel.CatalogCRN = core.StringPtr("testString")
				trustedProfileInfoModel.CatalogName = core.StringPtr("testString")
				trustedProfileInfoModel.TargetServiceID = core.StringPtr("testString")
				Expect(trustedProfileInfoModel.TrustedProfileID).To(Equal(core.StringPtr("testString")))
				Expect(trustedProfileInfoModel.CatalogCRN).To(Equal(core.StringPtr("testString")))
				Expect(trustedProfileInfoModel.CatalogName).To(Equal(core.StringPtr("testString")))
				Expect(trustedProfileInfoModel.TargetServiceID).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the TargetAccountContext model
				targetAccountContextModel := new(catalogmanagementv1.TargetAccountContext)
				Expect(targetAccountContextModel).ToNot(BeNil())
				targetAccountContextModel.APIKey = core.StringPtr("testString")
				targetAccountContextModel.TrustedProfile = trustedProfileInfoModel
				targetAccountContextModel.Name = core.StringPtr("testString")
				targetAccountContextModel.Label = core.StringPtr("testString")
				targetAccountContextModel.ProjectID = core.StringPtr("testString")
				Expect(targetAccountContextModel.APIKey).To(Equal(core.StringPtr("testString")))
				Expect(targetAccountContextModel.TrustedProfile).To(Equal(trustedProfileInfoModel))
				Expect(targetAccountContextModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(targetAccountContextModel.Label).To(Equal(core.StringPtr("testString")))
				Expect(targetAccountContextModel.ProjectID).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the CreateCatalogOptions model
				createCatalogOptionsModel := catalogManagementService.NewCreateCatalogOptions()
				createCatalogOptionsModel.SetLabel("testString")
				createCatalogOptionsModel.SetLabelI18n(map[string]string{"key1": "testString"})
				createCatalogOptionsModel.SetShortDescription("testString")
				createCatalogOptionsModel.SetShortDescriptionI18n(map[string]string{"key1": "testString"})
				createCatalogOptionsModel.SetCatalogIconURL("testString")
				createCatalogOptionsModel.SetCatalogBannerURL("testString")
				createCatalogOptionsModel.SetTags([]string{"testString"})
				createCatalogOptionsModel.SetFeatures([]catalogmanagementv1.Feature{*featureModel})
				createCatalogOptionsModel.SetDisabled(true)
				createCatalogOptionsModel.SetResourceGroupID("testString")
				createCatalogOptionsModel.SetOwningAccount("testString")
				createCatalogOptionsModel.SetCatalogFilters(filtersModel)
				createCatalogOptionsModel.SetKind("testString")
				createCatalogOptionsModel.SetMetadata(map[string]interface{}{"anyKey": "anyValue"})
				createCatalogOptionsModel.SetTargetAccountContexts([]catalogmanagementv1.TargetAccountContext{*targetAccountContextModel})
				createCatalogOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(createCatalogOptionsModel).ToNot(BeNil())
				Expect(createCatalogOptionsModel.Label).To(Equal(core.StringPtr("testString")))
				Expect(createCatalogOptionsModel.LabelI18n).To(Equal(map[string]string{"key1": "testString"}))
				Expect(createCatalogOptionsModel.ShortDescription).To(Equal(core.StringPtr("testString")))
				Expect(createCatalogOptionsModel.ShortDescriptionI18n).To(Equal(map[string]string{"key1": "testString"}))
				Expect(createCatalogOptionsModel.CatalogIconURL).To(Equal(core.StringPtr("testString")))
				Expect(createCatalogOptionsModel.CatalogBannerURL).To(Equal(core.StringPtr("testString")))
				Expect(createCatalogOptionsModel.Tags).To(Equal([]string{"testString"}))
				Expect(createCatalogOptionsModel.Features).To(Equal([]catalogmanagementv1.Feature{*featureModel}))
				Expect(createCatalogOptionsModel.Disabled).To(Equal(core.BoolPtr(true)))
				Expect(createCatalogOptionsModel.ResourceGroupID).To(Equal(core.StringPtr("testString")))
				Expect(createCatalogOptionsModel.OwningAccount).To(Equal(core.StringPtr("testString")))
				Expect(createCatalogOptionsModel.CatalogFilters).To(Equal(filtersModel))
				Expect(createCatalogOptionsModel.Kind).To(Equal(core.StringPtr("testString")))
				Expect(createCatalogOptionsModel.Metadata).To(Equal(map[string]interface{}{"anyKey": "anyValue"}))
				Expect(createCatalogOptionsModel.TargetAccountContexts).To(Equal([]catalogmanagementv1.TargetAccountContext{*targetAccountContextModel}))
				Expect(createCatalogOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewCreateObjectAccessOptions successfully`, func() {
				// Construct an instance of the CreateObjectAccessOptions model
				catalogIdentifier := "testString"
				objectIdentifier := "testString"
				accessIdentifier := "testString"
				createObjectAccessOptionsModel := catalogManagementService.NewCreateObjectAccessOptions(catalogIdentifier, objectIdentifier, accessIdentifier)
				createObjectAccessOptionsModel.SetCatalogIdentifier("testString")
				createObjectAccessOptionsModel.SetObjectIdentifier("testString")
				createObjectAccessOptionsModel.SetAccessIdentifier("testString")
				createObjectAccessOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(createObjectAccessOptionsModel).ToNot(BeNil())
				Expect(createObjectAccessOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(createObjectAccessOptionsModel.ObjectIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(createObjectAccessOptionsModel.AccessIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(createObjectAccessOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewCreateObjectOptions successfully`, func() {
				// Construct an instance of the PublishObject model
				publishObjectModel := new(catalogmanagementv1.PublishObject)
				Expect(publishObjectModel).ToNot(BeNil())
				publishObjectModel.PcManaged = core.BoolPtr(true)
				publishObjectModel.ApprovalType = core.StringPtr("testString")
				publishObjectModel.PublishApproved = core.BoolPtr(true)
				publishObjectModel.ShareWithAll = core.BoolPtr(true)
				publishObjectModel.ShareWithIBM = core.BoolPtr(true)
				publishObjectModel.ShareEnabled = core.BoolPtr(true)
				publishObjectModel.OriginalCRN = core.StringPtr("testString")
				publishObjectModel.PublicCRN = core.StringPtr("testString")
				publishObjectModel.ApprovalRecord = map[string]interface{}{"anyKey": "anyValue"}
				publishObjectModel.PermitIBMPublicPublish = core.BoolPtr(true)
				publishObjectModel.IBMApproved = core.BoolPtr(true)
				publishObjectModel.PublicApproved = core.BoolPtr(true)
				Expect(publishObjectModel.PcManaged).To(Equal(core.BoolPtr(true)))
				Expect(publishObjectModel.ApprovalType).To(Equal(core.StringPtr("testString")))
				Expect(publishObjectModel.PublishApproved).To(Equal(core.BoolPtr(true)))
				Expect(publishObjectModel.ShareWithAll).To(Equal(core.BoolPtr(true)))
				Expect(publishObjectModel.ShareWithIBM).To(Equal(core.BoolPtr(true)))
				Expect(publishObjectModel.ShareEnabled).To(Equal(core.BoolPtr(true)))
				Expect(publishObjectModel.OriginalCRN).To(Equal(core.StringPtr("testString")))
				Expect(publishObjectModel.PublicCRN).To(Equal(core.StringPtr("testString")))
				Expect(publishObjectModel.ApprovalRecord).To(Equal(map[string]interface{}{"anyKey": "anyValue"}))
				Expect(publishObjectModel.PermitIBMPublicPublish).To(Equal(core.BoolPtr(true)))
				Expect(publishObjectModel.IBMApproved).To(Equal(core.BoolPtr(true)))
				Expect(publishObjectModel.PublicApproved).To(Equal(core.BoolPtr(true)))

				// Construct an instance of the State model
				stateModel := new(catalogmanagementv1.State)
				Expect(stateModel).ToNot(BeNil())
				stateModel.Current = core.StringPtr("testString")
				stateModel.CurrentEntered = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Pending = core.StringPtr("testString")
				stateModel.PendingRequested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Previous = core.StringPtr("testString")
				Expect(stateModel.Current).To(Equal(core.StringPtr("testString")))
				Expect(stateModel.CurrentEntered).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(stateModel.Pending).To(Equal(core.StringPtr("testString")))
				Expect(stateModel.PendingRequested).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(stateModel.Previous).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the CreateObjectOptions model
				catalogIdentifier := "testString"
				createObjectOptionsModel := catalogManagementService.NewCreateObjectOptions(catalogIdentifier)
				createObjectOptionsModel.SetCatalogIdentifier("testString")
				createObjectOptionsModel.SetName("testString")
				createObjectOptionsModel.SetCRN("testString")
				createObjectOptionsModel.SetURL("testString")
				createObjectOptionsModel.SetParentID("testString")
				createObjectOptionsModel.SetLabelI18n(map[string]string{"key1": "testString"})
				createObjectOptionsModel.SetLabel("testString")
				createObjectOptionsModel.SetTags([]string{"testString"})
				createObjectOptionsModel.SetCreated(CreateMockDateTime("2019-01-01T12:00:00.000Z"))
				createObjectOptionsModel.SetUpdated(CreateMockDateTime("2019-01-01T12:00:00.000Z"))
				createObjectOptionsModel.SetShortDescription("testString")
				createObjectOptionsModel.SetShortDescriptionI18n(map[string]string{"key1": "testString"})
				createObjectOptionsModel.SetKind("testString")
				createObjectOptionsModel.SetPublish(publishObjectModel)
				createObjectOptionsModel.SetState(stateModel)
				createObjectOptionsModel.SetCatalogID("testString")
				createObjectOptionsModel.SetCatalogName("testString")
				createObjectOptionsModel.SetData(map[string]interface{}{"anyKey": "anyValue"})
				createObjectOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(createObjectOptionsModel).ToNot(BeNil())
				Expect(createObjectOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(createObjectOptionsModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(createObjectOptionsModel.CRN).To(Equal(core.StringPtr("testString")))
				Expect(createObjectOptionsModel.URL).To(Equal(core.StringPtr("testString")))
				Expect(createObjectOptionsModel.ParentID).To(Equal(core.StringPtr("testString")))
				Expect(createObjectOptionsModel.LabelI18n).To(Equal(map[string]string{"key1": "testString"}))
				Expect(createObjectOptionsModel.Label).To(Equal(core.StringPtr("testString")))
				Expect(createObjectOptionsModel.Tags).To(Equal([]string{"testString"}))
				Expect(createObjectOptionsModel.Created).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(createObjectOptionsModel.Updated).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(createObjectOptionsModel.ShortDescription).To(Equal(core.StringPtr("testString")))
				Expect(createObjectOptionsModel.ShortDescriptionI18n).To(Equal(map[string]string{"key1": "testString"}))
				Expect(createObjectOptionsModel.Kind).To(Equal(core.StringPtr("testString")))
				Expect(createObjectOptionsModel.Publish).To(Equal(publishObjectModel))
				Expect(createObjectOptionsModel.State).To(Equal(stateModel))
				Expect(createObjectOptionsModel.CatalogID).To(Equal(core.StringPtr("testString")))
				Expect(createObjectOptionsModel.CatalogName).To(Equal(core.StringPtr("testString")))
				Expect(createObjectOptionsModel.Data).To(Equal(map[string]interface{}{"anyKey": "anyValue"}))
				Expect(createObjectOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewCreateOfferingInstanceOptions successfully`, func() {
				// Construct an instance of the OfferingInstanceLastOperation model
				offeringInstanceLastOperationModel := new(catalogmanagementv1.OfferingInstanceLastOperation)
				Expect(offeringInstanceLastOperationModel).ToNot(BeNil())
				offeringInstanceLastOperationModel.Operation = core.StringPtr("testString")
				offeringInstanceLastOperationModel.State = core.StringPtr("testString")
				offeringInstanceLastOperationModel.Message = core.StringPtr("testString")
				offeringInstanceLastOperationModel.TransactionID = core.StringPtr("testString")
				offeringInstanceLastOperationModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				offeringInstanceLastOperationModel.Code = core.StringPtr("testString")
				Expect(offeringInstanceLastOperationModel.Operation).To(Equal(core.StringPtr("testString")))
				Expect(offeringInstanceLastOperationModel.State).To(Equal(core.StringPtr("testString")))
				Expect(offeringInstanceLastOperationModel.Message).To(Equal(core.StringPtr("testString")))
				Expect(offeringInstanceLastOperationModel.TransactionID).To(Equal(core.StringPtr("testString")))
				Expect(offeringInstanceLastOperationModel.Updated).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(offeringInstanceLastOperationModel.Code).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the CreateOfferingInstanceOptions model
				xAuthRefreshToken := "testString"
				createOfferingInstanceOptionsModel := catalogManagementService.NewCreateOfferingInstanceOptions(xAuthRefreshToken)
				createOfferingInstanceOptionsModel.SetXAuthRefreshToken("testString")
				createOfferingInstanceOptionsModel.SetID("testString")
				createOfferingInstanceOptionsModel.SetRev("testString")
				createOfferingInstanceOptionsModel.SetURL("testString")
				createOfferingInstanceOptionsModel.SetCRN("testString")
				createOfferingInstanceOptionsModel.SetLabel("testString")
				createOfferingInstanceOptionsModel.SetCatalogID("testString")
				createOfferingInstanceOptionsModel.SetOfferingID("testString")
				createOfferingInstanceOptionsModel.SetKindFormat("testString")
				createOfferingInstanceOptionsModel.SetKindFormatLabel("testString")
				createOfferingInstanceOptionsModel.SetVersion("testString")
				createOfferingInstanceOptionsModel.SetVersionID("testString")
				createOfferingInstanceOptionsModel.SetClusterID("testString")
				createOfferingInstanceOptionsModel.SetClusterRegion("testString")
				createOfferingInstanceOptionsModel.SetClusterNamespaces([]string{"testString"})
				createOfferingInstanceOptionsModel.SetClusterAllNamespaces(true)
				createOfferingInstanceOptionsModel.SetSchematicsWorkspaceID("testString")
				createOfferingInstanceOptionsModel.SetInstallPlan("testString")
				createOfferingInstanceOptionsModel.SetChannel("testString")
				createOfferingInstanceOptionsModel.SetCreated(CreateMockDateTime("2019-01-01T12:00:00.000Z"))
				createOfferingInstanceOptionsModel.SetUpdated(CreateMockDateTime("2019-01-01T12:00:00.000Z"))
				createOfferingInstanceOptionsModel.SetMetadata(map[string]interface{}{"anyKey": "anyValue"})
				createOfferingInstanceOptionsModel.SetResourceGroupID("testString")
				createOfferingInstanceOptionsModel.SetLocation("testString")
				createOfferingInstanceOptionsModel.SetDisabled(true)
				createOfferingInstanceOptionsModel.SetAccount("testString")
				createOfferingInstanceOptionsModel.SetLastOperation(offeringInstanceLastOperationModel)
				createOfferingInstanceOptionsModel.SetKindTarget("testString")
				createOfferingInstanceOptionsModel.SetKindTargetLabel("testString")
				createOfferingInstanceOptionsModel.SetSha("testString")
				createOfferingInstanceOptionsModel.SetPlanID("testString")
				createOfferingInstanceOptionsModel.SetParentCRN("testString")
				createOfferingInstanceOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(createOfferingInstanceOptionsModel).ToNot(BeNil())
				Expect(createOfferingInstanceOptionsModel.XAuthRefreshToken).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingInstanceOptionsModel.ID).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingInstanceOptionsModel.Rev).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingInstanceOptionsModel.URL).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingInstanceOptionsModel.CRN).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingInstanceOptionsModel.Label).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingInstanceOptionsModel.CatalogID).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingInstanceOptionsModel.OfferingID).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingInstanceOptionsModel.KindFormat).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingInstanceOptionsModel.KindFormatLabel).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingInstanceOptionsModel.Version).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingInstanceOptionsModel.VersionID).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingInstanceOptionsModel.ClusterID).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingInstanceOptionsModel.ClusterRegion).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingInstanceOptionsModel.ClusterNamespaces).To(Equal([]string{"testString"}))
				Expect(createOfferingInstanceOptionsModel.ClusterAllNamespaces).To(Equal(core.BoolPtr(true)))
				Expect(createOfferingInstanceOptionsModel.SchematicsWorkspaceID).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingInstanceOptionsModel.InstallPlan).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingInstanceOptionsModel.Channel).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingInstanceOptionsModel.Created).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(createOfferingInstanceOptionsModel.Updated).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(createOfferingInstanceOptionsModel.Metadata).To(Equal(map[string]interface{}{"anyKey": "anyValue"}))
				Expect(createOfferingInstanceOptionsModel.ResourceGroupID).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingInstanceOptionsModel.Location).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingInstanceOptionsModel.Disabled).To(Equal(core.BoolPtr(true)))
				Expect(createOfferingInstanceOptionsModel.Account).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingInstanceOptionsModel.LastOperation).To(Equal(offeringInstanceLastOperationModel))
				Expect(createOfferingInstanceOptionsModel.KindTarget).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingInstanceOptionsModel.KindTargetLabel).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingInstanceOptionsModel.Sha).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingInstanceOptionsModel.PlanID).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingInstanceOptionsModel.ParentCRN).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingInstanceOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewCreateOfferingOptions successfully`, func() {
				// Construct an instance of the Rating model
				ratingModel := new(catalogmanagementv1.Rating)
				Expect(ratingModel).ToNot(BeNil())
				ratingModel.OneStarCount = core.Int64Ptr(int64(38))
				ratingModel.TwoStarCount = core.Int64Ptr(int64(38))
				ratingModel.ThreeStarCount = core.Int64Ptr(int64(38))
				ratingModel.FourStarCount = core.Int64Ptr(int64(38))
				Expect(ratingModel.OneStarCount).To(Equal(core.Int64Ptr(int64(38))))
				Expect(ratingModel.TwoStarCount).To(Equal(core.Int64Ptr(int64(38))))
				Expect(ratingModel.ThreeStarCount).To(Equal(core.Int64Ptr(int64(38))))
				Expect(ratingModel.FourStarCount).To(Equal(core.Int64Ptr(int64(38))))

				// Construct an instance of the Feature model
				featureModel := new(catalogmanagementv1.Feature)
				Expect(featureModel).ToNot(BeNil())
				featureModel.Title = core.StringPtr("testString")
				featureModel.TitleI18n = map[string]string{"key1": "testString"}
				featureModel.Description = core.StringPtr("testString")
				featureModel.DescriptionI18n = map[string]string{"key1": "testString"}
				Expect(featureModel.Title).To(Equal(core.StringPtr("testString")))
				Expect(featureModel.TitleI18n).To(Equal(map[string]string{"key1": "testString"}))
				Expect(featureModel.Description).To(Equal(core.StringPtr("testString")))
				Expect(featureModel.DescriptionI18n).To(Equal(map[string]string{"key1": "testString"}))

				// Construct an instance of the Flavor model
				flavorModel := new(catalogmanagementv1.Flavor)
				Expect(flavorModel).ToNot(BeNil())
				flavorModel.Name = core.StringPtr("testString")
				flavorModel.Label = core.StringPtr("testString")
				flavorModel.LabelI18n = map[string]string{"key1": "testString"}
				flavorModel.Index = core.Int64Ptr(int64(38))
				Expect(flavorModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(flavorModel.Label).To(Equal(core.StringPtr("testString")))
				Expect(flavorModel.LabelI18n).To(Equal(map[string]string{"key1": "testString"}))
				Expect(flavorModel.Index).To(Equal(core.Int64Ptr(int64(38))))

				// Construct an instance of the RenderTypeAssociationsParametersItem model
				renderTypeAssociationsParametersItemModel := new(catalogmanagementv1.RenderTypeAssociationsParametersItem)
				Expect(renderTypeAssociationsParametersItemModel).ToNot(BeNil())
				renderTypeAssociationsParametersItemModel.Name = core.StringPtr("testString")
				renderTypeAssociationsParametersItemModel.OptionsRefresh = core.BoolPtr(true)
				Expect(renderTypeAssociationsParametersItemModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(renderTypeAssociationsParametersItemModel.OptionsRefresh).To(Equal(core.BoolPtr(true)))

				// Construct an instance of the RenderTypeAssociations model
				renderTypeAssociationsModel := new(catalogmanagementv1.RenderTypeAssociations)
				Expect(renderTypeAssociationsModel).ToNot(BeNil())
				renderTypeAssociationsModel.Parameters = []catalogmanagementv1.RenderTypeAssociationsParametersItem{*renderTypeAssociationsParametersItemModel}
				Expect(renderTypeAssociationsModel.Parameters).To(Equal([]catalogmanagementv1.RenderTypeAssociationsParametersItem{*renderTypeAssociationsParametersItemModel}))

				// Construct an instance of the RenderType model
				renderTypeModel := new(catalogmanagementv1.RenderType)
				Expect(renderTypeModel).ToNot(BeNil())
				renderTypeModel.Type = core.StringPtr("testString")
				renderTypeModel.Grouping = core.StringPtr("testString")
				renderTypeModel.OriginalGrouping = core.StringPtr("testString")
				renderTypeModel.GroupingIndex = core.Int64Ptr(int64(38))
				renderTypeModel.ConfigConstraints = map[string]interface{}{"anyKey": "anyValue"}
				renderTypeModel.Associations = renderTypeAssociationsModel
				Expect(renderTypeModel.Type).To(Equal(core.StringPtr("testString")))
				Expect(renderTypeModel.Grouping).To(Equal(core.StringPtr("testString")))
				Expect(renderTypeModel.OriginalGrouping).To(Equal(core.StringPtr("testString")))
				Expect(renderTypeModel.GroupingIndex).To(Equal(core.Int64Ptr(int64(38))))
				Expect(renderTypeModel.ConfigConstraints).To(Equal(map[string]interface{}{"anyKey": "anyValue"}))
				Expect(renderTypeModel.Associations).To(Equal(renderTypeAssociationsModel))

				// Construct an instance of the Configuration model
				configurationModel := new(catalogmanagementv1.Configuration)
				Expect(configurationModel).ToNot(BeNil())
				configurationModel.Key = core.StringPtr("testString")
				configurationModel.Type = core.StringPtr("testString")
				configurationModel.DefaultValue = "testString"
				configurationModel.DisplayName = core.StringPtr("testString")
				configurationModel.ValueConstraint = core.StringPtr("testString")
				configurationModel.Description = core.StringPtr("testString")
				configurationModel.Required = core.BoolPtr(true)
				configurationModel.Options = []interface{}{"testString"}
				configurationModel.Hidden = core.BoolPtr(true)
				configurationModel.CustomConfig = renderTypeModel
				configurationModel.TypeMetadata = core.StringPtr("testString")
				Expect(configurationModel.Key).To(Equal(core.StringPtr("testString")))
				Expect(configurationModel.Type).To(Equal(core.StringPtr("testString")))
				Expect(configurationModel.DefaultValue).To(Equal("testString"))
				Expect(configurationModel.DisplayName).To(Equal(core.StringPtr("testString")))
				Expect(configurationModel.ValueConstraint).To(Equal(core.StringPtr("testString")))
				Expect(configurationModel.Description).To(Equal(core.StringPtr("testString")))
				Expect(configurationModel.Required).To(Equal(core.BoolPtr(true)))
				Expect(configurationModel.Options).To(Equal([]interface{}{"testString"}))
				Expect(configurationModel.Hidden).To(Equal(core.BoolPtr(true)))
				Expect(configurationModel.CustomConfig).To(Equal(renderTypeModel))
				Expect(configurationModel.TypeMetadata).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the Output model
				outputModel := new(catalogmanagementv1.Output)
				Expect(outputModel).ToNot(BeNil())
				outputModel.Key = core.StringPtr("testString")
				outputModel.Description = core.StringPtr("testString")
				Expect(outputModel.Key).To(Equal(core.StringPtr("testString")))
				Expect(outputModel.Description).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the IamResource model
				iamResourceModel := new(catalogmanagementv1.IamResource)
				Expect(iamResourceModel).ToNot(BeNil())
				iamResourceModel.Name = core.StringPtr("testString")
				iamResourceModel.Description = core.StringPtr("testString")
				iamResourceModel.RoleCrns = []string{"testString"}
				Expect(iamResourceModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(iamResourceModel.Description).To(Equal(core.StringPtr("testString")))
				Expect(iamResourceModel.RoleCrns).To(Equal([]string{"testString"}))

				// Construct an instance of the IamPermission model
				iamPermissionModel := new(catalogmanagementv1.IamPermission)
				Expect(iamPermissionModel).ToNot(BeNil())
				iamPermissionModel.ServiceName = core.StringPtr("testString")
				iamPermissionModel.RoleCrns = []string{"testString"}
				iamPermissionModel.Resources = []catalogmanagementv1.IamResource{*iamResourceModel}
				Expect(iamPermissionModel.ServiceName).To(Equal(core.StringPtr("testString")))
				Expect(iamPermissionModel.RoleCrns).To(Equal([]string{"testString"}))
				Expect(iamPermissionModel.Resources).To(Equal([]catalogmanagementv1.IamResource{*iamResourceModel}))

				// Construct an instance of the Validation model
				validationModel := new(catalogmanagementv1.Validation)
				Expect(validationModel).ToNot(BeNil())
				validationModel.Validated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				validationModel.Requested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				validationModel.State = core.StringPtr("testString")
				validationModel.LastOperation = core.StringPtr("testString")
				validationModel.Target = map[string]interface{}{"anyKey": "anyValue"}
				validationModel.Message = core.StringPtr("testString")
				Expect(validationModel.Validated).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(validationModel.Requested).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(validationModel.State).To(Equal(core.StringPtr("testString")))
				Expect(validationModel.LastOperation).To(Equal(core.StringPtr("testString")))
				Expect(validationModel.Target).To(Equal(map[string]interface{}{"anyKey": "anyValue"}))
				Expect(validationModel.Message).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the Resource model
				resourceModel := new(catalogmanagementv1.Resource)
				Expect(resourceModel).ToNot(BeNil())
				resourceModel.Type = core.StringPtr("mem")
				resourceModel.Value = "testString"
				Expect(resourceModel.Type).To(Equal(core.StringPtr("mem")))
				Expect(resourceModel.Value).To(Equal("testString"))

				// Construct an instance of the SchematicsEnvValues model
				schematicsEnvValuesModel := new(catalogmanagementv1.SchematicsEnvValues)
				Expect(schematicsEnvValuesModel).ToNot(BeNil())
				schematicsEnvValuesModel.Value = core.StringPtr("[{\"name\": \"TF_LOG\",\"value\": \"TRACE\",\"secure\": false,\"hidden\": false}]")
				schematicsEnvValuesModel.SmRef = core.StringPtr("cmsm_v1:{\"name\": \"envVarSecret\",\"id\":\"1234567890\",\"service_id\":\"crn:v1:bluemix:public:secrets-manager:eu-gb:a/1234567890:1234567890::\",\"service_name\":\"My SM Instance\",\"group_id\":\"1234567890\",\"group_name\":\"My SM Group\",\"resource_group_id\":\"1234567890\",\"region\":\"eu-gb\",\"type\":\"arbitrary\"}")
				Expect(schematicsEnvValuesModel.Value).To(Equal(core.StringPtr("[{\"name\": \"TF_LOG\",\"value\": \"TRACE\",\"secure\": false,\"hidden\": false}]")))
				Expect(schematicsEnvValuesModel.SmRef).To(Equal(core.StringPtr("cmsm_v1:{\"name\": \"envVarSecret\",\"id\":\"1234567890\",\"service_id\":\"crn:v1:bluemix:public:secrets-manager:eu-gb:a/1234567890:1234567890::\",\"service_name\":\"My SM Instance\",\"group_id\":\"1234567890\",\"group_name\":\"My SM Group\",\"resource_group_id\":\"1234567890\",\"region\":\"eu-gb\",\"type\":\"arbitrary\"}")))

				// Construct an instance of the Script model
				scriptModel := new(catalogmanagementv1.Script)
				Expect(scriptModel).ToNot(BeNil())
				scriptModel.Instructions = core.StringPtr("testString")
				scriptModel.InstructionsI18n = map[string]string{"key1": "testString"}
				scriptModel.Script = core.StringPtr("testString")
				scriptModel.ScriptPermission = core.StringPtr("testString")
				scriptModel.DeleteScript = core.StringPtr("testString")
				scriptModel.Scope = core.StringPtr("testString")
				Expect(scriptModel.Instructions).To(Equal(core.StringPtr("testString")))
				Expect(scriptModel.InstructionsI18n).To(Equal(map[string]string{"key1": "testString"}))
				Expect(scriptModel.Script).To(Equal(core.StringPtr("testString")))
				Expect(scriptModel.ScriptPermission).To(Equal(core.StringPtr("testString")))
				Expect(scriptModel.DeleteScript).To(Equal(core.StringPtr("testString")))
				Expect(scriptModel.Scope).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the ScriptRef model
				scriptRefModel := new(catalogmanagementv1.ScriptRef)
				Expect(scriptRefModel).ToNot(BeNil())
				scriptRefModel.ShortDescription = core.StringPtr("testString")
				scriptRefModel.Type = core.StringPtr("ansible")
				scriptRefModel.Path = core.StringPtr("scripts/validate-post-ansible-playbook.yaml")
				scriptRefModel.Stage = core.StringPtr("pre")
				scriptRefModel.Action = core.StringPtr("validate")
				Expect(scriptRefModel.ShortDescription).To(Equal(core.StringPtr("testString")))
				Expect(scriptRefModel.Type).To(Equal(core.StringPtr("ansible")))
				Expect(scriptRefModel.Path).To(Equal(core.StringPtr("scripts/validate-post-ansible-playbook.yaml")))
				Expect(scriptRefModel.Stage).To(Equal(core.StringPtr("pre")))
				Expect(scriptRefModel.Action).To(Equal(core.StringPtr("validate")))

				// Construct an instance of the VersionEntitlement model
				versionEntitlementModel := new(catalogmanagementv1.VersionEntitlement)
				Expect(versionEntitlementModel).ToNot(BeNil())
				versionEntitlementModel.ProviderName = core.StringPtr("testString")
				versionEntitlementModel.ProviderID = core.StringPtr("testString")
				versionEntitlementModel.ProductID = core.StringPtr("testString")
				versionEntitlementModel.PartNumbers = []string{"testString"}
				versionEntitlementModel.ImageRepoName = core.StringPtr("testString")
				Expect(versionEntitlementModel.ProviderName).To(Equal(core.StringPtr("testString")))
				Expect(versionEntitlementModel.ProviderID).To(Equal(core.StringPtr("testString")))
				Expect(versionEntitlementModel.ProductID).To(Equal(core.StringPtr("testString")))
				Expect(versionEntitlementModel.PartNumbers).To(Equal([]string{"testString"}))
				Expect(versionEntitlementModel.ImageRepoName).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the License model
				licenseModel := new(catalogmanagementv1.License)
				Expect(licenseModel).ToNot(BeNil())
				licenseModel.ID = core.StringPtr("testString")
				licenseModel.Name = core.StringPtr("testString")
				licenseModel.Type = core.StringPtr("testString")
				licenseModel.URL = core.StringPtr("testString")
				licenseModel.Description = core.StringPtr("testString")
				Expect(licenseModel.ID).To(Equal(core.StringPtr("testString")))
				Expect(licenseModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(licenseModel.Type).To(Equal(core.StringPtr("testString")))
				Expect(licenseModel.URL).To(Equal(core.StringPtr("testString")))
				Expect(licenseModel.Description).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the State model
				stateModel := new(catalogmanagementv1.State)
				Expect(stateModel).ToNot(BeNil())
				stateModel.Current = core.StringPtr("testString")
				stateModel.CurrentEntered = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Pending = core.StringPtr("testString")
				stateModel.PendingRequested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Previous = core.StringPtr("testString")
				Expect(stateModel.Current).To(Equal(core.StringPtr("testString")))
				Expect(stateModel.CurrentEntered).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(stateModel.Pending).To(Equal(core.StringPtr("testString")))
				Expect(stateModel.PendingRequested).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(stateModel.Previous).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the DeprecatePending model
				deprecatePendingModel := new(catalogmanagementv1.DeprecatePending)
				Expect(deprecatePendingModel).ToNot(BeNil())
				deprecatePendingModel.DeprecateDate = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				deprecatePendingModel.DeprecateState = core.StringPtr("testString")
				deprecatePendingModel.Description = core.StringPtr("testString")
				Expect(deprecatePendingModel.DeprecateDate).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(deprecatePendingModel.DeprecateState).To(Equal(core.StringPtr("testString")))
				Expect(deprecatePendingModel.Description).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the URLProxy model
				urlProxyModel := new(catalogmanagementv1.URLProxy)
				Expect(urlProxyModel).ToNot(BeNil())
				urlProxyModel.URL = core.StringPtr("testString")
				urlProxyModel.Sha = core.StringPtr("testString")
				Expect(urlProxyModel.URL).To(Equal(core.StringPtr("testString")))
				Expect(urlProxyModel.Sha).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the MediaItem model
				mediaItemModel := new(catalogmanagementv1.MediaItem)
				Expect(mediaItemModel).ToNot(BeNil())
				mediaItemModel.URL = core.StringPtr("testString")
				mediaItemModel.APIURL = core.StringPtr("testString")
				mediaItemModel.URLProxy = urlProxyModel
				mediaItemModel.Caption = core.StringPtr("testString")
				mediaItemModel.CaptionI18n = map[string]string{"key1": "testString"}
				mediaItemModel.Type = core.StringPtr("testString")
				mediaItemModel.ThumbnailURL = core.StringPtr("testString")
				Expect(mediaItemModel.URL).To(Equal(core.StringPtr("testString")))
				Expect(mediaItemModel.APIURL).To(Equal(core.StringPtr("testString")))
				Expect(mediaItemModel.URLProxy).To(Equal(urlProxyModel))
				Expect(mediaItemModel.Caption).To(Equal(core.StringPtr("testString")))
				Expect(mediaItemModel.CaptionI18n).To(Equal(map[string]string{"key1": "testString"}))
				Expect(mediaItemModel.Type).To(Equal(core.StringPtr("testString")))
				Expect(mediaItemModel.ThumbnailURL).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the ArchitectureDiagram model
				architectureDiagramModel := new(catalogmanagementv1.ArchitectureDiagram)
				Expect(architectureDiagramModel).ToNot(BeNil())
				architectureDiagramModel.Diagram = mediaItemModel
				architectureDiagramModel.Description = core.StringPtr("testString")
				architectureDiagramModel.DescriptionI18n = map[string]string{"key1": "testString"}
				Expect(architectureDiagramModel.Diagram).To(Equal(mediaItemModel))
				Expect(architectureDiagramModel.Description).To(Equal(core.StringPtr("testString")))
				Expect(architectureDiagramModel.DescriptionI18n).To(Equal(map[string]string{"key1": "testString"}))

				// Construct an instance of the CostComponent model
				costComponentModel := new(catalogmanagementv1.CostComponent)
				Expect(costComponentModel).ToNot(BeNil())
				costComponentModel.Name = core.StringPtr("testString")
				costComponentModel.Unit = core.StringPtr("testString")
				costComponentModel.HourlyQuantity = core.StringPtr("testString")
				costComponentModel.MonthlyQuantity = core.StringPtr("testString")
				costComponentModel.Price = core.StringPtr("testString")
				costComponentModel.HourlyCost = core.StringPtr("testString")
				costComponentModel.MonthlyCost = core.StringPtr("testString")
				Expect(costComponentModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(costComponentModel.Unit).To(Equal(core.StringPtr("testString")))
				Expect(costComponentModel.HourlyQuantity).To(Equal(core.StringPtr("testString")))
				Expect(costComponentModel.MonthlyQuantity).To(Equal(core.StringPtr("testString")))
				Expect(costComponentModel.Price).To(Equal(core.StringPtr("testString")))
				Expect(costComponentModel.HourlyCost).To(Equal(core.StringPtr("testString")))
				Expect(costComponentModel.MonthlyCost).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the CostResource model
				costResourceModel := new(catalogmanagementv1.CostResource)
				Expect(costResourceModel).ToNot(BeNil())
				costResourceModel.Name = core.StringPtr("testString")
				costResourceModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				costResourceModel.HourlyCost = core.StringPtr("testString")
				costResourceModel.MonthlyCost = core.StringPtr("testString")
				costResourceModel.CostComponents = []catalogmanagementv1.CostComponent{*costComponentModel}
				Expect(costResourceModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(costResourceModel.Metadata).To(Equal(map[string]interface{}{"anyKey": "anyValue"}))
				Expect(costResourceModel.HourlyCost).To(Equal(core.StringPtr("testString")))
				Expect(costResourceModel.MonthlyCost).To(Equal(core.StringPtr("testString")))
				Expect(costResourceModel.CostComponents).To(Equal([]catalogmanagementv1.CostComponent{*costComponentModel}))

				// Construct an instance of the CostBreakdown model
				costBreakdownModel := new(catalogmanagementv1.CostBreakdown)
				Expect(costBreakdownModel).ToNot(BeNil())
				costBreakdownModel.TotalHourlyCost = core.StringPtr("testString")
				costBreakdownModel.TotalMonthlyCost = core.StringPtr("testString")
				costBreakdownModel.Resources = []catalogmanagementv1.CostResource{*costResourceModel}
				Expect(costBreakdownModel.TotalHourlyCost).To(Equal(core.StringPtr("testString")))
				Expect(costBreakdownModel.TotalMonthlyCost).To(Equal(core.StringPtr("testString")))
				Expect(costBreakdownModel.Resources).To(Equal([]catalogmanagementv1.CostResource{*costResourceModel}))

				// Construct an instance of the CostSummary model
				costSummaryModel := new(catalogmanagementv1.CostSummary)
				Expect(costSummaryModel).ToNot(BeNil())
				costSummaryModel.TotalDetectedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalSupportedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalUnsupportedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalUsageBasedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalNoPriceResources = core.Int64Ptr(int64(38))
				costSummaryModel.UnsupportedResourceCounts = map[string]int64{"key1": int64(38)}
				costSummaryModel.NoPriceResourceCounts = map[string]int64{"key1": int64(38)}
				Expect(costSummaryModel.TotalDetectedResources).To(Equal(core.Int64Ptr(int64(38))))
				Expect(costSummaryModel.TotalSupportedResources).To(Equal(core.Int64Ptr(int64(38))))
				Expect(costSummaryModel.TotalUnsupportedResources).To(Equal(core.Int64Ptr(int64(38))))
				Expect(costSummaryModel.TotalUsageBasedResources).To(Equal(core.Int64Ptr(int64(38))))
				Expect(costSummaryModel.TotalNoPriceResources).To(Equal(core.Int64Ptr(int64(38))))
				Expect(costSummaryModel.UnsupportedResourceCounts).To(Equal(map[string]int64{"key1": int64(38)}))
				Expect(costSummaryModel.NoPriceResourceCounts).To(Equal(map[string]int64{"key1": int64(38)}))

				// Construct an instance of the Project model
				projectModel := new(catalogmanagementv1.Project)
				Expect(projectModel).ToNot(BeNil())
				projectModel.Name = core.StringPtr("testString")
				projectModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				projectModel.PastBreakdown = costBreakdownModel
				projectModel.Breakdown = costBreakdownModel
				projectModel.Diff = costBreakdownModel
				projectModel.Summary = costSummaryModel
				Expect(projectModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(projectModel.Metadata).To(Equal(map[string]interface{}{"anyKey": "anyValue"}))
				Expect(projectModel.PastBreakdown).To(Equal(costBreakdownModel))
				Expect(projectModel.Breakdown).To(Equal(costBreakdownModel))
				Expect(projectModel.Diff).To(Equal(costBreakdownModel))
				Expect(projectModel.Summary).To(Equal(costSummaryModel))

				// Construct an instance of the CostEstimate model
				costEstimateModel := new(catalogmanagementv1.CostEstimate)
				Expect(costEstimateModel).ToNot(BeNil())
				costEstimateModel.Version = core.StringPtr("testString")
				costEstimateModel.Currency = core.StringPtr("testString")
				costEstimateModel.Projects = []catalogmanagementv1.Project{*projectModel}
				costEstimateModel.Summary = costSummaryModel
				costEstimateModel.TotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.TotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.PastTotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.PastTotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.DiffTotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.DiffTotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.TimeGenerated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				Expect(costEstimateModel.Version).To(Equal(core.StringPtr("testString")))
				Expect(costEstimateModel.Currency).To(Equal(core.StringPtr("testString")))
				Expect(costEstimateModel.Projects).To(Equal([]catalogmanagementv1.Project{*projectModel}))
				Expect(costEstimateModel.Summary).To(Equal(costSummaryModel))
				Expect(costEstimateModel.TotalHourlyCost).To(Equal(core.StringPtr("testString")))
				Expect(costEstimateModel.TotalMonthlyCost).To(Equal(core.StringPtr("testString")))
				Expect(costEstimateModel.PastTotalHourlyCost).To(Equal(core.StringPtr("testString")))
				Expect(costEstimateModel.PastTotalMonthlyCost).To(Equal(core.StringPtr("testString")))
				Expect(costEstimateModel.DiffTotalHourlyCost).To(Equal(core.StringPtr("testString")))
				Expect(costEstimateModel.DiffTotalMonthlyCost).To(Equal(core.StringPtr("testString")))
				Expect(costEstimateModel.TimeGenerated).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))

				// Construct an instance of the OfferingReference model
				offeringReferenceModel := new(catalogmanagementv1.OfferingReference)
				Expect(offeringReferenceModel).ToNot(BeNil())
				offeringReferenceModel.CatalogID = core.StringPtr("testString")
				offeringReferenceModel.ID = core.StringPtr("testString")
				offeringReferenceModel.Name = core.StringPtr("testString")
				offeringReferenceModel.Kind = core.StringPtr("testString")
				offeringReferenceModel.Version = core.StringPtr("testString")
				offeringReferenceModel.Description = core.StringPtr("testString")
				offeringReferenceModel.DefaultFlavor = core.StringPtr("testString")
				offeringReferenceModel.Flavors = []string{"testString"}
				offeringReferenceModel.Optional = core.BoolPtr(true)
				offeringReferenceModel.OnByDefault = core.BoolPtr(true)
				Expect(offeringReferenceModel.CatalogID).To(Equal(core.StringPtr("testString")))
				Expect(offeringReferenceModel.ID).To(Equal(core.StringPtr("testString")))
				Expect(offeringReferenceModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(offeringReferenceModel.Kind).To(Equal(core.StringPtr("testString")))
				Expect(offeringReferenceModel.Version).To(Equal(core.StringPtr("testString")))
				Expect(offeringReferenceModel.Description).To(Equal(core.StringPtr("testString")))
				Expect(offeringReferenceModel.DefaultFlavor).To(Equal(core.StringPtr("testString")))
				Expect(offeringReferenceModel.Flavors).To(Equal([]string{"testString"}))
				Expect(offeringReferenceModel.Optional).To(Equal(core.BoolPtr(true)))
				Expect(offeringReferenceModel.OnByDefault).To(Equal(core.BoolPtr(true)))

				// Construct an instance of the SolutionInfo model
				solutionInfoModel := new(catalogmanagementv1.SolutionInfo)
				Expect(solutionInfoModel).ToNot(BeNil())
				solutionInfoModel.ArchitectureDiagrams = []catalogmanagementv1.ArchitectureDiagram{*architectureDiagramModel}
				solutionInfoModel.Features = []catalogmanagementv1.Feature{*featureModel}
				solutionInfoModel.CostEstimate = costEstimateModel
				solutionInfoModel.Dependencies = []catalogmanagementv1.OfferingReference{*offeringReferenceModel}
				solutionInfoModel.InstallType = core.StringPtr("testString")
				Expect(solutionInfoModel.ArchitectureDiagrams).To(Equal([]catalogmanagementv1.ArchitectureDiagram{*architectureDiagramModel}))
				Expect(solutionInfoModel.Features).To(Equal([]catalogmanagementv1.Feature{*featureModel}))
				Expect(solutionInfoModel.CostEstimate).To(Equal(costEstimateModel))
				Expect(solutionInfoModel.Dependencies).To(Equal([]catalogmanagementv1.OfferingReference{*offeringReferenceModel}))
				Expect(solutionInfoModel.InstallType).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the SccProfile model
				sccProfileModel := new(catalogmanagementv1.SccProfile)
				Expect(sccProfileModel).ToNot(BeNil())
				sccProfileModel.ID = core.StringPtr("testString")
				sccProfileModel.Name = core.StringPtr("testString")
				sccProfileModel.Version = core.StringPtr("testString")
				sccProfileModel.Description = core.StringPtr("testString")
				sccProfileModel.Type = core.StringPtr("testString")
				sccProfileModel.UIHref = core.StringPtr("testString")
				Expect(sccProfileModel.ID).To(Equal(core.StringPtr("testString")))
				Expect(sccProfileModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(sccProfileModel.Version).To(Equal(core.StringPtr("testString")))
				Expect(sccProfileModel.Description).To(Equal(core.StringPtr("testString")))
				Expect(sccProfileModel.Type).To(Equal(core.StringPtr("testString")))
				Expect(sccProfileModel.UIHref).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the ClaimedControl model
				claimedControlModel := new(catalogmanagementv1.ClaimedControl)
				Expect(claimedControlModel).ToNot(BeNil())
				claimedControlModel.Profile = sccProfileModel
				claimedControlModel.Names = []string{"testString"}
				Expect(claimedControlModel.Profile).To(Equal(sccProfileModel))
				Expect(claimedControlModel.Names).To(Equal([]string{"testString"}))

				// Construct an instance of the Claims model
				claimsModel := new(catalogmanagementv1.Claims)
				Expect(claimsModel).ToNot(BeNil())
				claimsModel.Profiles = []catalogmanagementv1.SccProfile{*sccProfileModel}
				claimsModel.Controls = []catalogmanagementv1.ClaimedControl{*claimedControlModel}
				Expect(claimsModel.Profiles).To(Equal([]catalogmanagementv1.SccProfile{*sccProfileModel}))
				Expect(claimsModel.Controls).To(Equal([]catalogmanagementv1.ClaimedControl{*claimedControlModel}))

				// Construct an instance of the Result model
				resultModel := new(catalogmanagementv1.Result)
				Expect(resultModel).ToNot(BeNil())
				resultModel.FailureCount = core.Int64Ptr(int64(38))
				resultModel.ScanTime = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				resultModel.ErrorMessage = core.StringPtr("testString")
				resultModel.CompleteScan = core.BoolPtr(true)
				resultModel.UnscannedResources = []string{"testString"}
				Expect(resultModel.FailureCount).To(Equal(core.Int64Ptr(int64(38))))
				Expect(resultModel.ScanTime).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(resultModel.ErrorMessage).To(Equal(core.StringPtr("testString")))
				Expect(resultModel.CompleteScan).To(Equal(core.BoolPtr(true)))
				Expect(resultModel.UnscannedResources).To(Equal([]string{"testString"}))

				// Construct an instance of the SccAssessment model
				sccAssessmentModel := new(catalogmanagementv1.SccAssessment)
				Expect(sccAssessmentModel).ToNot(BeNil())
				sccAssessmentModel.ID = core.StringPtr("testString")
				sccAssessmentModel.Description = core.StringPtr("testString")
				sccAssessmentModel.Version = core.StringPtr("testString")
				sccAssessmentModel.Type = core.StringPtr("testString")
				sccAssessmentModel.Method = core.StringPtr("testString")
				sccAssessmentModel.UIHref = core.StringPtr("testString")
				Expect(sccAssessmentModel.ID).To(Equal(core.StringPtr("testString")))
				Expect(sccAssessmentModel.Description).To(Equal(core.StringPtr("testString")))
				Expect(sccAssessmentModel.Version).To(Equal(core.StringPtr("testString")))
				Expect(sccAssessmentModel.Type).To(Equal(core.StringPtr("testString")))
				Expect(sccAssessmentModel.Method).To(Equal(core.StringPtr("testString")))
				Expect(sccAssessmentModel.UIHref).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the SccSpecification model
				sccSpecificationModel := new(catalogmanagementv1.SccSpecification)
				Expect(sccSpecificationModel).ToNot(BeNil())
				sccSpecificationModel.ID = core.StringPtr("testString")
				sccSpecificationModel.Description = core.StringPtr("testString")
				sccSpecificationModel.ComponentName = core.StringPtr("testString")
				sccSpecificationModel.Assessments = []catalogmanagementv1.SccAssessment{*sccAssessmentModel}
				sccSpecificationModel.UIHref = core.StringPtr("testString")
				Expect(sccSpecificationModel.ID).To(Equal(core.StringPtr("testString")))
				Expect(sccSpecificationModel.Description).To(Equal(core.StringPtr("testString")))
				Expect(sccSpecificationModel.ComponentName).To(Equal(core.StringPtr("testString")))
				Expect(sccSpecificationModel.Assessments).To(Equal([]catalogmanagementv1.SccAssessment{*sccAssessmentModel}))
				Expect(sccSpecificationModel.UIHref).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the SccControl model
				sccControlModel := new(catalogmanagementv1.SccControl)
				Expect(sccControlModel).ToNot(BeNil())
				sccControlModel.ID = core.StringPtr("testString")
				sccControlModel.Name = core.StringPtr("testString")
				sccControlModel.Version = core.StringPtr("testString")
				sccControlModel.Description = core.StringPtr("testString")
				sccControlModel.Profile = sccProfileModel
				sccControlModel.ParentName = core.StringPtr("testString")
				sccControlModel.Specifications = []catalogmanagementv1.SccSpecification{*sccSpecificationModel}
				sccControlModel.UIHref = core.StringPtr("testString")
				Expect(sccControlModel.ID).To(Equal(core.StringPtr("testString")))
				Expect(sccControlModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(sccControlModel.Version).To(Equal(core.StringPtr("testString")))
				Expect(sccControlModel.Description).To(Equal(core.StringPtr("testString")))
				Expect(sccControlModel.Profile).To(Equal(sccProfileModel))
				Expect(sccControlModel.ParentName).To(Equal(core.StringPtr("testString")))
				Expect(sccControlModel.Specifications).To(Equal([]catalogmanagementv1.SccSpecification{*sccSpecificationModel}))
				Expect(sccControlModel.UIHref).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the EvaluatedControl model
				evaluatedControlModel := new(catalogmanagementv1.EvaluatedControl)
				Expect(evaluatedControlModel).ToNot(BeNil())
				evaluatedControlModel.ID = core.StringPtr("testString")
				evaluatedControlModel.Name = core.StringPtr("testString")
				evaluatedControlModel.Description = core.StringPtr("testString")
				evaluatedControlModel.Specifications = []catalogmanagementv1.SccSpecification{*sccSpecificationModel}
				evaluatedControlModel.FailureCount = core.Int64Ptr(int64(38))
				evaluatedControlModel.PassCount = core.Int64Ptr(int64(38))
				evaluatedControlModel.Parent = sccControlModel
				evaluatedControlModel.UIHref = core.StringPtr("testString")
				Expect(evaluatedControlModel.ID).To(Equal(core.StringPtr("testString")))
				Expect(evaluatedControlModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(evaluatedControlModel.Description).To(Equal(core.StringPtr("testString")))
				Expect(evaluatedControlModel.Specifications).To(Equal([]catalogmanagementv1.SccSpecification{*sccSpecificationModel}))
				Expect(evaluatedControlModel.FailureCount).To(Equal(core.Int64Ptr(int64(38))))
				Expect(evaluatedControlModel.PassCount).To(Equal(core.Int64Ptr(int64(38))))
				Expect(evaluatedControlModel.Parent).To(Equal(sccControlModel))
				Expect(evaluatedControlModel.UIHref).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the Evaluation model
				evaluationModel := new(catalogmanagementv1.Evaluation)
				Expect(evaluationModel).ToNot(BeNil())
				evaluationModel.ScanID = core.StringPtr("testString")
				evaluationModel.AccountID = core.StringPtr("testString")
				evaluationModel.Profile = sccProfileModel
				evaluationModel.Result = resultModel
				evaluationModel.Controls = []catalogmanagementv1.EvaluatedControl{*evaluatedControlModel}
				Expect(evaluationModel.ScanID).To(Equal(core.StringPtr("testString")))
				Expect(evaluationModel.AccountID).To(Equal(core.StringPtr("testString")))
				Expect(evaluationModel.Profile).To(Equal(sccProfileModel))
				Expect(evaluationModel.Result).To(Equal(resultModel))
				Expect(evaluationModel.Controls).To(Equal([]catalogmanagementv1.EvaluatedControl{*evaluatedControlModel}))

				// Construct an instance of the Compliance model
				complianceModel := new(catalogmanagementv1.Compliance)
				Expect(complianceModel).ToNot(BeNil())
				complianceModel.Authority = core.StringPtr("testString")
				complianceModel.Claims = claimsModel
				complianceModel.Evaluations = []catalogmanagementv1.Evaluation{*evaluationModel}
				Expect(complianceModel.Authority).To(Equal(core.StringPtr("testString")))
				Expect(complianceModel.Claims).To(Equal(claimsModel))
				Expect(complianceModel.Evaluations).To(Equal([]catalogmanagementv1.Evaluation{*evaluationModel}))

				// Construct an instance of the ChangeNotices model
				changeNoticesModel := new(catalogmanagementv1.ChangeNotices)
				Expect(changeNoticesModel).ToNot(BeNil())
				changeNoticesModel.Breaking = []catalogmanagementv1.Feature{*featureModel}
				changeNoticesModel.New = []catalogmanagementv1.Feature{*featureModel}
				changeNoticesModel.Update = []catalogmanagementv1.Feature{*featureModel}
				Expect(changeNoticesModel.Breaking).To(Equal([]catalogmanagementv1.Feature{*featureModel}))
				Expect(changeNoticesModel.New).To(Equal([]catalogmanagementv1.Feature{*featureModel}))
				Expect(changeNoticesModel.Update).To(Equal([]catalogmanagementv1.Feature{*featureModel}))

				// Construct an instance of the Version model
				versionModel := new(catalogmanagementv1.Version)
				Expect(versionModel).ToNot(BeNil())
				versionModel.CRN = core.StringPtr("testString")
				versionModel.Version = core.StringPtr("testString")
				versionModel.Flavor = flavorModel
				versionModel.Sha = core.StringPtr("testString")
				versionModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				versionModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				versionModel.OfferingID = core.StringPtr("testString")
				versionModel.CatalogID = core.StringPtr("testString")
				versionModel.KindID = core.StringPtr("testString")
				versionModel.Tags = []string{"testString"}
				versionModel.RepoURL = core.StringPtr("testString")
				versionModel.SourceURL = core.StringPtr("testString")
				versionModel.TgzURL = core.StringPtr("testString")
				versionModel.Configuration = []catalogmanagementv1.Configuration{*configurationModel}
				versionModel.Outputs = []catalogmanagementv1.Output{*outputModel}
				versionModel.IamPermissions = []catalogmanagementv1.IamPermission{*iamPermissionModel}
				versionModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				versionModel.Validation = validationModel
				versionModel.RequiredResources = []catalogmanagementv1.Resource{*resourceModel}
				versionModel.SingleInstance = core.BoolPtr(true)
				versionModel.SchematicsEnvValues = schematicsEnvValuesModel
				versionModel.Install = scriptModel
				versionModel.PreInstall = []catalogmanagementv1.Script{*scriptModel}
				versionModel.Scripts = map[string]catalogmanagementv1.ScriptRef{"key1": *scriptRefModel}
				versionModel.Entitlement = versionEntitlementModel
				versionModel.Licenses = []catalogmanagementv1.License{*licenseModel}
				versionModel.ImageManifestURL = core.StringPtr("testString")
				versionModel.Deprecated = core.BoolPtr(true)
				versionModel.PackageVersion = core.StringPtr("testString")
				versionModel.State = stateModel
				versionModel.VersionLocator = core.StringPtr("testString")
				versionModel.LongDescription = core.StringPtr("testString")
				versionModel.LongDescriptionI18n = map[string]string{"key1": "testString"}
				versionModel.WhitelistedAccounts = []string{"testString"}
				versionModel.ImagePullKeyName = core.StringPtr("testString")
				versionModel.DeprecatePending = deprecatePendingModel
				versionModel.SolutionInfo = solutionInfoModel
				versionModel.IsConsumable = core.BoolPtr(true)
				versionModel.ComplianceV3 = complianceModel
				versionModel.ChangeNotices = changeNoticesModel
				versionModel.PlanIds = []string{"testString"}
				versionModel.Stack = map[string]interface{}{"anyKey": "anyValue"}
				versionModel.MinimumCompatibleVersion = core.StringPtr("testString")
				versionModel.Scripts["foo"] = *scriptRefModel
				Expect(versionModel.CRN).To(Equal(core.StringPtr("testString")))
				Expect(versionModel.Version).To(Equal(core.StringPtr("testString")))
				Expect(versionModel.Flavor).To(Equal(flavorModel))
				Expect(versionModel.Sha).To(Equal(core.StringPtr("testString")))
				Expect(versionModel.Created).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(versionModel.Updated).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(versionModel.OfferingID).To(Equal(core.StringPtr("testString")))
				Expect(versionModel.CatalogID).To(Equal(core.StringPtr("testString")))
				Expect(versionModel.KindID).To(Equal(core.StringPtr("testString")))
				Expect(versionModel.Tags).To(Equal([]string{"testString"}))
				Expect(versionModel.RepoURL).To(Equal(core.StringPtr("testString")))
				Expect(versionModel.SourceURL).To(Equal(core.StringPtr("testString")))
				Expect(versionModel.TgzURL).To(Equal(core.StringPtr("testString")))
				Expect(versionModel.Configuration).To(Equal([]catalogmanagementv1.Configuration{*configurationModel}))
				Expect(versionModel.Outputs).To(Equal([]catalogmanagementv1.Output{*outputModel}))
				Expect(versionModel.IamPermissions).To(Equal([]catalogmanagementv1.IamPermission{*iamPermissionModel}))
				Expect(versionModel.Metadata).To(Equal(map[string]interface{}{"anyKey": "anyValue"}))
				Expect(versionModel.Validation).To(Equal(validationModel))
				Expect(versionModel.RequiredResources).To(Equal([]catalogmanagementv1.Resource{*resourceModel}))
				Expect(versionModel.SingleInstance).To(Equal(core.BoolPtr(true)))
				Expect(versionModel.SchematicsEnvValues).To(Equal(schematicsEnvValuesModel))
				Expect(versionModel.Install).To(Equal(scriptModel))
				Expect(versionModel.PreInstall).To(Equal([]catalogmanagementv1.Script{*scriptModel}))
				Expect(versionModel.Entitlement).To(Equal(versionEntitlementModel))
				Expect(versionModel.Licenses).To(Equal([]catalogmanagementv1.License{*licenseModel}))
				Expect(versionModel.ImageManifestURL).To(Equal(core.StringPtr("testString")))
				Expect(versionModel.Deprecated).To(Equal(core.BoolPtr(true)))
				Expect(versionModel.PackageVersion).To(Equal(core.StringPtr("testString")))
				Expect(versionModel.State).To(Equal(stateModel))
				Expect(versionModel.VersionLocator).To(Equal(core.StringPtr("testString")))
				Expect(versionModel.LongDescription).To(Equal(core.StringPtr("testString")))
				Expect(versionModel.LongDescriptionI18n).To(Equal(map[string]string{"key1": "testString"}))
				Expect(versionModel.WhitelistedAccounts).To(Equal([]string{"testString"}))
				Expect(versionModel.ImagePullKeyName).To(Equal(core.StringPtr("testString")))
				Expect(versionModel.DeprecatePending).To(Equal(deprecatePendingModel))
				Expect(versionModel.SolutionInfo).To(Equal(solutionInfoModel))
				Expect(versionModel.IsConsumable).To(Equal(core.BoolPtr(true)))
				Expect(versionModel.ComplianceV3).To(Equal(complianceModel))
				Expect(versionModel.ChangeNotices).To(Equal(changeNoticesModel))
				Expect(versionModel.PlanIds).To(Equal([]string{"testString"}))
				Expect(versionModel.Stack).To(Equal(map[string]interface{}{"anyKey": "anyValue"}))
				Expect(versionModel.MinimumCompatibleVersion).To(Equal(core.StringPtr("testString")))
				Expect(versionModel.Scripts["foo"]).To(Equal(*scriptRefModel))

				// Construct an instance of the PaginationTokenLink model
				paginationTokenLinkModel := new(catalogmanagementv1.PaginationTokenLink)
				Expect(paginationTokenLinkModel).ToNot(BeNil())
				paginationTokenLinkModel.Href = core.StringPtr("testString")
				paginationTokenLinkModel.Start = core.StringPtr("testString")
				Expect(paginationTokenLinkModel.Href).To(Equal(core.StringPtr("testString")))
				Expect(paginationTokenLinkModel.Start).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the KindAllVersions model
				kindAllVersionsModel := new(catalogmanagementv1.KindAllVersions)
				Expect(kindAllVersionsModel).ToNot(BeNil())
				kindAllVersionsModel.First = paginationTokenLinkModel
				kindAllVersionsModel.Next = paginationTokenLinkModel
				Expect(kindAllVersionsModel.First).To(Equal(paginationTokenLinkModel))
				Expect(kindAllVersionsModel.Next).To(Equal(paginationTokenLinkModel))

				// Construct an instance of the Kind model
				kindModel := new(catalogmanagementv1.Kind)
				Expect(kindModel).ToNot(BeNil())
				kindModel.ID = core.StringPtr("testString")
				kindModel.FormatKind = core.StringPtr("testString")
				kindModel.FormatKindLabel = core.StringPtr("testString")
				kindModel.InstallKind = core.StringPtr("testString")
				kindModel.InstallKindLabel = core.StringPtr("testString")
				kindModel.TargetKind = core.StringPtr("testString")
				kindModel.TargetKindLabel = core.StringPtr("testString")
				kindModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				kindModel.Tags = []string{"testString"}
				kindModel.AdditionalFeatures = []catalogmanagementv1.Feature{*featureModel}
				kindModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				kindModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				kindModel.Versions = []catalogmanagementv1.Version{*versionModel}
				kindModel.AllVersions = kindAllVersionsModel
				Expect(kindModel.ID).To(Equal(core.StringPtr("testString")))
				Expect(kindModel.FormatKind).To(Equal(core.StringPtr("testString")))
				Expect(kindModel.FormatKindLabel).To(Equal(core.StringPtr("testString")))
				Expect(kindModel.InstallKind).To(Equal(core.StringPtr("testString")))
				Expect(kindModel.InstallKindLabel).To(Equal(core.StringPtr("testString")))
				Expect(kindModel.TargetKind).To(Equal(core.StringPtr("testString")))
				Expect(kindModel.TargetKindLabel).To(Equal(core.StringPtr("testString")))
				Expect(kindModel.Metadata).To(Equal(map[string]interface{}{"anyKey": "anyValue"}))
				Expect(kindModel.Tags).To(Equal([]string{"testString"}))
				Expect(kindModel.AdditionalFeatures).To(Equal([]catalogmanagementv1.Feature{*featureModel}))
				Expect(kindModel.Created).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(kindModel.Updated).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(kindModel.Versions).To(Equal([]catalogmanagementv1.Version{*versionModel}))
				Expect(kindModel.AllVersions).To(Equal(kindAllVersionsModel))

				// Construct an instance of the PublishObject model
				publishObjectModel := new(catalogmanagementv1.PublishObject)
				Expect(publishObjectModel).ToNot(BeNil())
				publishObjectModel.PcManaged = core.BoolPtr(true)
				publishObjectModel.ApprovalType = core.StringPtr("testString")
				publishObjectModel.PublishApproved = core.BoolPtr(true)
				publishObjectModel.ShareWithAll = core.BoolPtr(true)
				publishObjectModel.ShareWithIBM = core.BoolPtr(true)
				publishObjectModel.ShareEnabled = core.BoolPtr(true)
				publishObjectModel.OriginalCRN = core.StringPtr("testString")
				publishObjectModel.PublicCRN = core.StringPtr("testString")
				publishObjectModel.ApprovalRecord = map[string]interface{}{"anyKey": "anyValue"}
				publishObjectModel.PermitIBMPublicPublish = core.BoolPtr(true)
				publishObjectModel.IBMApproved = core.BoolPtr(true)
				publishObjectModel.PublicApproved = core.BoolPtr(true)
				Expect(publishObjectModel.PcManaged).To(Equal(core.BoolPtr(true)))
				Expect(publishObjectModel.ApprovalType).To(Equal(core.StringPtr("testString")))
				Expect(publishObjectModel.PublishApproved).To(Equal(core.BoolPtr(true)))
				Expect(publishObjectModel.ShareWithAll).To(Equal(core.BoolPtr(true)))
				Expect(publishObjectModel.ShareWithIBM).To(Equal(core.BoolPtr(true)))
				Expect(publishObjectModel.ShareEnabled).To(Equal(core.BoolPtr(true)))
				Expect(publishObjectModel.OriginalCRN).To(Equal(core.StringPtr("testString")))
				Expect(publishObjectModel.PublicCRN).To(Equal(core.StringPtr("testString")))
				Expect(publishObjectModel.ApprovalRecord).To(Equal(map[string]interface{}{"anyKey": "anyValue"}))
				Expect(publishObjectModel.PermitIBMPublicPublish).To(Equal(core.BoolPtr(true)))
				Expect(publishObjectModel.IBMApproved).To(Equal(core.BoolPtr(true)))
				Expect(publishObjectModel.PublicApproved).To(Equal(core.BoolPtr(true)))

				// Construct an instance of the ProviderInfo model
				providerInfoModel := new(catalogmanagementv1.ProviderInfo)
				Expect(providerInfoModel).ToNot(BeNil())
				providerInfoModel.ID = core.StringPtr("testString")
				providerInfoModel.Name = core.StringPtr("testString")
				Expect(providerInfoModel.ID).To(Equal(core.StringPtr("testString")))
				Expect(providerInfoModel.Name).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the RepoInfo model
				repoInfoModel := new(catalogmanagementv1.RepoInfo)
				Expect(repoInfoModel).ToNot(BeNil())
				repoInfoModel.Token = core.StringPtr("testString")
				repoInfoModel.Type = core.StringPtr("testString")
				Expect(repoInfoModel.Token).To(Equal(core.StringPtr("testString")))
				Expect(repoInfoModel.Type).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the ImagePullKey model
				imagePullKeyModel := new(catalogmanagementv1.ImagePullKey)
				Expect(imagePullKeyModel).ToNot(BeNil())
				imagePullKeyModel.Name = core.StringPtr("testString")
				imagePullKeyModel.Value = core.StringPtr("testString")
				imagePullKeyModel.Description = core.StringPtr("testString")
				Expect(imagePullKeyModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(imagePullKeyModel.Value).To(Equal(core.StringPtr("testString")))
				Expect(imagePullKeyModel.Description).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the SupportWaitTime model
				supportWaitTimeModel := new(catalogmanagementv1.SupportWaitTime)
				Expect(supportWaitTimeModel).ToNot(BeNil())
				supportWaitTimeModel.Value = core.Int64Ptr(int64(38))
				supportWaitTimeModel.Type = core.StringPtr("testString")
				Expect(supportWaitTimeModel.Value).To(Equal(core.Int64Ptr(int64(38))))
				Expect(supportWaitTimeModel.Type).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the SupportTime model
				supportTimeModel := new(catalogmanagementv1.SupportTime)
				Expect(supportTimeModel).ToNot(BeNil())
				supportTimeModel.Day = core.Int64Ptr(int64(38))
				supportTimeModel.StartTime = core.StringPtr("testString")
				supportTimeModel.EndTime = core.StringPtr("testString")
				Expect(supportTimeModel.Day).To(Equal(core.Int64Ptr(int64(38))))
				Expect(supportTimeModel.StartTime).To(Equal(core.StringPtr("testString")))
				Expect(supportTimeModel.EndTime).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the SupportAvailability model
				supportAvailabilityModel := new(catalogmanagementv1.SupportAvailability)
				Expect(supportAvailabilityModel).ToNot(BeNil())
				supportAvailabilityModel.Times = []catalogmanagementv1.SupportTime{*supportTimeModel}
				supportAvailabilityModel.Timezone = core.StringPtr("testString")
				supportAvailabilityModel.AlwaysAvailable = core.BoolPtr(true)
				Expect(supportAvailabilityModel.Times).To(Equal([]catalogmanagementv1.SupportTime{*supportTimeModel}))
				Expect(supportAvailabilityModel.Timezone).To(Equal(core.StringPtr("testString")))
				Expect(supportAvailabilityModel.AlwaysAvailable).To(Equal(core.BoolPtr(true)))

				// Construct an instance of the SupportDetail model
				supportDetailModel := new(catalogmanagementv1.SupportDetail)
				Expect(supportDetailModel).ToNot(BeNil())
				supportDetailModel.Type = core.StringPtr("testString")
				supportDetailModel.Contact = core.StringPtr("testString")
				supportDetailModel.ResponseWaitTime = supportWaitTimeModel
				supportDetailModel.Availability = supportAvailabilityModel
				Expect(supportDetailModel.Type).To(Equal(core.StringPtr("testString")))
				Expect(supportDetailModel.Contact).To(Equal(core.StringPtr("testString")))
				Expect(supportDetailModel.ResponseWaitTime).To(Equal(supportWaitTimeModel))
				Expect(supportDetailModel.Availability).To(Equal(supportAvailabilityModel))

				// Construct an instance of the SupportEscalation model
				supportEscalationModel := new(catalogmanagementv1.SupportEscalation)
				Expect(supportEscalationModel).ToNot(BeNil())
				supportEscalationModel.EscalationWaitTime = supportWaitTimeModel
				supportEscalationModel.ResponseWaitTime = supportWaitTimeModel
				supportEscalationModel.Contact = core.StringPtr("testString")
				Expect(supportEscalationModel.EscalationWaitTime).To(Equal(supportWaitTimeModel))
				Expect(supportEscalationModel.ResponseWaitTime).To(Equal(supportWaitTimeModel))
				Expect(supportEscalationModel.Contact).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the Support model
				supportModel := new(catalogmanagementv1.Support)
				Expect(supportModel).ToNot(BeNil())
				supportModel.URL = core.StringPtr("testString")
				supportModel.Process = core.StringPtr("testString")
				supportModel.ProcessI18n = map[string]string{"key1": "testString"}
				supportModel.Locations = []string{"testString"}
				supportModel.SupportDetails = []catalogmanagementv1.SupportDetail{*supportDetailModel}
				supportModel.SupportEscalation = supportEscalationModel
				supportModel.SupportType = core.StringPtr("testString")
				Expect(supportModel.URL).To(Equal(core.StringPtr("testString")))
				Expect(supportModel.Process).To(Equal(core.StringPtr("testString")))
				Expect(supportModel.ProcessI18n).To(Equal(map[string]string{"key1": "testString"}))
				Expect(supportModel.Locations).To(Equal([]string{"testString"}))
				Expect(supportModel.SupportDetails).To(Equal([]catalogmanagementv1.SupportDetail{*supportDetailModel}))
				Expect(supportModel.SupportEscalation).To(Equal(supportEscalationModel))
				Expect(supportModel.SupportType).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the LearnMoreLinks model
				learnMoreLinksModel := new(catalogmanagementv1.LearnMoreLinks)
				Expect(learnMoreLinksModel).ToNot(BeNil())
				learnMoreLinksModel.FirstParty = core.StringPtr("testString")
				learnMoreLinksModel.ThirdParty = core.StringPtr("testString")
				Expect(learnMoreLinksModel.FirstParty).To(Equal(core.StringPtr("testString")))
				Expect(learnMoreLinksModel.ThirdParty).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the Constraint model
				constraintModel := new(catalogmanagementv1.Constraint)
				Expect(constraintModel).ToNot(BeNil())
				constraintModel.Type = core.StringPtr("testString")
				constraintModel.Rule = "testString"
				Expect(constraintModel.Type).To(Equal(core.StringPtr("testString")))
				Expect(constraintModel.Rule).To(Equal("testString"))

				// Construct an instance of the Badge model
				badgeModel := new(catalogmanagementv1.Badge)
				Expect(badgeModel).ToNot(BeNil())
				badgeModel.ID = core.StringPtr("testString")
				badgeModel.Label = core.StringPtr("testString")
				badgeModel.LabelI18n = map[string]string{"key1": "testString"}
				badgeModel.Description = core.StringPtr("testString")
				badgeModel.DescriptionI18n = map[string]string{"key1": "testString"}
				badgeModel.Icon = core.StringPtr("testString")
				badgeModel.Authority = core.StringPtr("testString")
				badgeModel.Tag = core.StringPtr("testString")
				badgeModel.LearnMoreLinks = learnMoreLinksModel
				badgeModel.Constraints = []catalogmanagementv1.Constraint{*constraintModel}
				Expect(badgeModel.ID).To(Equal(core.StringPtr("testString")))
				Expect(badgeModel.Label).To(Equal(core.StringPtr("testString")))
				Expect(badgeModel.LabelI18n).To(Equal(map[string]string{"key1": "testString"}))
				Expect(badgeModel.Description).To(Equal(core.StringPtr("testString")))
				Expect(badgeModel.DescriptionI18n).To(Equal(map[string]string{"key1": "testString"}))
				Expect(badgeModel.Icon).To(Equal(core.StringPtr("testString")))
				Expect(badgeModel.Authority).To(Equal(core.StringPtr("testString")))
				Expect(badgeModel.Tag).To(Equal(core.StringPtr("testString")))
				Expect(badgeModel.LearnMoreLinks).To(Equal(learnMoreLinksModel))
				Expect(badgeModel.Constraints).To(Equal([]catalogmanagementv1.Constraint{*constraintModel}))

				// Construct an instance of the VersionRange model
				versionRangeModel := new(catalogmanagementv1.VersionRange)
				Expect(versionRangeModel).ToNot(BeNil())
				versionRangeModel.Kinds = []string{"testString"}
				versionRangeModel.Version = core.StringPtr("testString")
				versionRangeModel.Flavors = []string{"testString"}
				Expect(versionRangeModel.Kinds).To(Equal([]string{"testString"}))
				Expect(versionRangeModel.Version).To(Equal(core.StringPtr("testString")))
				Expect(versionRangeModel.Flavors).To(Equal([]string{"testString"}))

				// Construct an instance of the Plan model
				planModel := new(catalogmanagementv1.Plan)
				Expect(planModel).ToNot(BeNil())
				planModel.URL = core.StringPtr("testString")
				planModel.CRN = core.StringPtr("testString")
				planModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				planModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				planModel.OfferingID = core.StringPtr("testString")
				planModel.CatalogID = core.StringPtr("testString")
				planModel.Label = core.StringPtr("testString")
				planModel.LabelI18n = map[string]string{"key1": "testString"}
				planModel.Name = core.StringPtr("testString")
				planModel.ShortDescription = core.StringPtr("testString")
				planModel.ShortDescriptionI18n = map[string]string{"key1": "testString"}
				planModel.PricingTags = []string{"testString"}
				planModel.VersionRange = versionRangeModel
				planModel.Features = []catalogmanagementv1.Feature{*featureModel}
				planModel.State = stateModel
				planModel.DeprecatePending = deprecatePendingModel
				planModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				planModel.PublishApproved = core.BoolPtr(true)
				Expect(planModel.URL).To(Equal(core.StringPtr("testString")))
				Expect(planModel.CRN).To(Equal(core.StringPtr("testString")))
				Expect(planModel.Created).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(planModel.Updated).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(planModel.OfferingID).To(Equal(core.StringPtr("testString")))
				Expect(planModel.CatalogID).To(Equal(core.StringPtr("testString")))
				Expect(planModel.Label).To(Equal(core.StringPtr("testString")))
				Expect(planModel.LabelI18n).To(Equal(map[string]string{"key1": "testString"}))
				Expect(planModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(planModel.ShortDescription).To(Equal(core.StringPtr("testString")))
				Expect(planModel.ShortDescriptionI18n).To(Equal(map[string]string{"key1": "testString"}))
				Expect(planModel.PricingTags).To(Equal([]string{"testString"}))
				Expect(planModel.VersionRange).To(Equal(versionRangeModel))
				Expect(planModel.Features).To(Equal([]catalogmanagementv1.Feature{*featureModel}))
				Expect(planModel.State).To(Equal(stateModel))
				Expect(planModel.DeprecatePending).To(Equal(deprecatePendingModel))
				Expect(planModel.Metadata).To(Equal(map[string]interface{}{"anyKey": "anyValue"}))
				Expect(planModel.PublishApproved).To(Equal(core.BoolPtr(true)))

				// Construct an instance of the CreateOfferingOptions model
				catalogIdentifier := "testString"
				createOfferingOptionsModel := catalogManagementService.NewCreateOfferingOptions(catalogIdentifier)
				createOfferingOptionsModel.SetCatalogIdentifier("testString")
				createOfferingOptionsModel.SetURL("testString")
				createOfferingOptionsModel.SetCRN("testString")
				createOfferingOptionsModel.SetLabel("testString")
				createOfferingOptionsModel.SetLabelI18n(map[string]string{"key1": "testString"})
				createOfferingOptionsModel.SetName("testString")
				createOfferingOptionsModel.SetOfferingIconURL("testString")
				createOfferingOptionsModel.SetOfferingDocsURL("testString")
				createOfferingOptionsModel.SetOfferingSupportURL("testString")
				createOfferingOptionsModel.SetTags([]string{"testString"})
				createOfferingOptionsModel.SetKeywords([]string{"testString"})
				createOfferingOptionsModel.SetRating(ratingModel)
				createOfferingOptionsModel.SetCreated(CreateMockDateTime("2019-01-01T12:00:00.000Z"))
				createOfferingOptionsModel.SetUpdated(CreateMockDateTime("2019-01-01T12:00:00.000Z"))
				createOfferingOptionsModel.SetShortDescription("testString")
				createOfferingOptionsModel.SetShortDescriptionI18n(map[string]string{"key1": "testString"})
				createOfferingOptionsModel.SetLongDescription("testString")
				createOfferingOptionsModel.SetLongDescriptionI18n(map[string]string{"key1": "testString"})
				createOfferingOptionsModel.SetFeatures([]catalogmanagementv1.Feature{*featureModel})
				createOfferingOptionsModel.SetKinds([]catalogmanagementv1.Kind{*kindModel})
				createOfferingOptionsModel.SetPublish(publishObjectModel)
				createOfferingOptionsModel.SetPcManaged(true)
				createOfferingOptionsModel.SetPublishApproved(true)
				createOfferingOptionsModel.SetShareWithAll(true)
				createOfferingOptionsModel.SetShareWithIBM(true)
				createOfferingOptionsModel.SetShareEnabled(true)
				createOfferingOptionsModel.SetPublicOriginalCRN("testString")
				createOfferingOptionsModel.SetPublishPublicCRN("testString")
				createOfferingOptionsModel.SetPortalApprovalRecord("testString")
				createOfferingOptionsModel.SetPortalUIURL("testString")
				createOfferingOptionsModel.SetCatalogID("testString")
				createOfferingOptionsModel.SetCatalogName("testString")
				createOfferingOptionsModel.SetMetadata(map[string]interface{}{"anyKey": "anyValue"})
				createOfferingOptionsModel.SetDisclaimer("testString")
				createOfferingOptionsModel.SetHidden(true)
				createOfferingOptionsModel.SetProvider("testString")
				createOfferingOptionsModel.SetProviderInfo(providerInfoModel)
				createOfferingOptionsModel.SetRepoInfo(repoInfoModel)
				createOfferingOptionsModel.SetImagePullKeys([]catalogmanagementv1.ImagePullKey{*imagePullKeyModel})
				createOfferingOptionsModel.SetSupport(supportModel)
				createOfferingOptionsModel.SetMedia([]catalogmanagementv1.MediaItem{*mediaItemModel})
				createOfferingOptionsModel.SetDeprecatePending(deprecatePendingModel)
				createOfferingOptionsModel.SetProductKind("testString")
				createOfferingOptionsModel.SetBadges([]catalogmanagementv1.Badge{*badgeModel})
				createOfferingOptionsModel.SetPlans([]catalogmanagementv1.Plan{*planModel})
				createOfferingOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(createOfferingOptionsModel).ToNot(BeNil())
				Expect(createOfferingOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingOptionsModel.URL).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingOptionsModel.CRN).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingOptionsModel.Label).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingOptionsModel.LabelI18n).To(Equal(map[string]string{"key1": "testString"}))
				Expect(createOfferingOptionsModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingOptionsModel.OfferingIconURL).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingOptionsModel.OfferingDocsURL).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingOptionsModel.OfferingSupportURL).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingOptionsModel.Tags).To(Equal([]string{"testString"}))
				Expect(createOfferingOptionsModel.Keywords).To(Equal([]string{"testString"}))
				Expect(createOfferingOptionsModel.Rating).To(Equal(ratingModel))
				Expect(createOfferingOptionsModel.Created).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(createOfferingOptionsModel.Updated).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(createOfferingOptionsModel.ShortDescription).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingOptionsModel.ShortDescriptionI18n).To(Equal(map[string]string{"key1": "testString"}))
				Expect(createOfferingOptionsModel.LongDescription).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingOptionsModel.LongDescriptionI18n).To(Equal(map[string]string{"key1": "testString"}))
				Expect(createOfferingOptionsModel.Features).To(Equal([]catalogmanagementv1.Feature{*featureModel}))
				Expect(createOfferingOptionsModel.Kinds).To(Equal([]catalogmanagementv1.Kind{*kindModel}))
				Expect(createOfferingOptionsModel.Publish).To(Equal(publishObjectModel))
				Expect(createOfferingOptionsModel.PcManaged).To(Equal(core.BoolPtr(true)))
				Expect(createOfferingOptionsModel.PublishApproved).To(Equal(core.BoolPtr(true)))
				Expect(createOfferingOptionsModel.ShareWithAll).To(Equal(core.BoolPtr(true)))
				Expect(createOfferingOptionsModel.ShareWithIBM).To(Equal(core.BoolPtr(true)))
				Expect(createOfferingOptionsModel.ShareEnabled).To(Equal(core.BoolPtr(true)))
				Expect(createOfferingOptionsModel.PublicOriginalCRN).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingOptionsModel.PublishPublicCRN).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingOptionsModel.PortalApprovalRecord).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingOptionsModel.PortalUIURL).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingOptionsModel.CatalogID).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingOptionsModel.CatalogName).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingOptionsModel.Metadata).To(Equal(map[string]interface{}{"anyKey": "anyValue"}))
				Expect(createOfferingOptionsModel.Disclaimer).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingOptionsModel.Hidden).To(Equal(core.BoolPtr(true)))
				Expect(createOfferingOptionsModel.Provider).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingOptionsModel.ProviderInfo).To(Equal(providerInfoModel))
				Expect(createOfferingOptionsModel.RepoInfo).To(Equal(repoInfoModel))
				Expect(createOfferingOptionsModel.ImagePullKeys).To(Equal([]catalogmanagementv1.ImagePullKey{*imagePullKeyModel}))
				Expect(createOfferingOptionsModel.Support).To(Equal(supportModel))
				Expect(createOfferingOptionsModel.Media).To(Equal([]catalogmanagementv1.MediaItem{*mediaItemModel}))
				Expect(createOfferingOptionsModel.DeprecatePending).To(Equal(deprecatePendingModel))
				Expect(createOfferingOptionsModel.ProductKind).To(Equal(core.StringPtr("testString")))
				Expect(createOfferingOptionsModel.Badges).To(Equal([]catalogmanagementv1.Badge{*badgeModel}))
				Expect(createOfferingOptionsModel.Plans).To(Equal([]catalogmanagementv1.Plan{*planModel}))
				Expect(createOfferingOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewDeleteCatalogOptions successfully`, func() {
				// Construct an instance of the DeleteCatalogOptions model
				catalogIdentifier := "testString"
				deleteCatalogOptionsModel := catalogManagementService.NewDeleteCatalogOptions(catalogIdentifier)
				deleteCatalogOptionsModel.SetCatalogIdentifier("testString")
				deleteCatalogOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(deleteCatalogOptionsModel).ToNot(BeNil())
				Expect(deleteCatalogOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(deleteCatalogOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewDeleteObjectAccessListOptions successfully`, func() {
				// Construct an instance of the DeleteObjectAccessListOptions model
				catalogIdentifier := "testString"
				objectIdentifier := "testString"
				accesses := []string{"testString"}
				deleteObjectAccessListOptionsModel := catalogManagementService.NewDeleteObjectAccessListOptions(catalogIdentifier, objectIdentifier, accesses)
				deleteObjectAccessListOptionsModel.SetCatalogIdentifier("testString")
				deleteObjectAccessListOptionsModel.SetObjectIdentifier("testString")
				deleteObjectAccessListOptionsModel.SetAccesses([]string{"testString"})
				deleteObjectAccessListOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(deleteObjectAccessListOptionsModel).ToNot(BeNil())
				Expect(deleteObjectAccessListOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(deleteObjectAccessListOptionsModel.ObjectIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(deleteObjectAccessListOptionsModel.Accesses).To(Equal([]string{"testString"}))
				Expect(deleteObjectAccessListOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewDeleteObjectAccessOptions successfully`, func() {
				// Construct an instance of the DeleteObjectAccessOptions model
				catalogIdentifier := "testString"
				objectIdentifier := "testString"
				accessIdentifier := "testString"
				deleteObjectAccessOptionsModel := catalogManagementService.NewDeleteObjectAccessOptions(catalogIdentifier, objectIdentifier, accessIdentifier)
				deleteObjectAccessOptionsModel.SetCatalogIdentifier("testString")
				deleteObjectAccessOptionsModel.SetObjectIdentifier("testString")
				deleteObjectAccessOptionsModel.SetAccessIdentifier("testString")
				deleteObjectAccessOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(deleteObjectAccessOptionsModel).ToNot(BeNil())
				Expect(deleteObjectAccessOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(deleteObjectAccessOptionsModel.ObjectIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(deleteObjectAccessOptionsModel.AccessIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(deleteObjectAccessOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewDeleteObjectOptions successfully`, func() {
				// Construct an instance of the DeleteObjectOptions model
				catalogIdentifier := "testString"
				objectIdentifier := "testString"
				deleteObjectOptionsModel := catalogManagementService.NewDeleteObjectOptions(catalogIdentifier, objectIdentifier)
				deleteObjectOptionsModel.SetCatalogIdentifier("testString")
				deleteObjectOptionsModel.SetObjectIdentifier("testString")
				deleteObjectOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(deleteObjectOptionsModel).ToNot(BeNil())
				Expect(deleteObjectOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(deleteObjectOptionsModel.ObjectIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(deleteObjectOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewDeleteOfferingAccessListOptions successfully`, func() {
				// Construct an instance of the DeleteOfferingAccessListOptions model
				catalogIdentifier := "testString"
				offeringID := "testString"
				accesses := []string{"testString"}
				deleteOfferingAccessListOptionsModel := catalogManagementService.NewDeleteOfferingAccessListOptions(catalogIdentifier, offeringID, accesses)
				deleteOfferingAccessListOptionsModel.SetCatalogIdentifier("testString")
				deleteOfferingAccessListOptionsModel.SetOfferingID("testString")
				deleteOfferingAccessListOptionsModel.SetAccesses([]string{"testString"})
				deleteOfferingAccessListOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(deleteOfferingAccessListOptionsModel).ToNot(BeNil())
				Expect(deleteOfferingAccessListOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(deleteOfferingAccessListOptionsModel.OfferingID).To(Equal(core.StringPtr("testString")))
				Expect(deleteOfferingAccessListOptionsModel.Accesses).To(Equal([]string{"testString"}))
				Expect(deleteOfferingAccessListOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewDeleteOfferingInstanceOptions successfully`, func() {
				// Construct an instance of the DeleteOfferingInstanceOptions model
				instanceIdentifier := "testString"
				xAuthRefreshToken := "testString"
				deleteOfferingInstanceOptionsModel := catalogManagementService.NewDeleteOfferingInstanceOptions(instanceIdentifier, xAuthRefreshToken)
				deleteOfferingInstanceOptionsModel.SetInstanceIdentifier("testString")
				deleteOfferingInstanceOptionsModel.SetXAuthRefreshToken("testString")
				deleteOfferingInstanceOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(deleteOfferingInstanceOptionsModel).ToNot(BeNil())
				Expect(deleteOfferingInstanceOptionsModel.InstanceIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(deleteOfferingInstanceOptionsModel.XAuthRefreshToken).To(Equal(core.StringPtr("testString")))
				Expect(deleteOfferingInstanceOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewDeleteOfferingOptions successfully`, func() {
				// Construct an instance of the DeleteOfferingOptions model
				catalogIdentifier := "testString"
				offeringID := "testString"
				deleteOfferingOptionsModel := catalogManagementService.NewDeleteOfferingOptions(catalogIdentifier, offeringID)
				deleteOfferingOptionsModel.SetCatalogIdentifier("testString")
				deleteOfferingOptionsModel.SetOfferingID("testString")
				deleteOfferingOptionsModel.SetXApproverToken("testString")
				deleteOfferingOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(deleteOfferingOptionsModel).ToNot(BeNil())
				Expect(deleteOfferingOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(deleteOfferingOptionsModel.OfferingID).To(Equal(core.StringPtr("testString")))
				Expect(deleteOfferingOptionsModel.XApproverToken).To(Equal(core.StringPtr("testString")))
				Expect(deleteOfferingOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewDeleteOperatorsOptions successfully`, func() {
				// Construct an instance of the DeleteOperatorsOptions model
				xAuthRefreshToken := "testString"
				clusterID := "testString"
				region := "testString"
				versionLocatorID := "testString"
				deleteOperatorsOptionsModel := catalogManagementService.NewDeleteOperatorsOptions(xAuthRefreshToken, clusterID, region, versionLocatorID)
				deleteOperatorsOptionsModel.SetXAuthRefreshToken("testString")
				deleteOperatorsOptionsModel.SetClusterID("testString")
				deleteOperatorsOptionsModel.SetRegion("testString")
				deleteOperatorsOptionsModel.SetVersionLocatorID("testString")
				deleteOperatorsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(deleteOperatorsOptionsModel).ToNot(BeNil())
				Expect(deleteOperatorsOptionsModel.XAuthRefreshToken).To(Equal(core.StringPtr("testString")))
				Expect(deleteOperatorsOptionsModel.ClusterID).To(Equal(core.StringPtr("testString")))
				Expect(deleteOperatorsOptionsModel.Region).To(Equal(core.StringPtr("testString")))
				Expect(deleteOperatorsOptionsModel.VersionLocatorID).To(Equal(core.StringPtr("testString")))
				Expect(deleteOperatorsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewDeletePlanOptions successfully`, func() {
				// Construct an instance of the DeletePlanOptions model
				planLocID := "testString"
				deletePlanOptionsModel := catalogManagementService.NewDeletePlanOptions(planLocID)
				deletePlanOptionsModel.SetPlanLocID("testString")
				deletePlanOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(deletePlanOptionsModel).ToNot(BeNil())
				Expect(deletePlanOptionsModel.PlanLocID).To(Equal(core.StringPtr("testString")))
				Expect(deletePlanOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewDeleteShareApprovalListOptions successfully`, func() {
				// Construct an instance of the DeleteShareApprovalListOptions model
				objectType := "offering"
				accesses := []string{"testString"}
				deleteShareApprovalListOptionsModel := catalogManagementService.NewDeleteShareApprovalListOptions(objectType, accesses)
				deleteShareApprovalListOptionsModel.SetObjectType("offering")
				deleteShareApprovalListOptionsModel.SetAccesses([]string{"testString"})
				deleteShareApprovalListOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(deleteShareApprovalListOptionsModel).ToNot(BeNil())
				Expect(deleteShareApprovalListOptionsModel.ObjectType).To(Equal(core.StringPtr("offering")))
				Expect(deleteShareApprovalListOptionsModel.Accesses).To(Equal([]string{"testString"}))
				Expect(deleteShareApprovalListOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewDeleteVersionOptions successfully`, func() {
				// Construct an instance of the DeleteVersionOptions model
				versionLocID := "testString"
				deleteVersionOptionsModel := catalogManagementService.NewDeleteVersionOptions(versionLocID)
				deleteVersionOptionsModel.SetVersionLocID("testString")
				deleteVersionOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(deleteVersionOptionsModel).ToNot(BeNil())
				Expect(deleteVersionOptionsModel.VersionLocID).To(Equal(core.StringPtr("testString")))
				Expect(deleteVersionOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewDeployOperatorsOptions successfully`, func() {
				// Construct an instance of the DeployOperatorsOptions model
				xAuthRefreshToken := "testString"
				deployOperatorsOptionsModel := catalogManagementService.NewDeployOperatorsOptions(xAuthRefreshToken)
				deployOperatorsOptionsModel.SetXAuthRefreshToken("testString")
				deployOperatorsOptionsModel.SetClusterID("testString")
				deployOperatorsOptionsModel.SetRegion("testString")
				deployOperatorsOptionsModel.SetNamespaces([]string{"testString"})
				deployOperatorsOptionsModel.SetAllNamespaces(true)
				deployOperatorsOptionsModel.SetVersionLocatorID("testString")
				deployOperatorsOptionsModel.SetChannel("testString")
				deployOperatorsOptionsModel.SetInstallPlan("testString")
				deployOperatorsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(deployOperatorsOptionsModel).ToNot(BeNil())
				Expect(deployOperatorsOptionsModel.XAuthRefreshToken).To(Equal(core.StringPtr("testString")))
				Expect(deployOperatorsOptionsModel.ClusterID).To(Equal(core.StringPtr("testString")))
				Expect(deployOperatorsOptionsModel.Region).To(Equal(core.StringPtr("testString")))
				Expect(deployOperatorsOptionsModel.Namespaces).To(Equal([]string{"testString"}))
				Expect(deployOperatorsOptionsModel.AllNamespaces).To(Equal(core.BoolPtr(true)))
				Expect(deployOperatorsOptionsModel.VersionLocatorID).To(Equal(core.StringPtr("testString")))
				Expect(deployOperatorsOptionsModel.Channel).To(Equal(core.StringPtr("testString")))
				Expect(deployOperatorsOptionsModel.InstallPlan).To(Equal(core.StringPtr("testString")))
				Expect(deployOperatorsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewDeprecateOfferingOptions successfully`, func() {
				// Construct an instance of the DeprecateOfferingOptions model
				catalogIdentifier := "testString"
				offeringID := "testString"
				setting := "true"
				deprecateOfferingOptionsModel := catalogManagementService.NewDeprecateOfferingOptions(catalogIdentifier, offeringID, setting)
				deprecateOfferingOptionsModel.SetCatalogIdentifier("testString")
				deprecateOfferingOptionsModel.SetOfferingID("testString")
				deprecateOfferingOptionsModel.SetSetting("true")
				deprecateOfferingOptionsModel.SetDescription("testString")
				deprecateOfferingOptionsModel.SetDaysUntilDeprecate(int64(38))
				deprecateOfferingOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(deprecateOfferingOptionsModel).ToNot(BeNil())
				Expect(deprecateOfferingOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(deprecateOfferingOptionsModel.OfferingID).To(Equal(core.StringPtr("testString")))
				Expect(deprecateOfferingOptionsModel.Setting).To(Equal(core.StringPtr("true")))
				Expect(deprecateOfferingOptionsModel.Description).To(Equal(core.StringPtr("testString")))
				Expect(deprecateOfferingOptionsModel.DaysUntilDeprecate).To(Equal(core.Int64Ptr(int64(38))))
				Expect(deprecateOfferingOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewDeprecateVersionOptions successfully`, func() {
				// Construct an instance of the DeprecateVersionOptions model
				versionLocID := "testString"
				deprecateVersionOptionsModel := catalogManagementService.NewDeprecateVersionOptions(versionLocID)
				deprecateVersionOptionsModel.SetVersionLocID("testString")
				deprecateVersionOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(deprecateVersionOptionsModel).ToNot(BeNil())
				Expect(deprecateVersionOptionsModel.VersionLocID).To(Equal(core.StringPtr("testString")))
				Expect(deprecateVersionOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetCatalogAccountAuditOptions successfully`, func() {
				// Construct an instance of the GetCatalogAccountAuditOptions model
				auditlogIdentifier := "testString"
				getCatalogAccountAuditOptionsModel := catalogManagementService.NewGetCatalogAccountAuditOptions(auditlogIdentifier)
				getCatalogAccountAuditOptionsModel.SetAuditlogIdentifier("testString")
				getCatalogAccountAuditOptionsModel.SetLookupnames(true)
				getCatalogAccountAuditOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getCatalogAccountAuditOptionsModel).ToNot(BeNil())
				Expect(getCatalogAccountAuditOptionsModel.AuditlogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(getCatalogAccountAuditOptionsModel.Lookupnames).To(Equal(core.BoolPtr(true)))
				Expect(getCatalogAccountAuditOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetCatalogAccountFiltersOptions successfully`, func() {
				// Construct an instance of the GetCatalogAccountFiltersOptions model
				getCatalogAccountFiltersOptionsModel := catalogManagementService.NewGetCatalogAccountFiltersOptions()
				getCatalogAccountFiltersOptionsModel.SetCatalog("testString")
				getCatalogAccountFiltersOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getCatalogAccountFiltersOptionsModel).ToNot(BeNil())
				Expect(getCatalogAccountFiltersOptionsModel.Catalog).To(Equal(core.StringPtr("testString")))
				Expect(getCatalogAccountFiltersOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetCatalogAccountOptions successfully`, func() {
				// Construct an instance of the GetCatalogAccountOptions model
				getCatalogAccountOptionsModel := catalogManagementService.NewGetCatalogAccountOptions()
				getCatalogAccountOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getCatalogAccountOptionsModel).ToNot(BeNil())
				Expect(getCatalogAccountOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetCatalogAuditOptions successfully`, func() {
				// Construct an instance of the GetCatalogAuditOptions model
				catalogIdentifier := "testString"
				auditlogIdentifier := "testString"
				getCatalogAuditOptionsModel := catalogManagementService.NewGetCatalogAuditOptions(catalogIdentifier, auditlogIdentifier)
				getCatalogAuditOptionsModel.SetCatalogIdentifier("testString")
				getCatalogAuditOptionsModel.SetAuditlogIdentifier("testString")
				getCatalogAuditOptionsModel.SetLookupnames(true)
				getCatalogAuditOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getCatalogAuditOptionsModel).ToNot(BeNil())
				Expect(getCatalogAuditOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(getCatalogAuditOptionsModel.AuditlogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(getCatalogAuditOptionsModel.Lookupnames).To(Equal(core.BoolPtr(true)))
				Expect(getCatalogAuditOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetCatalogOptions successfully`, func() {
				// Construct an instance of the GetCatalogOptions model
				catalogIdentifier := "testString"
				getCatalogOptionsModel := catalogManagementService.NewGetCatalogOptions(catalogIdentifier)
				getCatalogOptionsModel.SetCatalogIdentifier("testString")
				getCatalogOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getCatalogOptionsModel).ToNot(BeNil())
				Expect(getCatalogOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(getCatalogOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetClusterOptions successfully`, func() {
				// Construct an instance of the GetClusterOptions model
				clusterID := "testString"
				region := "testString"
				xAuthRefreshToken := "testString"
				getClusterOptionsModel := catalogManagementService.NewGetClusterOptions(clusterID, region, xAuthRefreshToken)
				getClusterOptionsModel.SetClusterID("testString")
				getClusterOptionsModel.SetRegion("testString")
				getClusterOptionsModel.SetXAuthRefreshToken("testString")
				getClusterOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getClusterOptionsModel).ToNot(BeNil())
				Expect(getClusterOptionsModel.ClusterID).To(Equal(core.StringPtr("testString")))
				Expect(getClusterOptionsModel.Region).To(Equal(core.StringPtr("testString")))
				Expect(getClusterOptionsModel.XAuthRefreshToken).To(Equal(core.StringPtr("testString")))
				Expect(getClusterOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetConsumptionOfferingsOptions successfully`, func() {
				// Construct an instance of the GetConsumptionOfferingsOptions model
				getConsumptionOfferingsOptionsModel := catalogManagementService.NewGetConsumptionOfferingsOptions()
				getConsumptionOfferingsOptionsModel.SetDigest(true)
				getConsumptionOfferingsOptionsModel.SetCatalog("testString")
				getConsumptionOfferingsOptionsModel.SetSelect("all")
				getConsumptionOfferingsOptionsModel.SetIncludeHidden(true)
				getConsumptionOfferingsOptionsModel.SetLimit(int64(10))
				getConsumptionOfferingsOptionsModel.SetOffset(int64(0))
				getConsumptionOfferingsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getConsumptionOfferingsOptionsModel).ToNot(BeNil())
				Expect(getConsumptionOfferingsOptionsModel.Digest).To(Equal(core.BoolPtr(true)))
				Expect(getConsumptionOfferingsOptionsModel.Catalog).To(Equal(core.StringPtr("testString")))
				Expect(getConsumptionOfferingsOptionsModel.Select).To(Equal(core.StringPtr("all")))
				Expect(getConsumptionOfferingsOptionsModel.IncludeHidden).To(Equal(core.BoolPtr(true)))
				Expect(getConsumptionOfferingsOptionsModel.Limit).To(Equal(core.Int64Ptr(int64(10))))
				Expect(getConsumptionOfferingsOptionsModel.Offset).To(Equal(core.Int64Ptr(int64(0))))
				Expect(getConsumptionOfferingsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetEnterpriseAuditOptions successfully`, func() {
				// Construct an instance of the GetEnterpriseAuditOptions model
				enterpriseIdentifier := "testString"
				auditlogIdentifier := "testString"
				getEnterpriseAuditOptionsModel := catalogManagementService.NewGetEnterpriseAuditOptions(enterpriseIdentifier, auditlogIdentifier)
				getEnterpriseAuditOptionsModel.SetEnterpriseIdentifier("testString")
				getEnterpriseAuditOptionsModel.SetAuditlogIdentifier("testString")
				getEnterpriseAuditOptionsModel.SetLookupnames(true)
				getEnterpriseAuditOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getEnterpriseAuditOptionsModel).ToNot(BeNil())
				Expect(getEnterpriseAuditOptionsModel.EnterpriseIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(getEnterpriseAuditOptionsModel.AuditlogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(getEnterpriseAuditOptionsModel.Lookupnames).To(Equal(core.BoolPtr(true)))
				Expect(getEnterpriseAuditOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetIamPermissionsOptions successfully`, func() {
				// Construct an instance of the GetIamPermissionsOptions model
				versionLocID := "testString"
				getIamPermissionsOptionsModel := catalogManagementService.NewGetIamPermissionsOptions(versionLocID)
				getIamPermissionsOptionsModel.SetVersionLocID("testString")
				getIamPermissionsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getIamPermissionsOptionsModel).ToNot(BeNil())
				Expect(getIamPermissionsOptionsModel.VersionLocID).To(Equal(core.StringPtr("testString")))
				Expect(getIamPermissionsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetNamespacesOptions successfully`, func() {
				// Construct an instance of the GetNamespacesOptions model
				clusterID := "testString"
				region := "testString"
				xAuthRefreshToken := "testString"
				getNamespacesOptionsModel := catalogManagementService.NewGetNamespacesOptions(clusterID, region, xAuthRefreshToken)
				getNamespacesOptionsModel.SetClusterID("testString")
				getNamespacesOptionsModel.SetRegion("testString")
				getNamespacesOptionsModel.SetXAuthRefreshToken("testString")
				getNamespacesOptionsModel.SetLimit(int64(10))
				getNamespacesOptionsModel.SetOffset(int64(0))
				getNamespacesOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getNamespacesOptionsModel).ToNot(BeNil())
				Expect(getNamespacesOptionsModel.ClusterID).To(Equal(core.StringPtr("testString")))
				Expect(getNamespacesOptionsModel.Region).To(Equal(core.StringPtr("testString")))
				Expect(getNamespacesOptionsModel.XAuthRefreshToken).To(Equal(core.StringPtr("testString")))
				Expect(getNamespacesOptionsModel.Limit).To(Equal(core.Int64Ptr(int64(10))))
				Expect(getNamespacesOptionsModel.Offset).To(Equal(core.Int64Ptr(int64(0))))
				Expect(getNamespacesOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetObjectAccessListDeprecatedOptions successfully`, func() {
				// Construct an instance of the GetObjectAccessListDeprecatedOptions model
				catalogIdentifier := "testString"
				objectIdentifier := "testString"
				getObjectAccessListDeprecatedOptionsModel := catalogManagementService.NewGetObjectAccessListDeprecatedOptions(catalogIdentifier, objectIdentifier)
				getObjectAccessListDeprecatedOptionsModel.SetCatalogIdentifier("testString")
				getObjectAccessListDeprecatedOptionsModel.SetObjectIdentifier("testString")
				getObjectAccessListDeprecatedOptionsModel.SetLimit(int64(10))
				getObjectAccessListDeprecatedOptionsModel.SetOffset(int64(0))
				getObjectAccessListDeprecatedOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getObjectAccessListDeprecatedOptionsModel).ToNot(BeNil())
				Expect(getObjectAccessListDeprecatedOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(getObjectAccessListDeprecatedOptionsModel.ObjectIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(getObjectAccessListDeprecatedOptionsModel.Limit).To(Equal(core.Int64Ptr(int64(10))))
				Expect(getObjectAccessListDeprecatedOptionsModel.Offset).To(Equal(core.Int64Ptr(int64(0))))
				Expect(getObjectAccessListDeprecatedOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetObjectAccessListOptions successfully`, func() {
				// Construct an instance of the GetObjectAccessListOptions model
				catalogIdentifier := "testString"
				objectIdentifier := "testString"
				getObjectAccessListOptionsModel := catalogManagementService.NewGetObjectAccessListOptions(catalogIdentifier, objectIdentifier)
				getObjectAccessListOptionsModel.SetCatalogIdentifier("testString")
				getObjectAccessListOptionsModel.SetObjectIdentifier("testString")
				getObjectAccessListOptionsModel.SetStart("testString")
				getObjectAccessListOptionsModel.SetLimit(int64(10))
				getObjectAccessListOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getObjectAccessListOptionsModel).ToNot(BeNil())
				Expect(getObjectAccessListOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(getObjectAccessListOptionsModel.ObjectIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(getObjectAccessListOptionsModel.Start).To(Equal(core.StringPtr("testString")))
				Expect(getObjectAccessListOptionsModel.Limit).To(Equal(core.Int64Ptr(int64(10))))
				Expect(getObjectAccessListOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetObjectAccessOptions successfully`, func() {
				// Construct an instance of the GetObjectAccessOptions model
				catalogIdentifier := "testString"
				objectIdentifier := "testString"
				accessIdentifier := "testString"
				getObjectAccessOptionsModel := catalogManagementService.NewGetObjectAccessOptions(catalogIdentifier, objectIdentifier, accessIdentifier)
				getObjectAccessOptionsModel.SetCatalogIdentifier("testString")
				getObjectAccessOptionsModel.SetObjectIdentifier("testString")
				getObjectAccessOptionsModel.SetAccessIdentifier("testString")
				getObjectAccessOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getObjectAccessOptionsModel).ToNot(BeNil())
				Expect(getObjectAccessOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(getObjectAccessOptionsModel.ObjectIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(getObjectAccessOptionsModel.AccessIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(getObjectAccessOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetObjectAuditOptions successfully`, func() {
				// Construct an instance of the GetObjectAuditOptions model
				catalogIdentifier := "testString"
				objectIdentifier := "testString"
				auditlogIdentifier := "testString"
				getObjectAuditOptionsModel := catalogManagementService.NewGetObjectAuditOptions(catalogIdentifier, objectIdentifier, auditlogIdentifier)
				getObjectAuditOptionsModel.SetCatalogIdentifier("testString")
				getObjectAuditOptionsModel.SetObjectIdentifier("testString")
				getObjectAuditOptionsModel.SetAuditlogIdentifier("testString")
				getObjectAuditOptionsModel.SetLookupnames(true)
				getObjectAuditOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getObjectAuditOptionsModel).ToNot(BeNil())
				Expect(getObjectAuditOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(getObjectAuditOptionsModel.ObjectIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(getObjectAuditOptionsModel.AuditlogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(getObjectAuditOptionsModel.Lookupnames).To(Equal(core.BoolPtr(true)))
				Expect(getObjectAuditOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetObjectOptions successfully`, func() {
				// Construct an instance of the GetObjectOptions model
				catalogIdentifier := "testString"
				objectIdentifier := "testString"
				getObjectOptionsModel := catalogManagementService.NewGetObjectOptions(catalogIdentifier, objectIdentifier)
				getObjectOptionsModel.SetCatalogIdentifier("testString")
				getObjectOptionsModel.SetObjectIdentifier("testString")
				getObjectOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getObjectOptionsModel).ToNot(BeNil())
				Expect(getObjectOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(getObjectOptionsModel.ObjectIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(getObjectOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetOfferingAboutOptions successfully`, func() {
				// Construct an instance of the GetOfferingAboutOptions model
				versionLocID := "testString"
				getOfferingAboutOptionsModel := catalogManagementService.NewGetOfferingAboutOptions(versionLocID)
				getOfferingAboutOptionsModel.SetVersionLocID("testString")
				getOfferingAboutOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getOfferingAboutOptionsModel).ToNot(BeNil())
				Expect(getOfferingAboutOptionsModel.VersionLocID).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingAboutOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetOfferingAccessListOptions successfully`, func() {
				// Construct an instance of the GetOfferingAccessListOptions model
				catalogIdentifier := "testString"
				offeringID := "testString"
				getOfferingAccessListOptionsModel := catalogManagementService.NewGetOfferingAccessListOptions(catalogIdentifier, offeringID)
				getOfferingAccessListOptionsModel.SetCatalogIdentifier("testString")
				getOfferingAccessListOptionsModel.SetOfferingID("testString")
				getOfferingAccessListOptionsModel.SetStart("testString")
				getOfferingAccessListOptionsModel.SetLimit(int64(10))
				getOfferingAccessListOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getOfferingAccessListOptionsModel).ToNot(BeNil())
				Expect(getOfferingAccessListOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingAccessListOptionsModel.OfferingID).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingAccessListOptionsModel.Start).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingAccessListOptionsModel.Limit).To(Equal(core.Int64Ptr(int64(10))))
				Expect(getOfferingAccessListOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetOfferingAccessOptions successfully`, func() {
				// Construct an instance of the GetOfferingAccessOptions model
				catalogIdentifier := "testString"
				offeringID := "testString"
				accessIdentifier := "testString"
				getOfferingAccessOptionsModel := catalogManagementService.NewGetOfferingAccessOptions(catalogIdentifier, offeringID, accessIdentifier)
				getOfferingAccessOptionsModel.SetCatalogIdentifier("testString")
				getOfferingAccessOptionsModel.SetOfferingID("testString")
				getOfferingAccessOptionsModel.SetAccessIdentifier("testString")
				getOfferingAccessOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getOfferingAccessOptionsModel).ToNot(BeNil())
				Expect(getOfferingAccessOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingAccessOptionsModel.OfferingID).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingAccessOptionsModel.AccessIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingAccessOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetOfferingAuditOptions successfully`, func() {
				// Construct an instance of the GetOfferingAuditOptions model
				catalogIdentifier := "testString"
				offeringID := "testString"
				auditlogIdentifier := "testString"
				getOfferingAuditOptionsModel := catalogManagementService.NewGetOfferingAuditOptions(catalogIdentifier, offeringID, auditlogIdentifier)
				getOfferingAuditOptionsModel.SetCatalogIdentifier("testString")
				getOfferingAuditOptionsModel.SetOfferingID("testString")
				getOfferingAuditOptionsModel.SetAuditlogIdentifier("testString")
				getOfferingAuditOptionsModel.SetLookupnames(true)
				getOfferingAuditOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getOfferingAuditOptionsModel).ToNot(BeNil())
				Expect(getOfferingAuditOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingAuditOptionsModel.OfferingID).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingAuditOptionsModel.AuditlogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingAuditOptionsModel.Lookupnames).To(Equal(core.BoolPtr(true)))
				Expect(getOfferingAuditOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetOfferingChangeNoticesOptions successfully`, func() {
				// Construct an instance of the GetOfferingChangeNoticesOptions model
				catalogIdentifier := "testString"
				offeringID := "testString"
				kind := "testString"
				getOfferingChangeNoticesOptionsModel := catalogManagementService.NewGetOfferingChangeNoticesOptions(catalogIdentifier, offeringID, kind)
				getOfferingChangeNoticesOptionsModel.SetCatalogIdentifier("testString")
				getOfferingChangeNoticesOptionsModel.SetOfferingID("testString")
				getOfferingChangeNoticesOptionsModel.SetKind("testString")
				getOfferingChangeNoticesOptionsModel.SetTarget("testString")
				getOfferingChangeNoticesOptionsModel.SetVersion("testString")
				getOfferingChangeNoticesOptionsModel.SetFlavor("testString")
				getOfferingChangeNoticesOptionsModel.SetVersions("latest")
				getOfferingChangeNoticesOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getOfferingChangeNoticesOptionsModel).ToNot(BeNil())
				Expect(getOfferingChangeNoticesOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingChangeNoticesOptionsModel.OfferingID).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingChangeNoticesOptionsModel.Kind).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingChangeNoticesOptionsModel.Target).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingChangeNoticesOptionsModel.Version).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingChangeNoticesOptionsModel.Flavor).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingChangeNoticesOptionsModel.Versions).To(Equal(core.StringPtr("latest")))
				Expect(getOfferingChangeNoticesOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetOfferingContainerImagesOptions successfully`, func() {
				// Construct an instance of the GetOfferingContainerImagesOptions model
				versionLocID := "testString"
				getOfferingContainerImagesOptionsModel := catalogManagementService.NewGetOfferingContainerImagesOptions(versionLocID)
				getOfferingContainerImagesOptionsModel.SetVersionLocID("testString")
				getOfferingContainerImagesOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getOfferingContainerImagesOptionsModel).ToNot(BeNil())
				Expect(getOfferingContainerImagesOptionsModel.VersionLocID).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingContainerImagesOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetOfferingInstanceAuditOptions successfully`, func() {
				// Construct an instance of the GetOfferingInstanceAuditOptions model
				instanceIdentifier := "testString"
				auditlogIdentifier := "testString"
				getOfferingInstanceAuditOptionsModel := catalogManagementService.NewGetOfferingInstanceAuditOptions(instanceIdentifier, auditlogIdentifier)
				getOfferingInstanceAuditOptionsModel.SetInstanceIdentifier("testString")
				getOfferingInstanceAuditOptionsModel.SetAuditlogIdentifier("testString")
				getOfferingInstanceAuditOptionsModel.SetLookupnames(true)
				getOfferingInstanceAuditOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getOfferingInstanceAuditOptionsModel).ToNot(BeNil())
				Expect(getOfferingInstanceAuditOptionsModel.InstanceIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingInstanceAuditOptionsModel.AuditlogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingInstanceAuditOptionsModel.Lookupnames).To(Equal(core.BoolPtr(true)))
				Expect(getOfferingInstanceAuditOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetOfferingInstanceOptions successfully`, func() {
				// Construct an instance of the GetOfferingInstanceOptions model
				instanceIdentifier := "testString"
				getOfferingInstanceOptionsModel := catalogManagementService.NewGetOfferingInstanceOptions(instanceIdentifier)
				getOfferingInstanceOptionsModel.SetInstanceIdentifier("testString")
				getOfferingInstanceOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getOfferingInstanceOptionsModel).ToNot(BeNil())
				Expect(getOfferingInstanceOptionsModel.InstanceIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingInstanceOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetOfferingLicenseOptions successfully`, func() {
				// Construct an instance of the GetOfferingLicenseOptions model
				versionLocID := "testString"
				licenseID := "testString"
				getOfferingLicenseOptionsModel := catalogManagementService.NewGetOfferingLicenseOptions(versionLocID, licenseID)
				getOfferingLicenseOptionsModel.SetVersionLocID("testString")
				getOfferingLicenseOptionsModel.SetLicenseID("testString")
				getOfferingLicenseOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getOfferingLicenseOptionsModel).ToNot(BeNil())
				Expect(getOfferingLicenseOptionsModel.VersionLocID).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingLicenseOptionsModel.LicenseID).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingLicenseOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetOfferingOptions successfully`, func() {
				// Construct an instance of the GetOfferingOptions model
				catalogIdentifier := "testString"
				offeringID := "testString"
				getOfferingOptionsModel := catalogManagementService.NewGetOfferingOptions(catalogIdentifier, offeringID)
				getOfferingOptionsModel.SetCatalogIdentifier("testString")
				getOfferingOptionsModel.SetOfferingID("testString")
				getOfferingOptionsModel.SetType("testString")
				getOfferingOptionsModel.SetDigest(true)
				getOfferingOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getOfferingOptionsModel).ToNot(BeNil())
				Expect(getOfferingOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingOptionsModel.OfferingID).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingOptionsModel.Type).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingOptionsModel.Digest).To(Equal(core.BoolPtr(true)))
				Expect(getOfferingOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetOfferingSourceArchiveOptions successfully`, func() {
				// Construct an instance of the GetOfferingSourceArchiveOptions model
				version := "testString"
				getOfferingSourceArchiveOptionsModel := catalogManagementService.NewGetOfferingSourceArchiveOptions(version)
				getOfferingSourceArchiveOptionsModel.SetVersion("testString")
				getOfferingSourceArchiveOptionsModel.SetAccept("application/yaml")
				getOfferingSourceArchiveOptionsModel.SetCatalogID("testString")
				getOfferingSourceArchiveOptionsModel.SetName("testString")
				getOfferingSourceArchiveOptionsModel.SetID("testString")
				getOfferingSourceArchiveOptionsModel.SetKind("testString")
				getOfferingSourceArchiveOptionsModel.SetChannel("testString")
				getOfferingSourceArchiveOptionsModel.SetFlavor("testString")
				getOfferingSourceArchiveOptionsModel.SetAsIs(true)
				getOfferingSourceArchiveOptionsModel.SetInstallType("testString")
				getOfferingSourceArchiveOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getOfferingSourceArchiveOptionsModel).ToNot(BeNil())
				Expect(getOfferingSourceArchiveOptionsModel.Version).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingSourceArchiveOptionsModel.Accept).To(Equal(core.StringPtr("application/yaml")))
				Expect(getOfferingSourceArchiveOptionsModel.CatalogID).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingSourceArchiveOptionsModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingSourceArchiveOptionsModel.ID).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingSourceArchiveOptionsModel.Kind).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingSourceArchiveOptionsModel.Channel).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingSourceArchiveOptionsModel.Flavor).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingSourceArchiveOptionsModel.AsIs).To(Equal(core.BoolPtr(true)))
				Expect(getOfferingSourceArchiveOptionsModel.InstallType).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingSourceArchiveOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetOfferingSourceOptions successfully`, func() {
				// Construct an instance of the GetOfferingSourceOptions model
				version := "testString"
				getOfferingSourceOptionsModel := catalogManagementService.NewGetOfferingSourceOptions(version)
				getOfferingSourceOptionsModel.SetVersion("testString")
				getOfferingSourceOptionsModel.SetAccept("application/yaml")
				getOfferingSourceOptionsModel.SetCatalogID("testString")
				getOfferingSourceOptionsModel.SetName("testString")
				getOfferingSourceOptionsModel.SetID("testString")
				getOfferingSourceOptionsModel.SetKind("testString")
				getOfferingSourceOptionsModel.SetChannel("testString")
				getOfferingSourceOptionsModel.SetFlavor("testString")
				getOfferingSourceOptionsModel.SetAsIs(true)
				getOfferingSourceOptionsModel.SetInstallType("testString")
				getOfferingSourceOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getOfferingSourceOptionsModel).ToNot(BeNil())
				Expect(getOfferingSourceOptionsModel.Version).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingSourceOptionsModel.Accept).To(Equal(core.StringPtr("application/yaml")))
				Expect(getOfferingSourceOptionsModel.CatalogID).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingSourceOptionsModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingSourceOptionsModel.ID).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingSourceOptionsModel.Kind).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingSourceOptionsModel.Channel).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingSourceOptionsModel.Flavor).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingSourceOptionsModel.AsIs).To(Equal(core.BoolPtr(true)))
				Expect(getOfferingSourceOptionsModel.InstallType).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingSourceOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetOfferingSourceURLOptions successfully`, func() {
				// Construct an instance of the GetOfferingSourceURLOptions model
				keyIdentifier := "testString"
				getOfferingSourceURLOptionsModel := catalogManagementService.NewGetOfferingSourceURLOptions(keyIdentifier)
				getOfferingSourceURLOptionsModel.SetKeyIdentifier("testString")
				getOfferingSourceURLOptionsModel.SetAccept("application/yaml")
				getOfferingSourceURLOptionsModel.SetCatalogID("testString")
				getOfferingSourceURLOptionsModel.SetName("testString")
				getOfferingSourceURLOptionsModel.SetID("testString")
				getOfferingSourceURLOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getOfferingSourceURLOptionsModel).ToNot(BeNil())
				Expect(getOfferingSourceURLOptionsModel.KeyIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingSourceURLOptionsModel.Accept).To(Equal(core.StringPtr("application/yaml")))
				Expect(getOfferingSourceURLOptionsModel.CatalogID).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingSourceURLOptionsModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingSourceURLOptionsModel.ID).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingSourceURLOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetOfferingStatsOptions successfully`, func() {
				// Construct an instance of the GetOfferingStatsOptions model
				catalogIdentifier := "testString"
				offeringID := "testString"
				getOfferingStatsOptionsModel := catalogManagementService.NewGetOfferingStatsOptions(catalogIdentifier, offeringID)
				getOfferingStatsOptionsModel.SetCatalogIdentifier("testString")
				getOfferingStatsOptionsModel.SetOfferingID("testString")
				getOfferingStatsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getOfferingStatsOptionsModel).ToNot(BeNil())
				Expect(getOfferingStatsOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingStatsOptionsModel.OfferingID).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingStatsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetOfferingUpdatesOptions successfully`, func() {
				// Construct an instance of the GetOfferingUpdatesOptions model
				catalogIdentifier := "testString"
				offeringID := "testString"
				kind := "testString"
				xAuthRefreshToken := "testString"
				getOfferingUpdatesOptionsModel := catalogManagementService.NewGetOfferingUpdatesOptions(catalogIdentifier, offeringID, kind, xAuthRefreshToken)
				getOfferingUpdatesOptionsModel.SetCatalogIdentifier("testString")
				getOfferingUpdatesOptionsModel.SetOfferingID("testString")
				getOfferingUpdatesOptionsModel.SetKind("testString")
				getOfferingUpdatesOptionsModel.SetXAuthRefreshToken("testString")
				getOfferingUpdatesOptionsModel.SetTarget("testString")
				getOfferingUpdatesOptionsModel.SetVersion("testString")
				getOfferingUpdatesOptionsModel.SetClusterID("testString")
				getOfferingUpdatesOptionsModel.SetRegion("testString")
				getOfferingUpdatesOptionsModel.SetResourceGroupID("testString")
				getOfferingUpdatesOptionsModel.SetNamespace("testString")
				getOfferingUpdatesOptionsModel.SetSha("testString")
				getOfferingUpdatesOptionsModel.SetChannel("testString")
				getOfferingUpdatesOptionsModel.SetNamespaces([]string{"testString"})
				getOfferingUpdatesOptionsModel.SetAllNamespaces(true)
				getOfferingUpdatesOptionsModel.SetFlavor("testString")
				getOfferingUpdatesOptionsModel.SetInstallType("testString")
				getOfferingUpdatesOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getOfferingUpdatesOptionsModel).ToNot(BeNil())
				Expect(getOfferingUpdatesOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingUpdatesOptionsModel.OfferingID).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingUpdatesOptionsModel.Kind).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingUpdatesOptionsModel.XAuthRefreshToken).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingUpdatesOptionsModel.Target).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingUpdatesOptionsModel.Version).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingUpdatesOptionsModel.ClusterID).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingUpdatesOptionsModel.Region).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingUpdatesOptionsModel.ResourceGroupID).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingUpdatesOptionsModel.Namespace).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingUpdatesOptionsModel.Sha).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingUpdatesOptionsModel.Channel).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingUpdatesOptionsModel.Namespaces).To(Equal([]string{"testString"}))
				Expect(getOfferingUpdatesOptionsModel.AllNamespaces).To(Equal(core.BoolPtr(true)))
				Expect(getOfferingUpdatesOptionsModel.Flavor).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingUpdatesOptionsModel.InstallType).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingUpdatesOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetOfferingWorkingCopyOptions successfully`, func() {
				// Construct an instance of the GetOfferingWorkingCopyOptions model
				versionLocID := "testString"
				getOfferingWorkingCopyOptionsModel := catalogManagementService.NewGetOfferingWorkingCopyOptions(versionLocID)
				getOfferingWorkingCopyOptionsModel.SetVersionLocID("testString")
				getOfferingWorkingCopyOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getOfferingWorkingCopyOptionsModel).ToNot(BeNil())
				Expect(getOfferingWorkingCopyOptionsModel.VersionLocID).To(Equal(core.StringPtr("testString")))
				Expect(getOfferingWorkingCopyOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetPlanOptions successfully`, func() {
				// Construct an instance of the GetPlanOptions model
				planLocID := "testString"
				getPlanOptionsModel := catalogManagementService.NewGetPlanOptions(planLocID)
				getPlanOptionsModel.SetPlanLocID("testString")
				getPlanOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getPlanOptionsModel).ToNot(BeNil())
				Expect(getPlanOptionsModel.PlanLocID).To(Equal(core.StringPtr("testString")))
				Expect(getPlanOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetPreinstallOptions successfully`, func() {
				// Construct an instance of the GetPreinstallOptions model
				versionLocID := "testString"
				xAuthRefreshToken := "testString"
				getPreinstallOptionsModel := catalogManagementService.NewGetPreinstallOptions(versionLocID, xAuthRefreshToken)
				getPreinstallOptionsModel.SetVersionLocID("testString")
				getPreinstallOptionsModel.SetXAuthRefreshToken("testString")
				getPreinstallOptionsModel.SetClusterID("testString")
				getPreinstallOptionsModel.SetRegion("testString")
				getPreinstallOptionsModel.SetNamespace("testString")
				getPreinstallOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getPreinstallOptionsModel).ToNot(BeNil())
				Expect(getPreinstallOptionsModel.VersionLocID).To(Equal(core.StringPtr("testString")))
				Expect(getPreinstallOptionsModel.XAuthRefreshToken).To(Equal(core.StringPtr("testString")))
				Expect(getPreinstallOptionsModel.ClusterID).To(Equal(core.StringPtr("testString")))
				Expect(getPreinstallOptionsModel.Region).To(Equal(core.StringPtr("testString")))
				Expect(getPreinstallOptionsModel.Namespace).To(Equal(core.StringPtr("testString")))
				Expect(getPreinstallOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetShareApprovalListAsSourceOptions successfully`, func() {
				// Construct an instance of the GetShareApprovalListAsSourceOptions model
				objectType := "offering"
				approvalStateIdentifier := "approved"
				getShareApprovalListAsSourceOptionsModel := catalogManagementService.NewGetShareApprovalListAsSourceOptions(objectType, approvalStateIdentifier)
				getShareApprovalListAsSourceOptionsModel.SetObjectType("offering")
				getShareApprovalListAsSourceOptionsModel.SetApprovalStateIdentifier("approved")
				getShareApprovalListAsSourceOptionsModel.SetStart("testString")
				getShareApprovalListAsSourceOptionsModel.SetLimit(int64(10))
				getShareApprovalListAsSourceOptionsModel.SetEnterpriseID("testString")
				getShareApprovalListAsSourceOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getShareApprovalListAsSourceOptionsModel).ToNot(BeNil())
				Expect(getShareApprovalListAsSourceOptionsModel.ObjectType).To(Equal(core.StringPtr("offering")))
				Expect(getShareApprovalListAsSourceOptionsModel.ApprovalStateIdentifier).To(Equal(core.StringPtr("approved")))
				Expect(getShareApprovalListAsSourceOptionsModel.Start).To(Equal(core.StringPtr("testString")))
				Expect(getShareApprovalListAsSourceOptionsModel.Limit).To(Equal(core.Int64Ptr(int64(10))))
				Expect(getShareApprovalListAsSourceOptionsModel.EnterpriseID).To(Equal(core.StringPtr("testString")))
				Expect(getShareApprovalListAsSourceOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetShareApprovalListOptions successfully`, func() {
				// Construct an instance of the GetShareApprovalListOptions model
				objectType := "offering"
				getShareApprovalListOptionsModel := catalogManagementService.NewGetShareApprovalListOptions(objectType)
				getShareApprovalListOptionsModel.SetObjectType("offering")
				getShareApprovalListOptionsModel.SetStart("testString")
				getShareApprovalListOptionsModel.SetLimit(int64(10))
				getShareApprovalListOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getShareApprovalListOptionsModel).ToNot(BeNil())
				Expect(getShareApprovalListOptionsModel.ObjectType).To(Equal(core.StringPtr("offering")))
				Expect(getShareApprovalListOptionsModel.Start).To(Equal(core.StringPtr("testString")))
				Expect(getShareApprovalListOptionsModel.Limit).To(Equal(core.Int64Ptr(int64(10))))
				Expect(getShareApprovalListOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetValidationStatusOptions successfully`, func() {
				// Construct an instance of the GetValidationStatusOptions model
				versionLocID := "testString"
				xAuthRefreshToken := "testString"
				getValidationStatusOptionsModel := catalogManagementService.NewGetValidationStatusOptions(versionLocID, xAuthRefreshToken)
				getValidationStatusOptionsModel.SetVersionLocID("testString")
				getValidationStatusOptionsModel.SetXAuthRefreshToken("testString")
				getValidationStatusOptionsModel.SetTargetContextName("testString")
				getValidationStatusOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getValidationStatusOptionsModel).ToNot(BeNil())
				Expect(getValidationStatusOptionsModel.VersionLocID).To(Equal(core.StringPtr("testString")))
				Expect(getValidationStatusOptionsModel.XAuthRefreshToken).To(Equal(core.StringPtr("testString")))
				Expect(getValidationStatusOptionsModel.TargetContextName).To(Equal(core.StringPtr("testString")))
				Expect(getValidationStatusOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetVersionDependenciesOptions successfully`, func() {
				// Construct an instance of the GetVersionDependenciesOptions model
				versionLocID := "testString"
				getVersionDependenciesOptionsModel := catalogManagementService.NewGetVersionDependenciesOptions(versionLocID)
				getVersionDependenciesOptionsModel.SetVersionLocID("testString")
				getVersionDependenciesOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getVersionDependenciesOptionsModel).ToNot(BeNil())
				Expect(getVersionDependenciesOptionsModel.VersionLocID).To(Equal(core.StringPtr("testString")))
				Expect(getVersionDependenciesOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetVersionOptions successfully`, func() {
				// Construct an instance of the GetVersionOptions model
				versionLocID := "testString"
				getVersionOptionsModel := catalogManagementService.NewGetVersionOptions(versionLocID)
				getVersionOptionsModel.SetVersionLocID("testString")
				getVersionOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getVersionOptionsModel).ToNot(BeNil())
				Expect(getVersionOptionsModel.VersionLocID).To(Equal(core.StringPtr("testString")))
				Expect(getVersionOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetVersionsOptions successfully`, func() {
				// Construct an instance of the GetVersionsOptions model
				catalogIdentifier := "testString"
				offeringID := "testString"
				kindID := "testString"
				getVersionsOptionsModel := catalogManagementService.NewGetVersionsOptions(catalogIdentifier, offeringID, kindID)
				getVersionsOptionsModel.SetCatalogIdentifier("testString")
				getVersionsOptionsModel.SetOfferingID("testString")
				getVersionsOptionsModel.SetKindID("testString")
				getVersionsOptionsModel.SetDigest(true)
				getVersionsOptionsModel.SetCatalog(true)
				getVersionsOptionsModel.SetStart("testString")
				getVersionsOptionsModel.SetLimit(int64(10))
				getVersionsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getVersionsOptionsModel).ToNot(BeNil())
				Expect(getVersionsOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(getVersionsOptionsModel.OfferingID).To(Equal(core.StringPtr("testString")))
				Expect(getVersionsOptionsModel.KindID).To(Equal(core.StringPtr("testString")))
				Expect(getVersionsOptionsModel.Digest).To(Equal(core.BoolPtr(true)))
				Expect(getVersionsOptionsModel.Catalog).To(Equal(core.BoolPtr(true)))
				Expect(getVersionsOptionsModel.Start).To(Equal(core.StringPtr("testString")))
				Expect(getVersionsOptionsModel.Limit).To(Equal(core.Int64Ptr(int64(10))))
				Expect(getVersionsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewImportOfferingOptions successfully`, func() {
				// Construct an instance of the Flavor model
				flavorModel := new(catalogmanagementv1.Flavor)
				Expect(flavorModel).ToNot(BeNil())
				flavorModel.Name = core.StringPtr("testString")
				flavorModel.Label = core.StringPtr("testString")
				flavorModel.LabelI18n = map[string]string{"key1": "testString"}
				flavorModel.Index = core.Int64Ptr(int64(38))
				Expect(flavorModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(flavorModel.Label).To(Equal(core.StringPtr("testString")))
				Expect(flavorModel.LabelI18n).To(Equal(map[string]string{"key1": "testString"}))
				Expect(flavorModel.Index).To(Equal(core.Int64Ptr(int64(38))))

				// Construct an instance of the ImportOfferingBodyMetadataOperatingSystem model
				importOfferingBodyMetadataOperatingSystemModel := new(catalogmanagementv1.ImportOfferingBodyMetadataOperatingSystem)
				Expect(importOfferingBodyMetadataOperatingSystemModel).ToNot(BeNil())
				importOfferingBodyMetadataOperatingSystemModel.DedicatedHostOnly = core.BoolPtr(true)
				importOfferingBodyMetadataOperatingSystemModel.Vendor = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Name = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Href = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.DisplayName = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Family = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Version = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Architecture = core.StringPtr("testString")
				Expect(importOfferingBodyMetadataOperatingSystemModel.DedicatedHostOnly).To(Equal(core.BoolPtr(true)))
				Expect(importOfferingBodyMetadataOperatingSystemModel.Vendor).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingBodyMetadataOperatingSystemModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingBodyMetadataOperatingSystemModel.Href).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingBodyMetadataOperatingSystemModel.DisplayName).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingBodyMetadataOperatingSystemModel.Family).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingBodyMetadataOperatingSystemModel.Version).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingBodyMetadataOperatingSystemModel.Architecture).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the ImportOfferingBodyMetadataFile model
				importOfferingBodyMetadataFileModel := new(catalogmanagementv1.ImportOfferingBodyMetadataFile)
				Expect(importOfferingBodyMetadataFileModel).ToNot(BeNil())
				importOfferingBodyMetadataFileModel.Size = core.Int64Ptr(int64(38))
				Expect(importOfferingBodyMetadataFileModel.Size).To(Equal(core.Int64Ptr(int64(38))))

				// Construct an instance of the ImportOfferingBodyMetadataImagesItem model
				importOfferingBodyMetadataImagesItemModel := new(catalogmanagementv1.ImportOfferingBodyMetadataImagesItem)
				Expect(importOfferingBodyMetadataImagesItemModel).ToNot(BeNil())
				importOfferingBodyMetadataImagesItemModel.ID = core.StringPtr("testString")
				importOfferingBodyMetadataImagesItemModel.Name = core.StringPtr("testString")
				importOfferingBodyMetadataImagesItemModel.Region = core.StringPtr("testString")
				Expect(importOfferingBodyMetadataImagesItemModel.ID).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingBodyMetadataImagesItemModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingBodyMetadataImagesItemModel.Region).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the ImportOfferingBodyMetadata model
				importOfferingBodyMetadataModel := new(catalogmanagementv1.ImportOfferingBodyMetadata)
				Expect(importOfferingBodyMetadataModel).ToNot(BeNil())
				importOfferingBodyMetadataModel.OperatingSystem = importOfferingBodyMetadataOperatingSystemModel
				importOfferingBodyMetadataModel.File = importOfferingBodyMetadataFileModel
				importOfferingBodyMetadataModel.MinimumProvisionedSize = core.Int64Ptr(int64(38))
				importOfferingBodyMetadataModel.Images = []catalogmanagementv1.ImportOfferingBodyMetadataImagesItem{*importOfferingBodyMetadataImagesItemModel}
				Expect(importOfferingBodyMetadataModel.OperatingSystem).To(Equal(importOfferingBodyMetadataOperatingSystemModel))
				Expect(importOfferingBodyMetadataModel.File).To(Equal(importOfferingBodyMetadataFileModel))
				Expect(importOfferingBodyMetadataModel.MinimumProvisionedSize).To(Equal(core.Int64Ptr(int64(38))))
				Expect(importOfferingBodyMetadataModel.Images).To(Equal([]catalogmanagementv1.ImportOfferingBodyMetadataImagesItem{*importOfferingBodyMetadataImagesItemModel}))

				// Construct an instance of the ImportOfferingOptions model
				catalogIdentifier := "testString"
				importOfferingOptionsModel := catalogManagementService.NewImportOfferingOptions(catalogIdentifier)
				importOfferingOptionsModel.SetCatalogIdentifier("testString")
				importOfferingOptionsModel.SetTags([]string{"testString"})
				importOfferingOptionsModel.SetKeywords([]string{"testString"})
				importOfferingOptionsModel.SetContent(*CreateMockByteArray("VGhpcyBpcyBhIG1vY2sgYnl0ZSBhcnJheSB2YWx1ZS4="))
				importOfferingOptionsModel.SetName("testString")
				importOfferingOptionsModel.SetLabel("testString")
				importOfferingOptionsModel.SetInstallKind("testString")
				importOfferingOptionsModel.SetTargetKinds([]string{"testString"})
				importOfferingOptionsModel.SetFormatKind("testString")
				importOfferingOptionsModel.SetProductKind("testString")
				importOfferingOptionsModel.SetProductKindLabel("testString")
				importOfferingOptionsModel.SetSha("testString")
				importOfferingOptionsModel.SetVersion("testString")
				importOfferingOptionsModel.SetFlavor(flavorModel)
				importOfferingOptionsModel.SetMetadata(importOfferingBodyMetadataModel)
				importOfferingOptionsModel.SetWorkingDirectory("testString")
				importOfferingOptionsModel.SetInstallType("testString")
				importOfferingOptionsModel.SetZipurl("testString")
				importOfferingOptionsModel.SetOfferingID("testString")
				importOfferingOptionsModel.SetTargetVersion("testString")
				importOfferingOptionsModel.SetIncludeConfig(true)
				importOfferingOptionsModel.SetIsVsi(true)
				importOfferingOptionsModel.SetRepotype("testString")
				importOfferingOptionsModel.SetXAuthToken("testString")
				importOfferingOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(importOfferingOptionsModel).ToNot(BeNil())
				Expect(importOfferingOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingOptionsModel.Tags).To(Equal([]string{"testString"}))
				Expect(importOfferingOptionsModel.Keywords).To(Equal([]string{"testString"}))
				Expect(importOfferingOptionsModel.Content).To(Equal(CreateMockByteArray("VGhpcyBpcyBhIG1vY2sgYnl0ZSBhcnJheSB2YWx1ZS4=")))
				Expect(importOfferingOptionsModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingOptionsModel.Label).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingOptionsModel.InstallKind).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingOptionsModel.TargetKinds).To(Equal([]string{"testString"}))
				Expect(importOfferingOptionsModel.FormatKind).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingOptionsModel.ProductKind).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingOptionsModel.ProductKindLabel).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingOptionsModel.Sha).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingOptionsModel.Version).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingOptionsModel.Flavor).To(Equal(flavorModel))
				Expect(importOfferingOptionsModel.Metadata).To(Equal(importOfferingBodyMetadataModel))
				Expect(importOfferingOptionsModel.WorkingDirectory).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingOptionsModel.InstallType).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingOptionsModel.Zipurl).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingOptionsModel.OfferingID).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingOptionsModel.TargetVersion).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingOptionsModel.IncludeConfig).To(Equal(core.BoolPtr(true)))
				Expect(importOfferingOptionsModel.IsVsi).To(Equal(core.BoolPtr(true)))
				Expect(importOfferingOptionsModel.Repotype).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingOptionsModel.XAuthToken).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewImportOfferingVersionOptions successfully`, func() {
				// Construct an instance of the Flavor model
				flavorModel := new(catalogmanagementv1.Flavor)
				Expect(flavorModel).ToNot(BeNil())
				flavorModel.Name = core.StringPtr("testString")
				flavorModel.Label = core.StringPtr("testString")
				flavorModel.LabelI18n = map[string]string{"key1": "testString"}
				flavorModel.Index = core.Int64Ptr(int64(38))
				Expect(flavorModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(flavorModel.Label).To(Equal(core.StringPtr("testString")))
				Expect(flavorModel.LabelI18n).To(Equal(map[string]string{"key1": "testString"}))
				Expect(flavorModel.Index).To(Equal(core.Int64Ptr(int64(38))))

				// Construct an instance of the ImportOfferingBodyMetadataOperatingSystem model
				importOfferingBodyMetadataOperatingSystemModel := new(catalogmanagementv1.ImportOfferingBodyMetadataOperatingSystem)
				Expect(importOfferingBodyMetadataOperatingSystemModel).ToNot(BeNil())
				importOfferingBodyMetadataOperatingSystemModel.DedicatedHostOnly = core.BoolPtr(true)
				importOfferingBodyMetadataOperatingSystemModel.Vendor = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Name = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Href = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.DisplayName = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Family = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Version = core.StringPtr("testString")
				importOfferingBodyMetadataOperatingSystemModel.Architecture = core.StringPtr("testString")
				Expect(importOfferingBodyMetadataOperatingSystemModel.DedicatedHostOnly).To(Equal(core.BoolPtr(true)))
				Expect(importOfferingBodyMetadataOperatingSystemModel.Vendor).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingBodyMetadataOperatingSystemModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingBodyMetadataOperatingSystemModel.Href).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingBodyMetadataOperatingSystemModel.DisplayName).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingBodyMetadataOperatingSystemModel.Family).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingBodyMetadataOperatingSystemModel.Version).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingBodyMetadataOperatingSystemModel.Architecture).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the ImportOfferingBodyMetadataFile model
				importOfferingBodyMetadataFileModel := new(catalogmanagementv1.ImportOfferingBodyMetadataFile)
				Expect(importOfferingBodyMetadataFileModel).ToNot(BeNil())
				importOfferingBodyMetadataFileModel.Size = core.Int64Ptr(int64(38))
				Expect(importOfferingBodyMetadataFileModel.Size).To(Equal(core.Int64Ptr(int64(38))))

				// Construct an instance of the ImportOfferingBodyMetadataImagesItem model
				importOfferingBodyMetadataImagesItemModel := new(catalogmanagementv1.ImportOfferingBodyMetadataImagesItem)
				Expect(importOfferingBodyMetadataImagesItemModel).ToNot(BeNil())
				importOfferingBodyMetadataImagesItemModel.ID = core.StringPtr("testString")
				importOfferingBodyMetadataImagesItemModel.Name = core.StringPtr("testString")
				importOfferingBodyMetadataImagesItemModel.Region = core.StringPtr("testString")
				Expect(importOfferingBodyMetadataImagesItemModel.ID).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingBodyMetadataImagesItemModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingBodyMetadataImagesItemModel.Region).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the ImportOfferingBodyMetadata model
				importOfferingBodyMetadataModel := new(catalogmanagementv1.ImportOfferingBodyMetadata)
				Expect(importOfferingBodyMetadataModel).ToNot(BeNil())
				importOfferingBodyMetadataModel.OperatingSystem = importOfferingBodyMetadataOperatingSystemModel
				importOfferingBodyMetadataModel.File = importOfferingBodyMetadataFileModel
				importOfferingBodyMetadataModel.MinimumProvisionedSize = core.Int64Ptr(int64(38))
				importOfferingBodyMetadataModel.Images = []catalogmanagementv1.ImportOfferingBodyMetadataImagesItem{*importOfferingBodyMetadataImagesItemModel}
				Expect(importOfferingBodyMetadataModel.OperatingSystem).To(Equal(importOfferingBodyMetadataOperatingSystemModel))
				Expect(importOfferingBodyMetadataModel.File).To(Equal(importOfferingBodyMetadataFileModel))
				Expect(importOfferingBodyMetadataModel.MinimumProvisionedSize).To(Equal(core.Int64Ptr(int64(38))))
				Expect(importOfferingBodyMetadataModel.Images).To(Equal([]catalogmanagementv1.ImportOfferingBodyMetadataImagesItem{*importOfferingBodyMetadataImagesItemModel}))

				// Construct an instance of the ImportOfferingVersionOptions model
				catalogIdentifier := "testString"
				offeringID := "testString"
				importOfferingVersionOptionsModel := catalogManagementService.NewImportOfferingVersionOptions(catalogIdentifier, offeringID)
				importOfferingVersionOptionsModel.SetCatalogIdentifier("testString")
				importOfferingVersionOptionsModel.SetOfferingID("testString")
				importOfferingVersionOptionsModel.SetTags([]string{"testString"})
				importOfferingVersionOptionsModel.SetKeywords([]string{"testString"})
				importOfferingVersionOptionsModel.SetContent(*CreateMockByteArray("VGhpcyBpcyBhIG1vY2sgYnl0ZSBhcnJheSB2YWx1ZS4="))
				importOfferingVersionOptionsModel.SetName("testString")
				importOfferingVersionOptionsModel.SetLabel("testString")
				importOfferingVersionOptionsModel.SetInstallKind("testString")
				importOfferingVersionOptionsModel.SetTargetKinds([]string{"testString"})
				importOfferingVersionOptionsModel.SetFormatKind("testString")
				importOfferingVersionOptionsModel.SetProductKind("testString")
				importOfferingVersionOptionsModel.SetProductKindLabel("testString")
				importOfferingVersionOptionsModel.SetSha("testString")
				importOfferingVersionOptionsModel.SetVersion("testString")
				importOfferingVersionOptionsModel.SetFlavor(flavorModel)
				importOfferingVersionOptionsModel.SetMetadata(importOfferingBodyMetadataModel)
				importOfferingVersionOptionsModel.SetWorkingDirectory("testString")
				importOfferingVersionOptionsModel.SetInstallType("testString")
				importOfferingVersionOptionsModel.SetZipurl("testString")
				importOfferingVersionOptionsModel.SetTargetVersion("testString")
				importOfferingVersionOptionsModel.SetIncludeConfig(true)
				importOfferingVersionOptionsModel.SetIsVsi(true)
				importOfferingVersionOptionsModel.SetRepotype("testString")
				importOfferingVersionOptionsModel.SetXAuthToken("testString")
				importOfferingVersionOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(importOfferingVersionOptionsModel).ToNot(BeNil())
				Expect(importOfferingVersionOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingVersionOptionsModel.OfferingID).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingVersionOptionsModel.Tags).To(Equal([]string{"testString"}))
				Expect(importOfferingVersionOptionsModel.Keywords).To(Equal([]string{"testString"}))
				Expect(importOfferingVersionOptionsModel.Content).To(Equal(CreateMockByteArray("VGhpcyBpcyBhIG1vY2sgYnl0ZSBhcnJheSB2YWx1ZS4=")))
				Expect(importOfferingVersionOptionsModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingVersionOptionsModel.Label).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingVersionOptionsModel.InstallKind).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingVersionOptionsModel.TargetKinds).To(Equal([]string{"testString"}))
				Expect(importOfferingVersionOptionsModel.FormatKind).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingVersionOptionsModel.ProductKind).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingVersionOptionsModel.ProductKindLabel).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingVersionOptionsModel.Sha).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingVersionOptionsModel.Version).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingVersionOptionsModel.Flavor).To(Equal(flavorModel))
				Expect(importOfferingVersionOptionsModel.Metadata).To(Equal(importOfferingBodyMetadataModel))
				Expect(importOfferingVersionOptionsModel.WorkingDirectory).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingVersionOptionsModel.InstallType).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingVersionOptionsModel.Zipurl).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingVersionOptionsModel.TargetVersion).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingVersionOptionsModel.IncludeConfig).To(Equal(core.BoolPtr(true)))
				Expect(importOfferingVersionOptionsModel.IsVsi).To(Equal(core.BoolPtr(true)))
				Expect(importOfferingVersionOptionsModel.Repotype).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingVersionOptionsModel.XAuthToken).To(Equal(core.StringPtr("testString")))
				Expect(importOfferingVersionOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewInstallVersionOptions successfully`, func() {
				// Construct an instance of the DeployRequestBodyOverrideValues model
				deployRequestBodyOverrideValuesModel := new(catalogmanagementv1.DeployRequestBodyOverrideValues)
				Expect(deployRequestBodyOverrideValuesModel).ToNot(BeNil())
				deployRequestBodyOverrideValuesModel.VsiInstanceName = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.VPCProfile = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.SubnetID = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.VPCID = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.SubnetZone = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.SSHKeyID = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.VPCRegion = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.SetProperty("foo", "testString")
				Expect(deployRequestBodyOverrideValuesModel.VsiInstanceName).To(Equal(core.StringPtr("testString")))
				Expect(deployRequestBodyOverrideValuesModel.VPCProfile).To(Equal(core.StringPtr("testString")))
				Expect(deployRequestBodyOverrideValuesModel.SubnetID).To(Equal(core.StringPtr("testString")))
				Expect(deployRequestBodyOverrideValuesModel.VPCID).To(Equal(core.StringPtr("testString")))
				Expect(deployRequestBodyOverrideValuesModel.SubnetZone).To(Equal(core.StringPtr("testString")))
				Expect(deployRequestBodyOverrideValuesModel.SSHKeyID).To(Equal(core.StringPtr("testString")))
				Expect(deployRequestBodyOverrideValuesModel.VPCRegion).To(Equal(core.StringPtr("testString")))
				Expect(deployRequestBodyOverrideValuesModel.GetProperties()).ToNot(BeEmpty())
				Expect(deployRequestBodyOverrideValuesModel.GetProperty("foo")).To(Equal("testString"))

				deployRequestBodyOverrideValuesModel.SetProperties(nil)
				Expect(deployRequestBodyOverrideValuesModel.GetProperties()).To(BeEmpty())

				deployRequestBodyOverrideValuesModelExpectedMap := make(map[string]interface{})
				deployRequestBodyOverrideValuesModelExpectedMap["foo"] = "testString"
				deployRequestBodyOverrideValuesModel.SetProperties(deployRequestBodyOverrideValuesModelExpectedMap)
				deployRequestBodyOverrideValuesModelActualMap := deployRequestBodyOverrideValuesModel.GetProperties()
				Expect(deployRequestBodyOverrideValuesModelActualMap).To(Equal(deployRequestBodyOverrideValuesModelExpectedMap))

				// Construct an instance of the DeployRequestBodyEnvironmentVariablesItem model
				deployRequestBodyEnvironmentVariablesItemModel := new(catalogmanagementv1.DeployRequestBodyEnvironmentVariablesItem)
				Expect(deployRequestBodyEnvironmentVariablesItemModel).ToNot(BeNil())
				deployRequestBodyEnvironmentVariablesItemModel.Name = core.StringPtr("testString")
				deployRequestBodyEnvironmentVariablesItemModel.Value = "testString"
				deployRequestBodyEnvironmentVariablesItemModel.Secure = core.BoolPtr(true)
				deployRequestBodyEnvironmentVariablesItemModel.Hidden = core.BoolPtr(true)
				Expect(deployRequestBodyEnvironmentVariablesItemModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(deployRequestBodyEnvironmentVariablesItemModel.Value).To(Equal("testString"))
				Expect(deployRequestBodyEnvironmentVariablesItemModel.Secure).To(Equal(core.BoolPtr(true)))
				Expect(deployRequestBodyEnvironmentVariablesItemModel.Hidden).To(Equal(core.BoolPtr(true)))

				// Construct an instance of the DeployRequestBodySchematics model
				deployRequestBodySchematicsModel := new(catalogmanagementv1.DeployRequestBodySchematics)
				Expect(deployRequestBodySchematicsModel).ToNot(BeNil())
				deployRequestBodySchematicsModel.Name = core.StringPtr("testString")
				deployRequestBodySchematicsModel.Description = core.StringPtr("testString")
				deployRequestBodySchematicsModel.Tags = []string{"testString"}
				deployRequestBodySchematicsModel.ResourceGroupID = core.StringPtr("testString")
				deployRequestBodySchematicsModel.TerraformVersion = core.StringPtr("testString")
				deployRequestBodySchematicsModel.Region = core.StringPtr("testString")
				Expect(deployRequestBodySchematicsModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(deployRequestBodySchematicsModel.Description).To(Equal(core.StringPtr("testString")))
				Expect(deployRequestBodySchematicsModel.Tags).To(Equal([]string{"testString"}))
				Expect(deployRequestBodySchematicsModel.ResourceGroupID).To(Equal(core.StringPtr("testString")))
				Expect(deployRequestBodySchematicsModel.TerraformVersion).To(Equal(core.StringPtr("testString")))
				Expect(deployRequestBodySchematicsModel.Region).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the InstallVersionOptions model
				versionLocID := "testString"
				xAuthRefreshToken := "testString"
				installVersionOptionsModel := catalogManagementService.NewInstallVersionOptions(versionLocID, xAuthRefreshToken)
				installVersionOptionsModel.SetVersionLocID("testString")
				installVersionOptionsModel.SetXAuthRefreshToken("testString")
				installVersionOptionsModel.SetClusterID("testString")
				installVersionOptionsModel.SetRegion("testString")
				installVersionOptionsModel.SetNamespace("testString")
				installVersionOptionsModel.SetNamespaces([]string{"testString"})
				installVersionOptionsModel.SetAllNamespaces(true)
				installVersionOptionsModel.SetOverrideValues(deployRequestBodyOverrideValuesModel)
				installVersionOptionsModel.SetDependencyConfigs([]string{"testString"})
				installVersionOptionsModel.SetEnvironmentVariables([]catalogmanagementv1.DeployRequestBodyEnvironmentVariablesItem{*deployRequestBodyEnvironmentVariablesItemModel})
				installVersionOptionsModel.SetEntitlementApikey("testString")
				installVersionOptionsModel.SetSchematics(deployRequestBodySchematicsModel)
				installVersionOptionsModel.SetScript("testString")
				installVersionOptionsModel.SetScriptID("testString")
				installVersionOptionsModel.SetVersionLocatorID("testString")
				installVersionOptionsModel.SetVcenterID("testString")
				installVersionOptionsModel.SetVcenterLocation("testString")
				installVersionOptionsModel.SetVcenterUser("testString")
				installVersionOptionsModel.SetVcenterPassword("testString")
				installVersionOptionsModel.SetVcenterDatastore("testString")
				installVersionOptionsModel.SetPlanID("testString")
				installVersionOptionsModel.SetChannel("testString")
				installVersionOptionsModel.SetInstallPlan("testString")
				installVersionOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(installVersionOptionsModel).ToNot(BeNil())
				Expect(installVersionOptionsModel.VersionLocID).To(Equal(core.StringPtr("testString")))
				Expect(installVersionOptionsModel.XAuthRefreshToken).To(Equal(core.StringPtr("testString")))
				Expect(installVersionOptionsModel.ClusterID).To(Equal(core.StringPtr("testString")))
				Expect(installVersionOptionsModel.Region).To(Equal(core.StringPtr("testString")))
				Expect(installVersionOptionsModel.Namespace).To(Equal(core.StringPtr("testString")))
				Expect(installVersionOptionsModel.Namespaces).To(Equal([]string{"testString"}))
				Expect(installVersionOptionsModel.AllNamespaces).To(Equal(core.BoolPtr(true)))
				Expect(installVersionOptionsModel.OverrideValues).To(Equal(deployRequestBodyOverrideValuesModel))
				Expect(installVersionOptionsModel.DependencyConfigs).To(Equal([]string{"testString"}))
				Expect(installVersionOptionsModel.EnvironmentVariables).To(Equal([]catalogmanagementv1.DeployRequestBodyEnvironmentVariablesItem{*deployRequestBodyEnvironmentVariablesItemModel}))
				Expect(installVersionOptionsModel.EntitlementApikey).To(Equal(core.StringPtr("testString")))
				Expect(installVersionOptionsModel.Schematics).To(Equal(deployRequestBodySchematicsModel))
				Expect(installVersionOptionsModel.Script).To(Equal(core.StringPtr("testString")))
				Expect(installVersionOptionsModel.ScriptID).To(Equal(core.StringPtr("testString")))
				Expect(installVersionOptionsModel.VersionLocatorID).To(Equal(core.StringPtr("testString")))
				Expect(installVersionOptionsModel.VcenterID).To(Equal(core.StringPtr("testString")))
				Expect(installVersionOptionsModel.VcenterLocation).To(Equal(core.StringPtr("testString")))
				Expect(installVersionOptionsModel.VcenterUser).To(Equal(core.StringPtr("testString")))
				Expect(installVersionOptionsModel.VcenterPassword).To(Equal(core.StringPtr("testString")))
				Expect(installVersionOptionsModel.VcenterDatastore).To(Equal(core.StringPtr("testString")))
				Expect(installVersionOptionsModel.PlanID).To(Equal(core.StringPtr("testString")))
				Expect(installVersionOptionsModel.Channel).To(Equal(core.StringPtr("testString")))
				Expect(installVersionOptionsModel.InstallPlan).To(Equal(core.StringPtr("testString")))
				Expect(installVersionOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewJSONPatchOperation successfully`, func() {
				op := "add"
				path := "testString"
				_model, err := catalogManagementService.NewJSONPatchOperation(op, path)
				Expect(_model).ToNot(BeNil())
				Expect(err).To(BeNil())
			})
			It(`Invoke NewListCatalogAccountAuditsOptions successfully`, func() {
				// Construct an instance of the ListCatalogAccountAuditsOptions model
				listCatalogAccountAuditsOptionsModel := catalogManagementService.NewListCatalogAccountAuditsOptions()
				listCatalogAccountAuditsOptionsModel.SetStart("testString")
				listCatalogAccountAuditsOptionsModel.SetLimit(int64(10))
				listCatalogAccountAuditsOptionsModel.SetLookupnames(true)
				listCatalogAccountAuditsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(listCatalogAccountAuditsOptionsModel).ToNot(BeNil())
				Expect(listCatalogAccountAuditsOptionsModel.Start).To(Equal(core.StringPtr("testString")))
				Expect(listCatalogAccountAuditsOptionsModel.Limit).To(Equal(core.Int64Ptr(int64(10))))
				Expect(listCatalogAccountAuditsOptionsModel.Lookupnames).To(Equal(core.BoolPtr(true)))
				Expect(listCatalogAccountAuditsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewListCatalogAuditsOptions successfully`, func() {
				// Construct an instance of the ListCatalogAuditsOptions model
				catalogIdentifier := "testString"
				listCatalogAuditsOptionsModel := catalogManagementService.NewListCatalogAuditsOptions(catalogIdentifier)
				listCatalogAuditsOptionsModel.SetCatalogIdentifier("testString")
				listCatalogAuditsOptionsModel.SetStart("testString")
				listCatalogAuditsOptionsModel.SetLimit(int64(10))
				listCatalogAuditsOptionsModel.SetLookupnames(true)
				listCatalogAuditsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(listCatalogAuditsOptionsModel).ToNot(BeNil())
				Expect(listCatalogAuditsOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(listCatalogAuditsOptionsModel.Start).To(Equal(core.StringPtr("testString")))
				Expect(listCatalogAuditsOptionsModel.Limit).To(Equal(core.Int64Ptr(int64(10))))
				Expect(listCatalogAuditsOptionsModel.Lookupnames).To(Equal(core.BoolPtr(true)))
				Expect(listCatalogAuditsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewListCatalogsOptions successfully`, func() {
				// Construct an instance of the ListCatalogsOptions model
				listCatalogsOptionsModel := catalogManagementService.NewListCatalogsOptions()
				listCatalogsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(listCatalogsOptionsModel).ToNot(BeNil())
				Expect(listCatalogsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewListEnterpriseAuditsOptions successfully`, func() {
				// Construct an instance of the ListEnterpriseAuditsOptions model
				enterpriseIdentifier := "testString"
				listEnterpriseAuditsOptionsModel := catalogManagementService.NewListEnterpriseAuditsOptions(enterpriseIdentifier)
				listEnterpriseAuditsOptionsModel.SetEnterpriseIdentifier("testString")
				listEnterpriseAuditsOptionsModel.SetStart("testString")
				listEnterpriseAuditsOptionsModel.SetLimit(int64(10))
				listEnterpriseAuditsOptionsModel.SetLookupnames(true)
				listEnterpriseAuditsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(listEnterpriseAuditsOptionsModel).ToNot(BeNil())
				Expect(listEnterpriseAuditsOptionsModel.EnterpriseIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(listEnterpriseAuditsOptionsModel.Start).To(Equal(core.StringPtr("testString")))
				Expect(listEnterpriseAuditsOptionsModel.Limit).To(Equal(core.Int64Ptr(int64(10))))
				Expect(listEnterpriseAuditsOptionsModel.Lookupnames).To(Equal(core.BoolPtr(true)))
				Expect(listEnterpriseAuditsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewListObjectAuditsOptions successfully`, func() {
				// Construct an instance of the ListObjectAuditsOptions model
				catalogIdentifier := "testString"
				objectIdentifier := "testString"
				listObjectAuditsOptionsModel := catalogManagementService.NewListObjectAuditsOptions(catalogIdentifier, objectIdentifier)
				listObjectAuditsOptionsModel.SetCatalogIdentifier("testString")
				listObjectAuditsOptionsModel.SetObjectIdentifier("testString")
				listObjectAuditsOptionsModel.SetStart("testString")
				listObjectAuditsOptionsModel.SetLimit(int64(10))
				listObjectAuditsOptionsModel.SetLookupnames(true)
				listObjectAuditsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(listObjectAuditsOptionsModel).ToNot(BeNil())
				Expect(listObjectAuditsOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(listObjectAuditsOptionsModel.ObjectIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(listObjectAuditsOptionsModel.Start).To(Equal(core.StringPtr("testString")))
				Expect(listObjectAuditsOptionsModel.Limit).To(Equal(core.Int64Ptr(int64(10))))
				Expect(listObjectAuditsOptionsModel.Lookupnames).To(Equal(core.BoolPtr(true)))
				Expect(listObjectAuditsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewListObjectsOptions successfully`, func() {
				// Construct an instance of the ListObjectsOptions model
				catalogIdentifier := "testString"
				listObjectsOptionsModel := catalogManagementService.NewListObjectsOptions(catalogIdentifier)
				listObjectsOptionsModel.SetCatalogIdentifier("testString")
				listObjectsOptionsModel.SetLimit(int64(10))
				listObjectsOptionsModel.SetOffset(int64(0))
				listObjectsOptionsModel.SetName("testString")
				listObjectsOptionsModel.SetSort("testString")
				listObjectsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(listObjectsOptionsModel).ToNot(BeNil())
				Expect(listObjectsOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(listObjectsOptionsModel.Limit).To(Equal(core.Int64Ptr(int64(10))))
				Expect(listObjectsOptionsModel.Offset).To(Equal(core.Int64Ptr(int64(0))))
				Expect(listObjectsOptionsModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(listObjectsOptionsModel.Sort).To(Equal(core.StringPtr("testString")))
				Expect(listObjectsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewListOfferingAuditsOptions successfully`, func() {
				// Construct an instance of the ListOfferingAuditsOptions model
				catalogIdentifier := "testString"
				offeringID := "testString"
				listOfferingAuditsOptionsModel := catalogManagementService.NewListOfferingAuditsOptions(catalogIdentifier, offeringID)
				listOfferingAuditsOptionsModel.SetCatalogIdentifier("testString")
				listOfferingAuditsOptionsModel.SetOfferingID("testString")
				listOfferingAuditsOptionsModel.SetStart("testString")
				listOfferingAuditsOptionsModel.SetLimit(int64(10))
				listOfferingAuditsOptionsModel.SetLookupnames(true)
				listOfferingAuditsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(listOfferingAuditsOptionsModel).ToNot(BeNil())
				Expect(listOfferingAuditsOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(listOfferingAuditsOptionsModel.OfferingID).To(Equal(core.StringPtr("testString")))
				Expect(listOfferingAuditsOptionsModel.Start).To(Equal(core.StringPtr("testString")))
				Expect(listOfferingAuditsOptionsModel.Limit).To(Equal(core.Int64Ptr(int64(10))))
				Expect(listOfferingAuditsOptionsModel.Lookupnames).To(Equal(core.BoolPtr(true)))
				Expect(listOfferingAuditsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewListOfferingInstanceAuditsOptions successfully`, func() {
				// Construct an instance of the ListOfferingInstanceAuditsOptions model
				instanceIdentifier := "testString"
				listOfferingInstanceAuditsOptionsModel := catalogManagementService.NewListOfferingInstanceAuditsOptions(instanceIdentifier)
				listOfferingInstanceAuditsOptionsModel.SetInstanceIdentifier("testString")
				listOfferingInstanceAuditsOptionsModel.SetStart("testString")
				listOfferingInstanceAuditsOptionsModel.SetLimit(int64(10))
				listOfferingInstanceAuditsOptionsModel.SetLookupnames(true)
				listOfferingInstanceAuditsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(listOfferingInstanceAuditsOptionsModel).ToNot(BeNil())
				Expect(listOfferingInstanceAuditsOptionsModel.InstanceIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(listOfferingInstanceAuditsOptionsModel.Start).To(Equal(core.StringPtr("testString")))
				Expect(listOfferingInstanceAuditsOptionsModel.Limit).To(Equal(core.Int64Ptr(int64(10))))
				Expect(listOfferingInstanceAuditsOptionsModel.Lookupnames).To(Equal(core.BoolPtr(true)))
				Expect(listOfferingInstanceAuditsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewListOfferingsOptions successfully`, func() {
				// Construct an instance of the ListOfferingsOptions model
				catalogIdentifier := "testString"
				listOfferingsOptionsModel := catalogManagementService.NewListOfferingsOptions(catalogIdentifier)
				listOfferingsOptionsModel.SetCatalogIdentifier("testString")
				listOfferingsOptionsModel.SetDigest(true)
				listOfferingsOptionsModel.SetLimit(int64(10))
				listOfferingsOptionsModel.SetOffset(int64(0))
				listOfferingsOptionsModel.SetName("testString")
				listOfferingsOptionsModel.SetSort("testString")
				listOfferingsOptionsModel.SetIncludeHidden(true)
				listOfferingsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(listOfferingsOptionsModel).ToNot(BeNil())
				Expect(listOfferingsOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(listOfferingsOptionsModel.Digest).To(Equal(core.BoolPtr(true)))
				Expect(listOfferingsOptionsModel.Limit).To(Equal(core.Int64Ptr(int64(10))))
				Expect(listOfferingsOptionsModel.Offset).To(Equal(core.Int64Ptr(int64(0))))
				Expect(listOfferingsOptionsModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(listOfferingsOptionsModel.Sort).To(Equal(core.StringPtr("testString")))
				Expect(listOfferingsOptionsModel.IncludeHidden).To(Equal(core.BoolPtr(true)))
				Expect(listOfferingsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewListOperatorsOptions successfully`, func() {
				// Construct an instance of the ListOperatorsOptions model
				xAuthRefreshToken := "testString"
				clusterID := "testString"
				region := "testString"
				versionLocatorID := "testString"
				listOperatorsOptionsModel := catalogManagementService.NewListOperatorsOptions(xAuthRefreshToken, clusterID, region, versionLocatorID)
				listOperatorsOptionsModel.SetXAuthRefreshToken("testString")
				listOperatorsOptionsModel.SetClusterID("testString")
				listOperatorsOptionsModel.SetRegion("testString")
				listOperatorsOptionsModel.SetVersionLocatorID("testString")
				listOperatorsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(listOperatorsOptionsModel).ToNot(BeNil())
				Expect(listOperatorsOptionsModel.XAuthRefreshToken).To(Equal(core.StringPtr("testString")))
				Expect(listOperatorsOptionsModel.ClusterID).To(Equal(core.StringPtr("testString")))
				Expect(listOperatorsOptionsModel.Region).To(Equal(core.StringPtr("testString")))
				Expect(listOperatorsOptionsModel.VersionLocatorID).To(Equal(core.StringPtr("testString")))
				Expect(listOperatorsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewListRegionsOptions successfully`, func() {
				// Construct an instance of the ListRegionsOptions model
				listRegionsOptionsModel := catalogManagementService.NewListRegionsOptions()
				listRegionsOptionsModel.SetFilter("testString")
				listRegionsOptionsModel.SetGetInactive(true)
				listRegionsOptionsModel.SetLimit(int64(100))
				listRegionsOptionsModel.SetOffset(int64(0))
				listRegionsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(listRegionsOptionsModel).ToNot(BeNil())
				Expect(listRegionsOptionsModel.Filter).To(Equal(core.StringPtr("testString")))
				Expect(listRegionsOptionsModel.GetInactive).To(Equal(core.BoolPtr(true)))
				Expect(listRegionsOptionsModel.Limit).To(Equal(core.Int64Ptr(int64(100))))
				Expect(listRegionsOptionsModel.Offset).To(Equal(core.Int64Ptr(int64(0))))
				Expect(listRegionsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewPaginationTokenLink successfully`, func() {
				href := "testString"
				_model, err := catalogManagementService.NewPaginationTokenLink(href)
				Expect(_model).ToNot(BeNil())
				Expect(err).To(BeNil())
			})
			It(`Invoke NewPatchUpdateVersionOptions successfully`, func() {
				// Construct an instance of the JSONPatchOperation model
				jsonPatchOperationModel := new(catalogmanagementv1.JSONPatchOperation)
				Expect(jsonPatchOperationModel).ToNot(BeNil())
				jsonPatchOperationModel.Op = core.StringPtr("add")
				jsonPatchOperationModel.Path = core.StringPtr("testString")
				jsonPatchOperationModel.Value = "testString"
				jsonPatchOperationModel.From = core.StringPtr("testString")
				Expect(jsonPatchOperationModel.Op).To(Equal(core.StringPtr("add")))
				Expect(jsonPatchOperationModel.Path).To(Equal(core.StringPtr("testString")))
				Expect(jsonPatchOperationModel.Value).To(Equal("testString"))
				Expect(jsonPatchOperationModel.From).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the PatchUpdateVersionOptions model
				versionLocID := "testString"
				ifMatch := "testString"
				patchUpdateVersionOptionsModel := catalogManagementService.NewPatchUpdateVersionOptions(versionLocID, ifMatch)
				patchUpdateVersionOptionsModel.SetVersionLocID("testString")
				patchUpdateVersionOptionsModel.SetIfMatch("testString")
				patchUpdateVersionOptionsModel.SetUpdates([]catalogmanagementv1.JSONPatchOperation{*jsonPatchOperationModel})
				patchUpdateVersionOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(patchUpdateVersionOptionsModel).ToNot(BeNil())
				Expect(patchUpdateVersionOptionsModel.VersionLocID).To(Equal(core.StringPtr("testString")))
				Expect(patchUpdateVersionOptionsModel.IfMatch).To(Equal(core.StringPtr("testString")))
				Expect(patchUpdateVersionOptionsModel.Updates).To(Equal([]catalogmanagementv1.JSONPatchOperation{*jsonPatchOperationModel}))
				Expect(patchUpdateVersionOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewPreinstallVersionOptions successfully`, func() {
				// Construct an instance of the DeployRequestBodyOverrideValues model
				deployRequestBodyOverrideValuesModel := new(catalogmanagementv1.DeployRequestBodyOverrideValues)
				Expect(deployRequestBodyOverrideValuesModel).ToNot(BeNil())
				deployRequestBodyOverrideValuesModel.VsiInstanceName = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.VPCProfile = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.SubnetID = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.VPCID = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.SubnetZone = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.SSHKeyID = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.VPCRegion = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.SetProperty("foo", "testString")
				Expect(deployRequestBodyOverrideValuesModel.VsiInstanceName).To(Equal(core.StringPtr("testString")))
				Expect(deployRequestBodyOverrideValuesModel.VPCProfile).To(Equal(core.StringPtr("testString")))
				Expect(deployRequestBodyOverrideValuesModel.SubnetID).To(Equal(core.StringPtr("testString")))
				Expect(deployRequestBodyOverrideValuesModel.VPCID).To(Equal(core.StringPtr("testString")))
				Expect(deployRequestBodyOverrideValuesModel.SubnetZone).To(Equal(core.StringPtr("testString")))
				Expect(deployRequestBodyOverrideValuesModel.SSHKeyID).To(Equal(core.StringPtr("testString")))
				Expect(deployRequestBodyOverrideValuesModel.VPCRegion).To(Equal(core.StringPtr("testString")))
				Expect(deployRequestBodyOverrideValuesModel.GetProperties()).ToNot(BeEmpty())
				Expect(deployRequestBodyOverrideValuesModel.GetProperty("foo")).To(Equal("testString"))

				deployRequestBodyOverrideValuesModel.SetProperties(nil)
				Expect(deployRequestBodyOverrideValuesModel.GetProperties()).To(BeEmpty())

				deployRequestBodyOverrideValuesModelExpectedMap := make(map[string]interface{})
				deployRequestBodyOverrideValuesModelExpectedMap["foo"] = "testString"
				deployRequestBodyOverrideValuesModel.SetProperties(deployRequestBodyOverrideValuesModelExpectedMap)
				deployRequestBodyOverrideValuesModelActualMap := deployRequestBodyOverrideValuesModel.GetProperties()
				Expect(deployRequestBodyOverrideValuesModelActualMap).To(Equal(deployRequestBodyOverrideValuesModelExpectedMap))

				// Construct an instance of the DeployRequestBodyEnvironmentVariablesItem model
				deployRequestBodyEnvironmentVariablesItemModel := new(catalogmanagementv1.DeployRequestBodyEnvironmentVariablesItem)
				Expect(deployRequestBodyEnvironmentVariablesItemModel).ToNot(BeNil())
				deployRequestBodyEnvironmentVariablesItemModel.Name = core.StringPtr("testString")
				deployRequestBodyEnvironmentVariablesItemModel.Value = "testString"
				deployRequestBodyEnvironmentVariablesItemModel.Secure = core.BoolPtr(true)
				deployRequestBodyEnvironmentVariablesItemModel.Hidden = core.BoolPtr(true)
				Expect(deployRequestBodyEnvironmentVariablesItemModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(deployRequestBodyEnvironmentVariablesItemModel.Value).To(Equal("testString"))
				Expect(deployRequestBodyEnvironmentVariablesItemModel.Secure).To(Equal(core.BoolPtr(true)))
				Expect(deployRequestBodyEnvironmentVariablesItemModel.Hidden).To(Equal(core.BoolPtr(true)))

				// Construct an instance of the DeployRequestBodySchematics model
				deployRequestBodySchematicsModel := new(catalogmanagementv1.DeployRequestBodySchematics)
				Expect(deployRequestBodySchematicsModel).ToNot(BeNil())
				deployRequestBodySchematicsModel.Name = core.StringPtr("testString")
				deployRequestBodySchematicsModel.Description = core.StringPtr("testString")
				deployRequestBodySchematicsModel.Tags = []string{"testString"}
				deployRequestBodySchematicsModel.ResourceGroupID = core.StringPtr("testString")
				deployRequestBodySchematicsModel.TerraformVersion = core.StringPtr("testString")
				deployRequestBodySchematicsModel.Region = core.StringPtr("testString")
				Expect(deployRequestBodySchematicsModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(deployRequestBodySchematicsModel.Description).To(Equal(core.StringPtr("testString")))
				Expect(deployRequestBodySchematicsModel.Tags).To(Equal([]string{"testString"}))
				Expect(deployRequestBodySchematicsModel.ResourceGroupID).To(Equal(core.StringPtr("testString")))
				Expect(deployRequestBodySchematicsModel.TerraformVersion).To(Equal(core.StringPtr("testString")))
				Expect(deployRequestBodySchematicsModel.Region).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the PreinstallVersionOptions model
				versionLocID := "testString"
				xAuthRefreshToken := "testString"
				preinstallVersionOptionsModel := catalogManagementService.NewPreinstallVersionOptions(versionLocID, xAuthRefreshToken)
				preinstallVersionOptionsModel.SetVersionLocID("testString")
				preinstallVersionOptionsModel.SetXAuthRefreshToken("testString")
				preinstallVersionOptionsModel.SetClusterID("testString")
				preinstallVersionOptionsModel.SetRegion("testString")
				preinstallVersionOptionsModel.SetNamespace("testString")
				preinstallVersionOptionsModel.SetNamespaces([]string{"testString"})
				preinstallVersionOptionsModel.SetAllNamespaces(true)
				preinstallVersionOptionsModel.SetOverrideValues(deployRequestBodyOverrideValuesModel)
				preinstallVersionOptionsModel.SetDependencyConfigs([]string{"testString"})
				preinstallVersionOptionsModel.SetEnvironmentVariables([]catalogmanagementv1.DeployRequestBodyEnvironmentVariablesItem{*deployRequestBodyEnvironmentVariablesItemModel})
				preinstallVersionOptionsModel.SetEntitlementApikey("testString")
				preinstallVersionOptionsModel.SetSchematics(deployRequestBodySchematicsModel)
				preinstallVersionOptionsModel.SetScript("testString")
				preinstallVersionOptionsModel.SetScriptID("testString")
				preinstallVersionOptionsModel.SetVersionLocatorID("testString")
				preinstallVersionOptionsModel.SetVcenterID("testString")
				preinstallVersionOptionsModel.SetVcenterLocation("testString")
				preinstallVersionOptionsModel.SetVcenterUser("testString")
				preinstallVersionOptionsModel.SetVcenterPassword("testString")
				preinstallVersionOptionsModel.SetVcenterDatastore("testString")
				preinstallVersionOptionsModel.SetPlanID("testString")
				preinstallVersionOptionsModel.SetChannel("testString")
				preinstallVersionOptionsModel.SetInstallPlan("testString")
				preinstallVersionOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(preinstallVersionOptionsModel).ToNot(BeNil())
				Expect(preinstallVersionOptionsModel.VersionLocID).To(Equal(core.StringPtr("testString")))
				Expect(preinstallVersionOptionsModel.XAuthRefreshToken).To(Equal(core.StringPtr("testString")))
				Expect(preinstallVersionOptionsModel.ClusterID).To(Equal(core.StringPtr("testString")))
				Expect(preinstallVersionOptionsModel.Region).To(Equal(core.StringPtr("testString")))
				Expect(preinstallVersionOptionsModel.Namespace).To(Equal(core.StringPtr("testString")))
				Expect(preinstallVersionOptionsModel.Namespaces).To(Equal([]string{"testString"}))
				Expect(preinstallVersionOptionsModel.AllNamespaces).To(Equal(core.BoolPtr(true)))
				Expect(preinstallVersionOptionsModel.OverrideValues).To(Equal(deployRequestBodyOverrideValuesModel))
				Expect(preinstallVersionOptionsModel.DependencyConfigs).To(Equal([]string{"testString"}))
				Expect(preinstallVersionOptionsModel.EnvironmentVariables).To(Equal([]catalogmanagementv1.DeployRequestBodyEnvironmentVariablesItem{*deployRequestBodyEnvironmentVariablesItemModel}))
				Expect(preinstallVersionOptionsModel.EntitlementApikey).To(Equal(core.StringPtr("testString")))
				Expect(preinstallVersionOptionsModel.Schematics).To(Equal(deployRequestBodySchematicsModel))
				Expect(preinstallVersionOptionsModel.Script).To(Equal(core.StringPtr("testString")))
				Expect(preinstallVersionOptionsModel.ScriptID).To(Equal(core.StringPtr("testString")))
				Expect(preinstallVersionOptionsModel.VersionLocatorID).To(Equal(core.StringPtr("testString")))
				Expect(preinstallVersionOptionsModel.VcenterID).To(Equal(core.StringPtr("testString")))
				Expect(preinstallVersionOptionsModel.VcenterLocation).To(Equal(core.StringPtr("testString")))
				Expect(preinstallVersionOptionsModel.VcenterUser).To(Equal(core.StringPtr("testString")))
				Expect(preinstallVersionOptionsModel.VcenterPassword).To(Equal(core.StringPtr("testString")))
				Expect(preinstallVersionOptionsModel.VcenterDatastore).To(Equal(core.StringPtr("testString")))
				Expect(preinstallVersionOptionsModel.PlanID).To(Equal(core.StringPtr("testString")))
				Expect(preinstallVersionOptionsModel.Channel).To(Equal(core.StringPtr("testString")))
				Expect(preinstallVersionOptionsModel.InstallPlan).To(Equal(core.StringPtr("testString")))
				Expect(preinstallVersionOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewPrereleaseVersionOptions successfully`, func() {
				// Construct an instance of the PrereleaseVersionOptions model
				versionLocID := "testString"
				prereleaseVersionOptionsModel := catalogManagementService.NewPrereleaseVersionOptions(versionLocID)
				prereleaseVersionOptionsModel.SetVersionLocID("testString")
				prereleaseVersionOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(prereleaseVersionOptionsModel).ToNot(BeNil())
				Expect(prereleaseVersionOptionsModel.VersionLocID).To(Equal(core.StringPtr("testString")))
				Expect(prereleaseVersionOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewPreviewRegionsOptions successfully`, func() {
				// Construct an instance of the PreviewRegionsOptions model
				previewRegionsOptionsModel := catalogManagementService.NewPreviewRegionsOptions()
				previewRegionsOptionsModel.SetFilter("testString")
				previewRegionsOptionsModel.SetGetInactive(true)
				previewRegionsOptionsModel.SetLimit(int64(100))
				previewRegionsOptionsModel.SetOffset(int64(0))
				previewRegionsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(previewRegionsOptionsModel).ToNot(BeNil())
				Expect(previewRegionsOptionsModel.Filter).To(Equal(core.StringPtr("testString")))
				Expect(previewRegionsOptionsModel.GetInactive).To(Equal(core.BoolPtr(true)))
				Expect(previewRegionsOptionsModel.Limit).To(Equal(core.Int64Ptr(int64(100))))
				Expect(previewRegionsOptionsModel.Offset).To(Equal(core.Int64Ptr(int64(0))))
				Expect(previewRegionsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewPutOfferingInstanceOptions successfully`, func() {
				// Construct an instance of the OfferingInstanceLastOperation model
				offeringInstanceLastOperationModel := new(catalogmanagementv1.OfferingInstanceLastOperation)
				Expect(offeringInstanceLastOperationModel).ToNot(BeNil())
				offeringInstanceLastOperationModel.Operation = core.StringPtr("testString")
				offeringInstanceLastOperationModel.State = core.StringPtr("testString")
				offeringInstanceLastOperationModel.Message = core.StringPtr("testString")
				offeringInstanceLastOperationModel.TransactionID = core.StringPtr("testString")
				offeringInstanceLastOperationModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				offeringInstanceLastOperationModel.Code = core.StringPtr("testString")
				Expect(offeringInstanceLastOperationModel.Operation).To(Equal(core.StringPtr("testString")))
				Expect(offeringInstanceLastOperationModel.State).To(Equal(core.StringPtr("testString")))
				Expect(offeringInstanceLastOperationModel.Message).To(Equal(core.StringPtr("testString")))
				Expect(offeringInstanceLastOperationModel.TransactionID).To(Equal(core.StringPtr("testString")))
				Expect(offeringInstanceLastOperationModel.Updated).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(offeringInstanceLastOperationModel.Code).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the PutOfferingInstanceOptions model
				instanceIdentifier := "testString"
				xAuthRefreshToken := "testString"
				putOfferingInstanceOptionsModel := catalogManagementService.NewPutOfferingInstanceOptions(instanceIdentifier, xAuthRefreshToken)
				putOfferingInstanceOptionsModel.SetInstanceIdentifier("testString")
				putOfferingInstanceOptionsModel.SetXAuthRefreshToken("testString")
				putOfferingInstanceOptionsModel.SetID("testString")
				putOfferingInstanceOptionsModel.SetRev("testString")
				putOfferingInstanceOptionsModel.SetURL("testString")
				putOfferingInstanceOptionsModel.SetCRN("testString")
				putOfferingInstanceOptionsModel.SetLabel("testString")
				putOfferingInstanceOptionsModel.SetCatalogID("testString")
				putOfferingInstanceOptionsModel.SetOfferingID("testString")
				putOfferingInstanceOptionsModel.SetKindFormat("testString")
				putOfferingInstanceOptionsModel.SetKindFormatLabel("testString")
				putOfferingInstanceOptionsModel.SetVersion("testString")
				putOfferingInstanceOptionsModel.SetVersionID("testString")
				putOfferingInstanceOptionsModel.SetClusterID("testString")
				putOfferingInstanceOptionsModel.SetClusterRegion("testString")
				putOfferingInstanceOptionsModel.SetClusterNamespaces([]string{"testString"})
				putOfferingInstanceOptionsModel.SetClusterAllNamespaces(true)
				putOfferingInstanceOptionsModel.SetSchematicsWorkspaceID("testString")
				putOfferingInstanceOptionsModel.SetInstallPlan("testString")
				putOfferingInstanceOptionsModel.SetChannel("testString")
				putOfferingInstanceOptionsModel.SetCreated(CreateMockDateTime("2019-01-01T12:00:00.000Z"))
				putOfferingInstanceOptionsModel.SetUpdated(CreateMockDateTime("2019-01-01T12:00:00.000Z"))
				putOfferingInstanceOptionsModel.SetMetadata(map[string]interface{}{"anyKey": "anyValue"})
				putOfferingInstanceOptionsModel.SetResourceGroupID("testString")
				putOfferingInstanceOptionsModel.SetLocation("testString")
				putOfferingInstanceOptionsModel.SetDisabled(true)
				putOfferingInstanceOptionsModel.SetAccount("testString")
				putOfferingInstanceOptionsModel.SetLastOperation(offeringInstanceLastOperationModel)
				putOfferingInstanceOptionsModel.SetKindTarget("testString")
				putOfferingInstanceOptionsModel.SetKindTargetLabel("testString")
				putOfferingInstanceOptionsModel.SetSha("testString")
				putOfferingInstanceOptionsModel.SetPlanID("testString")
				putOfferingInstanceOptionsModel.SetParentCRN("testString")
				putOfferingInstanceOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(putOfferingInstanceOptionsModel).ToNot(BeNil())
				Expect(putOfferingInstanceOptionsModel.InstanceIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(putOfferingInstanceOptionsModel.XAuthRefreshToken).To(Equal(core.StringPtr("testString")))
				Expect(putOfferingInstanceOptionsModel.ID).To(Equal(core.StringPtr("testString")))
				Expect(putOfferingInstanceOptionsModel.Rev).To(Equal(core.StringPtr("testString")))
				Expect(putOfferingInstanceOptionsModel.URL).To(Equal(core.StringPtr("testString")))
				Expect(putOfferingInstanceOptionsModel.CRN).To(Equal(core.StringPtr("testString")))
				Expect(putOfferingInstanceOptionsModel.Label).To(Equal(core.StringPtr("testString")))
				Expect(putOfferingInstanceOptionsModel.CatalogID).To(Equal(core.StringPtr("testString")))
				Expect(putOfferingInstanceOptionsModel.OfferingID).To(Equal(core.StringPtr("testString")))
				Expect(putOfferingInstanceOptionsModel.KindFormat).To(Equal(core.StringPtr("testString")))
				Expect(putOfferingInstanceOptionsModel.KindFormatLabel).To(Equal(core.StringPtr("testString")))
				Expect(putOfferingInstanceOptionsModel.Version).To(Equal(core.StringPtr("testString")))
				Expect(putOfferingInstanceOptionsModel.VersionID).To(Equal(core.StringPtr("testString")))
				Expect(putOfferingInstanceOptionsModel.ClusterID).To(Equal(core.StringPtr("testString")))
				Expect(putOfferingInstanceOptionsModel.ClusterRegion).To(Equal(core.StringPtr("testString")))
				Expect(putOfferingInstanceOptionsModel.ClusterNamespaces).To(Equal([]string{"testString"}))
				Expect(putOfferingInstanceOptionsModel.ClusterAllNamespaces).To(Equal(core.BoolPtr(true)))
				Expect(putOfferingInstanceOptionsModel.SchematicsWorkspaceID).To(Equal(core.StringPtr("testString")))
				Expect(putOfferingInstanceOptionsModel.InstallPlan).To(Equal(core.StringPtr("testString")))
				Expect(putOfferingInstanceOptionsModel.Channel).To(Equal(core.StringPtr("testString")))
				Expect(putOfferingInstanceOptionsModel.Created).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(putOfferingInstanceOptionsModel.Updated).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(putOfferingInstanceOptionsModel.Metadata).To(Equal(map[string]interface{}{"anyKey": "anyValue"}))
				Expect(putOfferingInstanceOptionsModel.ResourceGroupID).To(Equal(core.StringPtr("testString")))
				Expect(putOfferingInstanceOptionsModel.Location).To(Equal(core.StringPtr("testString")))
				Expect(putOfferingInstanceOptionsModel.Disabled).To(Equal(core.BoolPtr(true)))
				Expect(putOfferingInstanceOptionsModel.Account).To(Equal(core.StringPtr("testString")))
				Expect(putOfferingInstanceOptionsModel.LastOperation).To(Equal(offeringInstanceLastOperationModel))
				Expect(putOfferingInstanceOptionsModel.KindTarget).To(Equal(core.StringPtr("testString")))
				Expect(putOfferingInstanceOptionsModel.KindTargetLabel).To(Equal(core.StringPtr("testString")))
				Expect(putOfferingInstanceOptionsModel.Sha).To(Equal(core.StringPtr("testString")))
				Expect(putOfferingInstanceOptionsModel.PlanID).To(Equal(core.StringPtr("testString")))
				Expect(putOfferingInstanceOptionsModel.ParentCRN).To(Equal(core.StringPtr("testString")))
				Expect(putOfferingInstanceOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewReloadOfferingOptions successfully`, func() {
				// Construct an instance of the Flavor model
				flavorModel := new(catalogmanagementv1.Flavor)
				Expect(flavorModel).ToNot(BeNil())
				flavorModel.Name = core.StringPtr("testString")
				flavorModel.Label = core.StringPtr("testString")
				flavorModel.LabelI18n = map[string]string{"key1": "testString"}
				flavorModel.Index = core.Int64Ptr(int64(38))
				Expect(flavorModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(flavorModel.Label).To(Equal(core.StringPtr("testString")))
				Expect(flavorModel.LabelI18n).To(Equal(map[string]string{"key1": "testString"}))
				Expect(flavorModel.Index).To(Equal(core.Int64Ptr(int64(38))))

				// Construct an instance of the ReloadOfferingOptions model
				catalogIdentifier := "testString"
				offeringID := "testString"
				targetVersion := "testString"
				reloadOfferingOptionsModel := catalogManagementService.NewReloadOfferingOptions(catalogIdentifier, offeringID, targetVersion)
				reloadOfferingOptionsModel.SetCatalogIdentifier("testString")
				reloadOfferingOptionsModel.SetOfferingID("testString")
				reloadOfferingOptionsModel.SetTargetVersion("testString")
				reloadOfferingOptionsModel.SetTags([]string{"testString"})
				reloadOfferingOptionsModel.SetContent(*CreateMockByteArray("VGhpcyBpcyBhIG1vY2sgYnl0ZSBhcnJheSB2YWx1ZS4="))
				reloadOfferingOptionsModel.SetTargetKinds([]string{"testString"})
				reloadOfferingOptionsModel.SetFormatKind("testString")
				reloadOfferingOptionsModel.SetFlavor(flavorModel)
				reloadOfferingOptionsModel.SetWorkingDirectory("testString")
				reloadOfferingOptionsModel.SetInstallType("testString")
				reloadOfferingOptionsModel.SetZipurl("testString")
				reloadOfferingOptionsModel.SetRepoType("testString")
				reloadOfferingOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(reloadOfferingOptionsModel).ToNot(BeNil())
				Expect(reloadOfferingOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(reloadOfferingOptionsModel.OfferingID).To(Equal(core.StringPtr("testString")))
				Expect(reloadOfferingOptionsModel.TargetVersion).To(Equal(core.StringPtr("testString")))
				Expect(reloadOfferingOptionsModel.Tags).To(Equal([]string{"testString"}))
				Expect(reloadOfferingOptionsModel.Content).To(Equal(CreateMockByteArray("VGhpcyBpcyBhIG1vY2sgYnl0ZSBhcnJheSB2YWx1ZS4=")))
				Expect(reloadOfferingOptionsModel.TargetKinds).To(Equal([]string{"testString"}))
				Expect(reloadOfferingOptionsModel.FormatKind).To(Equal(core.StringPtr("testString")))
				Expect(reloadOfferingOptionsModel.Flavor).To(Equal(flavorModel))
				Expect(reloadOfferingOptionsModel.WorkingDirectory).To(Equal(core.StringPtr("testString")))
				Expect(reloadOfferingOptionsModel.InstallType).To(Equal(core.StringPtr("testString")))
				Expect(reloadOfferingOptionsModel.Zipurl).To(Equal(core.StringPtr("testString")))
				Expect(reloadOfferingOptionsModel.RepoType).To(Equal(core.StringPtr("testString")))
				Expect(reloadOfferingOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewReplaceCatalogOptions successfully`, func() {
				// Construct an instance of the Feature model
				featureModel := new(catalogmanagementv1.Feature)
				Expect(featureModel).ToNot(BeNil())
				featureModel.Title = core.StringPtr("testString")
				featureModel.TitleI18n = map[string]string{"key1": "testString"}
				featureModel.Description = core.StringPtr("testString")
				featureModel.DescriptionI18n = map[string]string{"key1": "testString"}
				Expect(featureModel.Title).To(Equal(core.StringPtr("testString")))
				Expect(featureModel.TitleI18n).To(Equal(map[string]string{"key1": "testString"}))
				Expect(featureModel.Description).To(Equal(core.StringPtr("testString")))
				Expect(featureModel.DescriptionI18n).To(Equal(map[string]string{"key1": "testString"}))

				// Construct an instance of the FilterTerms model
				filterTermsModel := new(catalogmanagementv1.FilterTerms)
				Expect(filterTermsModel).ToNot(BeNil())
				filterTermsModel.FilterTerms = []string{"testString"}
				Expect(filterTermsModel.FilterTerms).To(Equal([]string{"testString"}))

				// Construct an instance of the CategoryFilter model
				categoryFilterModel := new(catalogmanagementv1.CategoryFilter)
				Expect(categoryFilterModel).ToNot(BeNil())
				categoryFilterModel.Include = core.BoolPtr(true)
				categoryFilterModel.Filter = filterTermsModel
				Expect(categoryFilterModel.Include).To(Equal(core.BoolPtr(true)))
				Expect(categoryFilterModel.Filter).To(Equal(filterTermsModel))

				// Construct an instance of the IDFilter model
				idFilterModel := new(catalogmanagementv1.IDFilter)
				Expect(idFilterModel).ToNot(BeNil())
				idFilterModel.Include = filterTermsModel
				idFilterModel.Exclude = filterTermsModel
				Expect(idFilterModel.Include).To(Equal(filterTermsModel))
				Expect(idFilterModel.Exclude).To(Equal(filterTermsModel))

				// Construct an instance of the Filters model
				filtersModel := new(catalogmanagementv1.Filters)
				Expect(filtersModel).ToNot(BeNil())
				filtersModel.IncludeAll = core.BoolPtr(true)
				filtersModel.CategoryFilters = map[string]catalogmanagementv1.CategoryFilter{"key1": *categoryFilterModel}
				filtersModel.IDFilters = idFilterModel
				filtersModel.CategoryFilters["foo"] = *categoryFilterModel
				Expect(filtersModel.IncludeAll).To(Equal(core.BoolPtr(true)))
				Expect(filtersModel.IDFilters).To(Equal(idFilterModel))
				Expect(filtersModel.CategoryFilters["foo"]).To(Equal(*categoryFilterModel))

				// Construct an instance of the TrustedProfileInfo model
				trustedProfileInfoModel := new(catalogmanagementv1.TrustedProfileInfo)
				Expect(trustedProfileInfoModel).ToNot(BeNil())
				trustedProfileInfoModel.TrustedProfileID = core.StringPtr("testString")
				trustedProfileInfoModel.CatalogCRN = core.StringPtr("testString")
				trustedProfileInfoModel.CatalogName = core.StringPtr("testString")
				trustedProfileInfoModel.TargetServiceID = core.StringPtr("testString")
				Expect(trustedProfileInfoModel.TrustedProfileID).To(Equal(core.StringPtr("testString")))
				Expect(trustedProfileInfoModel.CatalogCRN).To(Equal(core.StringPtr("testString")))
				Expect(trustedProfileInfoModel.CatalogName).To(Equal(core.StringPtr("testString")))
				Expect(trustedProfileInfoModel.TargetServiceID).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the TargetAccountContext model
				targetAccountContextModel := new(catalogmanagementv1.TargetAccountContext)
				Expect(targetAccountContextModel).ToNot(BeNil())
				targetAccountContextModel.APIKey = core.StringPtr("testString")
				targetAccountContextModel.TrustedProfile = trustedProfileInfoModel
				targetAccountContextModel.Name = core.StringPtr("testString")
				targetAccountContextModel.Label = core.StringPtr("testString")
				targetAccountContextModel.ProjectID = core.StringPtr("testString")
				Expect(targetAccountContextModel.APIKey).To(Equal(core.StringPtr("testString")))
				Expect(targetAccountContextModel.TrustedProfile).To(Equal(trustedProfileInfoModel))
				Expect(targetAccountContextModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(targetAccountContextModel.Label).To(Equal(core.StringPtr("testString")))
				Expect(targetAccountContextModel.ProjectID).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the ReplaceCatalogOptions model
				catalogIdentifier := "testString"
				replaceCatalogOptionsModel := catalogManagementService.NewReplaceCatalogOptions(catalogIdentifier)
				replaceCatalogOptionsModel.SetCatalogIdentifier("testString")
				replaceCatalogOptionsModel.SetID("testString")
				replaceCatalogOptionsModel.SetRev("testString")
				replaceCatalogOptionsModel.SetLabel("testString")
				replaceCatalogOptionsModel.SetLabelI18n(map[string]string{"key1": "testString"})
				replaceCatalogOptionsModel.SetShortDescription("testString")
				replaceCatalogOptionsModel.SetShortDescriptionI18n(map[string]string{"key1": "testString"})
				replaceCatalogOptionsModel.SetCatalogIconURL("testString")
				replaceCatalogOptionsModel.SetCatalogBannerURL("testString")
				replaceCatalogOptionsModel.SetTags([]string{"testString"})
				replaceCatalogOptionsModel.SetFeatures([]catalogmanagementv1.Feature{*featureModel})
				replaceCatalogOptionsModel.SetDisabled(true)
				replaceCatalogOptionsModel.SetResourceGroupID("testString")
				replaceCatalogOptionsModel.SetOwningAccount("testString")
				replaceCatalogOptionsModel.SetCatalogFilters(filtersModel)
				replaceCatalogOptionsModel.SetKind("testString")
				replaceCatalogOptionsModel.SetMetadata(map[string]interface{}{"anyKey": "anyValue"})
				replaceCatalogOptionsModel.SetTargetAccountContexts([]catalogmanagementv1.TargetAccountContext{*targetAccountContextModel})
				replaceCatalogOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(replaceCatalogOptionsModel).ToNot(BeNil())
				Expect(replaceCatalogOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(replaceCatalogOptionsModel.ID).To(Equal(core.StringPtr("testString")))
				Expect(replaceCatalogOptionsModel.Rev).To(Equal(core.StringPtr("testString")))
				Expect(replaceCatalogOptionsModel.Label).To(Equal(core.StringPtr("testString")))
				Expect(replaceCatalogOptionsModel.LabelI18n).To(Equal(map[string]string{"key1": "testString"}))
				Expect(replaceCatalogOptionsModel.ShortDescription).To(Equal(core.StringPtr("testString")))
				Expect(replaceCatalogOptionsModel.ShortDescriptionI18n).To(Equal(map[string]string{"key1": "testString"}))
				Expect(replaceCatalogOptionsModel.CatalogIconURL).To(Equal(core.StringPtr("testString")))
				Expect(replaceCatalogOptionsModel.CatalogBannerURL).To(Equal(core.StringPtr("testString")))
				Expect(replaceCatalogOptionsModel.Tags).To(Equal([]string{"testString"}))
				Expect(replaceCatalogOptionsModel.Features).To(Equal([]catalogmanagementv1.Feature{*featureModel}))
				Expect(replaceCatalogOptionsModel.Disabled).To(Equal(core.BoolPtr(true)))
				Expect(replaceCatalogOptionsModel.ResourceGroupID).To(Equal(core.StringPtr("testString")))
				Expect(replaceCatalogOptionsModel.OwningAccount).To(Equal(core.StringPtr("testString")))
				Expect(replaceCatalogOptionsModel.CatalogFilters).To(Equal(filtersModel))
				Expect(replaceCatalogOptionsModel.Kind).To(Equal(core.StringPtr("testString")))
				Expect(replaceCatalogOptionsModel.Metadata).To(Equal(map[string]interface{}{"anyKey": "anyValue"}))
				Expect(replaceCatalogOptionsModel.TargetAccountContexts).To(Equal([]catalogmanagementv1.TargetAccountContext{*targetAccountContextModel}))
				Expect(replaceCatalogOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewReplaceObjectOptions successfully`, func() {
				// Construct an instance of the PublishObject model
				publishObjectModel := new(catalogmanagementv1.PublishObject)
				Expect(publishObjectModel).ToNot(BeNil())
				publishObjectModel.PcManaged = core.BoolPtr(true)
				publishObjectModel.ApprovalType = core.StringPtr("testString")
				publishObjectModel.PublishApproved = core.BoolPtr(true)
				publishObjectModel.ShareWithAll = core.BoolPtr(true)
				publishObjectModel.ShareWithIBM = core.BoolPtr(true)
				publishObjectModel.ShareEnabled = core.BoolPtr(true)
				publishObjectModel.OriginalCRN = core.StringPtr("testString")
				publishObjectModel.PublicCRN = core.StringPtr("testString")
				publishObjectModel.ApprovalRecord = map[string]interface{}{"anyKey": "anyValue"}
				publishObjectModel.PermitIBMPublicPublish = core.BoolPtr(true)
				publishObjectModel.IBMApproved = core.BoolPtr(true)
				publishObjectModel.PublicApproved = core.BoolPtr(true)
				Expect(publishObjectModel.PcManaged).To(Equal(core.BoolPtr(true)))
				Expect(publishObjectModel.ApprovalType).To(Equal(core.StringPtr("testString")))
				Expect(publishObjectModel.PublishApproved).To(Equal(core.BoolPtr(true)))
				Expect(publishObjectModel.ShareWithAll).To(Equal(core.BoolPtr(true)))
				Expect(publishObjectModel.ShareWithIBM).To(Equal(core.BoolPtr(true)))
				Expect(publishObjectModel.ShareEnabled).To(Equal(core.BoolPtr(true)))
				Expect(publishObjectModel.OriginalCRN).To(Equal(core.StringPtr("testString")))
				Expect(publishObjectModel.PublicCRN).To(Equal(core.StringPtr("testString")))
				Expect(publishObjectModel.ApprovalRecord).To(Equal(map[string]interface{}{"anyKey": "anyValue"}))
				Expect(publishObjectModel.PermitIBMPublicPublish).To(Equal(core.BoolPtr(true)))
				Expect(publishObjectModel.IBMApproved).To(Equal(core.BoolPtr(true)))
				Expect(publishObjectModel.PublicApproved).To(Equal(core.BoolPtr(true)))

				// Construct an instance of the State model
				stateModel := new(catalogmanagementv1.State)
				Expect(stateModel).ToNot(BeNil())
				stateModel.Current = core.StringPtr("testString")
				stateModel.CurrentEntered = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Pending = core.StringPtr("testString")
				stateModel.PendingRequested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Previous = core.StringPtr("testString")
				Expect(stateModel.Current).To(Equal(core.StringPtr("testString")))
				Expect(stateModel.CurrentEntered).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(stateModel.Pending).To(Equal(core.StringPtr("testString")))
				Expect(stateModel.PendingRequested).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(stateModel.Previous).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the ReplaceObjectOptions model
				catalogIdentifier := "testString"
				objectIdentifier := "testString"
				replaceObjectOptionsModel := catalogManagementService.NewReplaceObjectOptions(catalogIdentifier, objectIdentifier)
				replaceObjectOptionsModel.SetCatalogIdentifier("testString")
				replaceObjectOptionsModel.SetObjectIdentifier("testString")
				replaceObjectOptionsModel.SetID("testString")
				replaceObjectOptionsModel.SetRev("testString")
				replaceObjectOptionsModel.SetName("testString")
				replaceObjectOptionsModel.SetCRN("testString")
				replaceObjectOptionsModel.SetURL("testString")
				replaceObjectOptionsModel.SetParentID("testString")
				replaceObjectOptionsModel.SetLabelI18n(map[string]string{"key1": "testString"})
				replaceObjectOptionsModel.SetLabel("testString")
				replaceObjectOptionsModel.SetTags([]string{"testString"})
				replaceObjectOptionsModel.SetCreated(CreateMockDateTime("2019-01-01T12:00:00.000Z"))
				replaceObjectOptionsModel.SetUpdated(CreateMockDateTime("2019-01-01T12:00:00.000Z"))
				replaceObjectOptionsModel.SetShortDescription("testString")
				replaceObjectOptionsModel.SetShortDescriptionI18n(map[string]string{"key1": "testString"})
				replaceObjectOptionsModel.SetKind("testString")
				replaceObjectOptionsModel.SetPublish(publishObjectModel)
				replaceObjectOptionsModel.SetState(stateModel)
				replaceObjectOptionsModel.SetCatalogID("testString")
				replaceObjectOptionsModel.SetCatalogName("testString")
				replaceObjectOptionsModel.SetData(map[string]interface{}{"anyKey": "anyValue"})
				replaceObjectOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(replaceObjectOptionsModel).ToNot(BeNil())
				Expect(replaceObjectOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(replaceObjectOptionsModel.ObjectIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(replaceObjectOptionsModel.ID).To(Equal(core.StringPtr("testString")))
				Expect(replaceObjectOptionsModel.Rev).To(Equal(core.StringPtr("testString")))
				Expect(replaceObjectOptionsModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(replaceObjectOptionsModel.CRN).To(Equal(core.StringPtr("testString")))
				Expect(replaceObjectOptionsModel.URL).To(Equal(core.StringPtr("testString")))
				Expect(replaceObjectOptionsModel.ParentID).To(Equal(core.StringPtr("testString")))
				Expect(replaceObjectOptionsModel.LabelI18n).To(Equal(map[string]string{"key1": "testString"}))
				Expect(replaceObjectOptionsModel.Label).To(Equal(core.StringPtr("testString")))
				Expect(replaceObjectOptionsModel.Tags).To(Equal([]string{"testString"}))
				Expect(replaceObjectOptionsModel.Created).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(replaceObjectOptionsModel.Updated).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(replaceObjectOptionsModel.ShortDescription).To(Equal(core.StringPtr("testString")))
				Expect(replaceObjectOptionsModel.ShortDescriptionI18n).To(Equal(map[string]string{"key1": "testString"}))
				Expect(replaceObjectOptionsModel.Kind).To(Equal(core.StringPtr("testString")))
				Expect(replaceObjectOptionsModel.Publish).To(Equal(publishObjectModel))
				Expect(replaceObjectOptionsModel.State).To(Equal(stateModel))
				Expect(replaceObjectOptionsModel.CatalogID).To(Equal(core.StringPtr("testString")))
				Expect(replaceObjectOptionsModel.CatalogName).To(Equal(core.StringPtr("testString")))
				Expect(replaceObjectOptionsModel.Data).To(Equal(map[string]interface{}{"anyKey": "anyValue"}))
				Expect(replaceObjectOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewReplaceOfferingOptions successfully`, func() {
				// Construct an instance of the Rating model
				ratingModel := new(catalogmanagementv1.Rating)
				Expect(ratingModel).ToNot(BeNil())
				ratingModel.OneStarCount = core.Int64Ptr(int64(38))
				ratingModel.TwoStarCount = core.Int64Ptr(int64(38))
				ratingModel.ThreeStarCount = core.Int64Ptr(int64(38))
				ratingModel.FourStarCount = core.Int64Ptr(int64(38))
				Expect(ratingModel.OneStarCount).To(Equal(core.Int64Ptr(int64(38))))
				Expect(ratingModel.TwoStarCount).To(Equal(core.Int64Ptr(int64(38))))
				Expect(ratingModel.ThreeStarCount).To(Equal(core.Int64Ptr(int64(38))))
				Expect(ratingModel.FourStarCount).To(Equal(core.Int64Ptr(int64(38))))

				// Construct an instance of the Feature model
				featureModel := new(catalogmanagementv1.Feature)
				Expect(featureModel).ToNot(BeNil())
				featureModel.Title = core.StringPtr("testString")
				featureModel.TitleI18n = map[string]string{"key1": "testString"}
				featureModel.Description = core.StringPtr("testString")
				featureModel.DescriptionI18n = map[string]string{"key1": "testString"}
				Expect(featureModel.Title).To(Equal(core.StringPtr("testString")))
				Expect(featureModel.TitleI18n).To(Equal(map[string]string{"key1": "testString"}))
				Expect(featureModel.Description).To(Equal(core.StringPtr("testString")))
				Expect(featureModel.DescriptionI18n).To(Equal(map[string]string{"key1": "testString"}))

				// Construct an instance of the Flavor model
				flavorModel := new(catalogmanagementv1.Flavor)
				Expect(flavorModel).ToNot(BeNil())
				flavorModel.Name = core.StringPtr("testString")
				flavorModel.Label = core.StringPtr("testString")
				flavorModel.LabelI18n = map[string]string{"key1": "testString"}
				flavorModel.Index = core.Int64Ptr(int64(38))
				Expect(flavorModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(flavorModel.Label).To(Equal(core.StringPtr("testString")))
				Expect(flavorModel.LabelI18n).To(Equal(map[string]string{"key1": "testString"}))
				Expect(flavorModel.Index).To(Equal(core.Int64Ptr(int64(38))))

				// Construct an instance of the RenderTypeAssociationsParametersItem model
				renderTypeAssociationsParametersItemModel := new(catalogmanagementv1.RenderTypeAssociationsParametersItem)
				Expect(renderTypeAssociationsParametersItemModel).ToNot(BeNil())
				renderTypeAssociationsParametersItemModel.Name = core.StringPtr("testString")
				renderTypeAssociationsParametersItemModel.OptionsRefresh = core.BoolPtr(true)
				Expect(renderTypeAssociationsParametersItemModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(renderTypeAssociationsParametersItemModel.OptionsRefresh).To(Equal(core.BoolPtr(true)))

				// Construct an instance of the RenderTypeAssociations model
				renderTypeAssociationsModel := new(catalogmanagementv1.RenderTypeAssociations)
				Expect(renderTypeAssociationsModel).ToNot(BeNil())
				renderTypeAssociationsModel.Parameters = []catalogmanagementv1.RenderTypeAssociationsParametersItem{*renderTypeAssociationsParametersItemModel}
				Expect(renderTypeAssociationsModel.Parameters).To(Equal([]catalogmanagementv1.RenderTypeAssociationsParametersItem{*renderTypeAssociationsParametersItemModel}))

				// Construct an instance of the RenderType model
				renderTypeModel := new(catalogmanagementv1.RenderType)
				Expect(renderTypeModel).ToNot(BeNil())
				renderTypeModel.Type = core.StringPtr("testString")
				renderTypeModel.Grouping = core.StringPtr("testString")
				renderTypeModel.OriginalGrouping = core.StringPtr("testString")
				renderTypeModel.GroupingIndex = core.Int64Ptr(int64(38))
				renderTypeModel.ConfigConstraints = map[string]interface{}{"anyKey": "anyValue"}
				renderTypeModel.Associations = renderTypeAssociationsModel
				Expect(renderTypeModel.Type).To(Equal(core.StringPtr("testString")))
				Expect(renderTypeModel.Grouping).To(Equal(core.StringPtr("testString")))
				Expect(renderTypeModel.OriginalGrouping).To(Equal(core.StringPtr("testString")))
				Expect(renderTypeModel.GroupingIndex).To(Equal(core.Int64Ptr(int64(38))))
				Expect(renderTypeModel.ConfigConstraints).To(Equal(map[string]interface{}{"anyKey": "anyValue"}))
				Expect(renderTypeModel.Associations).To(Equal(renderTypeAssociationsModel))

				// Construct an instance of the Configuration model
				configurationModel := new(catalogmanagementv1.Configuration)
				Expect(configurationModel).ToNot(BeNil())
				configurationModel.Key = core.StringPtr("testString")
				configurationModel.Type = core.StringPtr("testString")
				configurationModel.DefaultValue = "testString"
				configurationModel.DisplayName = core.StringPtr("testString")
				configurationModel.ValueConstraint = core.StringPtr("testString")
				configurationModel.Description = core.StringPtr("testString")
				configurationModel.Required = core.BoolPtr(true)
				configurationModel.Options = []interface{}{"testString"}
				configurationModel.Hidden = core.BoolPtr(true)
				configurationModel.CustomConfig = renderTypeModel
				configurationModel.TypeMetadata = core.StringPtr("testString")
				Expect(configurationModel.Key).To(Equal(core.StringPtr("testString")))
				Expect(configurationModel.Type).To(Equal(core.StringPtr("testString")))
				Expect(configurationModel.DefaultValue).To(Equal("testString"))
				Expect(configurationModel.DisplayName).To(Equal(core.StringPtr("testString")))
				Expect(configurationModel.ValueConstraint).To(Equal(core.StringPtr("testString")))
				Expect(configurationModel.Description).To(Equal(core.StringPtr("testString")))
				Expect(configurationModel.Required).To(Equal(core.BoolPtr(true)))
				Expect(configurationModel.Options).To(Equal([]interface{}{"testString"}))
				Expect(configurationModel.Hidden).To(Equal(core.BoolPtr(true)))
				Expect(configurationModel.CustomConfig).To(Equal(renderTypeModel))
				Expect(configurationModel.TypeMetadata).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the Output model
				outputModel := new(catalogmanagementv1.Output)
				Expect(outputModel).ToNot(BeNil())
				outputModel.Key = core.StringPtr("testString")
				outputModel.Description = core.StringPtr("testString")
				Expect(outputModel.Key).To(Equal(core.StringPtr("testString")))
				Expect(outputModel.Description).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the IamResource model
				iamResourceModel := new(catalogmanagementv1.IamResource)
				Expect(iamResourceModel).ToNot(BeNil())
				iamResourceModel.Name = core.StringPtr("testString")
				iamResourceModel.Description = core.StringPtr("testString")
				iamResourceModel.RoleCrns = []string{"testString"}
				Expect(iamResourceModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(iamResourceModel.Description).To(Equal(core.StringPtr("testString")))
				Expect(iamResourceModel.RoleCrns).To(Equal([]string{"testString"}))

				// Construct an instance of the IamPermission model
				iamPermissionModel := new(catalogmanagementv1.IamPermission)
				Expect(iamPermissionModel).ToNot(BeNil())
				iamPermissionModel.ServiceName = core.StringPtr("testString")
				iamPermissionModel.RoleCrns = []string{"testString"}
				iamPermissionModel.Resources = []catalogmanagementv1.IamResource{*iamResourceModel}
				Expect(iamPermissionModel.ServiceName).To(Equal(core.StringPtr("testString")))
				Expect(iamPermissionModel.RoleCrns).To(Equal([]string{"testString"}))
				Expect(iamPermissionModel.Resources).To(Equal([]catalogmanagementv1.IamResource{*iamResourceModel}))

				// Construct an instance of the Validation model
				validationModel := new(catalogmanagementv1.Validation)
				Expect(validationModel).ToNot(BeNil())
				validationModel.Validated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				validationModel.Requested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				validationModel.State = core.StringPtr("testString")
				validationModel.LastOperation = core.StringPtr("testString")
				validationModel.Target = map[string]interface{}{"anyKey": "anyValue"}
				validationModel.Message = core.StringPtr("testString")
				Expect(validationModel.Validated).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(validationModel.Requested).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(validationModel.State).To(Equal(core.StringPtr("testString")))
				Expect(validationModel.LastOperation).To(Equal(core.StringPtr("testString")))
				Expect(validationModel.Target).To(Equal(map[string]interface{}{"anyKey": "anyValue"}))
				Expect(validationModel.Message).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the Resource model
				resourceModel := new(catalogmanagementv1.Resource)
				Expect(resourceModel).ToNot(BeNil())
				resourceModel.Type = core.StringPtr("mem")
				resourceModel.Value = "testString"
				Expect(resourceModel.Type).To(Equal(core.StringPtr("mem")))
				Expect(resourceModel.Value).To(Equal("testString"))

				// Construct an instance of the SchematicsEnvValues model
				schematicsEnvValuesModel := new(catalogmanagementv1.SchematicsEnvValues)
				Expect(schematicsEnvValuesModel).ToNot(BeNil())
				schematicsEnvValuesModel.Value = core.StringPtr("[{\"name\": \"TF_LOG\",\"value\": \"TRACE\",\"secure\": false,\"hidden\": false}]")
				schematicsEnvValuesModel.SmRef = core.StringPtr("cmsm_v1:{\"name\": \"envVarSecret\",\"id\":\"1234567890\",\"service_id\":\"crn:v1:bluemix:public:secrets-manager:eu-gb:a/1234567890:1234567890::\",\"service_name\":\"My SM Instance\",\"group_id\":\"1234567890\",\"group_name\":\"My SM Group\",\"resource_group_id\":\"1234567890\",\"region\":\"eu-gb\",\"type\":\"arbitrary\"}")
				Expect(schematicsEnvValuesModel.Value).To(Equal(core.StringPtr("[{\"name\": \"TF_LOG\",\"value\": \"TRACE\",\"secure\": false,\"hidden\": false}]")))
				Expect(schematicsEnvValuesModel.SmRef).To(Equal(core.StringPtr("cmsm_v1:{\"name\": \"envVarSecret\",\"id\":\"1234567890\",\"service_id\":\"crn:v1:bluemix:public:secrets-manager:eu-gb:a/1234567890:1234567890::\",\"service_name\":\"My SM Instance\",\"group_id\":\"1234567890\",\"group_name\":\"My SM Group\",\"resource_group_id\":\"1234567890\",\"region\":\"eu-gb\",\"type\":\"arbitrary\"}")))

				// Construct an instance of the Script model
				scriptModel := new(catalogmanagementv1.Script)
				Expect(scriptModel).ToNot(BeNil())
				scriptModel.Instructions = core.StringPtr("testString")
				scriptModel.InstructionsI18n = map[string]string{"key1": "testString"}
				scriptModel.Script = core.StringPtr("testString")
				scriptModel.ScriptPermission = core.StringPtr("testString")
				scriptModel.DeleteScript = core.StringPtr("testString")
				scriptModel.Scope = core.StringPtr("testString")
				Expect(scriptModel.Instructions).To(Equal(core.StringPtr("testString")))
				Expect(scriptModel.InstructionsI18n).To(Equal(map[string]string{"key1": "testString"}))
				Expect(scriptModel.Script).To(Equal(core.StringPtr("testString")))
				Expect(scriptModel.ScriptPermission).To(Equal(core.StringPtr("testString")))
				Expect(scriptModel.DeleteScript).To(Equal(core.StringPtr("testString")))
				Expect(scriptModel.Scope).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the ScriptRef model
				scriptRefModel := new(catalogmanagementv1.ScriptRef)
				Expect(scriptRefModel).ToNot(BeNil())
				scriptRefModel.ShortDescription = core.StringPtr("testString")
				scriptRefModel.Type = core.StringPtr("ansible")
				scriptRefModel.Path = core.StringPtr("scripts/validate-post-ansible-playbook.yaml")
				scriptRefModel.Stage = core.StringPtr("pre")
				scriptRefModel.Action = core.StringPtr("validate")
				Expect(scriptRefModel.ShortDescription).To(Equal(core.StringPtr("testString")))
				Expect(scriptRefModel.Type).To(Equal(core.StringPtr("ansible")))
				Expect(scriptRefModel.Path).To(Equal(core.StringPtr("scripts/validate-post-ansible-playbook.yaml")))
				Expect(scriptRefModel.Stage).To(Equal(core.StringPtr("pre")))
				Expect(scriptRefModel.Action).To(Equal(core.StringPtr("validate")))

				// Construct an instance of the VersionEntitlement model
				versionEntitlementModel := new(catalogmanagementv1.VersionEntitlement)
				Expect(versionEntitlementModel).ToNot(BeNil())
				versionEntitlementModel.ProviderName = core.StringPtr("testString")
				versionEntitlementModel.ProviderID = core.StringPtr("testString")
				versionEntitlementModel.ProductID = core.StringPtr("testString")
				versionEntitlementModel.PartNumbers = []string{"testString"}
				versionEntitlementModel.ImageRepoName = core.StringPtr("testString")
				Expect(versionEntitlementModel.ProviderName).To(Equal(core.StringPtr("testString")))
				Expect(versionEntitlementModel.ProviderID).To(Equal(core.StringPtr("testString")))
				Expect(versionEntitlementModel.ProductID).To(Equal(core.StringPtr("testString")))
				Expect(versionEntitlementModel.PartNumbers).To(Equal([]string{"testString"}))
				Expect(versionEntitlementModel.ImageRepoName).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the License model
				licenseModel := new(catalogmanagementv1.License)
				Expect(licenseModel).ToNot(BeNil())
				licenseModel.ID = core.StringPtr("testString")
				licenseModel.Name = core.StringPtr("testString")
				licenseModel.Type = core.StringPtr("testString")
				licenseModel.URL = core.StringPtr("testString")
				licenseModel.Description = core.StringPtr("testString")
				Expect(licenseModel.ID).To(Equal(core.StringPtr("testString")))
				Expect(licenseModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(licenseModel.Type).To(Equal(core.StringPtr("testString")))
				Expect(licenseModel.URL).To(Equal(core.StringPtr("testString")))
				Expect(licenseModel.Description).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the State model
				stateModel := new(catalogmanagementv1.State)
				Expect(stateModel).ToNot(BeNil())
				stateModel.Current = core.StringPtr("testString")
				stateModel.CurrentEntered = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Pending = core.StringPtr("testString")
				stateModel.PendingRequested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Previous = core.StringPtr("testString")
				Expect(stateModel.Current).To(Equal(core.StringPtr("testString")))
				Expect(stateModel.CurrentEntered).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(stateModel.Pending).To(Equal(core.StringPtr("testString")))
				Expect(stateModel.PendingRequested).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(stateModel.Previous).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the DeprecatePending model
				deprecatePendingModel := new(catalogmanagementv1.DeprecatePending)
				Expect(deprecatePendingModel).ToNot(BeNil())
				deprecatePendingModel.DeprecateDate = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				deprecatePendingModel.DeprecateState = core.StringPtr("testString")
				deprecatePendingModel.Description = core.StringPtr("testString")
				Expect(deprecatePendingModel.DeprecateDate).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(deprecatePendingModel.DeprecateState).To(Equal(core.StringPtr("testString")))
				Expect(deprecatePendingModel.Description).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the URLProxy model
				urlProxyModel := new(catalogmanagementv1.URLProxy)
				Expect(urlProxyModel).ToNot(BeNil())
				urlProxyModel.URL = core.StringPtr("testString")
				urlProxyModel.Sha = core.StringPtr("testString")
				Expect(urlProxyModel.URL).To(Equal(core.StringPtr("testString")))
				Expect(urlProxyModel.Sha).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the MediaItem model
				mediaItemModel := new(catalogmanagementv1.MediaItem)
				Expect(mediaItemModel).ToNot(BeNil())
				mediaItemModel.URL = core.StringPtr("testString")
				mediaItemModel.APIURL = core.StringPtr("testString")
				mediaItemModel.URLProxy = urlProxyModel
				mediaItemModel.Caption = core.StringPtr("testString")
				mediaItemModel.CaptionI18n = map[string]string{"key1": "testString"}
				mediaItemModel.Type = core.StringPtr("testString")
				mediaItemModel.ThumbnailURL = core.StringPtr("testString")
				Expect(mediaItemModel.URL).To(Equal(core.StringPtr("testString")))
				Expect(mediaItemModel.APIURL).To(Equal(core.StringPtr("testString")))
				Expect(mediaItemModel.URLProxy).To(Equal(urlProxyModel))
				Expect(mediaItemModel.Caption).To(Equal(core.StringPtr("testString")))
				Expect(mediaItemModel.CaptionI18n).To(Equal(map[string]string{"key1": "testString"}))
				Expect(mediaItemModel.Type).To(Equal(core.StringPtr("testString")))
				Expect(mediaItemModel.ThumbnailURL).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the ArchitectureDiagram model
				architectureDiagramModel := new(catalogmanagementv1.ArchitectureDiagram)
				Expect(architectureDiagramModel).ToNot(BeNil())
				architectureDiagramModel.Diagram = mediaItemModel
				architectureDiagramModel.Description = core.StringPtr("testString")
				architectureDiagramModel.DescriptionI18n = map[string]string{"key1": "testString"}
				Expect(architectureDiagramModel.Diagram).To(Equal(mediaItemModel))
				Expect(architectureDiagramModel.Description).To(Equal(core.StringPtr("testString")))
				Expect(architectureDiagramModel.DescriptionI18n).To(Equal(map[string]string{"key1": "testString"}))

				// Construct an instance of the CostComponent model
				costComponentModel := new(catalogmanagementv1.CostComponent)
				Expect(costComponentModel).ToNot(BeNil())
				costComponentModel.Name = core.StringPtr("testString")
				costComponentModel.Unit = core.StringPtr("testString")
				costComponentModel.HourlyQuantity = core.StringPtr("testString")
				costComponentModel.MonthlyQuantity = core.StringPtr("testString")
				costComponentModel.Price = core.StringPtr("testString")
				costComponentModel.HourlyCost = core.StringPtr("testString")
				costComponentModel.MonthlyCost = core.StringPtr("testString")
				Expect(costComponentModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(costComponentModel.Unit).To(Equal(core.StringPtr("testString")))
				Expect(costComponentModel.HourlyQuantity).To(Equal(core.StringPtr("testString")))
				Expect(costComponentModel.MonthlyQuantity).To(Equal(core.StringPtr("testString")))
				Expect(costComponentModel.Price).To(Equal(core.StringPtr("testString")))
				Expect(costComponentModel.HourlyCost).To(Equal(core.StringPtr("testString")))
				Expect(costComponentModel.MonthlyCost).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the CostResource model
				costResourceModel := new(catalogmanagementv1.CostResource)
				Expect(costResourceModel).ToNot(BeNil())
				costResourceModel.Name = core.StringPtr("testString")
				costResourceModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				costResourceModel.HourlyCost = core.StringPtr("testString")
				costResourceModel.MonthlyCost = core.StringPtr("testString")
				costResourceModel.CostComponents = []catalogmanagementv1.CostComponent{*costComponentModel}
				Expect(costResourceModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(costResourceModel.Metadata).To(Equal(map[string]interface{}{"anyKey": "anyValue"}))
				Expect(costResourceModel.HourlyCost).To(Equal(core.StringPtr("testString")))
				Expect(costResourceModel.MonthlyCost).To(Equal(core.StringPtr("testString")))
				Expect(costResourceModel.CostComponents).To(Equal([]catalogmanagementv1.CostComponent{*costComponentModel}))

				// Construct an instance of the CostBreakdown model
				costBreakdownModel := new(catalogmanagementv1.CostBreakdown)
				Expect(costBreakdownModel).ToNot(BeNil())
				costBreakdownModel.TotalHourlyCost = core.StringPtr("testString")
				costBreakdownModel.TotalMonthlyCost = core.StringPtr("testString")
				costBreakdownModel.Resources = []catalogmanagementv1.CostResource{*costResourceModel}
				Expect(costBreakdownModel.TotalHourlyCost).To(Equal(core.StringPtr("testString")))
				Expect(costBreakdownModel.TotalMonthlyCost).To(Equal(core.StringPtr("testString")))
				Expect(costBreakdownModel.Resources).To(Equal([]catalogmanagementv1.CostResource{*costResourceModel}))

				// Construct an instance of the CostSummary model
				costSummaryModel := new(catalogmanagementv1.CostSummary)
				Expect(costSummaryModel).ToNot(BeNil())
				costSummaryModel.TotalDetectedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalSupportedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalUnsupportedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalUsageBasedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalNoPriceResources = core.Int64Ptr(int64(38))
				costSummaryModel.UnsupportedResourceCounts = map[string]int64{"key1": int64(38)}
				costSummaryModel.NoPriceResourceCounts = map[string]int64{"key1": int64(38)}
				Expect(costSummaryModel.TotalDetectedResources).To(Equal(core.Int64Ptr(int64(38))))
				Expect(costSummaryModel.TotalSupportedResources).To(Equal(core.Int64Ptr(int64(38))))
				Expect(costSummaryModel.TotalUnsupportedResources).To(Equal(core.Int64Ptr(int64(38))))
				Expect(costSummaryModel.TotalUsageBasedResources).To(Equal(core.Int64Ptr(int64(38))))
				Expect(costSummaryModel.TotalNoPriceResources).To(Equal(core.Int64Ptr(int64(38))))
				Expect(costSummaryModel.UnsupportedResourceCounts).To(Equal(map[string]int64{"key1": int64(38)}))
				Expect(costSummaryModel.NoPriceResourceCounts).To(Equal(map[string]int64{"key1": int64(38)}))

				// Construct an instance of the Project model
				projectModel := new(catalogmanagementv1.Project)
				Expect(projectModel).ToNot(BeNil())
				projectModel.Name = core.StringPtr("testString")
				projectModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				projectModel.PastBreakdown = costBreakdownModel
				projectModel.Breakdown = costBreakdownModel
				projectModel.Diff = costBreakdownModel
				projectModel.Summary = costSummaryModel
				Expect(projectModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(projectModel.Metadata).To(Equal(map[string]interface{}{"anyKey": "anyValue"}))
				Expect(projectModel.PastBreakdown).To(Equal(costBreakdownModel))
				Expect(projectModel.Breakdown).To(Equal(costBreakdownModel))
				Expect(projectModel.Diff).To(Equal(costBreakdownModel))
				Expect(projectModel.Summary).To(Equal(costSummaryModel))

				// Construct an instance of the CostEstimate model
				costEstimateModel := new(catalogmanagementv1.CostEstimate)
				Expect(costEstimateModel).ToNot(BeNil())
				costEstimateModel.Version = core.StringPtr("testString")
				costEstimateModel.Currency = core.StringPtr("testString")
				costEstimateModel.Projects = []catalogmanagementv1.Project{*projectModel}
				costEstimateModel.Summary = costSummaryModel
				costEstimateModel.TotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.TotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.PastTotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.PastTotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.DiffTotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.DiffTotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.TimeGenerated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				Expect(costEstimateModel.Version).To(Equal(core.StringPtr("testString")))
				Expect(costEstimateModel.Currency).To(Equal(core.StringPtr("testString")))
				Expect(costEstimateModel.Projects).To(Equal([]catalogmanagementv1.Project{*projectModel}))
				Expect(costEstimateModel.Summary).To(Equal(costSummaryModel))
				Expect(costEstimateModel.TotalHourlyCost).To(Equal(core.StringPtr("testString")))
				Expect(costEstimateModel.TotalMonthlyCost).To(Equal(core.StringPtr("testString")))
				Expect(costEstimateModel.PastTotalHourlyCost).To(Equal(core.StringPtr("testString")))
				Expect(costEstimateModel.PastTotalMonthlyCost).To(Equal(core.StringPtr("testString")))
				Expect(costEstimateModel.DiffTotalHourlyCost).To(Equal(core.StringPtr("testString")))
				Expect(costEstimateModel.DiffTotalMonthlyCost).To(Equal(core.StringPtr("testString")))
				Expect(costEstimateModel.TimeGenerated).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))

				// Construct an instance of the OfferingReference model
				offeringReferenceModel := new(catalogmanagementv1.OfferingReference)
				Expect(offeringReferenceModel).ToNot(BeNil())
				offeringReferenceModel.CatalogID = core.StringPtr("testString")
				offeringReferenceModel.ID = core.StringPtr("testString")
				offeringReferenceModel.Name = core.StringPtr("testString")
				offeringReferenceModel.Kind = core.StringPtr("testString")
				offeringReferenceModel.Version = core.StringPtr("testString")
				offeringReferenceModel.Description = core.StringPtr("testString")
				offeringReferenceModel.DefaultFlavor = core.StringPtr("testString")
				offeringReferenceModel.Flavors = []string{"testString"}
				offeringReferenceModel.Optional = core.BoolPtr(true)
				offeringReferenceModel.OnByDefault = core.BoolPtr(true)
				Expect(offeringReferenceModel.CatalogID).To(Equal(core.StringPtr("testString")))
				Expect(offeringReferenceModel.ID).To(Equal(core.StringPtr("testString")))
				Expect(offeringReferenceModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(offeringReferenceModel.Kind).To(Equal(core.StringPtr("testString")))
				Expect(offeringReferenceModel.Version).To(Equal(core.StringPtr("testString")))
				Expect(offeringReferenceModel.Description).To(Equal(core.StringPtr("testString")))
				Expect(offeringReferenceModel.DefaultFlavor).To(Equal(core.StringPtr("testString")))
				Expect(offeringReferenceModel.Flavors).To(Equal([]string{"testString"}))
				Expect(offeringReferenceModel.Optional).To(Equal(core.BoolPtr(true)))
				Expect(offeringReferenceModel.OnByDefault).To(Equal(core.BoolPtr(true)))

				// Construct an instance of the SolutionInfo model
				solutionInfoModel := new(catalogmanagementv1.SolutionInfo)
				Expect(solutionInfoModel).ToNot(BeNil())
				solutionInfoModel.ArchitectureDiagrams = []catalogmanagementv1.ArchitectureDiagram{*architectureDiagramModel}
				solutionInfoModel.Features = []catalogmanagementv1.Feature{*featureModel}
				solutionInfoModel.CostEstimate = costEstimateModel
				solutionInfoModel.Dependencies = []catalogmanagementv1.OfferingReference{*offeringReferenceModel}
				solutionInfoModel.InstallType = core.StringPtr("testString")
				Expect(solutionInfoModel.ArchitectureDiagrams).To(Equal([]catalogmanagementv1.ArchitectureDiagram{*architectureDiagramModel}))
				Expect(solutionInfoModel.Features).To(Equal([]catalogmanagementv1.Feature{*featureModel}))
				Expect(solutionInfoModel.CostEstimate).To(Equal(costEstimateModel))
				Expect(solutionInfoModel.Dependencies).To(Equal([]catalogmanagementv1.OfferingReference{*offeringReferenceModel}))
				Expect(solutionInfoModel.InstallType).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the SccProfile model
				sccProfileModel := new(catalogmanagementv1.SccProfile)
				Expect(sccProfileModel).ToNot(BeNil())
				sccProfileModel.ID = core.StringPtr("testString")
				sccProfileModel.Name = core.StringPtr("testString")
				sccProfileModel.Version = core.StringPtr("testString")
				sccProfileModel.Description = core.StringPtr("testString")
				sccProfileModel.Type = core.StringPtr("testString")
				sccProfileModel.UIHref = core.StringPtr("testString")
				Expect(sccProfileModel.ID).To(Equal(core.StringPtr("testString")))
				Expect(sccProfileModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(sccProfileModel.Version).To(Equal(core.StringPtr("testString")))
				Expect(sccProfileModel.Description).To(Equal(core.StringPtr("testString")))
				Expect(sccProfileModel.Type).To(Equal(core.StringPtr("testString")))
				Expect(sccProfileModel.UIHref).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the ClaimedControl model
				claimedControlModel := new(catalogmanagementv1.ClaimedControl)
				Expect(claimedControlModel).ToNot(BeNil())
				claimedControlModel.Profile = sccProfileModel
				claimedControlModel.Names = []string{"testString"}
				Expect(claimedControlModel.Profile).To(Equal(sccProfileModel))
				Expect(claimedControlModel.Names).To(Equal([]string{"testString"}))

				// Construct an instance of the Claims model
				claimsModel := new(catalogmanagementv1.Claims)
				Expect(claimsModel).ToNot(BeNil())
				claimsModel.Profiles = []catalogmanagementv1.SccProfile{*sccProfileModel}
				claimsModel.Controls = []catalogmanagementv1.ClaimedControl{*claimedControlModel}
				Expect(claimsModel.Profiles).To(Equal([]catalogmanagementv1.SccProfile{*sccProfileModel}))
				Expect(claimsModel.Controls).To(Equal([]catalogmanagementv1.ClaimedControl{*claimedControlModel}))

				// Construct an instance of the Result model
				resultModel := new(catalogmanagementv1.Result)
				Expect(resultModel).ToNot(BeNil())
				resultModel.FailureCount = core.Int64Ptr(int64(38))
				resultModel.ScanTime = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				resultModel.ErrorMessage = core.StringPtr("testString")
				resultModel.CompleteScan = core.BoolPtr(true)
				resultModel.UnscannedResources = []string{"testString"}
				Expect(resultModel.FailureCount).To(Equal(core.Int64Ptr(int64(38))))
				Expect(resultModel.ScanTime).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(resultModel.ErrorMessage).To(Equal(core.StringPtr("testString")))
				Expect(resultModel.CompleteScan).To(Equal(core.BoolPtr(true)))
				Expect(resultModel.UnscannedResources).To(Equal([]string{"testString"}))

				// Construct an instance of the SccAssessment model
				sccAssessmentModel := new(catalogmanagementv1.SccAssessment)
				Expect(sccAssessmentModel).ToNot(BeNil())
				sccAssessmentModel.ID = core.StringPtr("testString")
				sccAssessmentModel.Description = core.StringPtr("testString")
				sccAssessmentModel.Version = core.StringPtr("testString")
				sccAssessmentModel.Type = core.StringPtr("testString")
				sccAssessmentModel.Method = core.StringPtr("testString")
				sccAssessmentModel.UIHref = core.StringPtr("testString")
				Expect(sccAssessmentModel.ID).To(Equal(core.StringPtr("testString")))
				Expect(sccAssessmentModel.Description).To(Equal(core.StringPtr("testString")))
				Expect(sccAssessmentModel.Version).To(Equal(core.StringPtr("testString")))
				Expect(sccAssessmentModel.Type).To(Equal(core.StringPtr("testString")))
				Expect(sccAssessmentModel.Method).To(Equal(core.StringPtr("testString")))
				Expect(sccAssessmentModel.UIHref).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the SccSpecification model
				sccSpecificationModel := new(catalogmanagementv1.SccSpecification)
				Expect(sccSpecificationModel).ToNot(BeNil())
				sccSpecificationModel.ID = core.StringPtr("testString")
				sccSpecificationModel.Description = core.StringPtr("testString")
				sccSpecificationModel.ComponentName = core.StringPtr("testString")
				sccSpecificationModel.Assessments = []catalogmanagementv1.SccAssessment{*sccAssessmentModel}
				sccSpecificationModel.UIHref = core.StringPtr("testString")
				Expect(sccSpecificationModel.ID).To(Equal(core.StringPtr("testString")))
				Expect(sccSpecificationModel.Description).To(Equal(core.StringPtr("testString")))
				Expect(sccSpecificationModel.ComponentName).To(Equal(core.StringPtr("testString")))
				Expect(sccSpecificationModel.Assessments).To(Equal([]catalogmanagementv1.SccAssessment{*sccAssessmentModel}))
				Expect(sccSpecificationModel.UIHref).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the SccControl model
				sccControlModel := new(catalogmanagementv1.SccControl)
				Expect(sccControlModel).ToNot(BeNil())
				sccControlModel.ID = core.StringPtr("testString")
				sccControlModel.Name = core.StringPtr("testString")
				sccControlModel.Version = core.StringPtr("testString")
				sccControlModel.Description = core.StringPtr("testString")
				sccControlModel.Profile = sccProfileModel
				sccControlModel.ParentName = core.StringPtr("testString")
				sccControlModel.Specifications = []catalogmanagementv1.SccSpecification{*sccSpecificationModel}
				sccControlModel.UIHref = core.StringPtr("testString")
				Expect(sccControlModel.ID).To(Equal(core.StringPtr("testString")))
				Expect(sccControlModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(sccControlModel.Version).To(Equal(core.StringPtr("testString")))
				Expect(sccControlModel.Description).To(Equal(core.StringPtr("testString")))
				Expect(sccControlModel.Profile).To(Equal(sccProfileModel))
				Expect(sccControlModel.ParentName).To(Equal(core.StringPtr("testString")))
				Expect(sccControlModel.Specifications).To(Equal([]catalogmanagementv1.SccSpecification{*sccSpecificationModel}))
				Expect(sccControlModel.UIHref).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the EvaluatedControl model
				evaluatedControlModel := new(catalogmanagementv1.EvaluatedControl)
				Expect(evaluatedControlModel).ToNot(BeNil())
				evaluatedControlModel.ID = core.StringPtr("testString")
				evaluatedControlModel.Name = core.StringPtr("testString")
				evaluatedControlModel.Description = core.StringPtr("testString")
				evaluatedControlModel.Specifications = []catalogmanagementv1.SccSpecification{*sccSpecificationModel}
				evaluatedControlModel.FailureCount = core.Int64Ptr(int64(38))
				evaluatedControlModel.PassCount = core.Int64Ptr(int64(38))
				evaluatedControlModel.Parent = sccControlModel
				evaluatedControlModel.UIHref = core.StringPtr("testString")
				Expect(evaluatedControlModel.ID).To(Equal(core.StringPtr("testString")))
				Expect(evaluatedControlModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(evaluatedControlModel.Description).To(Equal(core.StringPtr("testString")))
				Expect(evaluatedControlModel.Specifications).To(Equal([]catalogmanagementv1.SccSpecification{*sccSpecificationModel}))
				Expect(evaluatedControlModel.FailureCount).To(Equal(core.Int64Ptr(int64(38))))
				Expect(evaluatedControlModel.PassCount).To(Equal(core.Int64Ptr(int64(38))))
				Expect(evaluatedControlModel.Parent).To(Equal(sccControlModel))
				Expect(evaluatedControlModel.UIHref).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the Evaluation model
				evaluationModel := new(catalogmanagementv1.Evaluation)
				Expect(evaluationModel).ToNot(BeNil())
				evaluationModel.ScanID = core.StringPtr("testString")
				evaluationModel.AccountID = core.StringPtr("testString")
				evaluationModel.Profile = sccProfileModel
				evaluationModel.Result = resultModel
				evaluationModel.Controls = []catalogmanagementv1.EvaluatedControl{*evaluatedControlModel}
				Expect(evaluationModel.ScanID).To(Equal(core.StringPtr("testString")))
				Expect(evaluationModel.AccountID).To(Equal(core.StringPtr("testString")))
				Expect(evaluationModel.Profile).To(Equal(sccProfileModel))
				Expect(evaluationModel.Result).To(Equal(resultModel))
				Expect(evaluationModel.Controls).To(Equal([]catalogmanagementv1.EvaluatedControl{*evaluatedControlModel}))

				// Construct an instance of the Compliance model
				complianceModel := new(catalogmanagementv1.Compliance)
				Expect(complianceModel).ToNot(BeNil())
				complianceModel.Authority = core.StringPtr("testString")
				complianceModel.Claims = claimsModel
				complianceModel.Evaluations = []catalogmanagementv1.Evaluation{*evaluationModel}
				Expect(complianceModel.Authority).To(Equal(core.StringPtr("testString")))
				Expect(complianceModel.Claims).To(Equal(claimsModel))
				Expect(complianceModel.Evaluations).To(Equal([]catalogmanagementv1.Evaluation{*evaluationModel}))

				// Construct an instance of the ChangeNotices model
				changeNoticesModel := new(catalogmanagementv1.ChangeNotices)
				Expect(changeNoticesModel).ToNot(BeNil())
				changeNoticesModel.Breaking = []catalogmanagementv1.Feature{*featureModel}
				changeNoticesModel.New = []catalogmanagementv1.Feature{*featureModel}
				changeNoticesModel.Update = []catalogmanagementv1.Feature{*featureModel}
				Expect(changeNoticesModel.Breaking).To(Equal([]catalogmanagementv1.Feature{*featureModel}))
				Expect(changeNoticesModel.New).To(Equal([]catalogmanagementv1.Feature{*featureModel}))
				Expect(changeNoticesModel.Update).To(Equal([]catalogmanagementv1.Feature{*featureModel}))

				// Construct an instance of the Version model
				versionModel := new(catalogmanagementv1.Version)
				Expect(versionModel).ToNot(BeNil())
				versionModel.CRN = core.StringPtr("testString")
				versionModel.Version = core.StringPtr("testString")
				versionModel.Flavor = flavorModel
				versionModel.Sha = core.StringPtr("testString")
				versionModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				versionModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				versionModel.OfferingID = core.StringPtr("testString")
				versionModel.CatalogID = core.StringPtr("testString")
				versionModel.KindID = core.StringPtr("testString")
				versionModel.Tags = []string{"testString"}
				versionModel.RepoURL = core.StringPtr("testString")
				versionModel.SourceURL = core.StringPtr("testString")
				versionModel.TgzURL = core.StringPtr("testString")
				versionModel.Configuration = []catalogmanagementv1.Configuration{*configurationModel}
				versionModel.Outputs = []catalogmanagementv1.Output{*outputModel}
				versionModel.IamPermissions = []catalogmanagementv1.IamPermission{*iamPermissionModel}
				versionModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				versionModel.Validation = validationModel
				versionModel.RequiredResources = []catalogmanagementv1.Resource{*resourceModel}
				versionModel.SingleInstance = core.BoolPtr(true)
				versionModel.SchematicsEnvValues = schematicsEnvValuesModel
				versionModel.Install = scriptModel
				versionModel.PreInstall = []catalogmanagementv1.Script{*scriptModel}
				versionModel.Scripts = map[string]catalogmanagementv1.ScriptRef{"key1": *scriptRefModel}
				versionModel.Entitlement = versionEntitlementModel
				versionModel.Licenses = []catalogmanagementv1.License{*licenseModel}
				versionModel.ImageManifestURL = core.StringPtr("testString")
				versionModel.Deprecated = core.BoolPtr(true)
				versionModel.PackageVersion = core.StringPtr("testString")
				versionModel.State = stateModel
				versionModel.VersionLocator = core.StringPtr("testString")
				versionModel.LongDescription = core.StringPtr("testString")
				versionModel.LongDescriptionI18n = map[string]string{"key1": "testString"}
				versionModel.WhitelistedAccounts = []string{"testString"}
				versionModel.ImagePullKeyName = core.StringPtr("testString")
				versionModel.DeprecatePending = deprecatePendingModel
				versionModel.SolutionInfo = solutionInfoModel
				versionModel.IsConsumable = core.BoolPtr(true)
				versionModel.ComplianceV3 = complianceModel
				versionModel.ChangeNotices = changeNoticesModel
				versionModel.PlanIds = []string{"testString"}
				versionModel.Stack = map[string]interface{}{"anyKey": "anyValue"}
				versionModel.MinimumCompatibleVersion = core.StringPtr("testString")
				versionModel.Scripts["foo"] = *scriptRefModel
				Expect(versionModel.CRN).To(Equal(core.StringPtr("testString")))
				Expect(versionModel.Version).To(Equal(core.StringPtr("testString")))
				Expect(versionModel.Flavor).To(Equal(flavorModel))
				Expect(versionModel.Sha).To(Equal(core.StringPtr("testString")))
				Expect(versionModel.Created).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(versionModel.Updated).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(versionModel.OfferingID).To(Equal(core.StringPtr("testString")))
				Expect(versionModel.CatalogID).To(Equal(core.StringPtr("testString")))
				Expect(versionModel.KindID).To(Equal(core.StringPtr("testString")))
				Expect(versionModel.Tags).To(Equal([]string{"testString"}))
				Expect(versionModel.RepoURL).To(Equal(core.StringPtr("testString")))
				Expect(versionModel.SourceURL).To(Equal(core.StringPtr("testString")))
				Expect(versionModel.TgzURL).To(Equal(core.StringPtr("testString")))
				Expect(versionModel.Configuration).To(Equal([]catalogmanagementv1.Configuration{*configurationModel}))
				Expect(versionModel.Outputs).To(Equal([]catalogmanagementv1.Output{*outputModel}))
				Expect(versionModel.IamPermissions).To(Equal([]catalogmanagementv1.IamPermission{*iamPermissionModel}))
				Expect(versionModel.Metadata).To(Equal(map[string]interface{}{"anyKey": "anyValue"}))
				Expect(versionModel.Validation).To(Equal(validationModel))
				Expect(versionModel.RequiredResources).To(Equal([]catalogmanagementv1.Resource{*resourceModel}))
				Expect(versionModel.SingleInstance).To(Equal(core.BoolPtr(true)))
				Expect(versionModel.SchematicsEnvValues).To(Equal(schematicsEnvValuesModel))
				Expect(versionModel.Install).To(Equal(scriptModel))
				Expect(versionModel.PreInstall).To(Equal([]catalogmanagementv1.Script{*scriptModel}))
				Expect(versionModel.Entitlement).To(Equal(versionEntitlementModel))
				Expect(versionModel.Licenses).To(Equal([]catalogmanagementv1.License{*licenseModel}))
				Expect(versionModel.ImageManifestURL).To(Equal(core.StringPtr("testString")))
				Expect(versionModel.Deprecated).To(Equal(core.BoolPtr(true)))
				Expect(versionModel.PackageVersion).To(Equal(core.StringPtr("testString")))
				Expect(versionModel.State).To(Equal(stateModel))
				Expect(versionModel.VersionLocator).To(Equal(core.StringPtr("testString")))
				Expect(versionModel.LongDescription).To(Equal(core.StringPtr("testString")))
				Expect(versionModel.LongDescriptionI18n).To(Equal(map[string]string{"key1": "testString"}))
				Expect(versionModel.WhitelistedAccounts).To(Equal([]string{"testString"}))
				Expect(versionModel.ImagePullKeyName).To(Equal(core.StringPtr("testString")))
				Expect(versionModel.DeprecatePending).To(Equal(deprecatePendingModel))
				Expect(versionModel.SolutionInfo).To(Equal(solutionInfoModel))
				Expect(versionModel.IsConsumable).To(Equal(core.BoolPtr(true)))
				Expect(versionModel.ComplianceV3).To(Equal(complianceModel))
				Expect(versionModel.ChangeNotices).To(Equal(changeNoticesModel))
				Expect(versionModel.PlanIds).To(Equal([]string{"testString"}))
				Expect(versionModel.Stack).To(Equal(map[string]interface{}{"anyKey": "anyValue"}))
				Expect(versionModel.MinimumCompatibleVersion).To(Equal(core.StringPtr("testString")))
				Expect(versionModel.Scripts["foo"]).To(Equal(*scriptRefModel))

				// Construct an instance of the PaginationTokenLink model
				paginationTokenLinkModel := new(catalogmanagementv1.PaginationTokenLink)
				Expect(paginationTokenLinkModel).ToNot(BeNil())
				paginationTokenLinkModel.Href = core.StringPtr("testString")
				paginationTokenLinkModel.Start = core.StringPtr("testString")
				Expect(paginationTokenLinkModel.Href).To(Equal(core.StringPtr("testString")))
				Expect(paginationTokenLinkModel.Start).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the KindAllVersions model
				kindAllVersionsModel := new(catalogmanagementv1.KindAllVersions)
				Expect(kindAllVersionsModel).ToNot(BeNil())
				kindAllVersionsModel.First = paginationTokenLinkModel
				kindAllVersionsModel.Next = paginationTokenLinkModel
				Expect(kindAllVersionsModel.First).To(Equal(paginationTokenLinkModel))
				Expect(kindAllVersionsModel.Next).To(Equal(paginationTokenLinkModel))

				// Construct an instance of the Kind model
				kindModel := new(catalogmanagementv1.Kind)
				Expect(kindModel).ToNot(BeNil())
				kindModel.ID = core.StringPtr("testString")
				kindModel.FormatKind = core.StringPtr("testString")
				kindModel.FormatKindLabel = core.StringPtr("testString")
				kindModel.InstallKind = core.StringPtr("testString")
				kindModel.InstallKindLabel = core.StringPtr("testString")
				kindModel.TargetKind = core.StringPtr("testString")
				kindModel.TargetKindLabel = core.StringPtr("testString")
				kindModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				kindModel.Tags = []string{"testString"}
				kindModel.AdditionalFeatures = []catalogmanagementv1.Feature{*featureModel}
				kindModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				kindModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				kindModel.Versions = []catalogmanagementv1.Version{*versionModel}
				kindModel.AllVersions = kindAllVersionsModel
				Expect(kindModel.ID).To(Equal(core.StringPtr("testString")))
				Expect(kindModel.FormatKind).To(Equal(core.StringPtr("testString")))
				Expect(kindModel.FormatKindLabel).To(Equal(core.StringPtr("testString")))
				Expect(kindModel.InstallKind).To(Equal(core.StringPtr("testString")))
				Expect(kindModel.InstallKindLabel).To(Equal(core.StringPtr("testString")))
				Expect(kindModel.TargetKind).To(Equal(core.StringPtr("testString")))
				Expect(kindModel.TargetKindLabel).To(Equal(core.StringPtr("testString")))
				Expect(kindModel.Metadata).To(Equal(map[string]interface{}{"anyKey": "anyValue"}))
				Expect(kindModel.Tags).To(Equal([]string{"testString"}))
				Expect(kindModel.AdditionalFeatures).To(Equal([]catalogmanagementv1.Feature{*featureModel}))
				Expect(kindModel.Created).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(kindModel.Updated).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(kindModel.Versions).To(Equal([]catalogmanagementv1.Version{*versionModel}))
				Expect(kindModel.AllVersions).To(Equal(kindAllVersionsModel))

				// Construct an instance of the PublishObject model
				publishObjectModel := new(catalogmanagementv1.PublishObject)
				Expect(publishObjectModel).ToNot(BeNil())
				publishObjectModel.PcManaged = core.BoolPtr(true)
				publishObjectModel.ApprovalType = core.StringPtr("testString")
				publishObjectModel.PublishApproved = core.BoolPtr(true)
				publishObjectModel.ShareWithAll = core.BoolPtr(true)
				publishObjectModel.ShareWithIBM = core.BoolPtr(true)
				publishObjectModel.ShareEnabled = core.BoolPtr(true)
				publishObjectModel.OriginalCRN = core.StringPtr("testString")
				publishObjectModel.PublicCRN = core.StringPtr("testString")
				publishObjectModel.ApprovalRecord = map[string]interface{}{"anyKey": "anyValue"}
				publishObjectModel.PermitIBMPublicPublish = core.BoolPtr(true)
				publishObjectModel.IBMApproved = core.BoolPtr(true)
				publishObjectModel.PublicApproved = core.BoolPtr(true)
				Expect(publishObjectModel.PcManaged).To(Equal(core.BoolPtr(true)))
				Expect(publishObjectModel.ApprovalType).To(Equal(core.StringPtr("testString")))
				Expect(publishObjectModel.PublishApproved).To(Equal(core.BoolPtr(true)))
				Expect(publishObjectModel.ShareWithAll).To(Equal(core.BoolPtr(true)))
				Expect(publishObjectModel.ShareWithIBM).To(Equal(core.BoolPtr(true)))
				Expect(publishObjectModel.ShareEnabled).To(Equal(core.BoolPtr(true)))
				Expect(publishObjectModel.OriginalCRN).To(Equal(core.StringPtr("testString")))
				Expect(publishObjectModel.PublicCRN).To(Equal(core.StringPtr("testString")))
				Expect(publishObjectModel.ApprovalRecord).To(Equal(map[string]interface{}{"anyKey": "anyValue"}))
				Expect(publishObjectModel.PermitIBMPublicPublish).To(Equal(core.BoolPtr(true)))
				Expect(publishObjectModel.IBMApproved).To(Equal(core.BoolPtr(true)))
				Expect(publishObjectModel.PublicApproved).To(Equal(core.BoolPtr(true)))

				// Construct an instance of the ProviderInfo model
				providerInfoModel := new(catalogmanagementv1.ProviderInfo)
				Expect(providerInfoModel).ToNot(BeNil())
				providerInfoModel.ID = core.StringPtr("testString")
				providerInfoModel.Name = core.StringPtr("testString")
				Expect(providerInfoModel.ID).To(Equal(core.StringPtr("testString")))
				Expect(providerInfoModel.Name).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the RepoInfo model
				repoInfoModel := new(catalogmanagementv1.RepoInfo)
				Expect(repoInfoModel).ToNot(BeNil())
				repoInfoModel.Token = core.StringPtr("testString")
				repoInfoModel.Type = core.StringPtr("testString")
				Expect(repoInfoModel.Token).To(Equal(core.StringPtr("testString")))
				Expect(repoInfoModel.Type).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the ImagePullKey model
				imagePullKeyModel := new(catalogmanagementv1.ImagePullKey)
				Expect(imagePullKeyModel).ToNot(BeNil())
				imagePullKeyModel.Name = core.StringPtr("testString")
				imagePullKeyModel.Value = core.StringPtr("testString")
				imagePullKeyModel.Description = core.StringPtr("testString")
				Expect(imagePullKeyModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(imagePullKeyModel.Value).To(Equal(core.StringPtr("testString")))
				Expect(imagePullKeyModel.Description).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the SupportWaitTime model
				supportWaitTimeModel := new(catalogmanagementv1.SupportWaitTime)
				Expect(supportWaitTimeModel).ToNot(BeNil())
				supportWaitTimeModel.Value = core.Int64Ptr(int64(38))
				supportWaitTimeModel.Type = core.StringPtr("testString")
				Expect(supportWaitTimeModel.Value).To(Equal(core.Int64Ptr(int64(38))))
				Expect(supportWaitTimeModel.Type).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the SupportTime model
				supportTimeModel := new(catalogmanagementv1.SupportTime)
				Expect(supportTimeModel).ToNot(BeNil())
				supportTimeModel.Day = core.Int64Ptr(int64(38))
				supportTimeModel.StartTime = core.StringPtr("testString")
				supportTimeModel.EndTime = core.StringPtr("testString")
				Expect(supportTimeModel.Day).To(Equal(core.Int64Ptr(int64(38))))
				Expect(supportTimeModel.StartTime).To(Equal(core.StringPtr("testString")))
				Expect(supportTimeModel.EndTime).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the SupportAvailability model
				supportAvailabilityModel := new(catalogmanagementv1.SupportAvailability)
				Expect(supportAvailabilityModel).ToNot(BeNil())
				supportAvailabilityModel.Times = []catalogmanagementv1.SupportTime{*supportTimeModel}
				supportAvailabilityModel.Timezone = core.StringPtr("testString")
				supportAvailabilityModel.AlwaysAvailable = core.BoolPtr(true)
				Expect(supportAvailabilityModel.Times).To(Equal([]catalogmanagementv1.SupportTime{*supportTimeModel}))
				Expect(supportAvailabilityModel.Timezone).To(Equal(core.StringPtr("testString")))
				Expect(supportAvailabilityModel.AlwaysAvailable).To(Equal(core.BoolPtr(true)))

				// Construct an instance of the SupportDetail model
				supportDetailModel := new(catalogmanagementv1.SupportDetail)
				Expect(supportDetailModel).ToNot(BeNil())
				supportDetailModel.Type = core.StringPtr("testString")
				supportDetailModel.Contact = core.StringPtr("testString")
				supportDetailModel.ResponseWaitTime = supportWaitTimeModel
				supportDetailModel.Availability = supportAvailabilityModel
				Expect(supportDetailModel.Type).To(Equal(core.StringPtr("testString")))
				Expect(supportDetailModel.Contact).To(Equal(core.StringPtr("testString")))
				Expect(supportDetailModel.ResponseWaitTime).To(Equal(supportWaitTimeModel))
				Expect(supportDetailModel.Availability).To(Equal(supportAvailabilityModel))

				// Construct an instance of the SupportEscalation model
				supportEscalationModel := new(catalogmanagementv1.SupportEscalation)
				Expect(supportEscalationModel).ToNot(BeNil())
				supportEscalationModel.EscalationWaitTime = supportWaitTimeModel
				supportEscalationModel.ResponseWaitTime = supportWaitTimeModel
				supportEscalationModel.Contact = core.StringPtr("testString")
				Expect(supportEscalationModel.EscalationWaitTime).To(Equal(supportWaitTimeModel))
				Expect(supportEscalationModel.ResponseWaitTime).To(Equal(supportWaitTimeModel))
				Expect(supportEscalationModel.Contact).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the Support model
				supportModel := new(catalogmanagementv1.Support)
				Expect(supportModel).ToNot(BeNil())
				supportModel.URL = core.StringPtr("testString")
				supportModel.Process = core.StringPtr("testString")
				supportModel.ProcessI18n = map[string]string{"key1": "testString"}
				supportModel.Locations = []string{"testString"}
				supportModel.SupportDetails = []catalogmanagementv1.SupportDetail{*supportDetailModel}
				supportModel.SupportEscalation = supportEscalationModel
				supportModel.SupportType = core.StringPtr("testString")
				Expect(supportModel.URL).To(Equal(core.StringPtr("testString")))
				Expect(supportModel.Process).To(Equal(core.StringPtr("testString")))
				Expect(supportModel.ProcessI18n).To(Equal(map[string]string{"key1": "testString"}))
				Expect(supportModel.Locations).To(Equal([]string{"testString"}))
				Expect(supportModel.SupportDetails).To(Equal([]catalogmanagementv1.SupportDetail{*supportDetailModel}))
				Expect(supportModel.SupportEscalation).To(Equal(supportEscalationModel))
				Expect(supportModel.SupportType).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the LearnMoreLinks model
				learnMoreLinksModel := new(catalogmanagementv1.LearnMoreLinks)
				Expect(learnMoreLinksModel).ToNot(BeNil())
				learnMoreLinksModel.FirstParty = core.StringPtr("testString")
				learnMoreLinksModel.ThirdParty = core.StringPtr("testString")
				Expect(learnMoreLinksModel.FirstParty).To(Equal(core.StringPtr("testString")))
				Expect(learnMoreLinksModel.ThirdParty).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the Constraint model
				constraintModel := new(catalogmanagementv1.Constraint)
				Expect(constraintModel).ToNot(BeNil())
				constraintModel.Type = core.StringPtr("testString")
				constraintModel.Rule = "testString"
				Expect(constraintModel.Type).To(Equal(core.StringPtr("testString")))
				Expect(constraintModel.Rule).To(Equal("testString"))

				// Construct an instance of the Badge model
				badgeModel := new(catalogmanagementv1.Badge)
				Expect(badgeModel).ToNot(BeNil())
				badgeModel.ID = core.StringPtr("testString")
				badgeModel.Label = core.StringPtr("testString")
				badgeModel.LabelI18n = map[string]string{"key1": "testString"}
				badgeModel.Description = core.StringPtr("testString")
				badgeModel.DescriptionI18n = map[string]string{"key1": "testString"}
				badgeModel.Icon = core.StringPtr("testString")
				badgeModel.Authority = core.StringPtr("testString")
				badgeModel.Tag = core.StringPtr("testString")
				badgeModel.LearnMoreLinks = learnMoreLinksModel
				badgeModel.Constraints = []catalogmanagementv1.Constraint{*constraintModel}
				Expect(badgeModel.ID).To(Equal(core.StringPtr("testString")))
				Expect(badgeModel.Label).To(Equal(core.StringPtr("testString")))
				Expect(badgeModel.LabelI18n).To(Equal(map[string]string{"key1": "testString"}))
				Expect(badgeModel.Description).To(Equal(core.StringPtr("testString")))
				Expect(badgeModel.DescriptionI18n).To(Equal(map[string]string{"key1": "testString"}))
				Expect(badgeModel.Icon).To(Equal(core.StringPtr("testString")))
				Expect(badgeModel.Authority).To(Equal(core.StringPtr("testString")))
				Expect(badgeModel.Tag).To(Equal(core.StringPtr("testString")))
				Expect(badgeModel.LearnMoreLinks).To(Equal(learnMoreLinksModel))
				Expect(badgeModel.Constraints).To(Equal([]catalogmanagementv1.Constraint{*constraintModel}))

				// Construct an instance of the VersionRange model
				versionRangeModel := new(catalogmanagementv1.VersionRange)
				Expect(versionRangeModel).ToNot(BeNil())
				versionRangeModel.Kinds = []string{"testString"}
				versionRangeModel.Version = core.StringPtr("testString")
				versionRangeModel.Flavors = []string{"testString"}
				Expect(versionRangeModel.Kinds).To(Equal([]string{"testString"}))
				Expect(versionRangeModel.Version).To(Equal(core.StringPtr("testString")))
				Expect(versionRangeModel.Flavors).To(Equal([]string{"testString"}))

				// Construct an instance of the Plan model
				planModel := new(catalogmanagementv1.Plan)
				Expect(planModel).ToNot(BeNil())
				planModel.URL = core.StringPtr("testString")
				planModel.CRN = core.StringPtr("testString")
				planModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				planModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				planModel.OfferingID = core.StringPtr("testString")
				planModel.CatalogID = core.StringPtr("testString")
				planModel.Label = core.StringPtr("testString")
				planModel.LabelI18n = map[string]string{"key1": "testString"}
				planModel.Name = core.StringPtr("testString")
				planModel.ShortDescription = core.StringPtr("testString")
				planModel.ShortDescriptionI18n = map[string]string{"key1": "testString"}
				planModel.PricingTags = []string{"testString"}
				planModel.VersionRange = versionRangeModel
				planModel.Features = []catalogmanagementv1.Feature{*featureModel}
				planModel.State = stateModel
				planModel.DeprecatePending = deprecatePendingModel
				planModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				planModel.PublishApproved = core.BoolPtr(true)
				Expect(planModel.URL).To(Equal(core.StringPtr("testString")))
				Expect(planModel.CRN).To(Equal(core.StringPtr("testString")))
				Expect(planModel.Created).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(planModel.Updated).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(planModel.OfferingID).To(Equal(core.StringPtr("testString")))
				Expect(planModel.CatalogID).To(Equal(core.StringPtr("testString")))
				Expect(planModel.Label).To(Equal(core.StringPtr("testString")))
				Expect(planModel.LabelI18n).To(Equal(map[string]string{"key1": "testString"}))
				Expect(planModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(planModel.ShortDescription).To(Equal(core.StringPtr("testString")))
				Expect(planModel.ShortDescriptionI18n).To(Equal(map[string]string{"key1": "testString"}))
				Expect(planModel.PricingTags).To(Equal([]string{"testString"}))
				Expect(planModel.VersionRange).To(Equal(versionRangeModel))
				Expect(planModel.Features).To(Equal([]catalogmanagementv1.Feature{*featureModel}))
				Expect(planModel.State).To(Equal(stateModel))
				Expect(planModel.DeprecatePending).To(Equal(deprecatePendingModel))
				Expect(planModel.Metadata).To(Equal(map[string]interface{}{"anyKey": "anyValue"}))
				Expect(planModel.PublishApproved).To(Equal(core.BoolPtr(true)))

				// Construct an instance of the ReplaceOfferingOptions model
				catalogIdentifier := "testString"
				offeringID := "testString"
				replaceOfferingOptionsModel := catalogManagementService.NewReplaceOfferingOptions(catalogIdentifier, offeringID)
				replaceOfferingOptionsModel.SetCatalogIdentifier("testString")
				replaceOfferingOptionsModel.SetOfferingID("testString")
				replaceOfferingOptionsModel.SetID("testString")
				replaceOfferingOptionsModel.SetRev("testString")
				replaceOfferingOptionsModel.SetURL("testString")
				replaceOfferingOptionsModel.SetCRN("testString")
				replaceOfferingOptionsModel.SetLabel("testString")
				replaceOfferingOptionsModel.SetLabelI18n(map[string]string{"key1": "testString"})
				replaceOfferingOptionsModel.SetName("testString")
				replaceOfferingOptionsModel.SetOfferingIconURL("testString")
				replaceOfferingOptionsModel.SetOfferingDocsURL("testString")
				replaceOfferingOptionsModel.SetOfferingSupportURL("testString")
				replaceOfferingOptionsModel.SetTags([]string{"testString"})
				replaceOfferingOptionsModel.SetKeywords([]string{"testString"})
				replaceOfferingOptionsModel.SetRating(ratingModel)
				replaceOfferingOptionsModel.SetCreated(CreateMockDateTime("2019-01-01T12:00:00.000Z"))
				replaceOfferingOptionsModel.SetUpdated(CreateMockDateTime("2019-01-01T12:00:00.000Z"))
				replaceOfferingOptionsModel.SetShortDescription("testString")
				replaceOfferingOptionsModel.SetShortDescriptionI18n(map[string]string{"key1": "testString"})
				replaceOfferingOptionsModel.SetLongDescription("testString")
				replaceOfferingOptionsModel.SetLongDescriptionI18n(map[string]string{"key1": "testString"})
				replaceOfferingOptionsModel.SetFeatures([]catalogmanagementv1.Feature{*featureModel})
				replaceOfferingOptionsModel.SetKinds([]catalogmanagementv1.Kind{*kindModel})
				replaceOfferingOptionsModel.SetPublish(publishObjectModel)
				replaceOfferingOptionsModel.SetPcManaged(true)
				replaceOfferingOptionsModel.SetPublishApproved(true)
				replaceOfferingOptionsModel.SetShareWithAll(true)
				replaceOfferingOptionsModel.SetShareWithIBM(true)
				replaceOfferingOptionsModel.SetShareEnabled(true)
				replaceOfferingOptionsModel.SetPublicOriginalCRN("testString")
				replaceOfferingOptionsModel.SetPublishPublicCRN("testString")
				replaceOfferingOptionsModel.SetPortalApprovalRecord("testString")
				replaceOfferingOptionsModel.SetPortalUIURL("testString")
				replaceOfferingOptionsModel.SetCatalogID("testString")
				replaceOfferingOptionsModel.SetCatalogName("testString")
				replaceOfferingOptionsModel.SetMetadata(map[string]interface{}{"anyKey": "anyValue"})
				replaceOfferingOptionsModel.SetDisclaimer("testString")
				replaceOfferingOptionsModel.SetHidden(true)
				replaceOfferingOptionsModel.SetProvider("testString")
				replaceOfferingOptionsModel.SetProviderInfo(providerInfoModel)
				replaceOfferingOptionsModel.SetRepoInfo(repoInfoModel)
				replaceOfferingOptionsModel.SetImagePullKeys([]catalogmanagementv1.ImagePullKey{*imagePullKeyModel})
				replaceOfferingOptionsModel.SetSupport(supportModel)
				replaceOfferingOptionsModel.SetMedia([]catalogmanagementv1.MediaItem{*mediaItemModel})
				replaceOfferingOptionsModel.SetDeprecatePending(deprecatePendingModel)
				replaceOfferingOptionsModel.SetProductKind("testString")
				replaceOfferingOptionsModel.SetBadges([]catalogmanagementv1.Badge{*badgeModel})
				replaceOfferingOptionsModel.SetPlans([]catalogmanagementv1.Plan{*planModel})
				replaceOfferingOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(replaceOfferingOptionsModel).ToNot(BeNil())
				Expect(replaceOfferingOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(replaceOfferingOptionsModel.OfferingID).To(Equal(core.StringPtr("testString")))
				Expect(replaceOfferingOptionsModel.ID).To(Equal(core.StringPtr("testString")))
				Expect(replaceOfferingOptionsModel.Rev).To(Equal(core.StringPtr("testString")))
				Expect(replaceOfferingOptionsModel.URL).To(Equal(core.StringPtr("testString")))
				Expect(replaceOfferingOptionsModel.CRN).To(Equal(core.StringPtr("testString")))
				Expect(replaceOfferingOptionsModel.Label).To(Equal(core.StringPtr("testString")))
				Expect(replaceOfferingOptionsModel.LabelI18n).To(Equal(map[string]string{"key1": "testString"}))
				Expect(replaceOfferingOptionsModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(replaceOfferingOptionsModel.OfferingIconURL).To(Equal(core.StringPtr("testString")))
				Expect(replaceOfferingOptionsModel.OfferingDocsURL).To(Equal(core.StringPtr("testString")))
				Expect(replaceOfferingOptionsModel.OfferingSupportURL).To(Equal(core.StringPtr("testString")))
				Expect(replaceOfferingOptionsModel.Tags).To(Equal([]string{"testString"}))
				Expect(replaceOfferingOptionsModel.Keywords).To(Equal([]string{"testString"}))
				Expect(replaceOfferingOptionsModel.Rating).To(Equal(ratingModel))
				Expect(replaceOfferingOptionsModel.Created).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(replaceOfferingOptionsModel.Updated).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(replaceOfferingOptionsModel.ShortDescription).To(Equal(core.StringPtr("testString")))
				Expect(replaceOfferingOptionsModel.ShortDescriptionI18n).To(Equal(map[string]string{"key1": "testString"}))
				Expect(replaceOfferingOptionsModel.LongDescription).To(Equal(core.StringPtr("testString")))
				Expect(replaceOfferingOptionsModel.LongDescriptionI18n).To(Equal(map[string]string{"key1": "testString"}))
				Expect(replaceOfferingOptionsModel.Features).To(Equal([]catalogmanagementv1.Feature{*featureModel}))
				Expect(replaceOfferingOptionsModel.Kinds).To(Equal([]catalogmanagementv1.Kind{*kindModel}))
				Expect(replaceOfferingOptionsModel.Publish).To(Equal(publishObjectModel))
				Expect(replaceOfferingOptionsModel.PcManaged).To(Equal(core.BoolPtr(true)))
				Expect(replaceOfferingOptionsModel.PublishApproved).To(Equal(core.BoolPtr(true)))
				Expect(replaceOfferingOptionsModel.ShareWithAll).To(Equal(core.BoolPtr(true)))
				Expect(replaceOfferingOptionsModel.ShareWithIBM).To(Equal(core.BoolPtr(true)))
				Expect(replaceOfferingOptionsModel.ShareEnabled).To(Equal(core.BoolPtr(true)))
				Expect(replaceOfferingOptionsModel.PublicOriginalCRN).To(Equal(core.StringPtr("testString")))
				Expect(replaceOfferingOptionsModel.PublishPublicCRN).To(Equal(core.StringPtr("testString")))
				Expect(replaceOfferingOptionsModel.PortalApprovalRecord).To(Equal(core.StringPtr("testString")))
				Expect(replaceOfferingOptionsModel.PortalUIURL).To(Equal(core.StringPtr("testString")))
				Expect(replaceOfferingOptionsModel.CatalogID).To(Equal(core.StringPtr("testString")))
				Expect(replaceOfferingOptionsModel.CatalogName).To(Equal(core.StringPtr("testString")))
				Expect(replaceOfferingOptionsModel.Metadata).To(Equal(map[string]interface{}{"anyKey": "anyValue"}))
				Expect(replaceOfferingOptionsModel.Disclaimer).To(Equal(core.StringPtr("testString")))
				Expect(replaceOfferingOptionsModel.Hidden).To(Equal(core.BoolPtr(true)))
				Expect(replaceOfferingOptionsModel.Provider).To(Equal(core.StringPtr("testString")))
				Expect(replaceOfferingOptionsModel.ProviderInfo).To(Equal(providerInfoModel))
				Expect(replaceOfferingOptionsModel.RepoInfo).To(Equal(repoInfoModel))
				Expect(replaceOfferingOptionsModel.ImagePullKeys).To(Equal([]catalogmanagementv1.ImagePullKey{*imagePullKeyModel}))
				Expect(replaceOfferingOptionsModel.Support).To(Equal(supportModel))
				Expect(replaceOfferingOptionsModel.Media).To(Equal([]catalogmanagementv1.MediaItem{*mediaItemModel}))
				Expect(replaceOfferingOptionsModel.DeprecatePending).To(Equal(deprecatePendingModel))
				Expect(replaceOfferingOptionsModel.ProductKind).To(Equal(core.StringPtr("testString")))
				Expect(replaceOfferingOptionsModel.Badges).To(Equal([]catalogmanagementv1.Badge{*badgeModel}))
				Expect(replaceOfferingOptionsModel.Plans).To(Equal([]catalogmanagementv1.Plan{*planModel}))
				Expect(replaceOfferingOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewReplaceOperatorsOptions successfully`, func() {
				// Construct an instance of the ReplaceOperatorsOptions model
				xAuthRefreshToken := "testString"
				replaceOperatorsOptionsModel := catalogManagementService.NewReplaceOperatorsOptions(xAuthRefreshToken)
				replaceOperatorsOptionsModel.SetXAuthRefreshToken("testString")
				replaceOperatorsOptionsModel.SetClusterID("testString")
				replaceOperatorsOptionsModel.SetRegion("testString")
				replaceOperatorsOptionsModel.SetNamespaces([]string{"testString"})
				replaceOperatorsOptionsModel.SetAllNamespaces(true)
				replaceOperatorsOptionsModel.SetVersionLocatorID("testString")
				replaceOperatorsOptionsModel.SetChannel("testString")
				replaceOperatorsOptionsModel.SetInstallPlan("testString")
				replaceOperatorsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(replaceOperatorsOptionsModel).ToNot(BeNil())
				Expect(replaceOperatorsOptionsModel.XAuthRefreshToken).To(Equal(core.StringPtr("testString")))
				Expect(replaceOperatorsOptionsModel.ClusterID).To(Equal(core.StringPtr("testString")))
				Expect(replaceOperatorsOptionsModel.Region).To(Equal(core.StringPtr("testString")))
				Expect(replaceOperatorsOptionsModel.Namespaces).To(Equal([]string{"testString"}))
				Expect(replaceOperatorsOptionsModel.AllNamespaces).To(Equal(core.BoolPtr(true)))
				Expect(replaceOperatorsOptionsModel.VersionLocatorID).To(Equal(core.StringPtr("testString")))
				Expect(replaceOperatorsOptionsModel.Channel).To(Equal(core.StringPtr("testString")))
				Expect(replaceOperatorsOptionsModel.InstallPlan).To(Equal(core.StringPtr("testString")))
				Expect(replaceOperatorsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewSearchObjectsOptions successfully`, func() {
				// Construct an instance of the SearchObjectsOptions model
				query := "testString"
				searchObjectsOptionsModel := catalogManagementService.NewSearchObjectsOptions(query)
				searchObjectsOptionsModel.SetQuery("testString")
				searchObjectsOptionsModel.SetKind("vpe")
				searchObjectsOptionsModel.SetLimit(int64(10))
				searchObjectsOptionsModel.SetOffset(int64(0))
				searchObjectsOptionsModel.SetCollapse(true)
				searchObjectsOptionsModel.SetDigest(true)
				searchObjectsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(searchObjectsOptionsModel).ToNot(BeNil())
				Expect(searchObjectsOptionsModel.Query).To(Equal(core.StringPtr("testString")))
				Expect(searchObjectsOptionsModel.Kind).To(Equal(core.StringPtr("vpe")))
				Expect(searchObjectsOptionsModel.Limit).To(Equal(core.Int64Ptr(int64(10))))
				Expect(searchObjectsOptionsModel.Offset).To(Equal(core.Int64Ptr(int64(0))))
				Expect(searchObjectsOptionsModel.Collapse).To(Equal(core.BoolPtr(true)))
				Expect(searchObjectsOptionsModel.Digest).To(Equal(core.BoolPtr(true)))
				Expect(searchObjectsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewSetDeprecatePlanOptions successfully`, func() {
				// Construct an instance of the SetDeprecatePlanOptions model
				planLocID := "testString"
				setting := "true"
				setDeprecatePlanOptionsModel := catalogManagementService.NewSetDeprecatePlanOptions(planLocID, setting)
				setDeprecatePlanOptionsModel.SetPlanLocID("testString")
				setDeprecatePlanOptionsModel.SetSetting("true")
				setDeprecatePlanOptionsModel.SetDescription("testString")
				setDeprecatePlanOptionsModel.SetDaysUntilDeprecate(int64(38))
				setDeprecatePlanOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(setDeprecatePlanOptionsModel).ToNot(BeNil())
				Expect(setDeprecatePlanOptionsModel.PlanLocID).To(Equal(core.StringPtr("testString")))
				Expect(setDeprecatePlanOptionsModel.Setting).To(Equal(core.StringPtr("true")))
				Expect(setDeprecatePlanOptionsModel.Description).To(Equal(core.StringPtr("testString")))
				Expect(setDeprecatePlanOptionsModel.DaysUntilDeprecate).To(Equal(core.Int64Ptr(int64(38))))
				Expect(setDeprecatePlanOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewSetDeprecateVersionOptions successfully`, func() {
				// Construct an instance of the SetDeprecateVersionOptions model
				versionLocID := "testString"
				setting := "true"
				setDeprecateVersionOptionsModel := catalogManagementService.NewSetDeprecateVersionOptions(versionLocID, setting)
				setDeprecateVersionOptionsModel.SetVersionLocID("testString")
				setDeprecateVersionOptionsModel.SetSetting("true")
				setDeprecateVersionOptionsModel.SetDescription("testString")
				setDeprecateVersionOptionsModel.SetDaysUntilDeprecate(int64(38))
				setDeprecateVersionOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(setDeprecateVersionOptionsModel).ToNot(BeNil())
				Expect(setDeprecateVersionOptionsModel.VersionLocID).To(Equal(core.StringPtr("testString")))
				Expect(setDeprecateVersionOptionsModel.Setting).To(Equal(core.StringPtr("true")))
				Expect(setDeprecateVersionOptionsModel.Description).To(Equal(core.StringPtr("testString")))
				Expect(setDeprecateVersionOptionsModel.DaysUntilDeprecate).To(Equal(core.Int64Ptr(int64(38))))
				Expect(setDeprecateVersionOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewSetOfferingPublishOptions successfully`, func() {
				// Construct an instance of the SetOfferingPublishOptions model
				catalogIdentifier := "testString"
				offeringID := "testString"
				approvalType := "pc_managed"
				approved := "true"
				setOfferingPublishOptionsModel := catalogManagementService.NewSetOfferingPublishOptions(catalogIdentifier, offeringID, approvalType, approved)
				setOfferingPublishOptionsModel.SetCatalogIdentifier("testString")
				setOfferingPublishOptionsModel.SetOfferingID("testString")
				setOfferingPublishOptionsModel.SetApprovalType("pc_managed")
				setOfferingPublishOptionsModel.SetApproved("true")
				setOfferingPublishOptionsModel.SetPortalRecord("testString")
				setOfferingPublishOptionsModel.SetPortalURL("testString")
				setOfferingPublishOptionsModel.SetXApproverToken("testString")
				setOfferingPublishOptionsModel.SetXAuthToken("testString")
				setOfferingPublishOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(setOfferingPublishOptionsModel).ToNot(BeNil())
				Expect(setOfferingPublishOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(setOfferingPublishOptionsModel.OfferingID).To(Equal(core.StringPtr("testString")))
				Expect(setOfferingPublishOptionsModel.ApprovalType).To(Equal(core.StringPtr("pc_managed")))
				Expect(setOfferingPublishOptionsModel.Approved).To(Equal(core.StringPtr("true")))
				Expect(setOfferingPublishOptionsModel.PortalRecord).To(Equal(core.StringPtr("testString")))
				Expect(setOfferingPublishOptionsModel.PortalURL).To(Equal(core.StringPtr("testString")))
				Expect(setOfferingPublishOptionsModel.XApproverToken).To(Equal(core.StringPtr("testString")))
				Expect(setOfferingPublishOptionsModel.XAuthToken).To(Equal(core.StringPtr("testString")))
				Expect(setOfferingPublishOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewShareObjectOptions successfully`, func() {
				// Construct an instance of the ShareObjectOptions model
				catalogIdentifier := "testString"
				objectIdentifier := "testString"
				shareObjectOptionsModel := catalogManagementService.NewShareObjectOptions(catalogIdentifier, objectIdentifier)
				shareObjectOptionsModel.SetCatalogIdentifier("testString")
				shareObjectOptionsModel.SetObjectIdentifier("testString")
				shareObjectOptionsModel.SetIBM(true)
				shareObjectOptionsModel.SetPublic(true)
				shareObjectOptionsModel.SetEnabled(true)
				shareObjectOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(shareObjectOptionsModel).ToNot(BeNil())
				Expect(shareObjectOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(shareObjectOptionsModel.ObjectIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(shareObjectOptionsModel.IBM).To(Equal(core.BoolPtr(true)))
				Expect(shareObjectOptionsModel.Public).To(Equal(core.BoolPtr(true)))
				Expect(shareObjectOptionsModel.Enabled).To(Equal(core.BoolPtr(true)))
				Expect(shareObjectOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewShareOfferingOptions successfully`, func() {
				// Construct an instance of the ShareOfferingOptions model
				catalogIdentifier := "testString"
				offeringID := "testString"
				shareOfferingOptionsModel := catalogManagementService.NewShareOfferingOptions(catalogIdentifier, offeringID)
				shareOfferingOptionsModel.SetCatalogIdentifier("testString")
				shareOfferingOptionsModel.SetOfferingID("testString")
				shareOfferingOptionsModel.SetIBM(true)
				shareOfferingOptionsModel.SetPublic(true)
				shareOfferingOptionsModel.SetEnabled(true)
				shareOfferingOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(shareOfferingOptionsModel).ToNot(BeNil())
				Expect(shareOfferingOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(shareOfferingOptionsModel.OfferingID).To(Equal(core.StringPtr("testString")))
				Expect(shareOfferingOptionsModel.IBM).To(Equal(core.BoolPtr(true)))
				Expect(shareOfferingOptionsModel.Public).To(Equal(core.BoolPtr(true)))
				Expect(shareOfferingOptionsModel.Enabled).To(Equal(core.BoolPtr(true)))
				Expect(shareOfferingOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewSuspendVersionOptions successfully`, func() {
				// Construct an instance of the SuspendVersionOptions model
				versionLocID := "testString"
				suspendVersionOptionsModel := catalogManagementService.NewSuspendVersionOptions(versionLocID)
				suspendVersionOptionsModel.SetVersionLocID("testString")
				suspendVersionOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(suspendVersionOptionsModel).ToNot(BeNil())
				Expect(suspendVersionOptionsModel.VersionLocID).To(Equal(core.StringPtr("testString")))
				Expect(suspendVersionOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewTestVersionOptions successfully`, func() {
				// Construct an instance of the TestVersionOptions model
				versionLocID := "testString"
				testVersionOptionsModel := catalogManagementService.NewTestVersionOptions(versionLocID)
				testVersionOptionsModel.SetVersionLocID("testString")
				testVersionOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(testVersionOptionsModel).ToNot(BeNil())
				Expect(testVersionOptionsModel.VersionLocID).To(Equal(core.StringPtr("testString")))
				Expect(testVersionOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewUpdateCatalogAccountOptions successfully`, func() {
				// Construct an instance of the FilterTerms model
				filterTermsModel := new(catalogmanagementv1.FilterTerms)
				Expect(filterTermsModel).ToNot(BeNil())
				filterTermsModel.FilterTerms = []string{"testString"}
				Expect(filterTermsModel.FilterTerms).To(Equal([]string{"testString"}))

				// Construct an instance of the CategoryFilter model
				categoryFilterModel := new(catalogmanagementv1.CategoryFilter)
				Expect(categoryFilterModel).ToNot(BeNil())
				categoryFilterModel.Include = core.BoolPtr(true)
				categoryFilterModel.Filter = filterTermsModel
				Expect(categoryFilterModel.Include).To(Equal(core.BoolPtr(true)))
				Expect(categoryFilterModel.Filter).To(Equal(filterTermsModel))

				// Construct an instance of the IDFilter model
				idFilterModel := new(catalogmanagementv1.IDFilter)
				Expect(idFilterModel).ToNot(BeNil())
				idFilterModel.Include = filterTermsModel
				idFilterModel.Exclude = filterTermsModel
				Expect(idFilterModel.Include).To(Equal(filterTermsModel))
				Expect(idFilterModel.Exclude).To(Equal(filterTermsModel))

				// Construct an instance of the Filters model
				filtersModel := new(catalogmanagementv1.Filters)
				Expect(filtersModel).ToNot(BeNil())
				filtersModel.IncludeAll = core.BoolPtr(true)
				filtersModel.CategoryFilters = map[string]catalogmanagementv1.CategoryFilter{"key1": *categoryFilterModel}
				filtersModel.IDFilters = idFilterModel
				filtersModel.CategoryFilters["foo"] = *categoryFilterModel
				Expect(filtersModel.IncludeAll).To(Equal(core.BoolPtr(true)))
				Expect(filtersModel.IDFilters).To(Equal(idFilterModel))
				Expect(filtersModel.CategoryFilters["foo"]).To(Equal(*categoryFilterModel))

				// Construct an instance of the UpdateCatalogAccountOptions model
				updateCatalogAccountOptionsModel := catalogManagementService.NewUpdateCatalogAccountOptions()
				updateCatalogAccountOptionsModel.SetID("testString")
				updateCatalogAccountOptionsModel.SetRev("testString")
				updateCatalogAccountOptionsModel.SetHideIBMCloudCatalog(true)
				updateCatalogAccountOptionsModel.SetAccountFilters(filtersModel)
				updateCatalogAccountOptionsModel.SetRegionFilter("testString")
				updateCatalogAccountOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(updateCatalogAccountOptionsModel).ToNot(BeNil())
				Expect(updateCatalogAccountOptionsModel.ID).To(Equal(core.StringPtr("testString")))
				Expect(updateCatalogAccountOptionsModel.Rev).To(Equal(core.StringPtr("testString")))
				Expect(updateCatalogAccountOptionsModel.HideIBMCloudCatalog).To(Equal(core.BoolPtr(true)))
				Expect(updateCatalogAccountOptionsModel.AccountFilters).To(Equal(filtersModel))
				Expect(updateCatalogAccountOptionsModel.RegionFilter).To(Equal(core.StringPtr("testString")))
				Expect(updateCatalogAccountOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewUpdateOfferingOptions successfully`, func() {
				// Construct an instance of the JSONPatchOperation model
				jsonPatchOperationModel := new(catalogmanagementv1.JSONPatchOperation)
				Expect(jsonPatchOperationModel).ToNot(BeNil())
				jsonPatchOperationModel.Op = core.StringPtr("add")
				jsonPatchOperationModel.Path = core.StringPtr("testString")
				jsonPatchOperationModel.Value = "testString"
				jsonPatchOperationModel.From = core.StringPtr("testString")
				Expect(jsonPatchOperationModel.Op).To(Equal(core.StringPtr("add")))
				Expect(jsonPatchOperationModel.Path).To(Equal(core.StringPtr("testString")))
				Expect(jsonPatchOperationModel.Value).To(Equal("testString"))
				Expect(jsonPatchOperationModel.From).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the UpdateOfferingOptions model
				catalogIdentifier := "testString"
				offeringID := "testString"
				ifMatch := "testString"
				updateOfferingOptionsModel := catalogManagementService.NewUpdateOfferingOptions(catalogIdentifier, offeringID, ifMatch)
				updateOfferingOptionsModel.SetCatalogIdentifier("testString")
				updateOfferingOptionsModel.SetOfferingID("testString")
				updateOfferingOptionsModel.SetIfMatch("testString")
				updateOfferingOptionsModel.SetUpdates([]catalogmanagementv1.JSONPatchOperation{*jsonPatchOperationModel})
				updateOfferingOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(updateOfferingOptionsModel).ToNot(BeNil())
				Expect(updateOfferingOptionsModel.CatalogIdentifier).To(Equal(core.StringPtr("testString")))
				Expect(updateOfferingOptionsModel.OfferingID).To(Equal(core.StringPtr("testString")))
				Expect(updateOfferingOptionsModel.IfMatch).To(Equal(core.StringPtr("testString")))
				Expect(updateOfferingOptionsModel.Updates).To(Equal([]catalogmanagementv1.JSONPatchOperation{*jsonPatchOperationModel}))
				Expect(updateOfferingOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewUpdateShareApprovalListAsSourceOptions successfully`, func() {
				// Construct an instance of the UpdateShareApprovalListAsSourceOptions model
				objectType := "offering"
				approvalStateIdentifier := "approved"
				accesses := []string{"testString"}
				updateShareApprovalListAsSourceOptionsModel := catalogManagementService.NewUpdateShareApprovalListAsSourceOptions(objectType, approvalStateIdentifier, accesses)
				updateShareApprovalListAsSourceOptionsModel.SetObjectType("offering")
				updateShareApprovalListAsSourceOptionsModel.SetApprovalStateIdentifier("approved")
				updateShareApprovalListAsSourceOptionsModel.SetAccesses([]string{"testString"})
				updateShareApprovalListAsSourceOptionsModel.SetEnterpriseID("testString")
				updateShareApprovalListAsSourceOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(updateShareApprovalListAsSourceOptionsModel).ToNot(BeNil())
				Expect(updateShareApprovalListAsSourceOptionsModel.ObjectType).To(Equal(core.StringPtr("offering")))
				Expect(updateShareApprovalListAsSourceOptionsModel.ApprovalStateIdentifier).To(Equal(core.StringPtr("approved")))
				Expect(updateShareApprovalListAsSourceOptionsModel.Accesses).To(Equal([]string{"testString"}))
				Expect(updateShareApprovalListAsSourceOptionsModel.EnterpriseID).To(Equal(core.StringPtr("testString")))
				Expect(updateShareApprovalListAsSourceOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewUpdateVersionOptions successfully`, func() {
				// Construct an instance of the Rating model
				ratingModel := new(catalogmanagementv1.Rating)
				Expect(ratingModel).ToNot(BeNil())
				ratingModel.OneStarCount = core.Int64Ptr(int64(38))
				ratingModel.TwoStarCount = core.Int64Ptr(int64(38))
				ratingModel.ThreeStarCount = core.Int64Ptr(int64(38))
				ratingModel.FourStarCount = core.Int64Ptr(int64(38))
				Expect(ratingModel.OneStarCount).To(Equal(core.Int64Ptr(int64(38))))
				Expect(ratingModel.TwoStarCount).To(Equal(core.Int64Ptr(int64(38))))
				Expect(ratingModel.ThreeStarCount).To(Equal(core.Int64Ptr(int64(38))))
				Expect(ratingModel.FourStarCount).To(Equal(core.Int64Ptr(int64(38))))

				// Construct an instance of the Feature model
				featureModel := new(catalogmanagementv1.Feature)
				Expect(featureModel).ToNot(BeNil())
				featureModel.Title = core.StringPtr("testString")
				featureModel.TitleI18n = map[string]string{"key1": "testString"}
				featureModel.Description = core.StringPtr("testString")
				featureModel.DescriptionI18n = map[string]string{"key1": "testString"}
				Expect(featureModel.Title).To(Equal(core.StringPtr("testString")))
				Expect(featureModel.TitleI18n).To(Equal(map[string]string{"key1": "testString"}))
				Expect(featureModel.Description).To(Equal(core.StringPtr("testString")))
				Expect(featureModel.DescriptionI18n).To(Equal(map[string]string{"key1": "testString"}))

				// Construct an instance of the Flavor model
				flavorModel := new(catalogmanagementv1.Flavor)
				Expect(flavorModel).ToNot(BeNil())
				flavorModel.Name = core.StringPtr("testString")
				flavorModel.Label = core.StringPtr("testString")
				flavorModel.LabelI18n = map[string]string{"key1": "testString"}
				flavorModel.Index = core.Int64Ptr(int64(38))
				Expect(flavorModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(flavorModel.Label).To(Equal(core.StringPtr("testString")))
				Expect(flavorModel.LabelI18n).To(Equal(map[string]string{"key1": "testString"}))
				Expect(flavorModel.Index).To(Equal(core.Int64Ptr(int64(38))))

				// Construct an instance of the RenderTypeAssociationsParametersItem model
				renderTypeAssociationsParametersItemModel := new(catalogmanagementv1.RenderTypeAssociationsParametersItem)
				Expect(renderTypeAssociationsParametersItemModel).ToNot(BeNil())
				renderTypeAssociationsParametersItemModel.Name = core.StringPtr("testString")
				renderTypeAssociationsParametersItemModel.OptionsRefresh = core.BoolPtr(true)
				Expect(renderTypeAssociationsParametersItemModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(renderTypeAssociationsParametersItemModel.OptionsRefresh).To(Equal(core.BoolPtr(true)))

				// Construct an instance of the RenderTypeAssociations model
				renderTypeAssociationsModel := new(catalogmanagementv1.RenderTypeAssociations)
				Expect(renderTypeAssociationsModel).ToNot(BeNil())
				renderTypeAssociationsModel.Parameters = []catalogmanagementv1.RenderTypeAssociationsParametersItem{*renderTypeAssociationsParametersItemModel}
				Expect(renderTypeAssociationsModel.Parameters).To(Equal([]catalogmanagementv1.RenderTypeAssociationsParametersItem{*renderTypeAssociationsParametersItemModel}))

				// Construct an instance of the RenderType model
				renderTypeModel := new(catalogmanagementv1.RenderType)
				Expect(renderTypeModel).ToNot(BeNil())
				renderTypeModel.Type = core.StringPtr("testString")
				renderTypeModel.Grouping = core.StringPtr("testString")
				renderTypeModel.OriginalGrouping = core.StringPtr("testString")
				renderTypeModel.GroupingIndex = core.Int64Ptr(int64(38))
				renderTypeModel.ConfigConstraints = map[string]interface{}{"anyKey": "anyValue"}
				renderTypeModel.Associations = renderTypeAssociationsModel
				Expect(renderTypeModel.Type).To(Equal(core.StringPtr("testString")))
				Expect(renderTypeModel.Grouping).To(Equal(core.StringPtr("testString")))
				Expect(renderTypeModel.OriginalGrouping).To(Equal(core.StringPtr("testString")))
				Expect(renderTypeModel.GroupingIndex).To(Equal(core.Int64Ptr(int64(38))))
				Expect(renderTypeModel.ConfigConstraints).To(Equal(map[string]interface{}{"anyKey": "anyValue"}))
				Expect(renderTypeModel.Associations).To(Equal(renderTypeAssociationsModel))

				// Construct an instance of the Configuration model
				configurationModel := new(catalogmanagementv1.Configuration)
				Expect(configurationModel).ToNot(BeNil())
				configurationModel.Key = core.StringPtr("testString")
				configurationModel.Type = core.StringPtr("testString")
				configurationModel.DefaultValue = "testString"
				configurationModel.DisplayName = core.StringPtr("testString")
				configurationModel.ValueConstraint = core.StringPtr("testString")
				configurationModel.Description = core.StringPtr("testString")
				configurationModel.Required = core.BoolPtr(true)
				configurationModel.Options = []interface{}{"testString"}
				configurationModel.Hidden = core.BoolPtr(true)
				configurationModel.CustomConfig = renderTypeModel
				configurationModel.TypeMetadata = core.StringPtr("testString")
				Expect(configurationModel.Key).To(Equal(core.StringPtr("testString")))
				Expect(configurationModel.Type).To(Equal(core.StringPtr("testString")))
				Expect(configurationModel.DefaultValue).To(Equal("testString"))
				Expect(configurationModel.DisplayName).To(Equal(core.StringPtr("testString")))
				Expect(configurationModel.ValueConstraint).To(Equal(core.StringPtr("testString")))
				Expect(configurationModel.Description).To(Equal(core.StringPtr("testString")))
				Expect(configurationModel.Required).To(Equal(core.BoolPtr(true)))
				Expect(configurationModel.Options).To(Equal([]interface{}{"testString"}))
				Expect(configurationModel.Hidden).To(Equal(core.BoolPtr(true)))
				Expect(configurationModel.CustomConfig).To(Equal(renderTypeModel))
				Expect(configurationModel.TypeMetadata).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the Output model
				outputModel := new(catalogmanagementv1.Output)
				Expect(outputModel).ToNot(BeNil())
				outputModel.Key = core.StringPtr("testString")
				outputModel.Description = core.StringPtr("testString")
				Expect(outputModel.Key).To(Equal(core.StringPtr("testString")))
				Expect(outputModel.Description).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the IamResource model
				iamResourceModel := new(catalogmanagementv1.IamResource)
				Expect(iamResourceModel).ToNot(BeNil())
				iamResourceModel.Name = core.StringPtr("testString")
				iamResourceModel.Description = core.StringPtr("testString")
				iamResourceModel.RoleCrns = []string{"testString"}
				Expect(iamResourceModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(iamResourceModel.Description).To(Equal(core.StringPtr("testString")))
				Expect(iamResourceModel.RoleCrns).To(Equal([]string{"testString"}))

				// Construct an instance of the IamPermission model
				iamPermissionModel := new(catalogmanagementv1.IamPermission)
				Expect(iamPermissionModel).ToNot(BeNil())
				iamPermissionModel.ServiceName = core.StringPtr("testString")
				iamPermissionModel.RoleCrns = []string{"testString"}
				iamPermissionModel.Resources = []catalogmanagementv1.IamResource{*iamResourceModel}
				Expect(iamPermissionModel.ServiceName).To(Equal(core.StringPtr("testString")))
				Expect(iamPermissionModel.RoleCrns).To(Equal([]string{"testString"}))
				Expect(iamPermissionModel.Resources).To(Equal([]catalogmanagementv1.IamResource{*iamResourceModel}))

				// Construct an instance of the Validation model
				validationModel := new(catalogmanagementv1.Validation)
				Expect(validationModel).ToNot(BeNil())
				validationModel.Validated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				validationModel.Requested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				validationModel.State = core.StringPtr("testString")
				validationModel.LastOperation = core.StringPtr("testString")
				validationModel.Target = map[string]interface{}{"anyKey": "anyValue"}
				validationModel.Message = core.StringPtr("testString")
				Expect(validationModel.Validated).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(validationModel.Requested).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(validationModel.State).To(Equal(core.StringPtr("testString")))
				Expect(validationModel.LastOperation).To(Equal(core.StringPtr("testString")))
				Expect(validationModel.Target).To(Equal(map[string]interface{}{"anyKey": "anyValue"}))
				Expect(validationModel.Message).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the Resource model
				resourceModel := new(catalogmanagementv1.Resource)
				Expect(resourceModel).ToNot(BeNil())
				resourceModel.Type = core.StringPtr("mem")
				resourceModel.Value = "testString"
				Expect(resourceModel.Type).To(Equal(core.StringPtr("mem")))
				Expect(resourceModel.Value).To(Equal("testString"))

				// Construct an instance of the SchematicsEnvValues model
				schematicsEnvValuesModel := new(catalogmanagementv1.SchematicsEnvValues)
				Expect(schematicsEnvValuesModel).ToNot(BeNil())
				schematicsEnvValuesModel.Value = core.StringPtr("[{\"name\": \"TF_LOG\",\"value\": \"TRACE\",\"secure\": false,\"hidden\": false}]")
				schematicsEnvValuesModel.SmRef = core.StringPtr("cmsm_v1:{\"name\": \"envVarSecret\",\"id\":\"1234567890\",\"service_id\":\"crn:v1:bluemix:public:secrets-manager:eu-gb:a/1234567890:1234567890::\",\"service_name\":\"My SM Instance\",\"group_id\":\"1234567890\",\"group_name\":\"My SM Group\",\"resource_group_id\":\"1234567890\",\"region\":\"eu-gb\",\"type\":\"arbitrary\"}")
				Expect(schematicsEnvValuesModel.Value).To(Equal(core.StringPtr("[{\"name\": \"TF_LOG\",\"value\": \"TRACE\",\"secure\": false,\"hidden\": false}]")))
				Expect(schematicsEnvValuesModel.SmRef).To(Equal(core.StringPtr("cmsm_v1:{\"name\": \"envVarSecret\",\"id\":\"1234567890\",\"service_id\":\"crn:v1:bluemix:public:secrets-manager:eu-gb:a/1234567890:1234567890::\",\"service_name\":\"My SM Instance\",\"group_id\":\"1234567890\",\"group_name\":\"My SM Group\",\"resource_group_id\":\"1234567890\",\"region\":\"eu-gb\",\"type\":\"arbitrary\"}")))

				// Construct an instance of the Script model
				scriptModel := new(catalogmanagementv1.Script)
				Expect(scriptModel).ToNot(BeNil())
				scriptModel.Instructions = core.StringPtr("testString")
				scriptModel.InstructionsI18n = map[string]string{"key1": "testString"}
				scriptModel.Script = core.StringPtr("testString")
				scriptModel.ScriptPermission = core.StringPtr("testString")
				scriptModel.DeleteScript = core.StringPtr("testString")
				scriptModel.Scope = core.StringPtr("testString")
				Expect(scriptModel.Instructions).To(Equal(core.StringPtr("testString")))
				Expect(scriptModel.InstructionsI18n).To(Equal(map[string]string{"key1": "testString"}))
				Expect(scriptModel.Script).To(Equal(core.StringPtr("testString")))
				Expect(scriptModel.ScriptPermission).To(Equal(core.StringPtr("testString")))
				Expect(scriptModel.DeleteScript).To(Equal(core.StringPtr("testString")))
				Expect(scriptModel.Scope).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the ScriptRef model
				scriptRefModel := new(catalogmanagementv1.ScriptRef)
				Expect(scriptRefModel).ToNot(BeNil())
				scriptRefModel.ShortDescription = core.StringPtr("testString")
				scriptRefModel.Type = core.StringPtr("ansible")
				scriptRefModel.Path = core.StringPtr("scripts/validate-post-ansible-playbook.yaml")
				scriptRefModel.Stage = core.StringPtr("pre")
				scriptRefModel.Action = core.StringPtr("validate")
				Expect(scriptRefModel.ShortDescription).To(Equal(core.StringPtr("testString")))
				Expect(scriptRefModel.Type).To(Equal(core.StringPtr("ansible")))
				Expect(scriptRefModel.Path).To(Equal(core.StringPtr("scripts/validate-post-ansible-playbook.yaml")))
				Expect(scriptRefModel.Stage).To(Equal(core.StringPtr("pre")))
				Expect(scriptRefModel.Action).To(Equal(core.StringPtr("validate")))

				// Construct an instance of the VersionEntitlement model
				versionEntitlementModel := new(catalogmanagementv1.VersionEntitlement)
				Expect(versionEntitlementModel).ToNot(BeNil())
				versionEntitlementModel.ProviderName = core.StringPtr("testString")
				versionEntitlementModel.ProviderID = core.StringPtr("testString")
				versionEntitlementModel.ProductID = core.StringPtr("testString")
				versionEntitlementModel.PartNumbers = []string{"testString"}
				versionEntitlementModel.ImageRepoName = core.StringPtr("testString")
				Expect(versionEntitlementModel.ProviderName).To(Equal(core.StringPtr("testString")))
				Expect(versionEntitlementModel.ProviderID).To(Equal(core.StringPtr("testString")))
				Expect(versionEntitlementModel.ProductID).To(Equal(core.StringPtr("testString")))
				Expect(versionEntitlementModel.PartNumbers).To(Equal([]string{"testString"}))
				Expect(versionEntitlementModel.ImageRepoName).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the License model
				licenseModel := new(catalogmanagementv1.License)
				Expect(licenseModel).ToNot(BeNil())
				licenseModel.ID = core.StringPtr("testString")
				licenseModel.Name = core.StringPtr("testString")
				licenseModel.Type = core.StringPtr("testString")
				licenseModel.URL = core.StringPtr("testString")
				licenseModel.Description = core.StringPtr("testString")
				Expect(licenseModel.ID).To(Equal(core.StringPtr("testString")))
				Expect(licenseModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(licenseModel.Type).To(Equal(core.StringPtr("testString")))
				Expect(licenseModel.URL).To(Equal(core.StringPtr("testString")))
				Expect(licenseModel.Description).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the State model
				stateModel := new(catalogmanagementv1.State)
				Expect(stateModel).ToNot(BeNil())
				stateModel.Current = core.StringPtr("testString")
				stateModel.CurrentEntered = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Pending = core.StringPtr("testString")
				stateModel.PendingRequested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				stateModel.Previous = core.StringPtr("testString")
				Expect(stateModel.Current).To(Equal(core.StringPtr("testString")))
				Expect(stateModel.CurrentEntered).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(stateModel.Pending).To(Equal(core.StringPtr("testString")))
				Expect(stateModel.PendingRequested).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(stateModel.Previous).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the DeprecatePending model
				deprecatePendingModel := new(catalogmanagementv1.DeprecatePending)
				Expect(deprecatePendingModel).ToNot(BeNil())
				deprecatePendingModel.DeprecateDate = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				deprecatePendingModel.DeprecateState = core.StringPtr("testString")
				deprecatePendingModel.Description = core.StringPtr("testString")
				Expect(deprecatePendingModel.DeprecateDate).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(deprecatePendingModel.DeprecateState).To(Equal(core.StringPtr("testString")))
				Expect(deprecatePendingModel.Description).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the URLProxy model
				urlProxyModel := new(catalogmanagementv1.URLProxy)
				Expect(urlProxyModel).ToNot(BeNil())
				urlProxyModel.URL = core.StringPtr("testString")
				urlProxyModel.Sha = core.StringPtr("testString")
				Expect(urlProxyModel.URL).To(Equal(core.StringPtr("testString")))
				Expect(urlProxyModel.Sha).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the MediaItem model
				mediaItemModel := new(catalogmanagementv1.MediaItem)
				Expect(mediaItemModel).ToNot(BeNil())
				mediaItemModel.URL = core.StringPtr("testString")
				mediaItemModel.APIURL = core.StringPtr("testString")
				mediaItemModel.URLProxy = urlProxyModel
				mediaItemModel.Caption = core.StringPtr("testString")
				mediaItemModel.CaptionI18n = map[string]string{"key1": "testString"}
				mediaItemModel.Type = core.StringPtr("testString")
				mediaItemModel.ThumbnailURL = core.StringPtr("testString")
				Expect(mediaItemModel.URL).To(Equal(core.StringPtr("testString")))
				Expect(mediaItemModel.APIURL).To(Equal(core.StringPtr("testString")))
				Expect(mediaItemModel.URLProxy).To(Equal(urlProxyModel))
				Expect(mediaItemModel.Caption).To(Equal(core.StringPtr("testString")))
				Expect(mediaItemModel.CaptionI18n).To(Equal(map[string]string{"key1": "testString"}))
				Expect(mediaItemModel.Type).To(Equal(core.StringPtr("testString")))
				Expect(mediaItemModel.ThumbnailURL).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the ArchitectureDiagram model
				architectureDiagramModel := new(catalogmanagementv1.ArchitectureDiagram)
				Expect(architectureDiagramModel).ToNot(BeNil())
				architectureDiagramModel.Diagram = mediaItemModel
				architectureDiagramModel.Description = core.StringPtr("testString")
				architectureDiagramModel.DescriptionI18n = map[string]string{"key1": "testString"}
				Expect(architectureDiagramModel.Diagram).To(Equal(mediaItemModel))
				Expect(architectureDiagramModel.Description).To(Equal(core.StringPtr("testString")))
				Expect(architectureDiagramModel.DescriptionI18n).To(Equal(map[string]string{"key1": "testString"}))

				// Construct an instance of the CostComponent model
				costComponentModel := new(catalogmanagementv1.CostComponent)
				Expect(costComponentModel).ToNot(BeNil())
				costComponentModel.Name = core.StringPtr("testString")
				costComponentModel.Unit = core.StringPtr("testString")
				costComponentModel.HourlyQuantity = core.StringPtr("testString")
				costComponentModel.MonthlyQuantity = core.StringPtr("testString")
				costComponentModel.Price = core.StringPtr("testString")
				costComponentModel.HourlyCost = core.StringPtr("testString")
				costComponentModel.MonthlyCost = core.StringPtr("testString")
				Expect(costComponentModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(costComponentModel.Unit).To(Equal(core.StringPtr("testString")))
				Expect(costComponentModel.HourlyQuantity).To(Equal(core.StringPtr("testString")))
				Expect(costComponentModel.MonthlyQuantity).To(Equal(core.StringPtr("testString")))
				Expect(costComponentModel.Price).To(Equal(core.StringPtr("testString")))
				Expect(costComponentModel.HourlyCost).To(Equal(core.StringPtr("testString")))
				Expect(costComponentModel.MonthlyCost).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the CostResource model
				costResourceModel := new(catalogmanagementv1.CostResource)
				Expect(costResourceModel).ToNot(BeNil())
				costResourceModel.Name = core.StringPtr("testString")
				costResourceModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				costResourceModel.HourlyCost = core.StringPtr("testString")
				costResourceModel.MonthlyCost = core.StringPtr("testString")
				costResourceModel.CostComponents = []catalogmanagementv1.CostComponent{*costComponentModel}
				Expect(costResourceModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(costResourceModel.Metadata).To(Equal(map[string]interface{}{"anyKey": "anyValue"}))
				Expect(costResourceModel.HourlyCost).To(Equal(core.StringPtr("testString")))
				Expect(costResourceModel.MonthlyCost).To(Equal(core.StringPtr("testString")))
				Expect(costResourceModel.CostComponents).To(Equal([]catalogmanagementv1.CostComponent{*costComponentModel}))

				// Construct an instance of the CostBreakdown model
				costBreakdownModel := new(catalogmanagementv1.CostBreakdown)
				Expect(costBreakdownModel).ToNot(BeNil())
				costBreakdownModel.TotalHourlyCost = core.StringPtr("testString")
				costBreakdownModel.TotalMonthlyCost = core.StringPtr("testString")
				costBreakdownModel.Resources = []catalogmanagementv1.CostResource{*costResourceModel}
				Expect(costBreakdownModel.TotalHourlyCost).To(Equal(core.StringPtr("testString")))
				Expect(costBreakdownModel.TotalMonthlyCost).To(Equal(core.StringPtr("testString")))
				Expect(costBreakdownModel.Resources).To(Equal([]catalogmanagementv1.CostResource{*costResourceModel}))

				// Construct an instance of the CostSummary model
				costSummaryModel := new(catalogmanagementv1.CostSummary)
				Expect(costSummaryModel).ToNot(BeNil())
				costSummaryModel.TotalDetectedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalSupportedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalUnsupportedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalUsageBasedResources = core.Int64Ptr(int64(38))
				costSummaryModel.TotalNoPriceResources = core.Int64Ptr(int64(38))
				costSummaryModel.UnsupportedResourceCounts = map[string]int64{"key1": int64(38)}
				costSummaryModel.NoPriceResourceCounts = map[string]int64{"key1": int64(38)}
				Expect(costSummaryModel.TotalDetectedResources).To(Equal(core.Int64Ptr(int64(38))))
				Expect(costSummaryModel.TotalSupportedResources).To(Equal(core.Int64Ptr(int64(38))))
				Expect(costSummaryModel.TotalUnsupportedResources).To(Equal(core.Int64Ptr(int64(38))))
				Expect(costSummaryModel.TotalUsageBasedResources).To(Equal(core.Int64Ptr(int64(38))))
				Expect(costSummaryModel.TotalNoPriceResources).To(Equal(core.Int64Ptr(int64(38))))
				Expect(costSummaryModel.UnsupportedResourceCounts).To(Equal(map[string]int64{"key1": int64(38)}))
				Expect(costSummaryModel.NoPriceResourceCounts).To(Equal(map[string]int64{"key1": int64(38)}))

				// Construct an instance of the Project model
				projectModel := new(catalogmanagementv1.Project)
				Expect(projectModel).ToNot(BeNil())
				projectModel.Name = core.StringPtr("testString")
				projectModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				projectModel.PastBreakdown = costBreakdownModel
				projectModel.Breakdown = costBreakdownModel
				projectModel.Diff = costBreakdownModel
				projectModel.Summary = costSummaryModel
				Expect(projectModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(projectModel.Metadata).To(Equal(map[string]interface{}{"anyKey": "anyValue"}))
				Expect(projectModel.PastBreakdown).To(Equal(costBreakdownModel))
				Expect(projectModel.Breakdown).To(Equal(costBreakdownModel))
				Expect(projectModel.Diff).To(Equal(costBreakdownModel))
				Expect(projectModel.Summary).To(Equal(costSummaryModel))

				// Construct an instance of the CostEstimate model
				costEstimateModel := new(catalogmanagementv1.CostEstimate)
				Expect(costEstimateModel).ToNot(BeNil())
				costEstimateModel.Version = core.StringPtr("testString")
				costEstimateModel.Currency = core.StringPtr("testString")
				costEstimateModel.Projects = []catalogmanagementv1.Project{*projectModel}
				costEstimateModel.Summary = costSummaryModel
				costEstimateModel.TotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.TotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.PastTotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.PastTotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.DiffTotalHourlyCost = core.StringPtr("testString")
				costEstimateModel.DiffTotalMonthlyCost = core.StringPtr("testString")
				costEstimateModel.TimeGenerated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				Expect(costEstimateModel.Version).To(Equal(core.StringPtr("testString")))
				Expect(costEstimateModel.Currency).To(Equal(core.StringPtr("testString")))
				Expect(costEstimateModel.Projects).To(Equal([]catalogmanagementv1.Project{*projectModel}))
				Expect(costEstimateModel.Summary).To(Equal(costSummaryModel))
				Expect(costEstimateModel.TotalHourlyCost).To(Equal(core.StringPtr("testString")))
				Expect(costEstimateModel.TotalMonthlyCost).To(Equal(core.StringPtr("testString")))
				Expect(costEstimateModel.PastTotalHourlyCost).To(Equal(core.StringPtr("testString")))
				Expect(costEstimateModel.PastTotalMonthlyCost).To(Equal(core.StringPtr("testString")))
				Expect(costEstimateModel.DiffTotalHourlyCost).To(Equal(core.StringPtr("testString")))
				Expect(costEstimateModel.DiffTotalMonthlyCost).To(Equal(core.StringPtr("testString")))
				Expect(costEstimateModel.TimeGenerated).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))

				// Construct an instance of the OfferingReference model
				offeringReferenceModel := new(catalogmanagementv1.OfferingReference)
				Expect(offeringReferenceModel).ToNot(BeNil())
				offeringReferenceModel.CatalogID = core.StringPtr("testString")
				offeringReferenceModel.ID = core.StringPtr("testString")
				offeringReferenceModel.Name = core.StringPtr("testString")
				offeringReferenceModel.Kind = core.StringPtr("testString")
				offeringReferenceModel.Version = core.StringPtr("testString")
				offeringReferenceModel.Description = core.StringPtr("testString")
				offeringReferenceModel.DefaultFlavor = core.StringPtr("testString")
				offeringReferenceModel.Flavors = []string{"testString"}
				offeringReferenceModel.Optional = core.BoolPtr(true)
				offeringReferenceModel.OnByDefault = core.BoolPtr(true)
				Expect(offeringReferenceModel.CatalogID).To(Equal(core.StringPtr("testString")))
				Expect(offeringReferenceModel.ID).To(Equal(core.StringPtr("testString")))
				Expect(offeringReferenceModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(offeringReferenceModel.Kind).To(Equal(core.StringPtr("testString")))
				Expect(offeringReferenceModel.Version).To(Equal(core.StringPtr("testString")))
				Expect(offeringReferenceModel.Description).To(Equal(core.StringPtr("testString")))
				Expect(offeringReferenceModel.DefaultFlavor).To(Equal(core.StringPtr("testString")))
				Expect(offeringReferenceModel.Flavors).To(Equal([]string{"testString"}))
				Expect(offeringReferenceModel.Optional).To(Equal(core.BoolPtr(true)))
				Expect(offeringReferenceModel.OnByDefault).To(Equal(core.BoolPtr(true)))

				// Construct an instance of the SolutionInfo model
				solutionInfoModel := new(catalogmanagementv1.SolutionInfo)
				Expect(solutionInfoModel).ToNot(BeNil())
				solutionInfoModel.ArchitectureDiagrams = []catalogmanagementv1.ArchitectureDiagram{*architectureDiagramModel}
				solutionInfoModel.Features = []catalogmanagementv1.Feature{*featureModel}
				solutionInfoModel.CostEstimate = costEstimateModel
				solutionInfoModel.Dependencies = []catalogmanagementv1.OfferingReference{*offeringReferenceModel}
				solutionInfoModel.InstallType = core.StringPtr("testString")
				Expect(solutionInfoModel.ArchitectureDiagrams).To(Equal([]catalogmanagementv1.ArchitectureDiagram{*architectureDiagramModel}))
				Expect(solutionInfoModel.Features).To(Equal([]catalogmanagementv1.Feature{*featureModel}))
				Expect(solutionInfoModel.CostEstimate).To(Equal(costEstimateModel))
				Expect(solutionInfoModel.Dependencies).To(Equal([]catalogmanagementv1.OfferingReference{*offeringReferenceModel}))
				Expect(solutionInfoModel.InstallType).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the SccProfile model
				sccProfileModel := new(catalogmanagementv1.SccProfile)
				Expect(sccProfileModel).ToNot(BeNil())
				sccProfileModel.ID = core.StringPtr("testString")
				sccProfileModel.Name = core.StringPtr("testString")
				sccProfileModel.Version = core.StringPtr("testString")
				sccProfileModel.Description = core.StringPtr("testString")
				sccProfileModel.Type = core.StringPtr("testString")
				sccProfileModel.UIHref = core.StringPtr("testString")
				Expect(sccProfileModel.ID).To(Equal(core.StringPtr("testString")))
				Expect(sccProfileModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(sccProfileModel.Version).To(Equal(core.StringPtr("testString")))
				Expect(sccProfileModel.Description).To(Equal(core.StringPtr("testString")))
				Expect(sccProfileModel.Type).To(Equal(core.StringPtr("testString")))
				Expect(sccProfileModel.UIHref).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the ClaimedControl model
				claimedControlModel := new(catalogmanagementv1.ClaimedControl)
				Expect(claimedControlModel).ToNot(BeNil())
				claimedControlModel.Profile = sccProfileModel
				claimedControlModel.Names = []string{"testString"}
				Expect(claimedControlModel.Profile).To(Equal(sccProfileModel))
				Expect(claimedControlModel.Names).To(Equal([]string{"testString"}))

				// Construct an instance of the Claims model
				claimsModel := new(catalogmanagementv1.Claims)
				Expect(claimsModel).ToNot(BeNil())
				claimsModel.Profiles = []catalogmanagementv1.SccProfile{*sccProfileModel}
				claimsModel.Controls = []catalogmanagementv1.ClaimedControl{*claimedControlModel}
				Expect(claimsModel.Profiles).To(Equal([]catalogmanagementv1.SccProfile{*sccProfileModel}))
				Expect(claimsModel.Controls).To(Equal([]catalogmanagementv1.ClaimedControl{*claimedControlModel}))

				// Construct an instance of the Result model
				resultModel := new(catalogmanagementv1.Result)
				Expect(resultModel).ToNot(BeNil())
				resultModel.FailureCount = core.Int64Ptr(int64(38))
				resultModel.ScanTime = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				resultModel.ErrorMessage = core.StringPtr("testString")
				resultModel.CompleteScan = core.BoolPtr(true)
				resultModel.UnscannedResources = []string{"testString"}
				Expect(resultModel.FailureCount).To(Equal(core.Int64Ptr(int64(38))))
				Expect(resultModel.ScanTime).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(resultModel.ErrorMessage).To(Equal(core.StringPtr("testString")))
				Expect(resultModel.CompleteScan).To(Equal(core.BoolPtr(true)))
				Expect(resultModel.UnscannedResources).To(Equal([]string{"testString"}))

				// Construct an instance of the SccAssessment model
				sccAssessmentModel := new(catalogmanagementv1.SccAssessment)
				Expect(sccAssessmentModel).ToNot(BeNil())
				sccAssessmentModel.ID = core.StringPtr("testString")
				sccAssessmentModel.Description = core.StringPtr("testString")
				sccAssessmentModel.Version = core.StringPtr("testString")
				sccAssessmentModel.Type = core.StringPtr("testString")
				sccAssessmentModel.Method = core.StringPtr("testString")
				sccAssessmentModel.UIHref = core.StringPtr("testString")
				Expect(sccAssessmentModel.ID).To(Equal(core.StringPtr("testString")))
				Expect(sccAssessmentModel.Description).To(Equal(core.StringPtr("testString")))
				Expect(sccAssessmentModel.Version).To(Equal(core.StringPtr("testString")))
				Expect(sccAssessmentModel.Type).To(Equal(core.StringPtr("testString")))
				Expect(sccAssessmentModel.Method).To(Equal(core.StringPtr("testString")))
				Expect(sccAssessmentModel.UIHref).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the SccSpecification model
				sccSpecificationModel := new(catalogmanagementv1.SccSpecification)
				Expect(sccSpecificationModel).ToNot(BeNil())
				sccSpecificationModel.ID = core.StringPtr("testString")
				sccSpecificationModel.Description = core.StringPtr("testString")
				sccSpecificationModel.ComponentName = core.StringPtr("testString")
				sccSpecificationModel.Assessments = []catalogmanagementv1.SccAssessment{*sccAssessmentModel}
				sccSpecificationModel.UIHref = core.StringPtr("testString")
				Expect(sccSpecificationModel.ID).To(Equal(core.StringPtr("testString")))
				Expect(sccSpecificationModel.Description).To(Equal(core.StringPtr("testString")))
				Expect(sccSpecificationModel.ComponentName).To(Equal(core.StringPtr("testString")))
				Expect(sccSpecificationModel.Assessments).To(Equal([]catalogmanagementv1.SccAssessment{*sccAssessmentModel}))
				Expect(sccSpecificationModel.UIHref).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the SccControl model
				sccControlModel := new(catalogmanagementv1.SccControl)
				Expect(sccControlModel).ToNot(BeNil())
				sccControlModel.ID = core.StringPtr("testString")
				sccControlModel.Name = core.StringPtr("testString")
				sccControlModel.Version = core.StringPtr("testString")
				sccControlModel.Description = core.StringPtr("testString")
				sccControlModel.Profile = sccProfileModel
				sccControlModel.ParentName = core.StringPtr("testString")
				sccControlModel.Specifications = []catalogmanagementv1.SccSpecification{*sccSpecificationModel}
				sccControlModel.UIHref = core.StringPtr("testString")
				Expect(sccControlModel.ID).To(Equal(core.StringPtr("testString")))
				Expect(sccControlModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(sccControlModel.Version).To(Equal(core.StringPtr("testString")))
				Expect(sccControlModel.Description).To(Equal(core.StringPtr("testString")))
				Expect(sccControlModel.Profile).To(Equal(sccProfileModel))
				Expect(sccControlModel.ParentName).To(Equal(core.StringPtr("testString")))
				Expect(sccControlModel.Specifications).To(Equal([]catalogmanagementv1.SccSpecification{*sccSpecificationModel}))
				Expect(sccControlModel.UIHref).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the EvaluatedControl model
				evaluatedControlModel := new(catalogmanagementv1.EvaluatedControl)
				Expect(evaluatedControlModel).ToNot(BeNil())
				evaluatedControlModel.ID = core.StringPtr("testString")
				evaluatedControlModel.Name = core.StringPtr("testString")
				evaluatedControlModel.Description = core.StringPtr("testString")
				evaluatedControlModel.Specifications = []catalogmanagementv1.SccSpecification{*sccSpecificationModel}
				evaluatedControlModel.FailureCount = core.Int64Ptr(int64(38))
				evaluatedControlModel.PassCount = core.Int64Ptr(int64(38))
				evaluatedControlModel.Parent = sccControlModel
				evaluatedControlModel.UIHref = core.StringPtr("testString")
				Expect(evaluatedControlModel.ID).To(Equal(core.StringPtr("testString")))
				Expect(evaluatedControlModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(evaluatedControlModel.Description).To(Equal(core.StringPtr("testString")))
				Expect(evaluatedControlModel.Specifications).To(Equal([]catalogmanagementv1.SccSpecification{*sccSpecificationModel}))
				Expect(evaluatedControlModel.FailureCount).To(Equal(core.Int64Ptr(int64(38))))
				Expect(evaluatedControlModel.PassCount).To(Equal(core.Int64Ptr(int64(38))))
				Expect(evaluatedControlModel.Parent).To(Equal(sccControlModel))
				Expect(evaluatedControlModel.UIHref).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the Evaluation model
				evaluationModel := new(catalogmanagementv1.Evaluation)
				Expect(evaluationModel).ToNot(BeNil())
				evaluationModel.ScanID = core.StringPtr("testString")
				evaluationModel.AccountID = core.StringPtr("testString")
				evaluationModel.Profile = sccProfileModel
				evaluationModel.Result = resultModel
				evaluationModel.Controls = []catalogmanagementv1.EvaluatedControl{*evaluatedControlModel}
				Expect(evaluationModel.ScanID).To(Equal(core.StringPtr("testString")))
				Expect(evaluationModel.AccountID).To(Equal(core.StringPtr("testString")))
				Expect(evaluationModel.Profile).To(Equal(sccProfileModel))
				Expect(evaluationModel.Result).To(Equal(resultModel))
				Expect(evaluationModel.Controls).To(Equal([]catalogmanagementv1.EvaluatedControl{*evaluatedControlModel}))

				// Construct an instance of the Compliance model
				complianceModel := new(catalogmanagementv1.Compliance)
				Expect(complianceModel).ToNot(BeNil())
				complianceModel.Authority = core.StringPtr("testString")
				complianceModel.Claims = claimsModel
				complianceModel.Evaluations = []catalogmanagementv1.Evaluation{*evaluationModel}
				Expect(complianceModel.Authority).To(Equal(core.StringPtr("testString")))
				Expect(complianceModel.Claims).To(Equal(claimsModel))
				Expect(complianceModel.Evaluations).To(Equal([]catalogmanagementv1.Evaluation{*evaluationModel}))

				// Construct an instance of the ChangeNotices model
				changeNoticesModel := new(catalogmanagementv1.ChangeNotices)
				Expect(changeNoticesModel).ToNot(BeNil())
				changeNoticesModel.Breaking = []catalogmanagementv1.Feature{*featureModel}
				changeNoticesModel.New = []catalogmanagementv1.Feature{*featureModel}
				changeNoticesModel.Update = []catalogmanagementv1.Feature{*featureModel}
				Expect(changeNoticesModel.Breaking).To(Equal([]catalogmanagementv1.Feature{*featureModel}))
				Expect(changeNoticesModel.New).To(Equal([]catalogmanagementv1.Feature{*featureModel}))
				Expect(changeNoticesModel.Update).To(Equal([]catalogmanagementv1.Feature{*featureModel}))

				// Construct an instance of the Version model
				versionModel := new(catalogmanagementv1.Version)
				Expect(versionModel).ToNot(BeNil())
				versionModel.CRN = core.StringPtr("testString")
				versionModel.Version = core.StringPtr("testString")
				versionModel.Flavor = flavorModel
				versionModel.Sha = core.StringPtr("testString")
				versionModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				versionModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				versionModel.OfferingID = core.StringPtr("testString")
				versionModel.CatalogID = core.StringPtr("testString")
				versionModel.KindID = core.StringPtr("testString")
				versionModel.Tags = []string{"testString"}
				versionModel.RepoURL = core.StringPtr("testString")
				versionModel.SourceURL = core.StringPtr("testString")
				versionModel.TgzURL = core.StringPtr("testString")
				versionModel.Configuration = []catalogmanagementv1.Configuration{*configurationModel}
				versionModel.Outputs = []catalogmanagementv1.Output{*outputModel}
				versionModel.IamPermissions = []catalogmanagementv1.IamPermission{*iamPermissionModel}
				versionModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				versionModel.Validation = validationModel
				versionModel.RequiredResources = []catalogmanagementv1.Resource{*resourceModel}
				versionModel.SingleInstance = core.BoolPtr(true)
				versionModel.SchematicsEnvValues = schematicsEnvValuesModel
				versionModel.Install = scriptModel
				versionModel.PreInstall = []catalogmanagementv1.Script{*scriptModel}
				versionModel.Scripts = map[string]catalogmanagementv1.ScriptRef{"key1": *scriptRefModel}
				versionModel.Entitlement = versionEntitlementModel
				versionModel.Licenses = []catalogmanagementv1.License{*licenseModel}
				versionModel.ImageManifestURL = core.StringPtr("testString")
				versionModel.Deprecated = core.BoolPtr(true)
				versionModel.PackageVersion = core.StringPtr("testString")
				versionModel.State = stateModel
				versionModel.VersionLocator = core.StringPtr("testString")
				versionModel.LongDescription = core.StringPtr("testString")
				versionModel.LongDescriptionI18n = map[string]string{"key1": "testString"}
				versionModel.WhitelistedAccounts = []string{"testString"}
				versionModel.ImagePullKeyName = core.StringPtr("testString")
				versionModel.DeprecatePending = deprecatePendingModel
				versionModel.SolutionInfo = solutionInfoModel
				versionModel.IsConsumable = core.BoolPtr(true)
				versionModel.ComplianceV3 = complianceModel
				versionModel.ChangeNotices = changeNoticesModel
				versionModel.PlanIds = []string{"testString"}
				versionModel.Stack = map[string]interface{}{"anyKey": "anyValue"}
				versionModel.MinimumCompatibleVersion = core.StringPtr("testString")
				versionModel.Scripts["foo"] = *scriptRefModel
				Expect(versionModel.CRN).To(Equal(core.StringPtr("testString")))
				Expect(versionModel.Version).To(Equal(core.StringPtr("testString")))
				Expect(versionModel.Flavor).To(Equal(flavorModel))
				Expect(versionModel.Sha).To(Equal(core.StringPtr("testString")))
				Expect(versionModel.Created).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(versionModel.Updated).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(versionModel.OfferingID).To(Equal(core.StringPtr("testString")))
				Expect(versionModel.CatalogID).To(Equal(core.StringPtr("testString")))
				Expect(versionModel.KindID).To(Equal(core.StringPtr("testString")))
				Expect(versionModel.Tags).To(Equal([]string{"testString"}))
				Expect(versionModel.RepoURL).To(Equal(core.StringPtr("testString")))
				Expect(versionModel.SourceURL).To(Equal(core.StringPtr("testString")))
				Expect(versionModel.TgzURL).To(Equal(core.StringPtr("testString")))
				Expect(versionModel.Configuration).To(Equal([]catalogmanagementv1.Configuration{*configurationModel}))
				Expect(versionModel.Outputs).To(Equal([]catalogmanagementv1.Output{*outputModel}))
				Expect(versionModel.IamPermissions).To(Equal([]catalogmanagementv1.IamPermission{*iamPermissionModel}))
				Expect(versionModel.Metadata).To(Equal(map[string]interface{}{"anyKey": "anyValue"}))
				Expect(versionModel.Validation).To(Equal(validationModel))
				Expect(versionModel.RequiredResources).To(Equal([]catalogmanagementv1.Resource{*resourceModel}))
				Expect(versionModel.SingleInstance).To(Equal(core.BoolPtr(true)))
				Expect(versionModel.SchematicsEnvValues).To(Equal(schematicsEnvValuesModel))
				Expect(versionModel.Install).To(Equal(scriptModel))
				Expect(versionModel.PreInstall).To(Equal([]catalogmanagementv1.Script{*scriptModel}))
				Expect(versionModel.Entitlement).To(Equal(versionEntitlementModel))
				Expect(versionModel.Licenses).To(Equal([]catalogmanagementv1.License{*licenseModel}))
				Expect(versionModel.ImageManifestURL).To(Equal(core.StringPtr("testString")))
				Expect(versionModel.Deprecated).To(Equal(core.BoolPtr(true)))
				Expect(versionModel.PackageVersion).To(Equal(core.StringPtr("testString")))
				Expect(versionModel.State).To(Equal(stateModel))
				Expect(versionModel.VersionLocator).To(Equal(core.StringPtr("testString")))
				Expect(versionModel.LongDescription).To(Equal(core.StringPtr("testString")))
				Expect(versionModel.LongDescriptionI18n).To(Equal(map[string]string{"key1": "testString"}))
				Expect(versionModel.WhitelistedAccounts).To(Equal([]string{"testString"}))
				Expect(versionModel.ImagePullKeyName).To(Equal(core.StringPtr("testString")))
				Expect(versionModel.DeprecatePending).To(Equal(deprecatePendingModel))
				Expect(versionModel.SolutionInfo).To(Equal(solutionInfoModel))
				Expect(versionModel.IsConsumable).To(Equal(core.BoolPtr(true)))
				Expect(versionModel.ComplianceV3).To(Equal(complianceModel))
				Expect(versionModel.ChangeNotices).To(Equal(changeNoticesModel))
				Expect(versionModel.PlanIds).To(Equal([]string{"testString"}))
				Expect(versionModel.Stack).To(Equal(map[string]interface{}{"anyKey": "anyValue"}))
				Expect(versionModel.MinimumCompatibleVersion).To(Equal(core.StringPtr("testString")))
				Expect(versionModel.Scripts["foo"]).To(Equal(*scriptRefModel))

				// Construct an instance of the PaginationTokenLink model
				paginationTokenLinkModel := new(catalogmanagementv1.PaginationTokenLink)
				Expect(paginationTokenLinkModel).ToNot(BeNil())
				paginationTokenLinkModel.Href = core.StringPtr("testString")
				paginationTokenLinkModel.Start = core.StringPtr("testString")
				Expect(paginationTokenLinkModel.Href).To(Equal(core.StringPtr("testString")))
				Expect(paginationTokenLinkModel.Start).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the KindAllVersions model
				kindAllVersionsModel := new(catalogmanagementv1.KindAllVersions)
				Expect(kindAllVersionsModel).ToNot(BeNil())
				kindAllVersionsModel.First = paginationTokenLinkModel
				kindAllVersionsModel.Next = paginationTokenLinkModel
				Expect(kindAllVersionsModel.First).To(Equal(paginationTokenLinkModel))
				Expect(kindAllVersionsModel.Next).To(Equal(paginationTokenLinkModel))

				// Construct an instance of the Kind model
				kindModel := new(catalogmanagementv1.Kind)
				Expect(kindModel).ToNot(BeNil())
				kindModel.ID = core.StringPtr("testString")
				kindModel.FormatKind = core.StringPtr("testString")
				kindModel.FormatKindLabel = core.StringPtr("testString")
				kindModel.InstallKind = core.StringPtr("testString")
				kindModel.InstallKindLabel = core.StringPtr("testString")
				kindModel.TargetKind = core.StringPtr("testString")
				kindModel.TargetKindLabel = core.StringPtr("testString")
				kindModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				kindModel.Tags = []string{"testString"}
				kindModel.AdditionalFeatures = []catalogmanagementv1.Feature{*featureModel}
				kindModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				kindModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				kindModel.Versions = []catalogmanagementv1.Version{*versionModel}
				kindModel.AllVersions = kindAllVersionsModel
				Expect(kindModel.ID).To(Equal(core.StringPtr("testString")))
				Expect(kindModel.FormatKind).To(Equal(core.StringPtr("testString")))
				Expect(kindModel.FormatKindLabel).To(Equal(core.StringPtr("testString")))
				Expect(kindModel.InstallKind).To(Equal(core.StringPtr("testString")))
				Expect(kindModel.InstallKindLabel).To(Equal(core.StringPtr("testString")))
				Expect(kindModel.TargetKind).To(Equal(core.StringPtr("testString")))
				Expect(kindModel.TargetKindLabel).To(Equal(core.StringPtr("testString")))
				Expect(kindModel.Metadata).To(Equal(map[string]interface{}{"anyKey": "anyValue"}))
				Expect(kindModel.Tags).To(Equal([]string{"testString"}))
				Expect(kindModel.AdditionalFeatures).To(Equal([]catalogmanagementv1.Feature{*featureModel}))
				Expect(kindModel.Created).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(kindModel.Updated).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(kindModel.Versions).To(Equal([]catalogmanagementv1.Version{*versionModel}))
				Expect(kindModel.AllVersions).To(Equal(kindAllVersionsModel))

				// Construct an instance of the PublishObject model
				publishObjectModel := new(catalogmanagementv1.PublishObject)
				Expect(publishObjectModel).ToNot(BeNil())
				publishObjectModel.PcManaged = core.BoolPtr(true)
				publishObjectModel.ApprovalType = core.StringPtr("testString")
				publishObjectModel.PublishApproved = core.BoolPtr(true)
				publishObjectModel.ShareWithAll = core.BoolPtr(true)
				publishObjectModel.ShareWithIBM = core.BoolPtr(true)
				publishObjectModel.ShareEnabled = core.BoolPtr(true)
				publishObjectModel.OriginalCRN = core.StringPtr("testString")
				publishObjectModel.PublicCRN = core.StringPtr("testString")
				publishObjectModel.ApprovalRecord = map[string]interface{}{"anyKey": "anyValue"}
				publishObjectModel.PermitIBMPublicPublish = core.BoolPtr(true)
				publishObjectModel.IBMApproved = core.BoolPtr(true)
				publishObjectModel.PublicApproved = core.BoolPtr(true)
				Expect(publishObjectModel.PcManaged).To(Equal(core.BoolPtr(true)))
				Expect(publishObjectModel.ApprovalType).To(Equal(core.StringPtr("testString")))
				Expect(publishObjectModel.PublishApproved).To(Equal(core.BoolPtr(true)))
				Expect(publishObjectModel.ShareWithAll).To(Equal(core.BoolPtr(true)))
				Expect(publishObjectModel.ShareWithIBM).To(Equal(core.BoolPtr(true)))
				Expect(publishObjectModel.ShareEnabled).To(Equal(core.BoolPtr(true)))
				Expect(publishObjectModel.OriginalCRN).To(Equal(core.StringPtr("testString")))
				Expect(publishObjectModel.PublicCRN).To(Equal(core.StringPtr("testString")))
				Expect(publishObjectModel.ApprovalRecord).To(Equal(map[string]interface{}{"anyKey": "anyValue"}))
				Expect(publishObjectModel.PermitIBMPublicPublish).To(Equal(core.BoolPtr(true)))
				Expect(publishObjectModel.IBMApproved).To(Equal(core.BoolPtr(true)))
				Expect(publishObjectModel.PublicApproved).To(Equal(core.BoolPtr(true)))

				// Construct an instance of the ProviderInfo model
				providerInfoModel := new(catalogmanagementv1.ProviderInfo)
				Expect(providerInfoModel).ToNot(BeNil())
				providerInfoModel.ID = core.StringPtr("testString")
				providerInfoModel.Name = core.StringPtr("testString")
				Expect(providerInfoModel.ID).To(Equal(core.StringPtr("testString")))
				Expect(providerInfoModel.Name).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the RepoInfo model
				repoInfoModel := new(catalogmanagementv1.RepoInfo)
				Expect(repoInfoModel).ToNot(BeNil())
				repoInfoModel.Token = core.StringPtr("testString")
				repoInfoModel.Type = core.StringPtr("testString")
				Expect(repoInfoModel.Token).To(Equal(core.StringPtr("testString")))
				Expect(repoInfoModel.Type).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the ImagePullKey model
				imagePullKeyModel := new(catalogmanagementv1.ImagePullKey)
				Expect(imagePullKeyModel).ToNot(BeNil())
				imagePullKeyModel.Name = core.StringPtr("testString")
				imagePullKeyModel.Value = core.StringPtr("testString")
				imagePullKeyModel.Description = core.StringPtr("testString")
				Expect(imagePullKeyModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(imagePullKeyModel.Value).To(Equal(core.StringPtr("testString")))
				Expect(imagePullKeyModel.Description).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the SupportWaitTime model
				supportWaitTimeModel := new(catalogmanagementv1.SupportWaitTime)
				Expect(supportWaitTimeModel).ToNot(BeNil())
				supportWaitTimeModel.Value = core.Int64Ptr(int64(38))
				supportWaitTimeModel.Type = core.StringPtr("testString")
				Expect(supportWaitTimeModel.Value).To(Equal(core.Int64Ptr(int64(38))))
				Expect(supportWaitTimeModel.Type).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the SupportTime model
				supportTimeModel := new(catalogmanagementv1.SupportTime)
				Expect(supportTimeModel).ToNot(BeNil())
				supportTimeModel.Day = core.Int64Ptr(int64(38))
				supportTimeModel.StartTime = core.StringPtr("testString")
				supportTimeModel.EndTime = core.StringPtr("testString")
				Expect(supportTimeModel.Day).To(Equal(core.Int64Ptr(int64(38))))
				Expect(supportTimeModel.StartTime).To(Equal(core.StringPtr("testString")))
				Expect(supportTimeModel.EndTime).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the SupportAvailability model
				supportAvailabilityModel := new(catalogmanagementv1.SupportAvailability)
				Expect(supportAvailabilityModel).ToNot(BeNil())
				supportAvailabilityModel.Times = []catalogmanagementv1.SupportTime{*supportTimeModel}
				supportAvailabilityModel.Timezone = core.StringPtr("testString")
				supportAvailabilityModel.AlwaysAvailable = core.BoolPtr(true)
				Expect(supportAvailabilityModel.Times).To(Equal([]catalogmanagementv1.SupportTime{*supportTimeModel}))
				Expect(supportAvailabilityModel.Timezone).To(Equal(core.StringPtr("testString")))
				Expect(supportAvailabilityModel.AlwaysAvailable).To(Equal(core.BoolPtr(true)))

				// Construct an instance of the SupportDetail model
				supportDetailModel := new(catalogmanagementv1.SupportDetail)
				Expect(supportDetailModel).ToNot(BeNil())
				supportDetailModel.Type = core.StringPtr("testString")
				supportDetailModel.Contact = core.StringPtr("testString")
				supportDetailModel.ResponseWaitTime = supportWaitTimeModel
				supportDetailModel.Availability = supportAvailabilityModel
				Expect(supportDetailModel.Type).To(Equal(core.StringPtr("testString")))
				Expect(supportDetailModel.Contact).To(Equal(core.StringPtr("testString")))
				Expect(supportDetailModel.ResponseWaitTime).To(Equal(supportWaitTimeModel))
				Expect(supportDetailModel.Availability).To(Equal(supportAvailabilityModel))

				// Construct an instance of the SupportEscalation model
				supportEscalationModel := new(catalogmanagementv1.SupportEscalation)
				Expect(supportEscalationModel).ToNot(BeNil())
				supportEscalationModel.EscalationWaitTime = supportWaitTimeModel
				supportEscalationModel.ResponseWaitTime = supportWaitTimeModel
				supportEscalationModel.Contact = core.StringPtr("testString")
				Expect(supportEscalationModel.EscalationWaitTime).To(Equal(supportWaitTimeModel))
				Expect(supportEscalationModel.ResponseWaitTime).To(Equal(supportWaitTimeModel))
				Expect(supportEscalationModel.Contact).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the Support model
				supportModel := new(catalogmanagementv1.Support)
				Expect(supportModel).ToNot(BeNil())
				supportModel.URL = core.StringPtr("testString")
				supportModel.Process = core.StringPtr("testString")
				supportModel.ProcessI18n = map[string]string{"key1": "testString"}
				supportModel.Locations = []string{"testString"}
				supportModel.SupportDetails = []catalogmanagementv1.SupportDetail{*supportDetailModel}
				supportModel.SupportEscalation = supportEscalationModel
				supportModel.SupportType = core.StringPtr("testString")
				Expect(supportModel.URL).To(Equal(core.StringPtr("testString")))
				Expect(supportModel.Process).To(Equal(core.StringPtr("testString")))
				Expect(supportModel.ProcessI18n).To(Equal(map[string]string{"key1": "testString"}))
				Expect(supportModel.Locations).To(Equal([]string{"testString"}))
				Expect(supportModel.SupportDetails).To(Equal([]catalogmanagementv1.SupportDetail{*supportDetailModel}))
				Expect(supportModel.SupportEscalation).To(Equal(supportEscalationModel))
				Expect(supportModel.SupportType).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the LearnMoreLinks model
				learnMoreLinksModel := new(catalogmanagementv1.LearnMoreLinks)
				Expect(learnMoreLinksModel).ToNot(BeNil())
				learnMoreLinksModel.FirstParty = core.StringPtr("testString")
				learnMoreLinksModel.ThirdParty = core.StringPtr("testString")
				Expect(learnMoreLinksModel.FirstParty).To(Equal(core.StringPtr("testString")))
				Expect(learnMoreLinksModel.ThirdParty).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the Constraint model
				constraintModel := new(catalogmanagementv1.Constraint)
				Expect(constraintModel).ToNot(BeNil())
				constraintModel.Type = core.StringPtr("testString")
				constraintModel.Rule = "testString"
				Expect(constraintModel.Type).To(Equal(core.StringPtr("testString")))
				Expect(constraintModel.Rule).To(Equal("testString"))

				// Construct an instance of the Badge model
				badgeModel := new(catalogmanagementv1.Badge)
				Expect(badgeModel).ToNot(BeNil())
				badgeModel.ID = core.StringPtr("testString")
				badgeModel.Label = core.StringPtr("testString")
				badgeModel.LabelI18n = map[string]string{"key1": "testString"}
				badgeModel.Description = core.StringPtr("testString")
				badgeModel.DescriptionI18n = map[string]string{"key1": "testString"}
				badgeModel.Icon = core.StringPtr("testString")
				badgeModel.Authority = core.StringPtr("testString")
				badgeModel.Tag = core.StringPtr("testString")
				badgeModel.LearnMoreLinks = learnMoreLinksModel
				badgeModel.Constraints = []catalogmanagementv1.Constraint{*constraintModel}
				Expect(badgeModel.ID).To(Equal(core.StringPtr("testString")))
				Expect(badgeModel.Label).To(Equal(core.StringPtr("testString")))
				Expect(badgeModel.LabelI18n).To(Equal(map[string]string{"key1": "testString"}))
				Expect(badgeModel.Description).To(Equal(core.StringPtr("testString")))
				Expect(badgeModel.DescriptionI18n).To(Equal(map[string]string{"key1": "testString"}))
				Expect(badgeModel.Icon).To(Equal(core.StringPtr("testString")))
				Expect(badgeModel.Authority).To(Equal(core.StringPtr("testString")))
				Expect(badgeModel.Tag).To(Equal(core.StringPtr("testString")))
				Expect(badgeModel.LearnMoreLinks).To(Equal(learnMoreLinksModel))
				Expect(badgeModel.Constraints).To(Equal([]catalogmanagementv1.Constraint{*constraintModel}))

				// Construct an instance of the VersionRange model
				versionRangeModel := new(catalogmanagementv1.VersionRange)
				Expect(versionRangeModel).ToNot(BeNil())
				versionRangeModel.Kinds = []string{"testString"}
				versionRangeModel.Version = core.StringPtr("testString")
				versionRangeModel.Flavors = []string{"testString"}
				Expect(versionRangeModel.Kinds).To(Equal([]string{"testString"}))
				Expect(versionRangeModel.Version).To(Equal(core.StringPtr("testString")))
				Expect(versionRangeModel.Flavors).To(Equal([]string{"testString"}))

				// Construct an instance of the Plan model
				planModel := new(catalogmanagementv1.Plan)
				Expect(planModel).ToNot(BeNil())
				planModel.URL = core.StringPtr("testString")
				planModel.CRN = core.StringPtr("testString")
				planModel.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				planModel.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
				planModel.OfferingID = core.StringPtr("testString")
				planModel.CatalogID = core.StringPtr("testString")
				planModel.Label = core.StringPtr("testString")
				planModel.LabelI18n = map[string]string{"key1": "testString"}
				planModel.Name = core.StringPtr("testString")
				planModel.ShortDescription = core.StringPtr("testString")
				planModel.ShortDescriptionI18n = map[string]string{"key1": "testString"}
				planModel.PricingTags = []string{"testString"}
				planModel.VersionRange = versionRangeModel
				planModel.Features = []catalogmanagementv1.Feature{*featureModel}
				planModel.State = stateModel
				planModel.DeprecatePending = deprecatePendingModel
				planModel.Metadata = map[string]interface{}{"anyKey": "anyValue"}
				planModel.PublishApproved = core.BoolPtr(true)
				Expect(planModel.URL).To(Equal(core.StringPtr("testString")))
				Expect(planModel.CRN).To(Equal(core.StringPtr("testString")))
				Expect(planModel.Created).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(planModel.Updated).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(planModel.OfferingID).To(Equal(core.StringPtr("testString")))
				Expect(planModel.CatalogID).To(Equal(core.StringPtr("testString")))
				Expect(planModel.Label).To(Equal(core.StringPtr("testString")))
				Expect(planModel.LabelI18n).To(Equal(map[string]string{"key1": "testString"}))
				Expect(planModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(planModel.ShortDescription).To(Equal(core.StringPtr("testString")))
				Expect(planModel.ShortDescriptionI18n).To(Equal(map[string]string{"key1": "testString"}))
				Expect(planModel.PricingTags).To(Equal([]string{"testString"}))
				Expect(planModel.VersionRange).To(Equal(versionRangeModel))
				Expect(planModel.Features).To(Equal([]catalogmanagementv1.Feature{*featureModel}))
				Expect(planModel.State).To(Equal(stateModel))
				Expect(planModel.DeprecatePending).To(Equal(deprecatePendingModel))
				Expect(planModel.Metadata).To(Equal(map[string]interface{}{"anyKey": "anyValue"}))
				Expect(planModel.PublishApproved).To(Equal(core.BoolPtr(true)))

				// Construct an instance of the UpdateVersionOptions model
				versionLocID := "testString"
				updateVersionOptionsModel := catalogManagementService.NewUpdateVersionOptions(versionLocID)
				updateVersionOptionsModel.SetVersionLocID("testString")
				updateVersionOptionsModel.SetID("testString")
				updateVersionOptionsModel.SetRev("testString")
				updateVersionOptionsModel.SetURL("testString")
				updateVersionOptionsModel.SetCRN("testString")
				updateVersionOptionsModel.SetLabel("testString")
				updateVersionOptionsModel.SetLabelI18n(map[string]string{"key1": "testString"})
				updateVersionOptionsModel.SetName("testString")
				updateVersionOptionsModel.SetOfferingIconURL("testString")
				updateVersionOptionsModel.SetOfferingDocsURL("testString")
				updateVersionOptionsModel.SetOfferingSupportURL("testString")
				updateVersionOptionsModel.SetTags([]string{"testString"})
				updateVersionOptionsModel.SetKeywords([]string{"testString"})
				updateVersionOptionsModel.SetRating(ratingModel)
				updateVersionOptionsModel.SetCreated(CreateMockDateTime("2019-01-01T12:00:00.000Z"))
				updateVersionOptionsModel.SetUpdated(CreateMockDateTime("2019-01-01T12:00:00.000Z"))
				updateVersionOptionsModel.SetShortDescription("testString")
				updateVersionOptionsModel.SetShortDescriptionI18n(map[string]string{"key1": "testString"})
				updateVersionOptionsModel.SetLongDescription("testString")
				updateVersionOptionsModel.SetLongDescriptionI18n(map[string]string{"key1": "testString"})
				updateVersionOptionsModel.SetFeatures([]catalogmanagementv1.Feature{*featureModel})
				updateVersionOptionsModel.SetKinds([]catalogmanagementv1.Kind{*kindModel})
				updateVersionOptionsModel.SetPublish(publishObjectModel)
				updateVersionOptionsModel.SetPcManaged(true)
				updateVersionOptionsModel.SetPublishApproved(true)
				updateVersionOptionsModel.SetShareWithAll(true)
				updateVersionOptionsModel.SetShareWithIBM(true)
				updateVersionOptionsModel.SetShareEnabled(true)
				updateVersionOptionsModel.SetPublicOriginalCRN("testString")
				updateVersionOptionsModel.SetPublishPublicCRN("testString")
				updateVersionOptionsModel.SetPortalApprovalRecord("testString")
				updateVersionOptionsModel.SetPortalUIURL("testString")
				updateVersionOptionsModel.SetCatalogID("testString")
				updateVersionOptionsModel.SetCatalogName("testString")
				updateVersionOptionsModel.SetMetadata(map[string]interface{}{"anyKey": "anyValue"})
				updateVersionOptionsModel.SetDisclaimer("testString")
				updateVersionOptionsModel.SetHidden(true)
				updateVersionOptionsModel.SetProvider("testString")
				updateVersionOptionsModel.SetProviderInfo(providerInfoModel)
				updateVersionOptionsModel.SetRepoInfo(repoInfoModel)
				updateVersionOptionsModel.SetImagePullKeys([]catalogmanagementv1.ImagePullKey{*imagePullKeyModel})
				updateVersionOptionsModel.SetSupport(supportModel)
				updateVersionOptionsModel.SetMedia([]catalogmanagementv1.MediaItem{*mediaItemModel})
				updateVersionOptionsModel.SetDeprecatePending(deprecatePendingModel)
				updateVersionOptionsModel.SetProductKind("testString")
				updateVersionOptionsModel.SetBadges([]catalogmanagementv1.Badge{*badgeModel})
				updateVersionOptionsModel.SetPlans([]catalogmanagementv1.Plan{*planModel})
				updateVersionOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(updateVersionOptionsModel).ToNot(BeNil())
				Expect(updateVersionOptionsModel.VersionLocID).To(Equal(core.StringPtr("testString")))
				Expect(updateVersionOptionsModel.ID).To(Equal(core.StringPtr("testString")))
				Expect(updateVersionOptionsModel.Rev).To(Equal(core.StringPtr("testString")))
				Expect(updateVersionOptionsModel.URL).To(Equal(core.StringPtr("testString")))
				Expect(updateVersionOptionsModel.CRN).To(Equal(core.StringPtr("testString")))
				Expect(updateVersionOptionsModel.Label).To(Equal(core.StringPtr("testString")))
				Expect(updateVersionOptionsModel.LabelI18n).To(Equal(map[string]string{"key1": "testString"}))
				Expect(updateVersionOptionsModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(updateVersionOptionsModel.OfferingIconURL).To(Equal(core.StringPtr("testString")))
				Expect(updateVersionOptionsModel.OfferingDocsURL).To(Equal(core.StringPtr("testString")))
				Expect(updateVersionOptionsModel.OfferingSupportURL).To(Equal(core.StringPtr("testString")))
				Expect(updateVersionOptionsModel.Tags).To(Equal([]string{"testString"}))
				Expect(updateVersionOptionsModel.Keywords).To(Equal([]string{"testString"}))
				Expect(updateVersionOptionsModel.Rating).To(Equal(ratingModel))
				Expect(updateVersionOptionsModel.Created).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(updateVersionOptionsModel.Updated).To(Equal(CreateMockDateTime("2019-01-01T12:00:00.000Z")))
				Expect(updateVersionOptionsModel.ShortDescription).To(Equal(core.StringPtr("testString")))
				Expect(updateVersionOptionsModel.ShortDescriptionI18n).To(Equal(map[string]string{"key1": "testString"}))
				Expect(updateVersionOptionsModel.LongDescription).To(Equal(core.StringPtr("testString")))
				Expect(updateVersionOptionsModel.LongDescriptionI18n).To(Equal(map[string]string{"key1": "testString"}))
				Expect(updateVersionOptionsModel.Features).To(Equal([]catalogmanagementv1.Feature{*featureModel}))
				Expect(updateVersionOptionsModel.Kinds).To(Equal([]catalogmanagementv1.Kind{*kindModel}))
				Expect(updateVersionOptionsModel.Publish).To(Equal(publishObjectModel))
				Expect(updateVersionOptionsModel.PcManaged).To(Equal(core.BoolPtr(true)))
				Expect(updateVersionOptionsModel.PublishApproved).To(Equal(core.BoolPtr(true)))
				Expect(updateVersionOptionsModel.ShareWithAll).To(Equal(core.BoolPtr(true)))
				Expect(updateVersionOptionsModel.ShareWithIBM).To(Equal(core.BoolPtr(true)))
				Expect(updateVersionOptionsModel.ShareEnabled).To(Equal(core.BoolPtr(true)))
				Expect(updateVersionOptionsModel.PublicOriginalCRN).To(Equal(core.StringPtr("testString")))
				Expect(updateVersionOptionsModel.PublishPublicCRN).To(Equal(core.StringPtr("testString")))
				Expect(updateVersionOptionsModel.PortalApprovalRecord).To(Equal(core.StringPtr("testString")))
				Expect(updateVersionOptionsModel.PortalUIURL).To(Equal(core.StringPtr("testString")))
				Expect(updateVersionOptionsModel.CatalogID).To(Equal(core.StringPtr("testString")))
				Expect(updateVersionOptionsModel.CatalogName).To(Equal(core.StringPtr("testString")))
				Expect(updateVersionOptionsModel.Metadata).To(Equal(map[string]interface{}{"anyKey": "anyValue"}))
				Expect(updateVersionOptionsModel.Disclaimer).To(Equal(core.StringPtr("testString")))
				Expect(updateVersionOptionsModel.Hidden).To(Equal(core.BoolPtr(true)))
				Expect(updateVersionOptionsModel.Provider).To(Equal(core.StringPtr("testString")))
				Expect(updateVersionOptionsModel.ProviderInfo).To(Equal(providerInfoModel))
				Expect(updateVersionOptionsModel.RepoInfo).To(Equal(repoInfoModel))
				Expect(updateVersionOptionsModel.ImagePullKeys).To(Equal([]catalogmanagementv1.ImagePullKey{*imagePullKeyModel}))
				Expect(updateVersionOptionsModel.Support).To(Equal(supportModel))
				Expect(updateVersionOptionsModel.Media).To(Equal([]catalogmanagementv1.MediaItem{*mediaItemModel}))
				Expect(updateVersionOptionsModel.DeprecatePending).To(Equal(deprecatePendingModel))
				Expect(updateVersionOptionsModel.ProductKind).To(Equal(core.StringPtr("testString")))
				Expect(updateVersionOptionsModel.Badges).To(Equal([]catalogmanagementv1.Badge{*badgeModel}))
				Expect(updateVersionOptionsModel.Plans).To(Equal([]catalogmanagementv1.Plan{*planModel}))
				Expect(updateVersionOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewValidateInputsOptions successfully`, func() {
				// Construct an instance of the ValidateInputsOptions model
				versionLocID := "testString"
				validateInputsOptionsModel := catalogManagementService.NewValidateInputsOptions(versionLocID)
				validateInputsOptionsModel.SetVersionLocID("testString")
				validateInputsOptionsModel.SetInput1("testString")
				validateInputsOptionsModel.SetInput2("testString")
				validateInputsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(validateInputsOptionsModel).ToNot(BeNil())
				Expect(validateInputsOptionsModel.VersionLocID).To(Equal(core.StringPtr("testString")))
				Expect(validateInputsOptionsModel.Input1).To(Equal(core.StringPtr("testString")))
				Expect(validateInputsOptionsModel.Input2).To(Equal(core.StringPtr("testString")))
				Expect(validateInputsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewValidateInstallOptions successfully`, func() {
				// Construct an instance of the DeployRequestBodyOverrideValues model
				deployRequestBodyOverrideValuesModel := new(catalogmanagementv1.DeployRequestBodyOverrideValues)
				Expect(deployRequestBodyOverrideValuesModel).ToNot(BeNil())
				deployRequestBodyOverrideValuesModel.VsiInstanceName = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.VPCProfile = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.SubnetID = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.VPCID = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.SubnetZone = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.SSHKeyID = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.VPCRegion = core.StringPtr("testString")
				deployRequestBodyOverrideValuesModel.SetProperty("foo", "testString")
				Expect(deployRequestBodyOverrideValuesModel.VsiInstanceName).To(Equal(core.StringPtr("testString")))
				Expect(deployRequestBodyOverrideValuesModel.VPCProfile).To(Equal(core.StringPtr("testString")))
				Expect(deployRequestBodyOverrideValuesModel.SubnetID).To(Equal(core.StringPtr("testString")))
				Expect(deployRequestBodyOverrideValuesModel.VPCID).To(Equal(core.StringPtr("testString")))
				Expect(deployRequestBodyOverrideValuesModel.SubnetZone).To(Equal(core.StringPtr("testString")))
				Expect(deployRequestBodyOverrideValuesModel.SSHKeyID).To(Equal(core.StringPtr("testString")))
				Expect(deployRequestBodyOverrideValuesModel.VPCRegion).To(Equal(core.StringPtr("testString")))
				Expect(deployRequestBodyOverrideValuesModel.GetProperties()).ToNot(BeEmpty())
				Expect(deployRequestBodyOverrideValuesModel.GetProperty("foo")).To(Equal("testString"))

				deployRequestBodyOverrideValuesModel.SetProperties(nil)
				Expect(deployRequestBodyOverrideValuesModel.GetProperties()).To(BeEmpty())

				deployRequestBodyOverrideValuesModelExpectedMap := make(map[string]interface{})
				deployRequestBodyOverrideValuesModelExpectedMap["foo"] = "testString"
				deployRequestBodyOverrideValuesModel.SetProperties(deployRequestBodyOverrideValuesModelExpectedMap)
				deployRequestBodyOverrideValuesModelActualMap := deployRequestBodyOverrideValuesModel.GetProperties()
				Expect(deployRequestBodyOverrideValuesModelActualMap).To(Equal(deployRequestBodyOverrideValuesModelExpectedMap))

				// Construct an instance of the DeployRequestBodyEnvironmentVariablesItem model
				deployRequestBodyEnvironmentVariablesItemModel := new(catalogmanagementv1.DeployRequestBodyEnvironmentVariablesItem)
				Expect(deployRequestBodyEnvironmentVariablesItemModel).ToNot(BeNil())
				deployRequestBodyEnvironmentVariablesItemModel.Name = core.StringPtr("testString")
				deployRequestBodyEnvironmentVariablesItemModel.Value = "testString"
				deployRequestBodyEnvironmentVariablesItemModel.Secure = core.BoolPtr(true)
				deployRequestBodyEnvironmentVariablesItemModel.Hidden = core.BoolPtr(true)
				Expect(deployRequestBodyEnvironmentVariablesItemModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(deployRequestBodyEnvironmentVariablesItemModel.Value).To(Equal("testString"))
				Expect(deployRequestBodyEnvironmentVariablesItemModel.Secure).To(Equal(core.BoolPtr(true)))
				Expect(deployRequestBodyEnvironmentVariablesItemModel.Hidden).To(Equal(core.BoolPtr(true)))

				// Construct an instance of the DeployRequestBodySchematics model
				deployRequestBodySchematicsModel := new(catalogmanagementv1.DeployRequestBodySchematics)
				Expect(deployRequestBodySchematicsModel).ToNot(BeNil())
				deployRequestBodySchematicsModel.Name = core.StringPtr("testString")
				deployRequestBodySchematicsModel.Description = core.StringPtr("testString")
				deployRequestBodySchematicsModel.Tags = []string{"testString"}
				deployRequestBodySchematicsModel.ResourceGroupID = core.StringPtr("testString")
				deployRequestBodySchematicsModel.TerraformVersion = core.StringPtr("testString")
				deployRequestBodySchematicsModel.Region = core.StringPtr("testString")
				Expect(deployRequestBodySchematicsModel.Name).To(Equal(core.StringPtr("testString")))
				Expect(deployRequestBodySchematicsModel.Description).To(Equal(core.StringPtr("testString")))
				Expect(deployRequestBodySchematicsModel.Tags).To(Equal([]string{"testString"}))
				Expect(deployRequestBodySchematicsModel.ResourceGroupID).To(Equal(core.StringPtr("testString")))
				Expect(deployRequestBodySchematicsModel.TerraformVersion).To(Equal(core.StringPtr("testString")))
				Expect(deployRequestBodySchematicsModel.Region).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the ValidateInstallOptions model
				versionLocID := "testString"
				xAuthRefreshToken := "testString"
				validateInstallOptionsModel := catalogManagementService.NewValidateInstallOptions(versionLocID, xAuthRefreshToken)
				validateInstallOptionsModel.SetVersionLocID("testString")
				validateInstallOptionsModel.SetXAuthRefreshToken("testString")
				validateInstallOptionsModel.SetClusterID("testString")
				validateInstallOptionsModel.SetRegion("testString")
				validateInstallOptionsModel.SetNamespace("testString")
				validateInstallOptionsModel.SetNamespaces([]string{"testString"})
				validateInstallOptionsModel.SetAllNamespaces(true)
				validateInstallOptionsModel.SetOverrideValues(deployRequestBodyOverrideValuesModel)
				validateInstallOptionsModel.SetDependencyConfigs([]string{"testString"})
				validateInstallOptionsModel.SetEnvironmentVariables([]catalogmanagementv1.DeployRequestBodyEnvironmentVariablesItem{*deployRequestBodyEnvironmentVariablesItemModel})
				validateInstallOptionsModel.SetEntitlementApikey("testString")
				validateInstallOptionsModel.SetSchematics(deployRequestBodySchematicsModel)
				validateInstallOptionsModel.SetScript("testString")
				validateInstallOptionsModel.SetScriptID("testString")
				validateInstallOptionsModel.SetVersionLocatorID("testString")
				validateInstallOptionsModel.SetVcenterID("testString")
				validateInstallOptionsModel.SetVcenterLocation("testString")
				validateInstallOptionsModel.SetVcenterUser("testString")
				validateInstallOptionsModel.SetVcenterPassword("testString")
				validateInstallOptionsModel.SetVcenterDatastore("testString")
				validateInstallOptionsModel.SetPlanID("testString")
				validateInstallOptionsModel.SetChannel("testString")
				validateInstallOptionsModel.SetInstallPlan("testString")
				validateInstallOptionsModel.SetTargetContextName("testString")
				validateInstallOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(validateInstallOptionsModel).ToNot(BeNil())
				Expect(validateInstallOptionsModel.VersionLocID).To(Equal(core.StringPtr("testString")))
				Expect(validateInstallOptionsModel.XAuthRefreshToken).To(Equal(core.StringPtr("testString")))
				Expect(validateInstallOptionsModel.ClusterID).To(Equal(core.StringPtr("testString")))
				Expect(validateInstallOptionsModel.Region).To(Equal(core.StringPtr("testString")))
				Expect(validateInstallOptionsModel.Namespace).To(Equal(core.StringPtr("testString")))
				Expect(validateInstallOptionsModel.Namespaces).To(Equal([]string{"testString"}))
				Expect(validateInstallOptionsModel.AllNamespaces).To(Equal(core.BoolPtr(true)))
				Expect(validateInstallOptionsModel.OverrideValues).To(Equal(deployRequestBodyOverrideValuesModel))
				Expect(validateInstallOptionsModel.DependencyConfigs).To(Equal([]string{"testString"}))
				Expect(validateInstallOptionsModel.EnvironmentVariables).To(Equal([]catalogmanagementv1.DeployRequestBodyEnvironmentVariablesItem{*deployRequestBodyEnvironmentVariablesItemModel}))
				Expect(validateInstallOptionsModel.EntitlementApikey).To(Equal(core.StringPtr("testString")))
				Expect(validateInstallOptionsModel.Schematics).To(Equal(deployRequestBodySchematicsModel))
				Expect(validateInstallOptionsModel.Script).To(Equal(core.StringPtr("testString")))
				Expect(validateInstallOptionsModel.ScriptID).To(Equal(core.StringPtr("testString")))
				Expect(validateInstallOptionsModel.VersionLocatorID).To(Equal(core.StringPtr("testString")))
				Expect(validateInstallOptionsModel.VcenterID).To(Equal(core.StringPtr("testString")))
				Expect(validateInstallOptionsModel.VcenterLocation).To(Equal(core.StringPtr("testString")))
				Expect(validateInstallOptionsModel.VcenterUser).To(Equal(core.StringPtr("testString")))
				Expect(validateInstallOptionsModel.VcenterPassword).To(Equal(core.StringPtr("testString")))
				Expect(validateInstallOptionsModel.VcenterDatastore).To(Equal(core.StringPtr("testString")))
				Expect(validateInstallOptionsModel.PlanID).To(Equal(core.StringPtr("testString")))
				Expect(validateInstallOptionsModel.Channel).To(Equal(core.StringPtr("testString")))
				Expect(validateInstallOptionsModel.InstallPlan).To(Equal(core.StringPtr("testString")))
				Expect(validateInstallOptionsModel.TargetContextName).To(Equal(core.StringPtr("testString")))
				Expect(validateInstallOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
		})
	})
	Describe(`Model unmarshaling tests`, func() {
		It(`Invoke UnmarshalAccount successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.Account)
			model.ID = core.StringPtr("testString")
			model.Rev = core.StringPtr("testString")
			model.HideIBMCloudCatalog = core.BoolPtr(true)
			model.AccountFilters = nil
			model.RegionFilter = core.StringPtr("testString")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.Account
			err = catalogmanagementv1.UnmarshalAccount(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalArchitectureDiagram successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.ArchitectureDiagram)
			model.Diagram = nil
			model.Description = core.StringPtr("testString")
			model.DescriptionI18n = map[string]string{"key1": "testString"}

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.ArchitectureDiagram
			err = catalogmanagementv1.UnmarshalArchitectureDiagram(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalBadge successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.Badge)
			model.ID = core.StringPtr("testString")
			model.Label = core.StringPtr("testString")
			model.LabelI18n = map[string]string{"key1": "testString"}
			model.Description = core.StringPtr("testString")
			model.DescriptionI18n = map[string]string{"key1": "testString"}
			model.Icon = core.StringPtr("testString")
			model.Authority = core.StringPtr("testString")
			model.Tag = core.StringPtr("testString")
			model.LearnMoreLinks = nil
			model.Constraints = nil

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.Badge
			err = catalogmanagementv1.UnmarshalBadge(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalCatalog successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.Catalog)
			model.ID = core.StringPtr("testString")
			model.Rev = core.StringPtr("testString")
			model.Label = core.StringPtr("testString")
			model.LabelI18n = map[string]string{"key1": "testString"}
			model.ShortDescription = core.StringPtr("testString")
			model.ShortDescriptionI18n = map[string]string{"key1": "testString"}
			model.CatalogIconURL = core.StringPtr("testString")
			model.CatalogBannerURL = core.StringPtr("testString")
			model.Tags = []string{"testString"}
			model.URL = core.StringPtr("testString")
			model.CRN = core.StringPtr("testString")
			model.OfferingsURL = core.StringPtr("testString")
			model.Features = nil
			model.Disabled = core.BoolPtr(true)
			model.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
			model.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
			model.ResourceGroupID = core.StringPtr("testString")
			model.OwningAccount = core.StringPtr("testString")
			model.CatalogFilters = nil
			model.Kind = core.StringPtr("testString")
			model.Metadata = map[string]interface{}{"anyKey": "anyValue"}
			model.TargetAccountContexts = nil

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.Catalog
			err = catalogmanagementv1.UnmarshalCatalog(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalCatalogObject successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.CatalogObject)
			model.ID = core.StringPtr("testString")
			model.Rev = core.StringPtr("testString")
			model.Name = core.StringPtr("testString")
			model.CRN = core.StringPtr("testString")
			model.URL = core.StringPtr("testString")
			model.ParentID = core.StringPtr("testString")
			model.LabelI18n = map[string]string{"key1": "testString"}
			model.Label = core.StringPtr("testString")
			model.Tags = []string{"testString"}
			model.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
			model.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
			model.ShortDescription = core.StringPtr("testString")
			model.ShortDescriptionI18n = map[string]string{"key1": "testString"}
			model.Kind = core.StringPtr("testString")
			model.Publish = nil
			model.State = nil
			model.CatalogID = core.StringPtr("testString")
			model.CatalogName = core.StringPtr("testString")
			model.Data = map[string]interface{}{"anyKey": "anyValue"}

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.CatalogObject
			err = catalogmanagementv1.UnmarshalCatalogObject(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalCategoryFilter successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.CategoryFilter)
			model.Include = core.BoolPtr(true)
			model.Filter = nil

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.CategoryFilter
			err = catalogmanagementv1.UnmarshalCategoryFilter(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalChangeNotices successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.ChangeNotices)
			model.Breaking = nil
			model.New = nil
			model.Update = nil

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.ChangeNotices
			err = catalogmanagementv1.UnmarshalChangeNotices(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalClaimedControl successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.ClaimedControl)
			model.Profile = nil
			model.Names = []string{"testString"}

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.ClaimedControl
			err = catalogmanagementv1.UnmarshalClaimedControl(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalClaims successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.Claims)
			model.Profiles = nil
			model.Controls = nil

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.Claims
			err = catalogmanagementv1.UnmarshalClaims(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalCompliance successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.Compliance)
			model.Authority = core.StringPtr("testString")
			model.Claims = nil
			model.Evaluations = nil

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.Compliance
			err = catalogmanagementv1.UnmarshalCompliance(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalConfiguration successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.Configuration)
			model.Key = core.StringPtr("testString")
			model.Type = core.StringPtr("testString")
			model.DefaultValue = "testString"
			model.DisplayName = core.StringPtr("testString")
			model.ValueConstraint = core.StringPtr("testString")
			model.Description = core.StringPtr("testString")
			model.Required = core.BoolPtr(true)
			model.Options = []interface{}{"testString"}
			model.Hidden = core.BoolPtr(true)
			model.CustomConfig = nil
			model.TypeMetadata = core.StringPtr("testString")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.Configuration
			err = catalogmanagementv1.UnmarshalConfiguration(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalConstraint successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.Constraint)
			model.Type = core.StringPtr("testString")
			model.Rule = "testString"

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.Constraint
			err = catalogmanagementv1.UnmarshalConstraint(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalCostBreakdown successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.CostBreakdown)
			model.TotalHourlyCost = core.StringPtr("testString")
			model.TotalMonthlyCost = core.StringPtr("testString")
			model.Resources = nil

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.CostBreakdown
			err = catalogmanagementv1.UnmarshalCostBreakdown(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalCostComponent successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.CostComponent)
			model.Name = core.StringPtr("testString")
			model.Unit = core.StringPtr("testString")
			model.HourlyQuantity = core.StringPtr("testString")
			model.MonthlyQuantity = core.StringPtr("testString")
			model.Price = core.StringPtr("testString")
			model.HourlyCost = core.StringPtr("testString")
			model.MonthlyCost = core.StringPtr("testString")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.CostComponent
			err = catalogmanagementv1.UnmarshalCostComponent(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalCostEstimate successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.CostEstimate)
			model.Version = core.StringPtr("testString")
			model.Currency = core.StringPtr("testString")
			model.Projects = nil
			model.Summary = nil
			model.TotalHourlyCost = core.StringPtr("testString")
			model.TotalMonthlyCost = core.StringPtr("testString")
			model.PastTotalHourlyCost = core.StringPtr("testString")
			model.PastTotalMonthlyCost = core.StringPtr("testString")
			model.DiffTotalHourlyCost = core.StringPtr("testString")
			model.DiffTotalMonthlyCost = core.StringPtr("testString")
			model.TimeGenerated = CreateMockDateTime("2019-01-01T12:00:00.000Z")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.CostEstimate
			err = catalogmanagementv1.UnmarshalCostEstimate(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalCostResource successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.CostResource)
			model.Name = core.StringPtr("testString")
			model.Metadata = map[string]interface{}{"anyKey": "anyValue"}
			model.HourlyCost = core.StringPtr("testString")
			model.MonthlyCost = core.StringPtr("testString")
			model.CostComponents = nil

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.CostResource
			err = catalogmanagementv1.UnmarshalCostResource(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalCostSummary successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.CostSummary)
			model.TotalDetectedResources = core.Int64Ptr(int64(38))
			model.TotalSupportedResources = core.Int64Ptr(int64(38))
			model.TotalUnsupportedResources = core.Int64Ptr(int64(38))
			model.TotalUsageBasedResources = core.Int64Ptr(int64(38))
			model.TotalNoPriceResources = core.Int64Ptr(int64(38))
			model.UnsupportedResourceCounts = map[string]int64{"key1": int64(38)}
			model.NoPriceResourceCounts = map[string]int64{"key1": int64(38)}

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.CostSummary
			err = catalogmanagementv1.UnmarshalCostSummary(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalDeployRequestBodyEnvironmentVariablesItem successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.DeployRequestBodyEnvironmentVariablesItem)
			model.Name = core.StringPtr("testString")
			model.Value = "testString"
			model.Secure = core.BoolPtr(true)
			model.Hidden = core.BoolPtr(true)

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.DeployRequestBodyEnvironmentVariablesItem
			err = catalogmanagementv1.UnmarshalDeployRequestBodyEnvironmentVariablesItem(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalDeployRequestBodyOverrideValues successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.DeployRequestBodyOverrideValues)
			model.VsiInstanceName = core.StringPtr("testString")
			model.VPCProfile = core.StringPtr("testString")
			model.SubnetID = core.StringPtr("testString")
			model.VPCID = core.StringPtr("testString")
			model.SubnetZone = core.StringPtr("testString")
			model.SSHKeyID = core.StringPtr("testString")
			model.VPCRegion = core.StringPtr("testString")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.DeployRequestBodyOverrideValues
			err = catalogmanagementv1.UnmarshalDeployRequestBodyOverrideValues(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalDeployRequestBodySchematics successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.DeployRequestBodySchematics)
			model.Name = core.StringPtr("testString")
			model.Description = core.StringPtr("testString")
			model.Tags = []string{"testString"}
			model.ResourceGroupID = core.StringPtr("testString")
			model.TerraformVersion = core.StringPtr("testString")
			model.Region = core.StringPtr("testString")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.DeployRequestBodySchematics
			err = catalogmanagementv1.UnmarshalDeployRequestBodySchematics(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalDeprecatePending successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.DeprecatePending)
			model.DeprecateDate = CreateMockDateTime("2019-01-01T12:00:00.000Z")
			model.DeprecateState = core.StringPtr("testString")
			model.Description = core.StringPtr("testString")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.DeprecatePending
			err = catalogmanagementv1.UnmarshalDeprecatePending(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalEvaluatedControl successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.EvaluatedControl)
			model.ID = core.StringPtr("testString")
			model.Name = core.StringPtr("testString")
			model.Description = core.StringPtr("testString")
			model.Specifications = nil
			model.FailureCount = core.Int64Ptr(int64(38))
			model.PassCount = core.Int64Ptr(int64(38))
			model.Parent = nil
			model.UIHref = core.StringPtr("testString")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.EvaluatedControl
			err = catalogmanagementv1.UnmarshalEvaluatedControl(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalEvaluation successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.Evaluation)
			model.ScanID = core.StringPtr("testString")
			model.AccountID = core.StringPtr("testString")
			model.Profile = nil
			model.Result = nil
			model.Controls = nil

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.Evaluation
			err = catalogmanagementv1.UnmarshalEvaluation(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalFeature successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.Feature)
			model.Title = core.StringPtr("testString")
			model.TitleI18n = map[string]string{"key1": "testString"}
			model.Description = core.StringPtr("testString")
			model.DescriptionI18n = map[string]string{"key1": "testString"}

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.Feature
			err = catalogmanagementv1.UnmarshalFeature(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalFilterTerms successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.FilterTerms)
			model.FilterTerms = []string{"testString"}

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.FilterTerms
			err = catalogmanagementv1.UnmarshalFilterTerms(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalFilters successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.Filters)
			model.IncludeAll = core.BoolPtr(true)
			model.CategoryFilters = nil
			model.IDFilters = nil

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.Filters
			err = catalogmanagementv1.UnmarshalFilters(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalFlavor successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.Flavor)
			model.Name = core.StringPtr("testString")
			model.Label = core.StringPtr("testString")
			model.LabelI18n = map[string]string{"key1": "testString"}
			model.Index = core.Int64Ptr(int64(38))

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.Flavor
			err = catalogmanagementv1.UnmarshalFlavor(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalIamPermission successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.IamPermission)
			model.ServiceName = core.StringPtr("testString")
			model.RoleCrns = []string{"testString"}
			model.Resources = nil

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.IamPermission
			err = catalogmanagementv1.UnmarshalIamPermission(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalIamResource successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.IamResource)
			model.Name = core.StringPtr("testString")
			model.Description = core.StringPtr("testString")
			model.RoleCrns = []string{"testString"}

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.IamResource
			err = catalogmanagementv1.UnmarshalIamResource(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalIDFilter successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.IDFilter)
			model.Include = nil
			model.Exclude = nil

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.IDFilter
			err = catalogmanagementv1.UnmarshalIDFilter(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalImagePullKey successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.ImagePullKey)
			model.Name = core.StringPtr("testString")
			model.Value = core.StringPtr("testString")
			model.Description = core.StringPtr("testString")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.ImagePullKey
			err = catalogmanagementv1.UnmarshalImagePullKey(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalImportOfferingBodyMetadata successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.ImportOfferingBodyMetadata)
			model.OperatingSystem = nil
			model.File = nil
			model.MinimumProvisionedSize = core.Int64Ptr(int64(38))
			model.Images = nil

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.ImportOfferingBodyMetadata
			err = catalogmanagementv1.UnmarshalImportOfferingBodyMetadata(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalImportOfferingBodyMetadataFile successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.ImportOfferingBodyMetadataFile)
			model.Size = core.Int64Ptr(int64(38))

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.ImportOfferingBodyMetadataFile
			err = catalogmanagementv1.UnmarshalImportOfferingBodyMetadataFile(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalImportOfferingBodyMetadataImagesItem successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.ImportOfferingBodyMetadataImagesItem)
			model.ID = core.StringPtr("testString")
			model.Name = core.StringPtr("testString")
			model.Region = core.StringPtr("testString")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.ImportOfferingBodyMetadataImagesItem
			err = catalogmanagementv1.UnmarshalImportOfferingBodyMetadataImagesItem(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalImportOfferingBodyMetadataOperatingSystem successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.ImportOfferingBodyMetadataOperatingSystem)
			model.DedicatedHostOnly = core.BoolPtr(true)
			model.Vendor = core.StringPtr("testString")
			model.Name = core.StringPtr("testString")
			model.Href = core.StringPtr("testString")
			model.DisplayName = core.StringPtr("testString")
			model.Family = core.StringPtr("testString")
			model.Version = core.StringPtr("testString")
			model.Architecture = core.StringPtr("testString")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.ImportOfferingBodyMetadataOperatingSystem
			err = catalogmanagementv1.UnmarshalImportOfferingBodyMetadataOperatingSystem(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalJSONPatchOperation successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.JSONPatchOperation)
			model.Op = core.StringPtr("add")
			model.Path = core.StringPtr("testString")
			model.Value = "testString"
			model.From = core.StringPtr("testString")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.JSONPatchOperation
			err = catalogmanagementv1.UnmarshalJSONPatchOperation(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalKind successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.Kind)
			model.ID = core.StringPtr("testString")
			model.FormatKind = core.StringPtr("testString")
			model.FormatKindLabel = core.StringPtr("testString")
			model.InstallKind = core.StringPtr("testString")
			model.InstallKindLabel = core.StringPtr("testString")
			model.TargetKind = core.StringPtr("testString")
			model.TargetKindLabel = core.StringPtr("testString")
			model.Metadata = map[string]interface{}{"anyKey": "anyValue"}
			model.Tags = []string{"testString"}
			model.AdditionalFeatures = nil
			model.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
			model.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
			model.Versions = nil
			model.AllVersions = nil

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.Kind
			err = catalogmanagementv1.UnmarshalKind(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalKindAllVersions successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.KindAllVersions)
			model.First = nil
			model.Next = nil

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.KindAllVersions
			err = catalogmanagementv1.UnmarshalKindAllVersions(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalLearnMoreLinks successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.LearnMoreLinks)
			model.FirstParty = core.StringPtr("testString")
			model.ThirdParty = core.StringPtr("testString")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.LearnMoreLinks
			err = catalogmanagementv1.UnmarshalLearnMoreLinks(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalLicense successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.License)
			model.ID = core.StringPtr("testString")
			model.Name = core.StringPtr("testString")
			model.Type = core.StringPtr("testString")
			model.URL = core.StringPtr("testString")
			model.Description = core.StringPtr("testString")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.License
			err = catalogmanagementv1.UnmarshalLicense(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalMediaItem successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.MediaItem)
			model.URL = core.StringPtr("testString")
			model.APIURL = core.StringPtr("testString")
			model.URLProxy = nil
			model.Caption = core.StringPtr("testString")
			model.CaptionI18n = map[string]string{"key1": "testString"}
			model.Type = core.StringPtr("testString")
			model.ThumbnailURL = core.StringPtr("testString")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.MediaItem
			err = catalogmanagementv1.UnmarshalMediaItem(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalOffering successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.Offering)
			model.ID = core.StringPtr("testString")
			model.Rev = core.StringPtr("testString")
			model.URL = core.StringPtr("testString")
			model.CRN = core.StringPtr("testString")
			model.Label = core.StringPtr("testString")
			model.LabelI18n = map[string]string{"key1": "testString"}
			model.Name = core.StringPtr("testString")
			model.OfferingIconURL = core.StringPtr("testString")
			model.OfferingDocsURL = core.StringPtr("testString")
			model.OfferingSupportURL = core.StringPtr("testString")
			model.Tags = []string{"testString"}
			model.Keywords = []string{"testString"}
			model.Rating = nil
			model.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
			model.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
			model.ShortDescription = core.StringPtr("testString")
			model.ShortDescriptionI18n = map[string]string{"key1": "testString"}
			model.LongDescription = core.StringPtr("testString")
			model.LongDescriptionI18n = map[string]string{"key1": "testString"}
			model.Features = nil
			model.Kinds = nil
			model.Publish = nil
			model.PcManaged = core.BoolPtr(true)
			model.PublishApproved = core.BoolPtr(true)
			model.ShareWithAll = core.BoolPtr(true)
			model.ShareWithIBM = core.BoolPtr(true)
			model.ShareEnabled = core.BoolPtr(true)
			model.PublicOriginalCRN = core.StringPtr("testString")
			model.PublishPublicCRN = core.StringPtr("testString")
			model.PortalApprovalRecord = core.StringPtr("testString")
			model.PortalUIURL = core.StringPtr("testString")
			model.CatalogID = core.StringPtr("testString")
			model.CatalogName = core.StringPtr("testString")
			model.Metadata = map[string]interface{}{"anyKey": "anyValue"}
			model.Disclaimer = core.StringPtr("testString")
			model.Hidden = core.BoolPtr(true)
			model.Provider = core.StringPtr("testString")
			model.ProviderInfo = nil
			model.RepoInfo = nil
			model.ImagePullKeys = nil
			model.Support = nil
			model.Media = nil
			model.DeprecatePending = nil
			model.ProductKind = core.StringPtr("testString")
			model.Badges = nil
			model.Plans = nil

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.Offering
			err = catalogmanagementv1.UnmarshalOffering(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalOfferingInstance successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.OfferingInstance)
			model.ID = core.StringPtr("testString")
			model.Rev = core.StringPtr("testString")
			model.URL = core.StringPtr("testString")
			model.CRN = core.StringPtr("testString")
			model.Label = core.StringPtr("testString")
			model.CatalogID = core.StringPtr("testString")
			model.OfferingID = core.StringPtr("testString")
			model.KindFormat = core.StringPtr("testString")
			model.KindFormatLabel = core.StringPtr("testString")
			model.Version = core.StringPtr("testString")
			model.VersionID = core.StringPtr("testString")
			model.ClusterID = core.StringPtr("testString")
			model.ClusterRegion = core.StringPtr("testString")
			model.ClusterNamespaces = []string{"testString"}
			model.ClusterAllNamespaces = core.BoolPtr(true)
			model.SchematicsWorkspaceID = core.StringPtr("testString")
			model.InstallPlan = core.StringPtr("testString")
			model.Channel = core.StringPtr("testString")
			model.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
			model.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
			model.Metadata = map[string]interface{}{"anyKey": "anyValue"}
			model.ResourceGroupID = core.StringPtr("testString")
			model.Location = core.StringPtr("testString")
			model.Disabled = core.BoolPtr(true)
			model.Account = core.StringPtr("testString")
			model.LastOperation = nil
			model.KindTarget = core.StringPtr("testString")
			model.KindTargetLabel = core.StringPtr("testString")
			model.Sha = core.StringPtr("testString")
			model.PlanID = core.StringPtr("testString")
			model.ParentCRN = core.StringPtr("testString")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.OfferingInstance
			err = catalogmanagementv1.UnmarshalOfferingInstance(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalOfferingInstanceLastOperation successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.OfferingInstanceLastOperation)
			model.Operation = core.StringPtr("testString")
			model.State = core.StringPtr("testString")
			model.Message = core.StringPtr("testString")
			model.TransactionID = core.StringPtr("testString")
			model.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
			model.Code = core.StringPtr("testString")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.OfferingInstanceLastOperation
			err = catalogmanagementv1.UnmarshalOfferingInstanceLastOperation(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalOfferingReference successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.OfferingReference)
			model.CatalogID = core.StringPtr("testString")
			model.ID = core.StringPtr("testString")
			model.Name = core.StringPtr("testString")
			model.Kind = core.StringPtr("testString")
			model.Version = core.StringPtr("testString")
			model.Description = core.StringPtr("testString")
			model.DefaultFlavor = core.StringPtr("testString")
			model.Flavors = []string{"testString"}
			model.Optional = core.BoolPtr(true)
			model.OnByDefault = core.BoolPtr(true)

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.OfferingReference
			err = catalogmanagementv1.UnmarshalOfferingReference(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalOutput successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.Output)
			model.Key = core.StringPtr("testString")
			model.Description = core.StringPtr("testString")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.Output
			err = catalogmanagementv1.UnmarshalOutput(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalPaginationTokenLink successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.PaginationTokenLink)
			model.Href = core.StringPtr("testString")
			model.Start = core.StringPtr("testString")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.PaginationTokenLink
			err = catalogmanagementv1.UnmarshalPaginationTokenLink(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalPlan successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.Plan)
			model.ID = core.StringPtr("testString")
			model.Rev = core.StringPtr("testString")
			model.URL = core.StringPtr("testString")
			model.CRN = core.StringPtr("testString")
			model.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
			model.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
			model.OfferingID = core.StringPtr("testString")
			model.CatalogID = core.StringPtr("testString")
			model.Label = core.StringPtr("testString")
			model.LabelI18n = map[string]string{"key1": "testString"}
			model.Name = core.StringPtr("testString")
			model.ShortDescription = core.StringPtr("testString")
			model.ShortDescriptionI18n = map[string]string{"key1": "testString"}
			model.PricingTags = []string{"testString"}
			model.VersionRange = nil
			model.Features = nil
			model.State = nil
			model.DeprecatePending = nil
			model.Metadata = map[string]interface{}{"anyKey": "anyValue"}
			model.PublishApproved = core.BoolPtr(true)

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.Plan
			err = catalogmanagementv1.UnmarshalPlan(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalProject successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.Project)
			model.Name = core.StringPtr("testString")
			model.Metadata = map[string]interface{}{"anyKey": "anyValue"}
			model.PastBreakdown = nil
			model.Breakdown = nil
			model.Diff = nil
			model.Summary = nil

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.Project
			err = catalogmanagementv1.UnmarshalProject(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalProviderInfo successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.ProviderInfo)
			model.ID = core.StringPtr("testString")
			model.Name = core.StringPtr("testString")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.ProviderInfo
			err = catalogmanagementv1.UnmarshalProviderInfo(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalPublishObject successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.PublishObject)
			model.PcManaged = core.BoolPtr(true)
			model.ApprovalType = core.StringPtr("testString")
			model.PublishApproved = core.BoolPtr(true)
			model.ShareWithAll = core.BoolPtr(true)
			model.ShareWithIBM = core.BoolPtr(true)
			model.ShareEnabled = core.BoolPtr(true)
			model.OriginalCRN = core.StringPtr("testString")
			model.PublicCRN = core.StringPtr("testString")
			model.ApprovalRecord = map[string]interface{}{"anyKey": "anyValue"}
			model.PermitIBMPublicPublish = core.BoolPtr(true)
			model.IBMApproved = core.BoolPtr(true)
			model.PublicApproved = core.BoolPtr(true)

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.PublishObject
			err = catalogmanagementv1.UnmarshalPublishObject(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalRating successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.Rating)
			model.OneStarCount = core.Int64Ptr(int64(38))
			model.TwoStarCount = core.Int64Ptr(int64(38))
			model.ThreeStarCount = core.Int64Ptr(int64(38))
			model.FourStarCount = core.Int64Ptr(int64(38))

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.Rating
			err = catalogmanagementv1.UnmarshalRating(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalRenderType successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.RenderType)
			model.Type = core.StringPtr("testString")
			model.Grouping = core.StringPtr("testString")
			model.OriginalGrouping = core.StringPtr("testString")
			model.GroupingIndex = core.Int64Ptr(int64(38))
			model.ConfigConstraints = map[string]interface{}{"anyKey": "anyValue"}
			model.Associations = nil

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.RenderType
			err = catalogmanagementv1.UnmarshalRenderType(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalRenderTypeAssociations successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.RenderTypeAssociations)
			model.Parameters = nil

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.RenderTypeAssociations
			err = catalogmanagementv1.UnmarshalRenderTypeAssociations(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalRenderTypeAssociationsParametersItem successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.RenderTypeAssociationsParametersItem)
			model.Name = core.StringPtr("testString")
			model.OptionsRefresh = core.BoolPtr(true)

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.RenderTypeAssociationsParametersItem
			err = catalogmanagementv1.UnmarshalRenderTypeAssociationsParametersItem(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalRepoInfo successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.RepoInfo)
			model.Token = core.StringPtr("testString")
			model.Type = core.StringPtr("testString")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.RepoInfo
			err = catalogmanagementv1.UnmarshalRepoInfo(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalResource successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.Resource)
			model.Type = core.StringPtr("mem")
			model.Value = "testString"

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.Resource
			err = catalogmanagementv1.UnmarshalResource(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalResult successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.Result)
			model.FailureCount = core.Int64Ptr(int64(38))
			model.ScanTime = CreateMockDateTime("2019-01-01T12:00:00.000Z")
			model.ErrorMessage = core.StringPtr("testString")
			model.CompleteScan = core.BoolPtr(true)
			model.UnscannedResources = []string{"testString"}

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.Result
			err = catalogmanagementv1.UnmarshalResult(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalSccAssessment successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.SccAssessment)
			model.ID = core.StringPtr("testString")
			model.Description = core.StringPtr("testString")
			model.Version = core.StringPtr("testString")
			model.Type = core.StringPtr("testString")
			model.Method = core.StringPtr("testString")
			model.UIHref = core.StringPtr("testString")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.SccAssessment
			err = catalogmanagementv1.UnmarshalSccAssessment(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalSccControl successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.SccControl)
			model.ID = core.StringPtr("testString")
			model.Name = core.StringPtr("testString")
			model.Version = core.StringPtr("testString")
			model.Description = core.StringPtr("testString")
			model.Profile = nil
			model.ParentName = core.StringPtr("testString")
			model.Specifications = nil
			model.UIHref = core.StringPtr("testString")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.SccControl
			err = catalogmanagementv1.UnmarshalSccControl(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalSccProfile successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.SccProfile)
			model.ID = core.StringPtr("testString")
			model.Name = core.StringPtr("testString")
			model.Version = core.StringPtr("testString")
			model.Description = core.StringPtr("testString")
			model.Type = core.StringPtr("testString")
			model.UIHref = core.StringPtr("testString")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.SccProfile
			err = catalogmanagementv1.UnmarshalSccProfile(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalSccSpecification successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.SccSpecification)
			model.ID = core.StringPtr("testString")
			model.Description = core.StringPtr("testString")
			model.ComponentName = core.StringPtr("testString")
			model.Assessments = nil
			model.UIHref = core.StringPtr("testString")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.SccSpecification
			err = catalogmanagementv1.UnmarshalSccSpecification(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalSchematicsEnvValues successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.SchematicsEnvValues)
			model.Value = core.StringPtr("[{\"name\": \"TF_LOG\",\"value\": \"TRACE\",\"secure\": false,\"hidden\": false}]")
			model.SmRef = core.StringPtr("cmsm_v1:{\"name\": \"envVarSecret\",\"id\":\"1234567890\",\"service_id\":\"crn:v1:bluemix:public:secrets-manager:eu-gb:a/1234567890:1234567890::\",\"service_name\":\"My SM Instance\",\"group_id\":\"1234567890\",\"group_name\":\"My SM Group\",\"resource_group_id\":\"1234567890\",\"region\":\"eu-gb\",\"type\":\"arbitrary\"}")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.SchematicsEnvValues
			err = catalogmanagementv1.UnmarshalSchematicsEnvValues(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalScript successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.Script)
			model.Instructions = core.StringPtr("testString")
			model.InstructionsI18n = map[string]string{"key1": "testString"}
			model.Script = core.StringPtr("testString")
			model.ScriptPermission = core.StringPtr("testString")
			model.DeleteScript = core.StringPtr("testString")
			model.Scope = core.StringPtr("testString")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.Script
			err = catalogmanagementv1.UnmarshalScript(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalScriptRef successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.ScriptRef)
			model.ShortDescription = core.StringPtr("testString")
			model.Type = core.StringPtr("ansible")
			model.Path = core.StringPtr("scripts/validate-post-ansible-playbook.yaml")
			model.Stage = core.StringPtr("pre")
			model.Action = core.StringPtr("validate")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.ScriptRef
			err = catalogmanagementv1.UnmarshalScriptRef(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalShareSetting successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.ShareSetting)
			model.IBM = core.BoolPtr(true)
			model.Public = core.BoolPtr(true)
			model.Enabled = core.BoolPtr(true)

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.ShareSetting
			err = catalogmanagementv1.UnmarshalShareSetting(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalSolutionInfo successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.SolutionInfo)
			model.ArchitectureDiagrams = nil
			model.Features = nil
			model.CostEstimate = nil
			model.Dependencies = nil
			model.InstallType = core.StringPtr("testString")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.SolutionInfo
			err = catalogmanagementv1.UnmarshalSolutionInfo(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalState successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.State)
			model.Current = core.StringPtr("testString")
			model.CurrentEntered = CreateMockDateTime("2019-01-01T12:00:00.000Z")
			model.Pending = core.StringPtr("testString")
			model.PendingRequested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
			model.Previous = core.StringPtr("testString")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.State
			err = catalogmanagementv1.UnmarshalState(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalSupport successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.Support)
			model.URL = core.StringPtr("testString")
			model.Process = core.StringPtr("testString")
			model.ProcessI18n = map[string]string{"key1": "testString"}
			model.Locations = []string{"testString"}
			model.SupportDetails = nil
			model.SupportEscalation = nil
			model.SupportType = core.StringPtr("testString")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.Support
			err = catalogmanagementv1.UnmarshalSupport(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalSupportAvailability successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.SupportAvailability)
			model.Times = nil
			model.Timezone = core.StringPtr("testString")
			model.AlwaysAvailable = core.BoolPtr(true)

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.SupportAvailability
			err = catalogmanagementv1.UnmarshalSupportAvailability(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalSupportDetail successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.SupportDetail)
			model.Type = core.StringPtr("testString")
			model.Contact = core.StringPtr("testString")
			model.ResponseWaitTime = nil
			model.Availability = nil

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.SupportDetail
			err = catalogmanagementv1.UnmarshalSupportDetail(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalSupportEscalation successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.SupportEscalation)
			model.EscalationWaitTime = nil
			model.ResponseWaitTime = nil
			model.Contact = core.StringPtr("testString")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.SupportEscalation
			err = catalogmanagementv1.UnmarshalSupportEscalation(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalSupportTime successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.SupportTime)
			model.Day = core.Int64Ptr(int64(38))
			model.StartTime = core.StringPtr("testString")
			model.EndTime = core.StringPtr("testString")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.SupportTime
			err = catalogmanagementv1.UnmarshalSupportTime(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalSupportWaitTime successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.SupportWaitTime)
			model.Value = core.Int64Ptr(int64(38))
			model.Type = core.StringPtr("testString")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.SupportWaitTime
			err = catalogmanagementv1.UnmarshalSupportWaitTime(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalTargetAccountContext successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.TargetAccountContext)
			model.APIKey = core.StringPtr("testString")
			model.TrustedProfile = nil
			model.Name = core.StringPtr("testString")
			model.Label = core.StringPtr("testString")
			model.ProjectID = core.StringPtr("testString")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.TargetAccountContext
			err = catalogmanagementv1.UnmarshalTargetAccountContext(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalTrustedProfileInfo successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.TrustedProfileInfo)
			model.TrustedProfileID = core.StringPtr("testString")
			model.CatalogCRN = core.StringPtr("testString")
			model.CatalogName = core.StringPtr("testString")
			model.TargetServiceID = core.StringPtr("testString")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.TrustedProfileInfo
			err = catalogmanagementv1.UnmarshalTrustedProfileInfo(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalURLProxy successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.URLProxy)
			model.URL = core.StringPtr("testString")
			model.Sha = core.StringPtr("testString")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.URLProxy
			err = catalogmanagementv1.UnmarshalURLProxy(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalValidation successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.Validation)
			model.Validated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
			model.Requested = CreateMockDateTime("2019-01-01T12:00:00.000Z")
			model.State = core.StringPtr("testString")
			model.LastOperation = core.StringPtr("testString")
			model.Target = map[string]interface{}{"anyKey": "anyValue"}
			model.Message = core.StringPtr("testString")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.Validation
			err = catalogmanagementv1.UnmarshalValidation(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalVersion successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.Version)
			model.ID = core.StringPtr("testString")
			model.Rev = core.StringPtr("testString")
			model.CRN = core.StringPtr("testString")
			model.Version = core.StringPtr("testString")
			model.Flavor = nil
			model.Sha = core.StringPtr("testString")
			model.Created = CreateMockDateTime("2019-01-01T12:00:00.000Z")
			model.Updated = CreateMockDateTime("2019-01-01T12:00:00.000Z")
			model.OfferingID = core.StringPtr("testString")
			model.CatalogID = core.StringPtr("testString")
			model.KindID = core.StringPtr("testString")
			model.Tags = []string{"testString"}
			model.RepoURL = core.StringPtr("testString")
			model.SourceURL = core.StringPtr("testString")
			model.TgzURL = core.StringPtr("testString")
			model.Configuration = nil
			model.Outputs = nil
			model.IamPermissions = nil
			model.Metadata = map[string]interface{}{"anyKey": "anyValue"}
			model.Validation = nil
			model.RequiredResources = nil
			model.SingleInstance = core.BoolPtr(true)
			model.SchematicsEnvValues = nil
			model.Install = nil
			model.PreInstall = nil
			model.Scripts = nil
			model.Entitlement = nil
			model.Licenses = nil
			model.ImageManifestURL = core.StringPtr("testString")
			model.Deprecated = core.BoolPtr(true)
			model.PackageVersion = core.StringPtr("testString")
			model.State = nil
			model.VersionLocator = core.StringPtr("testString")
			model.LongDescription = core.StringPtr("testString")
			model.LongDescriptionI18n = map[string]string{"key1": "testString"}
			model.WhitelistedAccounts = []string{"testString"}
			model.ImagePullKeyName = core.StringPtr("testString")
			model.DeprecatePending = nil
			model.SolutionInfo = nil
			model.IsConsumable = core.BoolPtr(true)
			model.ComplianceV3 = nil
			model.ChangeNotices = nil
			model.PlanIds = []string{"testString"}
			model.Stack = map[string]interface{}{"anyKey": "anyValue"}
			model.MinimumCompatibleVersion = core.StringPtr("testString")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.Version
			err = catalogmanagementv1.UnmarshalVersion(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalVersionEntitlement successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.VersionEntitlement)
			model.ProviderName = core.StringPtr("testString")
			model.ProviderID = core.StringPtr("testString")
			model.ProductID = core.StringPtr("testString")
			model.PartNumbers = []string{"testString"}
			model.ImageRepoName = core.StringPtr("testString")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.VersionEntitlement
			err = catalogmanagementv1.UnmarshalVersionEntitlement(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalVersionRange successfully`, func() {
			// Construct an instance of the model.
			model := new(catalogmanagementv1.VersionRange)
			model.Kinds = []string{"testString"}
			model.Version = core.StringPtr("testString")
			model.Flavors = []string{"testString"}

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *catalogmanagementv1.VersionRange
			err = catalogmanagementv1.UnmarshalVersionRange(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
	})
	Describe(`Utility function tests`, func() {
		It(`Invoke CreateMockByteArray() successfully`, func() {
			mockByteArray := CreateMockByteArray("VGhpcyBpcyBhIHRlc3Qgb2YgdGhlIGVtZXJnZW5jeSBicm9hZGNhc3Qgc3lzdGVt")
			Expect(mockByteArray).ToNot(BeNil())
		})
		It(`Invoke CreateMockUUID() successfully`, func() {
			mockUUID := CreateMockUUID("9fab83da-98cb-4f18-a7ba-b6f0435c9673")
			Expect(mockUUID).ToNot(BeNil())
		})
		It(`Invoke CreateMockReader() successfully`, func() {
			mockReader := CreateMockReader("This is a test.")
			Expect(mockReader).ToNot(BeNil())
		})
		It(`Invoke CreateMockDate() successfully`, func() {
			mockDate := CreateMockDate("2019-01-01")
			Expect(mockDate).ToNot(BeNil())
		})
		It(`Invoke CreateMockDateTime() successfully`, func() {
			mockDateTime := CreateMockDateTime("2019-01-01T12:00:00.000Z")
			Expect(mockDateTime).ToNot(BeNil())
		})
	})
})

//
// Utility functions used by the generated test code
//

func CreateMockByteArray(encodedString string) *[]byte {
	ba, err := base64.StdEncoding.DecodeString(encodedString)
	if err != nil {
		panic(err)
	}
	return &ba
}

func CreateMockUUID(mockData string) *strfmt.UUID {
	uuid := strfmt.UUID(mockData)
	return &uuid
}

func CreateMockReader(mockData string) io.ReadCloser {
	return io.NopCloser(bytes.NewReader([]byte(mockData)))
}

func CreateMockDate(mockData string) *strfmt.Date {
	d, err := core.ParseDate(mockData)
	if err != nil {
		return nil
	}
	return &d
}

func CreateMockDateTime(mockData string) *strfmt.DateTime {
	d, err := core.ParseDateTime(mockData)
	if err != nil {
		return nil
	}
	return &d
}

func SetTestEnvironment(testEnvironment map[string]string) {
	for key, value := range testEnvironment {
		os.Setenv(key, value)
	}
}

func ClearTestEnvironment(testEnvironment map[string]string) {
	for key := range testEnvironment {
		os.Unsetenv(key)
	}
}
