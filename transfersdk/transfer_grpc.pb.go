// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v3.21.5
// source: transfer.proto

package transfersdk

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	TransferService_Validate_FullMethodName                 = "/transfersdk.TransferService/Validate"
	TransferService_StartTransfer_FullMethodName            = "/transfersdk.TransferService/StartTransfer"
	TransferService_StartTransferWithMonitor_FullMethodName = "/transfersdk.TransferService/StartTransferWithMonitor"
	TransferService_QueryTransfer_FullMethodName            = "/transfersdk.TransferService/QueryTransfer"
	TransferService_ModifyTransfer_FullMethodName           = "/transfersdk.TransferService/ModifyTransfer"
	TransferService_AddTransferPaths_FullMethodName         = "/transfersdk.TransferService/AddTransferPaths"
	TransferService_LockPersistentTransfer_FullMethodName   = "/transfersdk.TransferService/LockPersistentTransfer"
	TransferService_StopTransfer_FullMethodName             = "/transfersdk.TransferService/StopTransfer"
	TransferService_MonitorTransfers_FullMethodName         = "/transfersdk.TransferService/MonitorTransfers"
	TransferService_GetAPIVersion_FullMethodName            = "/transfersdk.TransferService/GetAPIVersion"
	TransferService_GetInfo_FullMethodName                  = "/transfersdk.TransferService/GetInfo"
	TransferService_IsPeerReachable_FullMethodName          = "/transfersdk.TransferService/IsPeerReachable"
	TransferService_WriteStreamChunk_FullMethodName         = "/transfersdk.TransferService/WriteStreamChunk"
	TransferService_WriteStream_FullMethodName              = "/transfersdk.TransferService/WriteStream"
	TransferService_ReadStream_FullMethodName               = "/transfersdk.TransferService/ReadStream"
)

// TransferServiceClient is the client API for TransferService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TransferServiceClient interface {
	// Validate accepts a transfer spec string and a transfer type, and returns the validation result.
	Validate(ctx context.Context, in *ValidationRequest, opts ...grpc.CallOption) (*ValidationResponse, error)
	// StartTransfer starts a new transfer and returns the transfer information required to manage and monitor the transfer.
	// This request doesn't close until the transfer is terminated or the request is canceled by the client.
	StartTransfer(ctx context.Context, in *TransferRequest, opts ...grpc.CallOption) (*StartTransferResponse, error)
	// StartTransferWithMonitor starts a new transfer and streams back the transfer events.
	// The request doesn't return immediately, as it continues streaming responses to the client until the transfer is terminated or the request is canceled
	// by the client.
	StartTransferWithMonitor(ctx context.Context, in *TransferRequest, opts ...grpc.CallOption) (TransferService_StartTransferWithMonitorClient, error)
	// QueryTransfer requests transfer data.
	QueryTransfer(ctx context.Context, in *TransferInfoRequest, opts ...grpc.CallOption) (*QueryTransferResponse, error)
	// ModifyTransfer modifies an existing transfer.
	ModifyTransfer(ctx context.Context, in *TransferModificationRequest, opts ...grpc.CallOption) (*TransferModificationResponse, error)
	// AddTransferPaths can be used with persistent transfer to add paths to an existing transfer.
	// (type TransferType.FILE_PERSISTENT).
	AddTransferPaths(ctx context.Context, in *TransferPathRequest, opts ...grpc.CallOption) (*TransferPathResponse, error)
	// LockPersistentTransfer, used with persistent transfer, marks an existing persistent transfer as done.
	// Once the method is called, any subsequent call to AddTransferPaths results in an error.
	// (type TransferType.FILE_PERSISTENT).
	LockPersistentTransfer(ctx context.Context, in *LockPersistentTransferRequest, opts ...grpc.CallOption) (*LockPersistentTransferResponse, error)
	// StopTransfer stops a transfer.
	StopTransfer(ctx context.Context, in *StopTransferRequest, opts ...grpc.CallOption) (*StopTransferResponse, error)
	// MonitorTransfers monitors transfers matching the defined filters and streams back the transfer events.
	// The request doesn't return an immediate response because MonitorTransfers continues streaming
	// responses to the client until the client cancels the request.
	MonitorTransfers(ctx context.Context, in *RegistrationRequest, opts ...grpc.CallOption) (TransferService_MonitorTransfersClient, error)
	// GetAPIVersion gets the API version.
	GetAPIVersion(ctx context.Context, in *APIVersionRequest, opts ...grpc.CallOption) (*APIVersionResponse, error)
	// GetInfo gets data about the Transfer SDK service instance.
	GetInfo(ctx context.Context, in *InstanceInfoRequest, opts ...grpc.CallOption) (*InstanceInfoResponse, error)
	// IsPeerReachable confirms whether or not the peer endpoint is reachable.
	IsPeerReachable(ctx context.Context, in *PeerCheckRequest, opts ...grpc.CallOption) (*PeerCheckResponse, error)
	// WriteStreamChunk writes chunks of streaming data for the specified in-progress
	// transfer of type PERSISTENT_STREAM_UPLOAD, at a specific offset.
	// When StopTransfer is called on the transfer, subsequent calls to this function will fail.
	WriteStreamChunk(ctx context.Context, opts ...grpc.CallOption) (TransferService_WriteStreamChunkClient, error)
	// WriteStream writes chunks of streaming data for the specified in-progress transfer of type STREAM_TO_FILE_UPLOAD.
	// Once StopTransfer is called on the transfer, subsequent calls to this function will fail.
	WriteStream(ctx context.Context, opts ...grpc.CallOption) (TransferService_WriteStreamClient, error)
	// ReadStream reads chunks of streaming data from a specified in-progress transfer of type FILE_TO_STREAM_DOWNLOAD.
	// Once StopTransfer is called on this transfer, subsequent calls to this function will fail.
	ReadStream(ctx context.Context, in *ReadStreamRequest, opts ...grpc.CallOption) (TransferService_ReadStreamClient, error)
}

type transferServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTransferServiceClient(cc grpc.ClientConnInterface) TransferServiceClient {
	return &transferServiceClient{cc}
}

func (c *transferServiceClient) Validate(ctx context.Context, in *ValidationRequest, opts ...grpc.CallOption) (*ValidationResponse, error) {
	out := new(ValidationResponse)
	err := c.cc.Invoke(ctx, TransferService_Validate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transferServiceClient) StartTransfer(ctx context.Context, in *TransferRequest, opts ...grpc.CallOption) (*StartTransferResponse, error) {
	out := new(StartTransferResponse)
	err := c.cc.Invoke(ctx, TransferService_StartTransfer_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transferServiceClient) StartTransferWithMonitor(ctx context.Context, in *TransferRequest, opts ...grpc.CallOption) (TransferService_StartTransferWithMonitorClient, error) {
	stream, err := c.cc.NewStream(ctx, &TransferService_ServiceDesc.Streams[0], TransferService_StartTransferWithMonitor_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &transferServiceStartTransferWithMonitorClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type TransferService_StartTransferWithMonitorClient interface {
	Recv() (*TransferResponse, error)
	grpc.ClientStream
}

type transferServiceStartTransferWithMonitorClient struct {
	grpc.ClientStream
}

func (x *transferServiceStartTransferWithMonitorClient) Recv() (*TransferResponse, error) {
	m := new(TransferResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *transferServiceClient) QueryTransfer(ctx context.Context, in *TransferInfoRequest, opts ...grpc.CallOption) (*QueryTransferResponse, error) {
	out := new(QueryTransferResponse)
	err := c.cc.Invoke(ctx, TransferService_QueryTransfer_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transferServiceClient) ModifyTransfer(ctx context.Context, in *TransferModificationRequest, opts ...grpc.CallOption) (*TransferModificationResponse, error) {
	out := new(TransferModificationResponse)
	err := c.cc.Invoke(ctx, TransferService_ModifyTransfer_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transferServiceClient) AddTransferPaths(ctx context.Context, in *TransferPathRequest, opts ...grpc.CallOption) (*TransferPathResponse, error) {
	out := new(TransferPathResponse)
	err := c.cc.Invoke(ctx, TransferService_AddTransferPaths_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transferServiceClient) LockPersistentTransfer(ctx context.Context, in *LockPersistentTransferRequest, opts ...grpc.CallOption) (*LockPersistentTransferResponse, error) {
	out := new(LockPersistentTransferResponse)
	err := c.cc.Invoke(ctx, TransferService_LockPersistentTransfer_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transferServiceClient) StopTransfer(ctx context.Context, in *StopTransferRequest, opts ...grpc.CallOption) (*StopTransferResponse, error) {
	out := new(StopTransferResponse)
	err := c.cc.Invoke(ctx, TransferService_StopTransfer_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transferServiceClient) MonitorTransfers(ctx context.Context, in *RegistrationRequest, opts ...grpc.CallOption) (TransferService_MonitorTransfersClient, error) {
	stream, err := c.cc.NewStream(ctx, &TransferService_ServiceDesc.Streams[1], TransferService_MonitorTransfers_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &transferServiceMonitorTransfersClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type TransferService_MonitorTransfersClient interface {
	Recv() (*TransferResponse, error)
	grpc.ClientStream
}

type transferServiceMonitorTransfersClient struct {
	grpc.ClientStream
}

func (x *transferServiceMonitorTransfersClient) Recv() (*TransferResponse, error) {
	m := new(TransferResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *transferServiceClient) GetAPIVersion(ctx context.Context, in *APIVersionRequest, opts ...grpc.CallOption) (*APIVersionResponse, error) {
	out := new(APIVersionResponse)
	err := c.cc.Invoke(ctx, TransferService_GetAPIVersion_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transferServiceClient) GetInfo(ctx context.Context, in *InstanceInfoRequest, opts ...grpc.CallOption) (*InstanceInfoResponse, error) {
	out := new(InstanceInfoResponse)
	err := c.cc.Invoke(ctx, TransferService_GetInfo_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transferServiceClient) IsPeerReachable(ctx context.Context, in *PeerCheckRequest, opts ...grpc.CallOption) (*PeerCheckResponse, error) {
	out := new(PeerCheckResponse)
	err := c.cc.Invoke(ctx, TransferService_IsPeerReachable_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transferServiceClient) WriteStreamChunk(ctx context.Context, opts ...grpc.CallOption) (TransferService_WriteStreamChunkClient, error) {
	stream, err := c.cc.NewStream(ctx, &TransferService_ServiceDesc.Streams[2], TransferService_WriteStreamChunk_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &transferServiceWriteStreamChunkClient{stream}
	return x, nil
}

type TransferService_WriteStreamChunkClient interface {
	Send(*WriteStreamChunkRequest) error
	CloseAndRecv() (*WriteStreamChunkResponse, error)
	grpc.ClientStream
}

type transferServiceWriteStreamChunkClient struct {
	grpc.ClientStream
}

func (x *transferServiceWriteStreamChunkClient) Send(m *WriteStreamChunkRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *transferServiceWriteStreamChunkClient) CloseAndRecv() (*WriteStreamChunkResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(WriteStreamChunkResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *transferServiceClient) WriteStream(ctx context.Context, opts ...grpc.CallOption) (TransferService_WriteStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &TransferService_ServiceDesc.Streams[3], TransferService_WriteStream_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &transferServiceWriteStreamClient{stream}
	return x, nil
}

type TransferService_WriteStreamClient interface {
	Send(*WriteStreamRequest) error
	CloseAndRecv() (*WriteStreamResponse, error)
	grpc.ClientStream
}

type transferServiceWriteStreamClient struct {
	grpc.ClientStream
}

func (x *transferServiceWriteStreamClient) Send(m *WriteStreamRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *transferServiceWriteStreamClient) CloseAndRecv() (*WriteStreamResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(WriteStreamResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *transferServiceClient) ReadStream(ctx context.Context, in *ReadStreamRequest, opts ...grpc.CallOption) (TransferService_ReadStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &TransferService_ServiceDesc.Streams[4], TransferService_ReadStream_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &transferServiceReadStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type TransferService_ReadStreamClient interface {
	Recv() (*ReadStreamResponse, error)
	grpc.ClientStream
}

type transferServiceReadStreamClient struct {
	grpc.ClientStream
}

func (x *transferServiceReadStreamClient) Recv() (*ReadStreamResponse, error) {
	m := new(ReadStreamResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// TransferServiceServer is the server API for TransferService service.
// All implementations must embed UnimplementedTransferServiceServer
// for forward compatibility
type TransferServiceServer interface {
	// Validate accepts a transfer spec string and a transfer type, and returns the validation result.
	Validate(context.Context, *ValidationRequest) (*ValidationResponse, error)
	// StartTransfer starts a new transfer and returns the transfer information required to manage and monitor the transfer.
	// This request doesn't close until the transfer is terminated or the request is canceled by the client.
	StartTransfer(context.Context, *TransferRequest) (*StartTransferResponse, error)
	// StartTransferWithMonitor starts a new transfer and streams back the transfer events.
	// The request doesn't return immediately, as it continues streaming responses to the client until the transfer is terminated or the request is canceled
	// by the client.
	StartTransferWithMonitor(*TransferRequest, TransferService_StartTransferWithMonitorServer) error
	// QueryTransfer requests transfer data.
	QueryTransfer(context.Context, *TransferInfoRequest) (*QueryTransferResponse, error)
	// ModifyTransfer modifies an existing transfer.
	ModifyTransfer(context.Context, *TransferModificationRequest) (*TransferModificationResponse, error)
	// AddTransferPaths can be used with persistent transfer to add paths to an existing transfer.
	// (type TransferType.FILE_PERSISTENT).
	AddTransferPaths(context.Context, *TransferPathRequest) (*TransferPathResponse, error)
	// LockPersistentTransfer, used with persistent transfer, marks an existing persistent transfer as done.
	// Once the method is called, any subsequent call to AddTransferPaths results in an error.
	// (type TransferType.FILE_PERSISTENT).
	LockPersistentTransfer(context.Context, *LockPersistentTransferRequest) (*LockPersistentTransferResponse, error)
	// StopTransfer stops a transfer.
	StopTransfer(context.Context, *StopTransferRequest) (*StopTransferResponse, error)
	// MonitorTransfers monitors transfers matching the defined filters and streams back the transfer events.
	// The request doesn't return an immediate response because MonitorTransfers continues streaming
	// responses to the client until the client cancels the request.
	MonitorTransfers(*RegistrationRequest, TransferService_MonitorTransfersServer) error
	// GetAPIVersion gets the API version.
	GetAPIVersion(context.Context, *APIVersionRequest) (*APIVersionResponse, error)
	// GetInfo gets data about the Transfer SDK service instance.
	GetInfo(context.Context, *InstanceInfoRequest) (*InstanceInfoResponse, error)
	// IsPeerReachable confirms whether or not the peer endpoint is reachable.
	IsPeerReachable(context.Context, *PeerCheckRequest) (*PeerCheckResponse, error)
	// WriteStreamChunk writes chunks of streaming data for the specified in-progress
	// transfer of type PERSISTENT_STREAM_UPLOAD, at a specific offset.
	// When StopTransfer is called on the transfer, subsequent calls to this function will fail.
	WriteStreamChunk(TransferService_WriteStreamChunkServer) error
	// WriteStream writes chunks of streaming data for the specified in-progress transfer of type STREAM_TO_FILE_UPLOAD.
	// Once StopTransfer is called on the transfer, subsequent calls to this function will fail.
	WriteStream(TransferService_WriteStreamServer) error
	// ReadStream reads chunks of streaming data from a specified in-progress transfer of type FILE_TO_STREAM_DOWNLOAD.
	// Once StopTransfer is called on this transfer, subsequent calls to this function will fail.
	ReadStream(*ReadStreamRequest, TransferService_ReadStreamServer) error
	mustEmbedUnimplementedTransferServiceServer()
}

// UnimplementedTransferServiceServer must be embedded to have forward compatible implementations.
type UnimplementedTransferServiceServer struct {
}

func (UnimplementedTransferServiceServer) Validate(context.Context, *ValidationRequest) (*ValidationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Validate not implemented")
}
func (UnimplementedTransferServiceServer) StartTransfer(context.Context, *TransferRequest) (*StartTransferResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartTransfer not implemented")
}
func (UnimplementedTransferServiceServer) StartTransferWithMonitor(*TransferRequest, TransferService_StartTransferWithMonitorServer) error {
	return status.Errorf(codes.Unimplemented, "method StartTransferWithMonitor not implemented")
}
func (UnimplementedTransferServiceServer) QueryTransfer(context.Context, *TransferInfoRequest) (*QueryTransferResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryTransfer not implemented")
}
func (UnimplementedTransferServiceServer) ModifyTransfer(context.Context, *TransferModificationRequest) (*TransferModificationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ModifyTransfer not implemented")
}
func (UnimplementedTransferServiceServer) AddTransferPaths(context.Context, *TransferPathRequest) (*TransferPathResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddTransferPaths not implemented")
}
func (UnimplementedTransferServiceServer) LockPersistentTransfer(context.Context, *LockPersistentTransferRequest) (*LockPersistentTransferResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LockPersistentTransfer not implemented")
}
func (UnimplementedTransferServiceServer) StopTransfer(context.Context, *StopTransferRequest) (*StopTransferResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopTransfer not implemented")
}
func (UnimplementedTransferServiceServer) MonitorTransfers(*RegistrationRequest, TransferService_MonitorTransfersServer) error {
	return status.Errorf(codes.Unimplemented, "method MonitorTransfers not implemented")
}
func (UnimplementedTransferServiceServer) GetAPIVersion(context.Context, *APIVersionRequest) (*APIVersionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAPIVersion not implemented")
}
func (UnimplementedTransferServiceServer) GetInfo(context.Context, *InstanceInfoRequest) (*InstanceInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetInfo not implemented")
}
func (UnimplementedTransferServiceServer) IsPeerReachable(context.Context, *PeerCheckRequest) (*PeerCheckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsPeerReachable not implemented")
}
func (UnimplementedTransferServiceServer) WriteStreamChunk(TransferService_WriteStreamChunkServer) error {
	return status.Errorf(codes.Unimplemented, "method WriteStreamChunk not implemented")
}
func (UnimplementedTransferServiceServer) WriteStream(TransferService_WriteStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method WriteStream not implemented")
}
func (UnimplementedTransferServiceServer) ReadStream(*ReadStreamRequest, TransferService_ReadStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method ReadStream not implemented")
}
func (UnimplementedTransferServiceServer) mustEmbedUnimplementedTransferServiceServer() {}

// UnsafeTransferServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TransferServiceServer will
// result in compilation errors.
type UnsafeTransferServiceServer interface {
	mustEmbedUnimplementedTransferServiceServer()
}

func RegisterTransferServiceServer(s grpc.ServiceRegistrar, srv TransferServiceServer) {
	s.RegisterService(&TransferService_ServiceDesc, srv)
}

func _TransferService_Validate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransferServiceServer).Validate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TransferService_Validate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransferServiceServer).Validate(ctx, req.(*ValidationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TransferService_StartTransfer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransferRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransferServiceServer).StartTransfer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TransferService_StartTransfer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransferServiceServer).StartTransfer(ctx, req.(*TransferRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TransferService_StartTransferWithMonitor_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(TransferRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TransferServiceServer).StartTransferWithMonitor(m, &transferServiceStartTransferWithMonitorServer{stream})
}

type TransferService_StartTransferWithMonitorServer interface {
	Send(*TransferResponse) error
	grpc.ServerStream
}

type transferServiceStartTransferWithMonitorServer struct {
	grpc.ServerStream
}

func (x *transferServiceStartTransferWithMonitorServer) Send(m *TransferResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _TransferService_QueryTransfer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransferInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransferServiceServer).QueryTransfer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TransferService_QueryTransfer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransferServiceServer).QueryTransfer(ctx, req.(*TransferInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TransferService_ModifyTransfer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransferModificationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransferServiceServer).ModifyTransfer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TransferService_ModifyTransfer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransferServiceServer).ModifyTransfer(ctx, req.(*TransferModificationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TransferService_AddTransferPaths_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransferPathRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransferServiceServer).AddTransferPaths(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TransferService_AddTransferPaths_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransferServiceServer).AddTransferPaths(ctx, req.(*TransferPathRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TransferService_LockPersistentTransfer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LockPersistentTransferRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransferServiceServer).LockPersistentTransfer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TransferService_LockPersistentTransfer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransferServiceServer).LockPersistentTransfer(ctx, req.(*LockPersistentTransferRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TransferService_StopTransfer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopTransferRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransferServiceServer).StopTransfer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TransferService_StopTransfer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransferServiceServer).StopTransfer(ctx, req.(*StopTransferRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TransferService_MonitorTransfers_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RegistrationRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TransferServiceServer).MonitorTransfers(m, &transferServiceMonitorTransfersServer{stream})
}

type TransferService_MonitorTransfersServer interface {
	Send(*TransferResponse) error
	grpc.ServerStream
}

type transferServiceMonitorTransfersServer struct {
	grpc.ServerStream
}

func (x *transferServiceMonitorTransfersServer) Send(m *TransferResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _TransferService_GetAPIVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(APIVersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransferServiceServer).GetAPIVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TransferService_GetAPIVersion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransferServiceServer).GetAPIVersion(ctx, req.(*APIVersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TransferService_GetInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InstanceInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransferServiceServer).GetInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TransferService_GetInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransferServiceServer).GetInfo(ctx, req.(*InstanceInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TransferService_IsPeerReachable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PeerCheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransferServiceServer).IsPeerReachable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TransferService_IsPeerReachable_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransferServiceServer).IsPeerReachable(ctx, req.(*PeerCheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TransferService_WriteStreamChunk_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(TransferServiceServer).WriteStreamChunk(&transferServiceWriteStreamChunkServer{stream})
}

type TransferService_WriteStreamChunkServer interface {
	SendAndClose(*WriteStreamChunkResponse) error
	Recv() (*WriteStreamChunkRequest, error)
	grpc.ServerStream
}

type transferServiceWriteStreamChunkServer struct {
	grpc.ServerStream
}

func (x *transferServiceWriteStreamChunkServer) SendAndClose(m *WriteStreamChunkResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *transferServiceWriteStreamChunkServer) Recv() (*WriteStreamChunkRequest, error) {
	m := new(WriteStreamChunkRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _TransferService_WriteStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(TransferServiceServer).WriteStream(&transferServiceWriteStreamServer{stream})
}

type TransferService_WriteStreamServer interface {
	SendAndClose(*WriteStreamResponse) error
	Recv() (*WriteStreamRequest, error)
	grpc.ServerStream
}

type transferServiceWriteStreamServer struct {
	grpc.ServerStream
}

func (x *transferServiceWriteStreamServer) SendAndClose(m *WriteStreamResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *transferServiceWriteStreamServer) Recv() (*WriteStreamRequest, error) {
	m := new(WriteStreamRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _TransferService_ReadStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ReadStreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TransferServiceServer).ReadStream(m, &transferServiceReadStreamServer{stream})
}

type TransferService_ReadStreamServer interface {
	Send(*ReadStreamResponse) error
	grpc.ServerStream
}

type transferServiceReadStreamServer struct {
	grpc.ServerStream
}

func (x *transferServiceReadStreamServer) Send(m *ReadStreamResponse) error {
	return x.ServerStream.SendMsg(m)
}

// TransferService_ServiceDesc is the grpc.ServiceDesc for TransferService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TransferService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "transfersdk.TransferService",
	HandlerType: (*TransferServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Validate",
			Handler:    _TransferService_Validate_Handler,
		},
		{
			MethodName: "StartTransfer",
			Handler:    _TransferService_StartTransfer_Handler,
		},
		{
			MethodName: "QueryTransfer",
			Handler:    _TransferService_QueryTransfer_Handler,
		},
		{
			MethodName: "ModifyTransfer",
			Handler:    _TransferService_ModifyTransfer_Handler,
		},
		{
			MethodName: "AddTransferPaths",
			Handler:    _TransferService_AddTransferPaths_Handler,
		},
		{
			MethodName: "LockPersistentTransfer",
			Handler:    _TransferService_LockPersistentTransfer_Handler,
		},
		{
			MethodName: "StopTransfer",
			Handler:    _TransferService_StopTransfer_Handler,
		},
		{
			MethodName: "GetAPIVersion",
			Handler:    _TransferService_GetAPIVersion_Handler,
		},
		{
			MethodName: "GetInfo",
			Handler:    _TransferService_GetInfo_Handler,
		},
		{
			MethodName: "IsPeerReachable",
			Handler:    _TransferService_IsPeerReachable_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StartTransferWithMonitor",
			Handler:       _TransferService_StartTransferWithMonitor_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "MonitorTransfers",
			Handler:       _TransferService_MonitorTransfers_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "WriteStreamChunk",
			Handler:       _TransferService_WriteStreamChunk_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "WriteStream",
			Handler:       _TransferService_WriteStream_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "ReadStream",
			Handler:       _TransferService_ReadStream_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "transfer.proto",
}
