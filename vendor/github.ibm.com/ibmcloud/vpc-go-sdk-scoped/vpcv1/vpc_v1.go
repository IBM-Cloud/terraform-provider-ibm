/**
 * (C) Copyright IBM Corp. 2020.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package vpcv1 : Operations and models for the VpcV1 service
package vpcv1

import (
	"encoding/json"
	"fmt"
	"reflect"

	"github.com/IBM/go-sdk-core/v4/core"
	"github.com/go-openapi/strfmt"
	common "github.ibm.com/ibmcloud/vpc-go-sdk/common"
)

// VpcV1 : The IBM Cloud Virtual Private Cloud (VPC) API can be used to programmatically provision and manage
// infrastructure resources, including virtual server instances, subnets, volumes, and load balancers.
//
// Version: 2020-06-15
type VpcV1 struct {
	Service *core.BaseService

	// Requests the version of the API as of a date in the format `YYYY-MM-DD`. Any date up to the current date may be
	// provided. Specify the current date to request the latest version.
	Version *string

	// The infrastructure generation for the request. For the API behavior documented here, use
	// `2`.
	generation *int64
}

// DefaultServiceURL is the default URL to make service requests to.
const DefaultServiceURL = "https://us-south.iaas.cloud.ibm.com/v1"

// DefaultServiceName is the default key used to find external configuration information.
const DefaultServiceName = "vpc"

// VpcV1Options : Service options
type VpcV1Options struct {
	ServiceName   string
	URL           string
	Authenticator core.Authenticator

	// Requests the version of the API as of a date in the format `YYYY-MM-DD`. Any date up to the current date may be
	// provided. Specify the current date to request the latest version.
	Version *string
}

// NewVpcV1UsingExternalConfig : constructs an instance of VpcV1 with passed in options and external configuration.
func NewVpcV1UsingExternalConfig(options *VpcV1Options) (vpc *VpcV1, err error) {
	if options.ServiceName == "" {
		options.ServiceName = DefaultServiceName
	}

	if options.Authenticator == nil {
		options.Authenticator, err = core.GetAuthenticatorFromEnvironment(options.ServiceName)
		if err != nil {
			return
		}
	}

	vpc, err = NewVpcV1(options)
	if err != nil {
		return
	}

	err = vpc.Service.ConfigureService(options.ServiceName)
	if err != nil {
		return
	}

	if options.URL != "" {
		err = vpc.Service.SetServiceURL(options.URL)
	}
	return
}

// NewVpcV1 : constructs an instance of VpcV1 with passed in options.
func NewVpcV1(options *VpcV1Options) (service *VpcV1, err error) {
	serviceOptions := &core.ServiceOptions{
		URL:           DefaultServiceURL,
		Authenticator: options.Authenticator,
	}

	err = core.ValidateStruct(options, "options")
	if err != nil {
		return
	}

	baseService, err := core.NewBaseService(serviceOptions)
	if err != nil {
		return
	}

	if options.Version == nil {
		options.Version = core.StringPtr("2020-06-15")
	}

	if options.URL != "" {
		err = baseService.SetServiceURL(options.URL)
		if err != nil {
			return
		}
	}

	service = &VpcV1{
		Service:    baseService,
		Version:    options.Version,
		generation: core.Int64Ptr(2),
	}

	return
}

// SetServiceURL sets the service URL
func (vpc *VpcV1) SetServiceURL(url string) error {
	return vpc.Service.SetServiceURL(url)
}

// ListDedicatedHostGroups : List all dedicated host groups
// This request lists all dedicated host groups in the region. Host groups are a collection of dedicated hosts for
// placement of instances. Each dedicated host must belong to one and only one group. Host groups do not span zones.
func (vpc *VpcV1) ListDedicatedHostGroups(listDedicatedHostGroupsOptions *ListDedicatedHostGroupsOptions) (result *DedicatedHostGroupCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listDedicatedHostGroupsOptions, "listDedicatedHostGroupsOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"dedicated_host/groups"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listDedicatedHostGroupsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListDedicatedHostGroups")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listDedicatedHostGroupsOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listDedicatedHostGroupsOptions.Start))
	}
	if listDedicatedHostGroupsOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listDedicatedHostGroupsOptions.Limit))
	}
	if listDedicatedHostGroupsOptions.ResourceGroupID != nil {
		builder.AddQuery("resource_group.id", fmt.Sprint(*listDedicatedHostGroupsOptions.ResourceGroupID))
	}
	if listDedicatedHostGroupsOptions.ZoneName != nil {
		builder.AddQuery("zone.name", fmt.Sprint(*listDedicatedHostGroupsOptions.ZoneName))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalDedicatedHostGroupCollection)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// CreateDedicatedHostGroup : Create a dedicated host group
// This request creates a new dedicated host group.
func (vpc *VpcV1) CreateDedicatedHostGroup(createDedicatedHostGroupOptions *CreateDedicatedHostGroupOptions) (result *DedicatedHostGroup, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(createDedicatedHostGroupOptions, "createDedicatedHostGroupOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"dedicated_host/groups"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.POST)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range createDedicatedHostGroupOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateDedicatedHostGroup")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if createDedicatedHostGroupOptions.Name != nil {
		body["name"] = createDedicatedHostGroupOptions.Name
	}
	if createDedicatedHostGroupOptions.ResourceGroup != nil {
		body["resource_group"] = createDedicatedHostGroupOptions.ResourceGroup
	}
	if createDedicatedHostGroupOptions.Zone != nil {
		body["zone"] = createDedicatedHostGroupOptions.Zone
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalDedicatedHostGroup)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// DeleteDedicatedHostGroup : Delete specified dedicated host group
// This request deletes a dedicated host group.
func (vpc *VpcV1) DeleteDedicatedHostGroup(deleteDedicatedHostGroupOptions *DeleteDedicatedHostGroupOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteDedicatedHostGroupOptions, "deleteDedicatedHostGroupOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteDedicatedHostGroupOptions, "deleteDedicatedHostGroupOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"dedicated_host/groups"}
	pathParameters := []string{*deleteDedicatedHostGroupOptions.ID}

	builder := core.NewRequestBuilder(core.DELETE)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteDedicatedHostGroupOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteDedicatedHostGroup")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetDedicatedHostGroup : Retrieve a dedicated host group
// This request retrieves a single dedicated host group specified by the identifier in the URL.
func (vpc *VpcV1) GetDedicatedHostGroup(getDedicatedHostGroupOptions *GetDedicatedHostGroupOptions) (result *DedicatedHostGroup, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getDedicatedHostGroupOptions, "getDedicatedHostGroupOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getDedicatedHostGroupOptions, "getDedicatedHostGroupOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"dedicated_host/groups"}
	pathParameters := []string{*getDedicatedHostGroupOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getDedicatedHostGroupOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetDedicatedHostGroup")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalDedicatedHostGroup)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// UpdateDedicatedHostGroup : Update specified dedicated host group
// This request updates a dedicated host group with the information in a provided dedicated host group patch. The
// dedicated host group patch object is structured in the same way as a retrieved dedicated host group and contains only
// the information to be updated.
func (vpc *VpcV1) UpdateDedicatedHostGroup(updateDedicatedHostGroupOptions *UpdateDedicatedHostGroupOptions) (result *DedicatedHostGroup, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateDedicatedHostGroupOptions, "updateDedicatedHostGroupOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateDedicatedHostGroupOptions, "updateDedicatedHostGroupOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"dedicated_host/groups"}
	pathParameters := []string{*updateDedicatedHostGroupOptions.ID}

	builder := core.NewRequestBuilder(core.PATCH)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateDedicatedHostGroupOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateDedicatedHostGroup")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if updateDedicatedHostGroupOptions.Name != nil {
		body["name"] = updateDedicatedHostGroupOptions.Name
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalDedicatedHostGroup)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// ListDedicatedHostProfiles : List all dedicated host profiles
// This request lists all dedicated host profiles available in the region. A dedicated host profile specifies the
// hardware characteristics for a dedicated host.
func (vpc *VpcV1) ListDedicatedHostProfiles(listDedicatedHostProfilesOptions *ListDedicatedHostProfilesOptions) (result *DedicatedHostProfileCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listDedicatedHostProfilesOptions, "listDedicatedHostProfilesOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"dedicated_host/profiles"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listDedicatedHostProfilesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListDedicatedHostProfiles")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listDedicatedHostProfilesOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listDedicatedHostProfilesOptions.Start))
	}
	if listDedicatedHostProfilesOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listDedicatedHostProfilesOptions.Limit))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalDedicatedHostProfileCollection)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// GetDedicatedHostProfile : Retrieve specified dedicated host profile
// This request retrieves a single dedicated host profile specified by the name in the URL.
func (vpc *VpcV1) GetDedicatedHostProfile(getDedicatedHostProfileOptions *GetDedicatedHostProfileOptions) (result *DedicatedHostProfile, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getDedicatedHostProfileOptions, "getDedicatedHostProfileOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getDedicatedHostProfileOptions, "getDedicatedHostProfileOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"dedicated_host/profiles"}
	pathParameters := []string{*getDedicatedHostProfileOptions.Name}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getDedicatedHostProfileOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetDedicatedHostProfile")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalDedicatedHostProfile)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// ListDedicatedHosts : List all dedicated hosts
// This request lists all dedicated hosts.
func (vpc *VpcV1) ListDedicatedHosts(listDedicatedHostsOptions *ListDedicatedHostsOptions) (result *DedicatedHostCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listDedicatedHostsOptions, "listDedicatedHostsOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"dedicated_hosts"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listDedicatedHostsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListDedicatedHosts")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listDedicatedHostsOptions.DedicatedHostGroupID != nil {
		builder.AddQuery("dedicated_host_group.id", fmt.Sprint(*listDedicatedHostsOptions.DedicatedHostGroupID))
	}
	if listDedicatedHostsOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listDedicatedHostsOptions.Start))
	}
	if listDedicatedHostsOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listDedicatedHostsOptions.Limit))
	}
	if listDedicatedHostsOptions.ResourceGroupID != nil {
		builder.AddQuery("resource_group.id", fmt.Sprint(*listDedicatedHostsOptions.ResourceGroupID))
	}
	if listDedicatedHostsOptions.ZoneName != nil {
		builder.AddQuery("zone.name", fmt.Sprint(*listDedicatedHostsOptions.ZoneName))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalDedicatedHostCollection)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// CreateDedicatedHost : Create a dedicated host
// This request creates a new dedicated host.
func (vpc *VpcV1) CreateDedicatedHost(createDedicatedHostOptions *CreateDedicatedHostOptions) (result *DedicatedHost, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createDedicatedHostOptions, "createDedicatedHostOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createDedicatedHostOptions, "createDedicatedHostOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"dedicated_hosts"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.POST)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range createDedicatedHostOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateDedicatedHost")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if createDedicatedHostOptions.Group != nil {
		body["group"] = createDedicatedHostOptions.Group
	}
	if createDedicatedHostOptions.Profile != nil {
		body["profile"] = createDedicatedHostOptions.Profile
	}
	if createDedicatedHostOptions.InstancePlacementEnabled != nil {
		body["instance_placement_enabled"] = createDedicatedHostOptions.InstancePlacementEnabled
	}
	if createDedicatedHostOptions.Name != nil {
		body["name"] = createDedicatedHostOptions.Name
	}
	if createDedicatedHostOptions.ResourceGroup != nil {
		body["resource_group"] = createDedicatedHostOptions.ResourceGroup
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalDedicatedHost)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// DeleteDedicatedHost : Delete specified dedicated host
// This request deletes a dedicated host.
func (vpc *VpcV1) DeleteDedicatedHost(deleteDedicatedHostOptions *DeleteDedicatedHostOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteDedicatedHostOptions, "deleteDedicatedHostOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteDedicatedHostOptions, "deleteDedicatedHostOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"dedicated_hosts"}
	pathParameters := []string{*deleteDedicatedHostOptions.ID}

	builder := core.NewRequestBuilder(core.DELETE)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteDedicatedHostOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteDedicatedHost")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetDedicatedHost : Retrieve a dedicated host
// This request retrieves a single dedicated host specified by the identifiers in the URL.
func (vpc *VpcV1) GetDedicatedHost(getDedicatedHostOptions *GetDedicatedHostOptions) (result *DedicatedHost, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getDedicatedHostOptions, "getDedicatedHostOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getDedicatedHostOptions, "getDedicatedHostOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"dedicated_hosts"}
	pathParameters := []string{*getDedicatedHostOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getDedicatedHostOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetDedicatedHost")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalDedicatedHost)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// UpdateDedicatedHost : Update specified dedicated host
// This request updates a dedicated host with the information in a provided dedicated host patch. The dedicated host
// patch object is structured in the same way as a retrieved dedicated host and contains only the information to be
// updated.
func (vpc *VpcV1) UpdateDedicatedHost(updateDedicatedHostOptions *UpdateDedicatedHostOptions) (result *DedicatedHost, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateDedicatedHostOptions, "updateDedicatedHostOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateDedicatedHostOptions, "updateDedicatedHostOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"dedicated_hosts"}
	pathParameters := []string{*updateDedicatedHostOptions.ID}

	builder := core.NewRequestBuilder(core.PATCH)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateDedicatedHostOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateDedicatedHost")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if updateDedicatedHostOptions.InstancePlacementEnabled != nil {
		body["instance_placement_enabled"] = updateDedicatedHostOptions.InstancePlacementEnabled
	}
	if updateDedicatedHostOptions.Name != nil {
		body["name"] = updateDedicatedHostOptions.Name
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalDedicatedHost)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// ListFloatingIps : List all floating IPs
// This request retrieves all floating IPs in the region. Floating IPs allow inbound and outbound traffic from the
// Internet to an instance.
func (vpc *VpcV1) ListFloatingIps(listFloatingIpsOptions *ListFloatingIpsOptions) (result *FloatingIPCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listFloatingIpsOptions, "listFloatingIpsOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"floating_ips"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listFloatingIpsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListFloatingIps")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listFloatingIpsOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listFloatingIpsOptions.Start))
	}
	if listFloatingIpsOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listFloatingIpsOptions.Limit))
	}
	if listFloatingIpsOptions.ResourceGroupID != nil {
		builder.AddQuery("resource_group.id", fmt.Sprint(*listFloatingIpsOptions.ResourceGroupID))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalFloatingIPCollection)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// CreateFloatingIP : Reserve a floating IP
// This request reserves a new floating IP.
func (vpc *VpcV1) CreateFloatingIP(createFloatingIPOptions *CreateFloatingIPOptions) (result *FloatingIP, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createFloatingIPOptions, "createFloatingIPOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createFloatingIPOptions, "createFloatingIPOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"floating_ips"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.POST)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range createFloatingIPOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateFloatingIP")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(createFloatingIPOptions.FloatingIPPrototype)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalFloatingIP)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// DeleteFloatingIP : Release the specified floating IP
// This request disassociates (if associated) and releases a floating IP. This operation cannot be reversed. For this
// request to succeed, the floating IP must not be required by another resource, such as a public gateway.
func (vpc *VpcV1) DeleteFloatingIP(deleteFloatingIPOptions *DeleteFloatingIPOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteFloatingIPOptions, "deleteFloatingIPOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteFloatingIPOptions, "deleteFloatingIPOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"floating_ips"}
	pathParameters := []string{*deleteFloatingIPOptions.ID}

	builder := core.NewRequestBuilder(core.DELETE)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteFloatingIPOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteFloatingIP")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetFloatingIP : Retrieve the specified floating IP
// This request retrieves a single floating IP specified by the identifier in the URL.
func (vpc *VpcV1) GetFloatingIP(getFloatingIPOptions *GetFloatingIPOptions) (result *FloatingIP, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getFloatingIPOptions, "getFloatingIPOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getFloatingIPOptions, "getFloatingIPOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"floating_ips"}
	pathParameters := []string{*getFloatingIPOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getFloatingIPOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetFloatingIP")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalFloatingIP)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// UpdateFloatingIP : Update the specified floating IP
// This request updates a floating IP's name and/or target.
func (vpc *VpcV1) UpdateFloatingIP(updateFloatingIPOptions *UpdateFloatingIPOptions) (result *FloatingIP, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateFloatingIPOptions, "updateFloatingIPOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateFloatingIPOptions, "updateFloatingIPOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"floating_ips"}
	pathParameters := []string{*updateFloatingIPOptions.ID}

	builder := core.NewRequestBuilder(core.PATCH)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateFloatingIPOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateFloatingIP")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if updateFloatingIPOptions.Name != nil {
		body["name"] = updateFloatingIPOptions.Name
	}
	if updateFloatingIPOptions.Target != nil {
		body["target"] = updateFloatingIPOptions.Target
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalFloatingIP)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// ListFlowLogCollectors : List all flow log collectors
// This request retrieves all flow log collectors in the region. A flow log collector summarizes data sent over one or
// more network interfaces within a VPC, depending on the chosen target.
func (vpc *VpcV1) ListFlowLogCollectors(listFlowLogCollectorsOptions *ListFlowLogCollectorsOptions) (result *FlowLogCollectorCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listFlowLogCollectorsOptions, "listFlowLogCollectorsOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"flow_log_collectors"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listFlowLogCollectorsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListFlowLogCollectors")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listFlowLogCollectorsOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listFlowLogCollectorsOptions.Start))
	}
	if listFlowLogCollectorsOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listFlowLogCollectorsOptions.Limit))
	}
	if listFlowLogCollectorsOptions.ResourceGroupID != nil {
		builder.AddQuery("resource_group.id", fmt.Sprint(*listFlowLogCollectorsOptions.ResourceGroupID))
	}
	if listFlowLogCollectorsOptions.Name != nil {
		builder.AddQuery("name", fmt.Sprint(*listFlowLogCollectorsOptions.Name))
	}
	if listFlowLogCollectorsOptions.VPCID != nil {
		builder.AddQuery("vpc.id", fmt.Sprint(*listFlowLogCollectorsOptions.VPCID))
	}
	if listFlowLogCollectorsOptions.VPCCRN != nil {
		builder.AddQuery("vpc.crn", fmt.Sprint(*listFlowLogCollectorsOptions.VPCCRN))
	}
	if listFlowLogCollectorsOptions.VPCName != nil {
		builder.AddQuery("vpc.name", fmt.Sprint(*listFlowLogCollectorsOptions.VPCName))
	}
	if listFlowLogCollectorsOptions.TargetID != nil {
		builder.AddQuery("target.id", fmt.Sprint(*listFlowLogCollectorsOptions.TargetID))
	}
	if listFlowLogCollectorsOptions.TargetResourceType != nil {
		builder.AddQuery("target.resource_type", fmt.Sprint(*listFlowLogCollectorsOptions.TargetResourceType))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalFlowLogCollectorCollection)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// CreateFlowLogCollector : Create a flow log collector
// This request creates and starts a new flow log collector from a flow log collector prototype object. The prototype
// object is structured in the same way as a retrieved flow log collector, and contains the information necessary to
// create and start the new flow log collector.
func (vpc *VpcV1) CreateFlowLogCollector(createFlowLogCollectorOptions *CreateFlowLogCollectorOptions) (result *FlowLogCollector, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createFlowLogCollectorOptions, "createFlowLogCollectorOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createFlowLogCollectorOptions, "createFlowLogCollectorOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"flow_log_collectors"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.POST)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range createFlowLogCollectorOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateFlowLogCollector")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if createFlowLogCollectorOptions.StorageBucket != nil {
		body["storage_bucket"] = createFlowLogCollectorOptions.StorageBucket
	}
	if createFlowLogCollectorOptions.Target != nil {
		body["target"] = createFlowLogCollectorOptions.Target
	}
	if createFlowLogCollectorOptions.Active != nil {
		body["active"] = createFlowLogCollectorOptions.Active
	}
	if createFlowLogCollectorOptions.Name != nil {
		body["name"] = createFlowLogCollectorOptions.Name
	}
	if createFlowLogCollectorOptions.ResourceGroup != nil {
		body["resource_group"] = createFlowLogCollectorOptions.ResourceGroup
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalFlowLogCollector)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// DeleteFlowLogCollector : Delete the specified flow log collector
// This request stops and deletes a flow log collector. Collected flow logs remain available within the flow log
// collector's bucket.
func (vpc *VpcV1) DeleteFlowLogCollector(deleteFlowLogCollectorOptions *DeleteFlowLogCollectorOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteFlowLogCollectorOptions, "deleteFlowLogCollectorOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteFlowLogCollectorOptions, "deleteFlowLogCollectorOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"flow_log_collectors"}
	pathParameters := []string{*deleteFlowLogCollectorOptions.ID}

	builder := core.NewRequestBuilder(core.DELETE)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteFlowLogCollectorOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteFlowLogCollector")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetFlowLogCollector : Retrieve the specified flow log collector
// This request retrieves a single flow log collector specified by the identifier in the URL.
func (vpc *VpcV1) GetFlowLogCollector(getFlowLogCollectorOptions *GetFlowLogCollectorOptions) (result *FlowLogCollector, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getFlowLogCollectorOptions, "getFlowLogCollectorOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getFlowLogCollectorOptions, "getFlowLogCollectorOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"flow_log_collectors"}
	pathParameters := []string{*getFlowLogCollectorOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getFlowLogCollectorOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetFlowLogCollector")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalFlowLogCollector)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// UpdateFlowLogCollector : Update the specified flow log collector
// This request updates a flow log collector with the information in a provided flow log collector patch. The flow log
// collector patch object is structured in the same way as a retrieved flow log collector and contains only the
// information to be updated.
func (vpc *VpcV1) UpdateFlowLogCollector(updateFlowLogCollectorOptions *UpdateFlowLogCollectorOptions) (result *FlowLogCollector, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateFlowLogCollectorOptions, "updateFlowLogCollectorOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateFlowLogCollectorOptions, "updateFlowLogCollectorOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"flow_log_collectors"}
	pathParameters := []string{*updateFlowLogCollectorOptions.ID}

	builder := core.NewRequestBuilder(core.PATCH)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateFlowLogCollectorOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateFlowLogCollector")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if updateFlowLogCollectorOptions.Active != nil {
		body["active"] = updateFlowLogCollectorOptions.Active
	}
	if updateFlowLogCollectorOptions.Name != nil {
		body["name"] = updateFlowLogCollectorOptions.Name
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalFlowLogCollector)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// ListRegions : List all regions
// This request lists all regions. Each region is a separate geographic area that contains multiple isolated zones.
// Resources can be provisioned into a one or more zones in a region. Each zone is isolated, but connected to other
// zones in the same region with low-latency and high-bandwidth links. Regions represent the top-level of fault
// isolation available. Resources deployed within a single region also benefit from the low latency afforded by
// geographic proximity.
func (vpc *VpcV1) ListRegions(listRegionsOptions *ListRegionsOptions) (result *RegionCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listRegionsOptions, "listRegionsOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"regions"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listRegionsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListRegions")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalRegionCollection)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// GetRegion : Retrieve a region
// This request retrieves a single region specified by the name in the URL.
func (vpc *VpcV1) GetRegion(getRegionOptions *GetRegionOptions) (result *Region, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getRegionOptions, "getRegionOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getRegionOptions, "getRegionOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"regions"}
	pathParameters := []string{*getRegionOptions.Name}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getRegionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetRegion")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalRegion)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// ListRegionZones : List all zones in a region
// This request lists all zones in a region. Zones represent logically-isolated data centers with high-bandwidth and
// low-latency interconnects to other zones in the same region. Faults in a zone do not affect other zones.
func (vpc *VpcV1) ListRegionZones(listRegionZonesOptions *ListRegionZonesOptions) (result *ZoneCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listRegionZonesOptions, "listRegionZonesOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listRegionZonesOptions, "listRegionZonesOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"regions", "zones"}
	pathParameters := []string{*listRegionZonesOptions.RegionName}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listRegionZonesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListRegionZones")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalZoneCollection)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// GetRegionZone : Retrieve a zone
// This request retrieves a single zone specified by the region and zone names in the URL.
func (vpc *VpcV1) GetRegionZone(getRegionZoneOptions *GetRegionZoneOptions) (result *Zone, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getRegionZoneOptions, "getRegionZoneOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getRegionZoneOptions, "getRegionZoneOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"regions", "zones"}
	pathParameters := []string{*getRegionZoneOptions.RegionName, *getRegionZoneOptions.ZoneName}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getRegionZoneOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetRegionZone")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalZone)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// ListImages : List all images
// This request lists all images available in the region. An image provides source data for a volume. Images are either
// system-provided, or created from another source, such as importing from object storage.
func (vpc *VpcV1) ListImages(listImagesOptions *ListImagesOptions) (result *ImageCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listImagesOptions, "listImagesOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"images"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listImagesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListImages")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listImagesOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listImagesOptions.Start))
	}
	if listImagesOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listImagesOptions.Limit))
	}
	if listImagesOptions.ResourceGroupID != nil {
		builder.AddQuery("resource_group.id", fmt.Sprint(*listImagesOptions.ResourceGroupID))
	}
	if listImagesOptions.Name != nil {
		builder.AddQuery("name", fmt.Sprint(*listImagesOptions.Name))
	}
	if listImagesOptions.Visibility != nil {
		builder.AddQuery("visibility", fmt.Sprint(*listImagesOptions.Visibility))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalImageCollection)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// CreateImage : Create an image
// This request creates a new image from an image prototype object. The prototype object is structured in the same way
// as a retrieved image, and contains the information necessary to create the new image. A URL to the image file on
// object storage must be provided.
func (vpc *VpcV1) CreateImage(createImageOptions *CreateImageOptions) (result *Image, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createImageOptions, "createImageOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createImageOptions, "createImageOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"images"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.POST)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range createImageOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateImage")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(createImageOptions.ImagePrototype)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalImage)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// DeleteImage : Delete specified image
// This request deletes an image. This operation cannot be reversed. System-provided images are not allowed to be
// deleted. An image with a `status` of `pending`, `tentative`, or `deleting` cannot be deleted.
func (vpc *VpcV1) DeleteImage(deleteImageOptions *DeleteImageOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteImageOptions, "deleteImageOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteImageOptions, "deleteImageOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"images"}
	pathParameters := []string{*deleteImageOptions.ID}

	builder := core.NewRequestBuilder(core.DELETE)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteImageOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteImage")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetImage : Retrieve the specified image
// This request retrieves a single image specified by the identifier in the URL.
func (vpc *VpcV1) GetImage(getImageOptions *GetImageOptions) (result *Image, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getImageOptions, "getImageOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getImageOptions, "getImageOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"images"}
	pathParameters := []string{*getImageOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getImageOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetImage")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalImage)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// UpdateImage : Update specified image
// This request updates an image with the information in a provided image patch. The image patch object is structured in
// the same way as a retrieved image and contains only the information to be updated. System-provided images are not
// allowed to be updated. An image with a `status` of `deleting` cannot be updated.
func (vpc *VpcV1) UpdateImage(updateImageOptions *UpdateImageOptions) (result *Image, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateImageOptions, "updateImageOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateImageOptions, "updateImageOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"images"}
	pathParameters := []string{*updateImageOptions.ID}

	builder := core.NewRequestBuilder(core.PATCH)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateImageOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateImage")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if updateImageOptions.Name != nil {
		body["name"] = updateImageOptions.Name
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalImage)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// ListOperatingSystems : Retrieves all operating systems
// This request retrieves all operating systems.
func (vpc *VpcV1) ListOperatingSystems(listOperatingSystemsOptions *ListOperatingSystemsOptions) (result *OperatingSystemCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listOperatingSystemsOptions, "listOperatingSystemsOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"operating_systems"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listOperatingSystemsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListOperatingSystems")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listOperatingSystemsOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listOperatingSystemsOptions.Start))
	}
	if listOperatingSystemsOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listOperatingSystemsOptions.Limit))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalOperatingSystemCollection)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// GetOperatingSystem : Retrieves an operating system
// This request retrieves a single operating system specified by the name in the URL.
func (vpc *VpcV1) GetOperatingSystem(getOperatingSystemOptions *GetOperatingSystemOptions) (result *OperatingSystem, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getOperatingSystemOptions, "getOperatingSystemOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getOperatingSystemOptions, "getOperatingSystemOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"operating_systems"}
	pathParameters := []string{*getOperatingSystemOptions.Name}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getOperatingSystemOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetOperatingSystem")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalOperatingSystem)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// ListInstanceGroups : List all instance groups
func (vpc *VpcV1) ListInstanceGroups(listInstanceGroupsOptions *ListInstanceGroupsOptions) (result *InstanceGroupCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listInstanceGroupsOptions, "listInstanceGroupsOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"instance_groups"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listInstanceGroupsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListInstanceGroups")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listInstanceGroupsOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listInstanceGroupsOptions.Start))
	}
	if listInstanceGroupsOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listInstanceGroupsOptions.Limit))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalInstanceGroupCollection)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// CreateInstanceGroup : Create an instance group
// This request creates a new instance group.
func (vpc *VpcV1) CreateInstanceGroup(createInstanceGroupOptions *CreateInstanceGroupOptions) (result *InstanceGroup, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createInstanceGroupOptions, "createInstanceGroupOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createInstanceGroupOptions, "createInstanceGroupOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"instance_groups"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.POST)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range createInstanceGroupOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateInstanceGroup")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if createInstanceGroupOptions.InstanceTemplate != nil {
		body["instance_template"] = createInstanceGroupOptions.InstanceTemplate
	}
	if createInstanceGroupOptions.Subnets != nil {
		body["subnets"] = createInstanceGroupOptions.Subnets
	}
	if createInstanceGroupOptions.ApplicationPort != nil {
		body["application_port"] = createInstanceGroupOptions.ApplicationPort
	}
	if createInstanceGroupOptions.LoadBalancer != nil {
		body["load_balancer"] = createInstanceGroupOptions.LoadBalancer
	}
	if createInstanceGroupOptions.LoadBalancerPool != nil {
		body["load_balancer_pool"] = createInstanceGroupOptions.LoadBalancerPool
	}
	if createInstanceGroupOptions.MembershipCount != nil {
		body["membership_count"] = createInstanceGroupOptions.MembershipCount
	}
	if createInstanceGroupOptions.Name != nil {
		body["name"] = createInstanceGroupOptions.Name
	}
	if createInstanceGroupOptions.ResourceGroup != nil {
		body["resource_group"] = createInstanceGroupOptions.ResourceGroup
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalInstanceGroup)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// DeleteInstanceGroup : Delete specified instance group
// This request deletes an instance group. This operation cannot be reversed. Any instances associated with the group
// will be deleted.
func (vpc *VpcV1) DeleteInstanceGroup(deleteInstanceGroupOptions *DeleteInstanceGroupOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteInstanceGroupOptions, "deleteInstanceGroupOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteInstanceGroupOptions, "deleteInstanceGroupOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"instance_groups"}
	pathParameters := []string{*deleteInstanceGroupOptions.ID}

	builder := core.NewRequestBuilder(core.DELETE)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteInstanceGroupOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteInstanceGroup")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetInstanceGroup : Retrieve specified instance group
// This request retrieves a single instance group specified by identifier in the URL.
func (vpc *VpcV1) GetInstanceGroup(getInstanceGroupOptions *GetInstanceGroupOptions) (result *InstanceGroup, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getInstanceGroupOptions, "getInstanceGroupOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getInstanceGroupOptions, "getInstanceGroupOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"instance_groups"}
	pathParameters := []string{*getInstanceGroupOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getInstanceGroupOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetInstanceGroup")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalInstanceGroup)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// UpdateInstanceGroup : Update specified instance group
// This request updates an instance group with the information provided instance group patch. The instance group patch
// object is structured in the same way as a retrieved instance group and contains only the information to be updated.
func (vpc *VpcV1) UpdateInstanceGroup(updateInstanceGroupOptions *UpdateInstanceGroupOptions) (result *InstanceGroup, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateInstanceGroupOptions, "updateInstanceGroupOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateInstanceGroupOptions, "updateInstanceGroupOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"instance_groups"}
	pathParameters := []string{*updateInstanceGroupOptions.ID}

	builder := core.NewRequestBuilder(core.PATCH)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateInstanceGroupOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateInstanceGroup")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if updateInstanceGroupOptions.ApplicationPort != nil {
		body["application_port"] = updateInstanceGroupOptions.ApplicationPort
	}
	if updateInstanceGroupOptions.InstanceTemplate != nil {
		body["instance_template"] = updateInstanceGroupOptions.InstanceTemplate
	}
	if updateInstanceGroupOptions.LoadBalancer != nil {
		body["load_balancer"] = updateInstanceGroupOptions.LoadBalancer
	}
	if updateInstanceGroupOptions.LoadBalancerPool != nil {
		body["load_balancer_pool"] = updateInstanceGroupOptions.LoadBalancerPool
	}
	if updateInstanceGroupOptions.MembershipCount != nil {
		body["membership_count"] = updateInstanceGroupOptions.MembershipCount
	}
	if updateInstanceGroupOptions.Name != nil {
		body["name"] = updateInstanceGroupOptions.Name
	}
	if updateInstanceGroupOptions.Subnets != nil {
		body["subnets"] = updateInstanceGroupOptions.Subnets
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalInstanceGroup)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// DeleteInstanceGroupLoadBalancer : Delete specified instance group load balancer
// This request unbinds the instance group from the load balancer pool, and deletes the load balancer pool members.
func (vpc *VpcV1) DeleteInstanceGroupLoadBalancer(deleteInstanceGroupLoadBalancerOptions *DeleteInstanceGroupLoadBalancerOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteInstanceGroupLoadBalancerOptions, "deleteInstanceGroupLoadBalancerOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteInstanceGroupLoadBalancerOptions, "deleteInstanceGroupLoadBalancerOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"instance_groups", "load_balancer"}
	pathParameters := []string{*deleteInstanceGroupLoadBalancerOptions.InstanceGroupID}

	builder := core.NewRequestBuilder(core.DELETE)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteInstanceGroupLoadBalancerOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteInstanceGroupLoadBalancer")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// ListInstanceGroupManagers : List all managers for an instance group
// This request retrieves instance group managers.
func (vpc *VpcV1) ListInstanceGroupManagers(listInstanceGroupManagersOptions *ListInstanceGroupManagersOptions) (result *InstanceGroupManagerCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listInstanceGroupManagersOptions, "listInstanceGroupManagersOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listInstanceGroupManagersOptions, "listInstanceGroupManagersOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"instance_groups", "managers"}
	pathParameters := []string{*listInstanceGroupManagersOptions.InstanceGroupID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listInstanceGroupManagersOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListInstanceGroupManagers")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalInstanceGroupManagerCollection)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// CreateInstanceGroupManager : Create an instance group manager
// This request creates a new instance group manager.
func (vpc *VpcV1) CreateInstanceGroupManager(createInstanceGroupManagerOptions *CreateInstanceGroupManagerOptions) (result *InstanceGroupManager, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createInstanceGroupManagerOptions, "createInstanceGroupManagerOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createInstanceGroupManagerOptions, "createInstanceGroupManagerOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"instance_groups", "managers"}
	pathParameters := []string{*createInstanceGroupManagerOptions.InstanceGroupID}

	builder := core.NewRequestBuilder(core.POST)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range createInstanceGroupManagerOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateInstanceGroupManager")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(createInstanceGroupManagerOptions.InstanceGroupManagerPrototype)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalInstanceGroupManager)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// DeleteInstanceGroupManager : Delete specified instance group manager
// This request deletes an instance group manager. This operation cannot be reversed.
func (vpc *VpcV1) DeleteInstanceGroupManager(deleteInstanceGroupManagerOptions *DeleteInstanceGroupManagerOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteInstanceGroupManagerOptions, "deleteInstanceGroupManagerOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteInstanceGroupManagerOptions, "deleteInstanceGroupManagerOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"instance_groups", "managers"}
	pathParameters := []string{*deleteInstanceGroupManagerOptions.InstanceGroupID, *deleteInstanceGroupManagerOptions.ID}

	builder := core.NewRequestBuilder(core.DELETE)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteInstanceGroupManagerOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteInstanceGroupManager")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetInstanceGroupManager : Retrieve specified instance group
// This request retrieves a single instance group manager specified by identifier in the URL.
func (vpc *VpcV1) GetInstanceGroupManager(getInstanceGroupManagerOptions *GetInstanceGroupManagerOptions) (result *InstanceGroupManager, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getInstanceGroupManagerOptions, "getInstanceGroupManagerOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getInstanceGroupManagerOptions, "getInstanceGroupManagerOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"instance_groups", "managers"}
	pathParameters := []string{*getInstanceGroupManagerOptions.InstanceGroupID, *getInstanceGroupManagerOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getInstanceGroupManagerOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetInstanceGroupManager")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalInstanceGroupManager)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// UpdateInstanceGroupManager : Update specified instance group manager
// This request updates an instance group manager with the information provided instance group manager patch.
func (vpc *VpcV1) UpdateInstanceGroupManager(updateInstanceGroupManagerOptions *UpdateInstanceGroupManagerOptions) (result *InstanceGroupManager, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateInstanceGroupManagerOptions, "updateInstanceGroupManagerOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateInstanceGroupManagerOptions, "updateInstanceGroupManagerOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"instance_groups", "managers"}
	pathParameters := []string{*updateInstanceGroupManagerOptions.InstanceGroupID, *updateInstanceGroupManagerOptions.ID}

	builder := core.NewRequestBuilder(core.PATCH)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateInstanceGroupManagerOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateInstanceGroupManager")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if updateInstanceGroupManagerOptions.AggregationWindow != nil {
		body["aggregation_window"] = updateInstanceGroupManagerOptions.AggregationWindow
	}
	if updateInstanceGroupManagerOptions.Cooldown != nil {
		body["cooldown"] = updateInstanceGroupManagerOptions.Cooldown
	}
	if updateInstanceGroupManagerOptions.ManagementEnabled != nil {
		body["management_enabled"] = updateInstanceGroupManagerOptions.ManagementEnabled
	}
	if updateInstanceGroupManagerOptions.MaxMembershipCount != nil {
		body["max_membership_count"] = updateInstanceGroupManagerOptions.MaxMembershipCount
	}
	if updateInstanceGroupManagerOptions.MinMembershipCount != nil {
		body["min_membership_count"] = updateInstanceGroupManagerOptions.MinMembershipCount
	}
	if updateInstanceGroupManagerOptions.Name != nil {
		body["name"] = updateInstanceGroupManagerOptions.Name
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalInstanceGroupManager)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// ListInstanceGroupManagerPolicies : List all policies for an instance group manager
func (vpc *VpcV1) ListInstanceGroupManagerPolicies(listInstanceGroupManagerPoliciesOptions *ListInstanceGroupManagerPoliciesOptions) (result *InstanceGroupManagerPolicyCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listInstanceGroupManagerPoliciesOptions, "listInstanceGroupManagerPoliciesOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listInstanceGroupManagerPoliciesOptions, "listInstanceGroupManagerPoliciesOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"instance_groups", "managers", "policies"}
	pathParameters := []string{*listInstanceGroupManagerPoliciesOptions.InstanceGroupID, *listInstanceGroupManagerPoliciesOptions.InstanceGroupManagerID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listInstanceGroupManagerPoliciesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListInstanceGroupManagerPolicies")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalInstanceGroupManagerPolicyCollection)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// CreateInstanceGroupManagerPolicy : Create an instance group manager policy
// This request creates a new instance group manager policy.
func (vpc *VpcV1) CreateInstanceGroupManagerPolicy(createInstanceGroupManagerPolicyOptions *CreateInstanceGroupManagerPolicyOptions) (result InstanceGroupManagerPolicyIntf, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createInstanceGroupManagerPolicyOptions, "createInstanceGroupManagerPolicyOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createInstanceGroupManagerPolicyOptions, "createInstanceGroupManagerPolicyOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"instance_groups", "managers", "policies"}
	pathParameters := []string{*createInstanceGroupManagerPolicyOptions.InstanceGroupID, *createInstanceGroupManagerPolicyOptions.InstanceGroupManagerID}

	builder := core.NewRequestBuilder(core.POST)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range createInstanceGroupManagerPolicyOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateInstanceGroupManagerPolicy")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(createInstanceGroupManagerPolicyOptions.InstanceGroupManagerPolicyPrototype)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalInstanceGroupManagerPolicy)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// DeleteInstanceGroupManagerPolicy : Delete specified instance group manager policy
// This request deletes an instance group manager policy. This operation cannot be reversed.
func (vpc *VpcV1) DeleteInstanceGroupManagerPolicy(deleteInstanceGroupManagerPolicyOptions *DeleteInstanceGroupManagerPolicyOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteInstanceGroupManagerPolicyOptions, "deleteInstanceGroupManagerPolicyOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteInstanceGroupManagerPolicyOptions, "deleteInstanceGroupManagerPolicyOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"instance_groups", "managers", "policies"}
	pathParameters := []string{*deleteInstanceGroupManagerPolicyOptions.InstanceGroupID, *deleteInstanceGroupManagerPolicyOptions.InstanceGroupManagerID, *deleteInstanceGroupManagerPolicyOptions.ID}

	builder := core.NewRequestBuilder(core.DELETE)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteInstanceGroupManagerPolicyOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteInstanceGroupManagerPolicy")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetInstanceGroupManagerPolicy : Retrieve specified instance group manager policy
// This request retrieves a single instance group manager policy specified by identifier in the URL.
func (vpc *VpcV1) GetInstanceGroupManagerPolicy(getInstanceGroupManagerPolicyOptions *GetInstanceGroupManagerPolicyOptions) (result InstanceGroupManagerPolicyIntf, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getInstanceGroupManagerPolicyOptions, "getInstanceGroupManagerPolicyOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getInstanceGroupManagerPolicyOptions, "getInstanceGroupManagerPolicyOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"instance_groups", "managers", "policies"}
	pathParameters := []string{*getInstanceGroupManagerPolicyOptions.InstanceGroupID, *getInstanceGroupManagerPolicyOptions.InstanceGroupManagerID, *getInstanceGroupManagerPolicyOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getInstanceGroupManagerPolicyOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetInstanceGroupManagerPolicy")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalInstanceGroupManagerPolicy)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// UpdateInstanceGroupManagerPolicy : Update specified instance group manager policy
// This request updates an instance group manager policy.
func (vpc *VpcV1) UpdateInstanceGroupManagerPolicy(updateInstanceGroupManagerPolicyOptions *UpdateInstanceGroupManagerPolicyOptions) (result InstanceGroupManagerPolicyIntf, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateInstanceGroupManagerPolicyOptions, "updateInstanceGroupManagerPolicyOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateInstanceGroupManagerPolicyOptions, "updateInstanceGroupManagerPolicyOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"instance_groups", "managers", "policies"}
	pathParameters := []string{*updateInstanceGroupManagerPolicyOptions.InstanceGroupID, *updateInstanceGroupManagerPolicyOptions.InstanceGroupManagerID, *updateInstanceGroupManagerPolicyOptions.ID}

	builder := core.NewRequestBuilder(core.PATCH)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateInstanceGroupManagerPolicyOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateInstanceGroupManagerPolicy")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if updateInstanceGroupManagerPolicyOptions.MetricType != nil {
		body["metric_type"] = updateInstanceGroupManagerPolicyOptions.MetricType
	}
	if updateInstanceGroupManagerPolicyOptions.MetricValue != nil {
		body["metric_value"] = updateInstanceGroupManagerPolicyOptions.MetricValue
	}
	if updateInstanceGroupManagerPolicyOptions.Name != nil {
		body["name"] = updateInstanceGroupManagerPolicyOptions.Name
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalInstanceGroupManagerPolicy)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// DeleteInstanceGroupMemberships : Delete all memberships from the instance group
// This request deletes all memberships of an instance group. This operation cannot be reversed. reversed. Any
// memberships that have `delete_instance_on_membership_delete` set to `true` will also have their instances deleted.
func (vpc *VpcV1) DeleteInstanceGroupMemberships(deleteInstanceGroupMembershipsOptions *DeleteInstanceGroupMembershipsOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteInstanceGroupMembershipsOptions, "deleteInstanceGroupMembershipsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteInstanceGroupMembershipsOptions, "deleteInstanceGroupMembershipsOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"instance_groups", "memberships"}
	pathParameters := []string{*deleteInstanceGroupMembershipsOptions.InstanceGroupID}

	builder := core.NewRequestBuilder(core.DELETE)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteInstanceGroupMembershipsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteInstanceGroupMemberships")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// ListInstanceGroupMemberships : List all memberships for the instance group
func (vpc *VpcV1) ListInstanceGroupMemberships(listInstanceGroupMembershipsOptions *ListInstanceGroupMembershipsOptions) (result *InstanceGroupMembershipCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listInstanceGroupMembershipsOptions, "listInstanceGroupMembershipsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listInstanceGroupMembershipsOptions, "listInstanceGroupMembershipsOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"instance_groups", "memberships"}
	pathParameters := []string{*listInstanceGroupMembershipsOptions.InstanceGroupID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listInstanceGroupMembershipsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListInstanceGroupMemberships")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalInstanceGroupMembershipCollection)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// DeleteInstanceGroupMembership : Delete specified instance group membership
// This request deletes a memberships of an instance group. This operation cannot be reversed. reversed. If the
// membership has `delete_instance_on_membership_delete` set to `true`, the instance will also be deleted.
func (vpc *VpcV1) DeleteInstanceGroupMembership(deleteInstanceGroupMembershipOptions *DeleteInstanceGroupMembershipOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteInstanceGroupMembershipOptions, "deleteInstanceGroupMembershipOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteInstanceGroupMembershipOptions, "deleteInstanceGroupMembershipOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"instance_groups", "memberships"}
	pathParameters := []string{*deleteInstanceGroupMembershipOptions.InstanceGroupID, *deleteInstanceGroupMembershipOptions.ID}

	builder := core.NewRequestBuilder(core.DELETE)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteInstanceGroupMembershipOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteInstanceGroupMembership")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetInstanceGroupMembership : Retrieve specified instance group membership
// This request retrieves a single instance group membership specified by identifier in the URL.
func (vpc *VpcV1) GetInstanceGroupMembership(getInstanceGroupMembershipOptions *GetInstanceGroupMembershipOptions) (result *InstanceGroupMembership, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getInstanceGroupMembershipOptions, "getInstanceGroupMembershipOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getInstanceGroupMembershipOptions, "getInstanceGroupMembershipOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"instance_groups", "memberships"}
	pathParameters := []string{*getInstanceGroupMembershipOptions.InstanceGroupID, *getInstanceGroupMembershipOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getInstanceGroupMembershipOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetInstanceGroupMembership")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalInstanceGroupMembership)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// UpdateInstanceGroupMembership : Update specified instance group membership
// This request updates an instance group membership with the information provided instance group membership patch.
func (vpc *VpcV1) UpdateInstanceGroupMembership(updateInstanceGroupMembershipOptions *UpdateInstanceGroupMembershipOptions) (result *InstanceGroupMembership, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateInstanceGroupMembershipOptions, "updateInstanceGroupMembershipOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateInstanceGroupMembershipOptions, "updateInstanceGroupMembershipOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"instance_groups", "memberships"}
	pathParameters := []string{*updateInstanceGroupMembershipOptions.InstanceGroupID, *updateInstanceGroupMembershipOptions.ID}

	builder := core.NewRequestBuilder(core.PATCH)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateInstanceGroupMembershipOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateInstanceGroupMembership")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if updateInstanceGroupMembershipOptions.Name != nil {
		body["name"] = updateInstanceGroupMembershipOptions.Name
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalInstanceGroupMembership)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// ListInstanceProfiles : List all instance profiles
// This request lists all instance profiles available in the region. An instance profile specifies the performance
// characteristics and pricing model for an instance.
func (vpc *VpcV1) ListInstanceProfiles(listInstanceProfilesOptions *ListInstanceProfilesOptions) (result *InstanceProfileCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listInstanceProfilesOptions, "listInstanceProfilesOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"instance/profiles"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listInstanceProfilesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListInstanceProfiles")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listInstanceProfilesOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listInstanceProfilesOptions.Start))
	}
	if listInstanceProfilesOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listInstanceProfilesOptions.Limit))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalInstanceProfileCollection)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// GetInstanceProfile : Retrieve specified instance profile
// This request retrieves a single instance profile specified by the name in the URL.
func (vpc *VpcV1) GetInstanceProfile(getInstanceProfileOptions *GetInstanceProfileOptions) (result *InstanceProfile, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getInstanceProfileOptions, "getInstanceProfileOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getInstanceProfileOptions, "getInstanceProfileOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"instance/profiles"}
	pathParameters := []string{*getInstanceProfileOptions.Name}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getInstanceProfileOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetInstanceProfile")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalInstanceProfile)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// ListInstanceTemplates : Get instance templates
func (vpc *VpcV1) ListInstanceTemplates(listInstanceTemplatesOptions *ListInstanceTemplatesOptions) (result *InstanceTemplateCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listInstanceTemplatesOptions, "listInstanceTemplatesOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"instance/templates"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listInstanceTemplatesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListInstanceTemplates")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalInstanceTemplateCollection)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// CreateInstanceTemplate : Create an instance template
// This request creates a new instance template.
func (vpc *VpcV1) CreateInstanceTemplate(createInstanceTemplateOptions *CreateInstanceTemplateOptions) (result InstanceTemplateIntf, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createInstanceTemplateOptions, "createInstanceTemplateOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createInstanceTemplateOptions, "createInstanceTemplateOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"instance/templates"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.POST)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range createInstanceTemplateOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateInstanceTemplate")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(createInstanceTemplateOptions.InstanceTemplatePrototype)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalInstanceTemplate)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// DeleteInstanceTemplate : Delete specified instance template
// This request deletes the instance template. This operation cannot be reversed.
func (vpc *VpcV1) DeleteInstanceTemplate(deleteInstanceTemplateOptions *DeleteInstanceTemplateOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteInstanceTemplateOptions, "deleteInstanceTemplateOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteInstanceTemplateOptions, "deleteInstanceTemplateOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"instance/templates"}
	pathParameters := []string{*deleteInstanceTemplateOptions.ID}

	builder := core.NewRequestBuilder(core.DELETE)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteInstanceTemplateOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteInstanceTemplate")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetInstanceTemplate : Retrieve specified instance template
func (vpc *VpcV1) GetInstanceTemplate(getInstanceTemplateOptions *GetInstanceTemplateOptions) (result InstanceTemplateIntf, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getInstanceTemplateOptions, "getInstanceTemplateOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getInstanceTemplateOptions, "getInstanceTemplateOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"instance/templates"}
	pathParameters := []string{*getInstanceTemplateOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getInstanceTemplateOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetInstanceTemplate")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalInstanceTemplate)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// UpdateInstanceTemplate : Update specified instance template
// This request updates an instance template with the information provided in the instance template patch. The instance
// template patch object is structured in the same way as a retrieved instance template and contains only the
// information to be updated.
func (vpc *VpcV1) UpdateInstanceTemplate(updateInstanceTemplateOptions *UpdateInstanceTemplateOptions) (result InstanceTemplateIntf, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateInstanceTemplateOptions, "updateInstanceTemplateOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateInstanceTemplateOptions, "updateInstanceTemplateOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"instance/templates"}
	pathParameters := []string{*updateInstanceTemplateOptions.ID}

	builder := core.NewRequestBuilder(core.PATCH)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateInstanceTemplateOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateInstanceTemplate")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if updateInstanceTemplateOptions.Name != nil {
		body["name"] = updateInstanceTemplateOptions.Name
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalInstanceTemplate)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// ListInstances : List all instances
// This request lists all instances in the region.
func (vpc *VpcV1) ListInstances(listInstancesOptions *ListInstancesOptions) (result *InstanceCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listInstancesOptions, "listInstancesOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"instances"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listInstancesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListInstances")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listInstancesOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listInstancesOptions.Start))
	}
	if listInstancesOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listInstancesOptions.Limit))
	}
	if listInstancesOptions.ResourceGroupID != nil {
		builder.AddQuery("resource_group.id", fmt.Sprint(*listInstancesOptions.ResourceGroupID))
	}
	if listInstancesOptions.Name != nil {
		builder.AddQuery("name", fmt.Sprint(*listInstancesOptions.Name))
	}
	if listInstancesOptions.VPCID != nil {
		builder.AddQuery("vpc.id", fmt.Sprint(*listInstancesOptions.VPCID))
	}
	if listInstancesOptions.VPCCRN != nil {
		builder.AddQuery("vpc.crn", fmt.Sprint(*listInstancesOptions.VPCCRN))
	}
	if listInstancesOptions.VPCName != nil {
		builder.AddQuery("vpc.name", fmt.Sprint(*listInstancesOptions.VPCName))
	}
	if listInstancesOptions.NetworkInterfacesSubnetID != nil {
		builder.AddQuery("network_interfaces.subnet.id", fmt.Sprint(*listInstancesOptions.NetworkInterfacesSubnetID))
	}
	if listInstancesOptions.NetworkInterfacesSubnetCRN != nil {
		builder.AddQuery("network_interfaces.subnet.crn", fmt.Sprint(*listInstancesOptions.NetworkInterfacesSubnetCRN))
	}
	if listInstancesOptions.NetworkInterfacesSubnetName != nil {
		builder.AddQuery("network_interfaces.subnet.name", fmt.Sprint(*listInstancesOptions.NetworkInterfacesSubnetName))
	}
	if listInstancesOptions.DedicatedHostID != nil {
		builder.AddQuery("dedicated_host.id", fmt.Sprint(*listInstancesOptions.DedicatedHostID))
	}
	if listInstancesOptions.DedicatedHostCRN != nil {
		builder.AddQuery("dedicated_host.crn", fmt.Sprint(*listInstancesOptions.DedicatedHostCRN))
	}
	if listInstancesOptions.DedicatedHostName != nil {
		builder.AddQuery("dedicated_host.name", fmt.Sprint(*listInstancesOptions.DedicatedHostName))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalInstanceCollection)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// CreateInstance : Create an instance
// This request provisions a new instance from an instance prototype object. The prototype object is structured in the
// same way as a retrieved instance, and contains the information necessary to provision the new instance. The instance
// is automatically started.
func (vpc *VpcV1) CreateInstance(createInstanceOptions *CreateInstanceOptions) (result *Instance, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createInstanceOptions, "createInstanceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createInstanceOptions, "createInstanceOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"instances"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.POST)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range createInstanceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateInstance")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(createInstanceOptions.InstancePrototype)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalInstance)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// DeleteInstance : Delete specified instance
// This request deletes an instance. This operation cannot be reversed. Any floating IPs associated with the instance's
// network interfaces are implicitly disassociated. All flow log collectors with `auto_delete` set to `true` targeting
// the instance and/or the instance's network interfaces are automatically deleted.
func (vpc *VpcV1) DeleteInstance(deleteInstanceOptions *DeleteInstanceOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteInstanceOptions, "deleteInstanceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteInstanceOptions, "deleteInstanceOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"instances"}
	pathParameters := []string{*deleteInstanceOptions.ID}

	builder := core.NewRequestBuilder(core.DELETE)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteInstanceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteInstance")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetInstance : Retrieve an instance
// This request retrieves a single instance specified by the identifier in the URL.
func (vpc *VpcV1) GetInstance(getInstanceOptions *GetInstanceOptions) (result *Instance, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getInstanceOptions, "getInstanceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getInstanceOptions, "getInstanceOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"instances"}
	pathParameters := []string{*getInstanceOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getInstanceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetInstance")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalInstance)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// UpdateInstance : Update specified instance
// This request updates an instance with the information in a provided instance patch. The instance patch object is
// structured in the same way as a retrieved instance and contains only the information to be updated.
func (vpc *VpcV1) UpdateInstance(updateInstanceOptions *UpdateInstanceOptions) (result *Instance, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateInstanceOptions, "updateInstanceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateInstanceOptions, "updateInstanceOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"instances"}
	pathParameters := []string{*updateInstanceOptions.ID}

	builder := core.NewRequestBuilder(core.PATCH)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateInstanceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateInstance")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if updateInstanceOptions.Name != nil {
		body["name"] = updateInstanceOptions.Name
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalInstance)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// GetInstanceInitialization : Retrieve configuration used to initialize the instance
// This request retrieves configuration variables used to initialize the instance, such as SSH keys and the Windows
// administrator password.
func (vpc *VpcV1) GetInstanceInitialization(getInstanceInitializationOptions *GetInstanceInitializationOptions) (result *InstanceInitialization, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getInstanceInitializationOptions, "getInstanceInitializationOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getInstanceInitializationOptions, "getInstanceInitializationOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"instances", "initialization"}
	pathParameters := []string{*getInstanceInitializationOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getInstanceInitializationOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetInstanceInitialization")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalInstanceInitialization)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// CreateInstanceAction : Create an instance action
// This request creates a new action which will be queued up to run as soon as any pending or running actions have
// completed.
func (vpc *VpcV1) CreateInstanceAction(createInstanceActionOptions *CreateInstanceActionOptions) (result *InstanceAction, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createInstanceActionOptions, "createInstanceActionOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createInstanceActionOptions, "createInstanceActionOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"instances", "actions"}
	pathParameters := []string{*createInstanceActionOptions.InstanceID}

	builder := core.NewRequestBuilder(core.POST)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range createInstanceActionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateInstanceAction")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if createInstanceActionOptions.Type != nil {
		body["type"] = createInstanceActionOptions.Type
	}
	if createInstanceActionOptions.Force != nil {
		body["force"] = createInstanceActionOptions.Force
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalInstanceAction)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// ListInstanceNetworkInterfaces : List all network interfaces on an instance
// This request lists all network interfaces on an instance. A network interface is an abstract representation of a
// network interface card and connects an instance to a subnet. While each network interface can attach to only one
// subnet, multiple network interfaces can be created to attach to multiple subnets. Multiple interfaces may also attach
// to the same subnet.
func (vpc *VpcV1) ListInstanceNetworkInterfaces(listInstanceNetworkInterfacesOptions *ListInstanceNetworkInterfacesOptions) (result *NetworkInterfaceCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listInstanceNetworkInterfacesOptions, "listInstanceNetworkInterfacesOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listInstanceNetworkInterfacesOptions, "listInstanceNetworkInterfacesOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"instances", "network_interfaces"}
	pathParameters := []string{*listInstanceNetworkInterfacesOptions.InstanceID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listInstanceNetworkInterfacesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListInstanceNetworkInterfaces")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalNetworkInterfaceCollection)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// CreateInstanceNetworkInterface : Create a network interface
// This request creates a new network interface from a network interface prototype object. The prototype object is
// structured in the same way as a retrieved network interface, and contains the information necessary to create the new
// network interface. Any subnet in the instance's VPC may be specified, even if it is already attached to another
// network interface. Addresses on the network interface must be within the specified subnet's CIDR blocks.
func (vpc *VpcV1) CreateInstanceNetworkInterface(createInstanceNetworkInterfaceOptions *CreateInstanceNetworkInterfaceOptions) (result *NetworkInterface, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createInstanceNetworkInterfaceOptions, "createInstanceNetworkInterfaceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createInstanceNetworkInterfaceOptions, "createInstanceNetworkInterfaceOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"instances", "network_interfaces"}
	pathParameters := []string{*createInstanceNetworkInterfaceOptions.InstanceID}

	builder := core.NewRequestBuilder(core.POST)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range createInstanceNetworkInterfaceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateInstanceNetworkInterface")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if createInstanceNetworkInterfaceOptions.Subnet != nil {
		body["subnet"] = createInstanceNetworkInterfaceOptions.Subnet
	}
	if createInstanceNetworkInterfaceOptions.AllowIPSpoofing != nil {
		body["allow_ip_spoofing"] = createInstanceNetworkInterfaceOptions.AllowIPSpoofing
	}
	if createInstanceNetworkInterfaceOptions.Name != nil {
		body["name"] = createInstanceNetworkInterfaceOptions.Name
	}
	if createInstanceNetworkInterfaceOptions.PrimaryIpv4Address != nil {
		body["primary_ipv4_address"] = createInstanceNetworkInterfaceOptions.PrimaryIpv4Address
	}
	if createInstanceNetworkInterfaceOptions.SecurityGroups != nil {
		body["security_groups"] = createInstanceNetworkInterfaceOptions.SecurityGroups
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalNetworkInterface)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// DeleteInstanceNetworkInterface : Delete specified network interface
// This request deletes a network interface. This operation cannot be reversed. Any floating IPs associated with the
// network interface are implicitly disassociated. All flow log collectors with `auto_delete` set to `true` targeting
// the network interface are automatically deleted. The primary network interface is not allowed to be deleted.
func (vpc *VpcV1) DeleteInstanceNetworkInterface(deleteInstanceNetworkInterfaceOptions *DeleteInstanceNetworkInterfaceOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteInstanceNetworkInterfaceOptions, "deleteInstanceNetworkInterfaceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteInstanceNetworkInterfaceOptions, "deleteInstanceNetworkInterfaceOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"instances", "network_interfaces"}
	pathParameters := []string{*deleteInstanceNetworkInterfaceOptions.InstanceID, *deleteInstanceNetworkInterfaceOptions.ID}

	builder := core.NewRequestBuilder(core.DELETE)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteInstanceNetworkInterfaceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteInstanceNetworkInterface")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetInstanceNetworkInterface : Retrieve specified network interface
// This request retrieves a single network interface specified by the identifier in the URL.
func (vpc *VpcV1) GetInstanceNetworkInterface(getInstanceNetworkInterfaceOptions *GetInstanceNetworkInterfaceOptions) (result *NetworkInterface, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getInstanceNetworkInterfaceOptions, "getInstanceNetworkInterfaceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getInstanceNetworkInterfaceOptions, "getInstanceNetworkInterfaceOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"instances", "network_interfaces"}
	pathParameters := []string{*getInstanceNetworkInterfaceOptions.InstanceID, *getInstanceNetworkInterfaceOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getInstanceNetworkInterfaceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetInstanceNetworkInterface")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalNetworkInterface)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// UpdateInstanceNetworkInterface : Update a network interface
// This request updates a network interface with the information in a provided network interface patch. The network
// interface patch object is structured in the same way as a retrieved network interface and can contain an updated name
// and/or port speed.
func (vpc *VpcV1) UpdateInstanceNetworkInterface(updateInstanceNetworkInterfaceOptions *UpdateInstanceNetworkInterfaceOptions) (result *NetworkInterface, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateInstanceNetworkInterfaceOptions, "updateInstanceNetworkInterfaceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateInstanceNetworkInterfaceOptions, "updateInstanceNetworkInterfaceOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"instances", "network_interfaces"}
	pathParameters := []string{*updateInstanceNetworkInterfaceOptions.InstanceID, *updateInstanceNetworkInterfaceOptions.ID}

	builder := core.NewRequestBuilder(core.PATCH)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateInstanceNetworkInterfaceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateInstanceNetworkInterface")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if updateInstanceNetworkInterfaceOptions.AllowIPSpoofing != nil {
		body["allow_ip_spoofing"] = updateInstanceNetworkInterfaceOptions.AllowIPSpoofing
	}
	if updateInstanceNetworkInterfaceOptions.Name != nil {
		body["name"] = updateInstanceNetworkInterfaceOptions.Name
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalNetworkInterface)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// ListInstanceNetworkInterfaceFloatingIps : List all floating IPs associated with a network interface
// This request lists all floating IPs associated with a network interface.
func (vpc *VpcV1) ListInstanceNetworkInterfaceFloatingIps(listInstanceNetworkInterfaceFloatingIpsOptions *ListInstanceNetworkInterfaceFloatingIpsOptions) (result *FloatingIPUnpaginatedCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listInstanceNetworkInterfaceFloatingIpsOptions, "listInstanceNetworkInterfaceFloatingIpsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listInstanceNetworkInterfaceFloatingIpsOptions, "listInstanceNetworkInterfaceFloatingIpsOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"instances", "network_interfaces", "floating_ips"}
	pathParameters := []string{*listInstanceNetworkInterfaceFloatingIpsOptions.InstanceID, *listInstanceNetworkInterfaceFloatingIpsOptions.NetworkInterfaceID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listInstanceNetworkInterfaceFloatingIpsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListInstanceNetworkInterfaceFloatingIps")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalFloatingIPUnpaginatedCollection)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// RemoveInstanceNetworkInterfaceFloatingIP : Disassociate specified floating IP
// This request disassociates the specified floating IP from the specified network interface.
func (vpc *VpcV1) RemoveInstanceNetworkInterfaceFloatingIP(removeInstanceNetworkInterfaceFloatingIPOptions *RemoveInstanceNetworkInterfaceFloatingIPOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(removeInstanceNetworkInterfaceFloatingIPOptions, "removeInstanceNetworkInterfaceFloatingIPOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(removeInstanceNetworkInterfaceFloatingIPOptions, "removeInstanceNetworkInterfaceFloatingIPOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"instances", "network_interfaces", "floating_ips"}
	pathParameters := []string{*removeInstanceNetworkInterfaceFloatingIPOptions.InstanceID, *removeInstanceNetworkInterfaceFloatingIPOptions.NetworkInterfaceID, *removeInstanceNetworkInterfaceFloatingIPOptions.ID}

	builder := core.NewRequestBuilder(core.DELETE)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range removeInstanceNetworkInterfaceFloatingIPOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "RemoveInstanceNetworkInterfaceFloatingIP")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetInstanceNetworkInterfaceFloatingIP : Retrieve associated floating IP
// This request a retrieves a specified floating IP address if it is associated with the network interface and instance
// specified in the URL.
func (vpc *VpcV1) GetInstanceNetworkInterfaceFloatingIP(getInstanceNetworkInterfaceFloatingIPOptions *GetInstanceNetworkInterfaceFloatingIPOptions) (result *FloatingIP, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getInstanceNetworkInterfaceFloatingIPOptions, "getInstanceNetworkInterfaceFloatingIPOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getInstanceNetworkInterfaceFloatingIPOptions, "getInstanceNetworkInterfaceFloatingIPOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"instances", "network_interfaces", "floating_ips"}
	pathParameters := []string{*getInstanceNetworkInterfaceFloatingIPOptions.InstanceID, *getInstanceNetworkInterfaceFloatingIPOptions.NetworkInterfaceID, *getInstanceNetworkInterfaceFloatingIPOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getInstanceNetworkInterfaceFloatingIPOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetInstanceNetworkInterfaceFloatingIP")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalFloatingIP)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// AddInstanceNetworkInterfaceFloatingIP : Associate a floating IP with a network interface
// This request associates the specified floating IP with the specified network interface, replacing any existing
// association. For this request to succeed, the existing floating IP must not be required by another resource, such as
// a public gateway. A request body is not required, and if supplied, is ignored.
func (vpc *VpcV1) AddInstanceNetworkInterfaceFloatingIP(addInstanceNetworkInterfaceFloatingIPOptions *AddInstanceNetworkInterfaceFloatingIPOptions) (result *FloatingIP, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(addInstanceNetworkInterfaceFloatingIPOptions, "addInstanceNetworkInterfaceFloatingIPOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(addInstanceNetworkInterfaceFloatingIPOptions, "addInstanceNetworkInterfaceFloatingIPOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"instances", "network_interfaces", "floating_ips"}
	pathParameters := []string{*addInstanceNetworkInterfaceFloatingIPOptions.InstanceID, *addInstanceNetworkInterfaceFloatingIPOptions.NetworkInterfaceID, *addInstanceNetworkInterfaceFloatingIPOptions.ID}

	builder := core.NewRequestBuilder(core.PUT)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range addInstanceNetworkInterfaceFloatingIPOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "AddInstanceNetworkInterfaceFloatingIP")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalFloatingIP)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// ListInstanceVolumeAttachments : List all volumes attached to an instance
// This request lists all volume attachments for an instance. A volume attachment connects a volume to an instance. Each
// instance may have many volume attachments but each volume attachment connects exactly one instance to exactly one
// volume.
func (vpc *VpcV1) ListInstanceVolumeAttachments(listInstanceVolumeAttachmentsOptions *ListInstanceVolumeAttachmentsOptions) (result *VolumeAttachmentCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listInstanceVolumeAttachmentsOptions, "listInstanceVolumeAttachmentsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listInstanceVolumeAttachmentsOptions, "listInstanceVolumeAttachmentsOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"instances", "volume_attachments"}
	pathParameters := []string{*listInstanceVolumeAttachmentsOptions.InstanceID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listInstanceVolumeAttachmentsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListInstanceVolumeAttachments")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVolumeAttachmentCollection)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// CreateInstanceVolumeAttachment : Create a volume attachment, connecting a volume to an instance
// This request creates a new volume attachment from a volume attachment prototype object. The prototype object is
// structured in the same way as a retrieved volume attachment, and contains the information necessary to create the new
// volume attachment. The creation of a new volume attachment connects a volume to an instance.
func (vpc *VpcV1) CreateInstanceVolumeAttachment(createInstanceVolumeAttachmentOptions *CreateInstanceVolumeAttachmentOptions) (result *VolumeAttachment, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createInstanceVolumeAttachmentOptions, "createInstanceVolumeAttachmentOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createInstanceVolumeAttachmentOptions, "createInstanceVolumeAttachmentOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"instances", "volume_attachments"}
	pathParameters := []string{*createInstanceVolumeAttachmentOptions.InstanceID}

	builder := core.NewRequestBuilder(core.POST)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range createInstanceVolumeAttachmentOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateInstanceVolumeAttachment")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if createInstanceVolumeAttachmentOptions.Volume != nil {
		body["volume"] = createInstanceVolumeAttachmentOptions.Volume
	}
	if createInstanceVolumeAttachmentOptions.DeleteVolumeOnInstanceDelete != nil {
		body["delete_volume_on_instance_delete"] = createInstanceVolumeAttachmentOptions.DeleteVolumeOnInstanceDelete
	}
	if createInstanceVolumeAttachmentOptions.Name != nil {
		body["name"] = createInstanceVolumeAttachmentOptions.Name
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVolumeAttachment)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// DeleteInstanceVolumeAttachment : Delete a volume attachment, detaching a volume from an instance
// This request deletes a volume attachment. The deletion of a volume attachment detaches a volume from an instance.
func (vpc *VpcV1) DeleteInstanceVolumeAttachment(deleteInstanceVolumeAttachmentOptions *DeleteInstanceVolumeAttachmentOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteInstanceVolumeAttachmentOptions, "deleteInstanceVolumeAttachmentOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteInstanceVolumeAttachmentOptions, "deleteInstanceVolumeAttachmentOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"instances", "volume_attachments"}
	pathParameters := []string{*deleteInstanceVolumeAttachmentOptions.InstanceID, *deleteInstanceVolumeAttachmentOptions.ID}

	builder := core.NewRequestBuilder(core.DELETE)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteInstanceVolumeAttachmentOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteInstanceVolumeAttachment")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetInstanceVolumeAttachment : Retrieve specified volume attachment
// This request retrieves a single volume attachment specified by the identifier in the URL.
func (vpc *VpcV1) GetInstanceVolumeAttachment(getInstanceVolumeAttachmentOptions *GetInstanceVolumeAttachmentOptions) (result *VolumeAttachment, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getInstanceVolumeAttachmentOptions, "getInstanceVolumeAttachmentOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getInstanceVolumeAttachmentOptions, "getInstanceVolumeAttachmentOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"instances", "volume_attachments"}
	pathParameters := []string{*getInstanceVolumeAttachmentOptions.InstanceID, *getInstanceVolumeAttachmentOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getInstanceVolumeAttachmentOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetInstanceVolumeAttachment")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVolumeAttachment)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// UpdateInstanceVolumeAttachment : Update a volume attachment
// This request updates a volume attachment with the information in a provided volume attachment patch. The volume
// attachment patch object is structured in the same way as a retrieved volume attachment and can contain an updated
// name.
func (vpc *VpcV1) UpdateInstanceVolumeAttachment(updateInstanceVolumeAttachmentOptions *UpdateInstanceVolumeAttachmentOptions) (result *VolumeAttachment, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateInstanceVolumeAttachmentOptions, "updateInstanceVolumeAttachmentOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateInstanceVolumeAttachmentOptions, "updateInstanceVolumeAttachmentOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"instances", "volume_attachments"}
	pathParameters := []string{*updateInstanceVolumeAttachmentOptions.InstanceID, *updateInstanceVolumeAttachmentOptions.ID}

	builder := core.NewRequestBuilder(core.PATCH)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateInstanceVolumeAttachmentOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateInstanceVolumeAttachment")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if updateInstanceVolumeAttachmentOptions.DeleteVolumeOnInstanceDelete != nil {
		body["delete_volume_on_instance_delete"] = updateInstanceVolumeAttachmentOptions.DeleteVolumeOnInstanceDelete
	}
	if updateInstanceVolumeAttachmentOptions.Name != nil {
		body["name"] = updateInstanceVolumeAttachmentOptions.Name
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVolumeAttachment)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// ListLoadBalancerProfiles : List all load balancer profiles
// This request lists all load balancer profiles available in the region. A load balancer profile specifies the
// performance characteristics and pricing model for a load balancer.
func (vpc *VpcV1) ListLoadBalancerProfiles(listLoadBalancerProfilesOptions *ListLoadBalancerProfilesOptions) (result *LoadBalancerProfileCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listLoadBalancerProfilesOptions, "listLoadBalancerProfilesOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"load_balancer/profiles"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listLoadBalancerProfilesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListLoadBalancerProfiles")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listLoadBalancerProfilesOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listLoadBalancerProfilesOptions.Start))
	}
	if listLoadBalancerProfilesOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listLoadBalancerProfilesOptions.Limit))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalLoadBalancerProfileCollection)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// GetLoadBalancerProfile : Retrieve specified load balancer profile
// This request retrieves a load balancer profile specified by the name in the URL.
func (vpc *VpcV1) GetLoadBalancerProfile(getLoadBalancerProfileOptions *GetLoadBalancerProfileOptions) (result *LoadBalancerProfile, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getLoadBalancerProfileOptions, "getLoadBalancerProfileOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getLoadBalancerProfileOptions, "getLoadBalancerProfileOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"load_balancer/profiles"}
	pathParameters := []string{*getLoadBalancerProfileOptions.Name}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getLoadBalancerProfileOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetLoadBalancerProfile")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalLoadBalancerProfile)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// ListLoadBalancers : List all load balancers
// This request retrieves a paginated list of all load balancers that belong to this account.
func (vpc *VpcV1) ListLoadBalancers(listLoadBalancersOptions *ListLoadBalancersOptions) (result *LoadBalancerCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listLoadBalancersOptions, "listLoadBalancersOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"load_balancers"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listLoadBalancersOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListLoadBalancers")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listLoadBalancersOptions.ResourceGroupID != nil {
		builder.AddQuery("resource_group.id", fmt.Sprint(*listLoadBalancersOptions.ResourceGroupID))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalLoadBalancerCollection)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// CreateLoadBalancer : Create and provision a load balancer
// This request creates and provisions a new load balancer.
func (vpc *VpcV1) CreateLoadBalancer(createLoadBalancerOptions *CreateLoadBalancerOptions) (result *LoadBalancer, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createLoadBalancerOptions, "createLoadBalancerOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createLoadBalancerOptions, "createLoadBalancerOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"load_balancers"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.POST)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range createLoadBalancerOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateLoadBalancer")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if createLoadBalancerOptions.IsPublic != nil {
		body["is_public"] = createLoadBalancerOptions.IsPublic
	}
	if createLoadBalancerOptions.Subnets != nil {
		body["subnets"] = createLoadBalancerOptions.Subnets
	}
	if createLoadBalancerOptions.Listeners != nil {
		body["listeners"] = createLoadBalancerOptions.Listeners
	}
	if createLoadBalancerOptions.Name != nil {
		body["name"] = createLoadBalancerOptions.Name
	}
	if createLoadBalancerOptions.Pools != nil {
		body["pools"] = createLoadBalancerOptions.Pools
	}
	if createLoadBalancerOptions.Profile != nil {
		body["profile"] = createLoadBalancerOptions.Profile
	}
	if createLoadBalancerOptions.ResourceGroup != nil {
		body["resource_group"] = createLoadBalancerOptions.ResourceGroup
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalLoadBalancer)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// DeleteLoadBalancer : Delete a load balancer
// This request deletes a load balancer. This operation cannot be reversed.
func (vpc *VpcV1) DeleteLoadBalancer(deleteLoadBalancerOptions *DeleteLoadBalancerOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteLoadBalancerOptions, "deleteLoadBalancerOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteLoadBalancerOptions, "deleteLoadBalancerOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"load_balancers"}
	pathParameters := []string{*deleteLoadBalancerOptions.ID}

	builder := core.NewRequestBuilder(core.DELETE)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteLoadBalancerOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteLoadBalancer")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetLoadBalancer : Retrieve a load balancer
// This request retrieves a single load balancer specified by the identifier in the URL path.
func (vpc *VpcV1) GetLoadBalancer(getLoadBalancerOptions *GetLoadBalancerOptions) (result *LoadBalancer, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getLoadBalancerOptions, "getLoadBalancerOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getLoadBalancerOptions, "getLoadBalancerOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"load_balancers"}
	pathParameters := []string{*getLoadBalancerOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getLoadBalancerOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetLoadBalancer")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalLoadBalancer)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// UpdateLoadBalancer : Update a load balancer
// This request updates a load balancer.
func (vpc *VpcV1) UpdateLoadBalancer(updateLoadBalancerOptions *UpdateLoadBalancerOptions) (result *LoadBalancer, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateLoadBalancerOptions, "updateLoadBalancerOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateLoadBalancerOptions, "updateLoadBalancerOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"load_balancers"}
	pathParameters := []string{*updateLoadBalancerOptions.ID}

	builder := core.NewRequestBuilder(core.PATCH)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateLoadBalancerOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateLoadBalancer")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if updateLoadBalancerOptions.Name != nil {
		body["name"] = updateLoadBalancerOptions.Name
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalLoadBalancer)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// GetLoadBalancerStatistics : List statistics of a load balancer
// This request lists statistics of a load balancer specified by the identifier in the URL path.
func (vpc *VpcV1) GetLoadBalancerStatistics(getLoadBalancerStatisticsOptions *GetLoadBalancerStatisticsOptions) (result *LoadBalancerStatistics, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getLoadBalancerStatisticsOptions, "getLoadBalancerStatisticsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getLoadBalancerStatisticsOptions, "getLoadBalancerStatisticsOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"load_balancers", "statistics"}
	pathParameters := []string{*getLoadBalancerStatisticsOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getLoadBalancerStatisticsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetLoadBalancerStatistics")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalLoadBalancerStatistics)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// ListLoadBalancerListeners : List all listeners of the load balancer
// This request retrieves a list of all listeners that belong to the load balancer.
func (vpc *VpcV1) ListLoadBalancerListeners(listLoadBalancerListenersOptions *ListLoadBalancerListenersOptions) (result *LoadBalancerListenerCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listLoadBalancerListenersOptions, "listLoadBalancerListenersOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listLoadBalancerListenersOptions, "listLoadBalancerListenersOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"load_balancers", "listeners"}
	pathParameters := []string{*listLoadBalancerListenersOptions.LoadBalancerID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listLoadBalancerListenersOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListLoadBalancerListeners")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalLoadBalancerListenerCollection)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// CreateLoadBalancerListener : Create a listener
// This request creates a new listener to the load balancer.
func (vpc *VpcV1) CreateLoadBalancerListener(createLoadBalancerListenerOptions *CreateLoadBalancerListenerOptions) (result *LoadBalancerListener, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createLoadBalancerListenerOptions, "createLoadBalancerListenerOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createLoadBalancerListenerOptions, "createLoadBalancerListenerOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"load_balancers", "listeners"}
	pathParameters := []string{*createLoadBalancerListenerOptions.LoadBalancerID}

	builder := core.NewRequestBuilder(core.POST)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range createLoadBalancerListenerOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateLoadBalancerListener")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if createLoadBalancerListenerOptions.Port != nil {
		body["port"] = createLoadBalancerListenerOptions.Port
	}
	if createLoadBalancerListenerOptions.Protocol != nil {
		body["protocol"] = createLoadBalancerListenerOptions.Protocol
	}
	if createLoadBalancerListenerOptions.CertificateInstance != nil {
		body["certificate_instance"] = createLoadBalancerListenerOptions.CertificateInstance
	}
	if createLoadBalancerListenerOptions.ConnectionLimit != nil {
		body["connection_limit"] = createLoadBalancerListenerOptions.ConnectionLimit
	}
	if createLoadBalancerListenerOptions.DefaultPool != nil {
		body["default_pool"] = createLoadBalancerListenerOptions.DefaultPool
	}
	if createLoadBalancerListenerOptions.Policies != nil {
		body["policies"] = createLoadBalancerListenerOptions.Policies
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalLoadBalancerListener)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// DeleteLoadBalancerListener : Delete a listener
// This request deletes a load balancer listener. This operation cannot be reversed.
func (vpc *VpcV1) DeleteLoadBalancerListener(deleteLoadBalancerListenerOptions *DeleteLoadBalancerListenerOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteLoadBalancerListenerOptions, "deleteLoadBalancerListenerOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteLoadBalancerListenerOptions, "deleteLoadBalancerListenerOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"load_balancers", "listeners"}
	pathParameters := []string{*deleteLoadBalancerListenerOptions.LoadBalancerID, *deleteLoadBalancerListenerOptions.ID}

	builder := core.NewRequestBuilder(core.DELETE)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteLoadBalancerListenerOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteLoadBalancerListener")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetLoadBalancerListener : Retrieve a listener
// This request retrieves a single listener specified by the identifier in the URL path.
func (vpc *VpcV1) GetLoadBalancerListener(getLoadBalancerListenerOptions *GetLoadBalancerListenerOptions) (result *LoadBalancerListener, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getLoadBalancerListenerOptions, "getLoadBalancerListenerOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getLoadBalancerListenerOptions, "getLoadBalancerListenerOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"load_balancers", "listeners"}
	pathParameters := []string{*getLoadBalancerListenerOptions.LoadBalancerID, *getLoadBalancerListenerOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getLoadBalancerListenerOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetLoadBalancerListener")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalLoadBalancerListener)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// UpdateLoadBalancerListener : Update a listener
// This request updates a load balancer listener from a listener patch.
func (vpc *VpcV1) UpdateLoadBalancerListener(updateLoadBalancerListenerOptions *UpdateLoadBalancerListenerOptions) (result *LoadBalancerListener, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateLoadBalancerListenerOptions, "updateLoadBalancerListenerOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateLoadBalancerListenerOptions, "updateLoadBalancerListenerOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"load_balancers", "listeners"}
	pathParameters := []string{*updateLoadBalancerListenerOptions.LoadBalancerID, *updateLoadBalancerListenerOptions.ID}

	builder := core.NewRequestBuilder(core.PATCH)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateLoadBalancerListenerOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateLoadBalancerListener")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if updateLoadBalancerListenerOptions.CertificateInstance != nil {
		body["certificate_instance"] = updateLoadBalancerListenerOptions.CertificateInstance
	}
	if updateLoadBalancerListenerOptions.ConnectionLimit != nil {
		body["connection_limit"] = updateLoadBalancerListenerOptions.ConnectionLimit
	}
	if updateLoadBalancerListenerOptions.DefaultPool != nil {
		body["default_pool"] = updateLoadBalancerListenerOptions.DefaultPool
	}
	if updateLoadBalancerListenerOptions.Port != nil {
		body["port"] = updateLoadBalancerListenerOptions.Port
	}
	if updateLoadBalancerListenerOptions.Protocol != nil {
		body["protocol"] = updateLoadBalancerListenerOptions.Protocol
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalLoadBalancerListener)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// ListLoadBalancerListenerPolicies : List all policies of the load balancer listener
// Retrieves a list of all policies belonging to the load balancer listener.
func (vpc *VpcV1) ListLoadBalancerListenerPolicies(listLoadBalancerListenerPoliciesOptions *ListLoadBalancerListenerPoliciesOptions) (result *LoadBalancerListenerPolicyCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listLoadBalancerListenerPoliciesOptions, "listLoadBalancerListenerPoliciesOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listLoadBalancerListenerPoliciesOptions, "listLoadBalancerListenerPoliciesOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"load_balancers", "listeners", "policies"}
	pathParameters := []string{*listLoadBalancerListenerPoliciesOptions.LoadBalancerID, *listLoadBalancerListenerPoliciesOptions.ListenerID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listLoadBalancerListenerPoliciesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListLoadBalancerListenerPolicies")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalLoadBalancerListenerPolicyCollection)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// CreateLoadBalancerListenerPolicy : Create a policy for the load balancer listener
// Creates a new policy to the load balancer listener.
func (vpc *VpcV1) CreateLoadBalancerListenerPolicy(createLoadBalancerListenerPolicyOptions *CreateLoadBalancerListenerPolicyOptions) (result *LoadBalancerListenerPolicy, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createLoadBalancerListenerPolicyOptions, "createLoadBalancerListenerPolicyOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createLoadBalancerListenerPolicyOptions, "createLoadBalancerListenerPolicyOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"load_balancers", "listeners", "policies"}
	pathParameters := []string{*createLoadBalancerListenerPolicyOptions.LoadBalancerID, *createLoadBalancerListenerPolicyOptions.ListenerID}

	builder := core.NewRequestBuilder(core.POST)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range createLoadBalancerListenerPolicyOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateLoadBalancerListenerPolicy")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if createLoadBalancerListenerPolicyOptions.Action != nil {
		body["action"] = createLoadBalancerListenerPolicyOptions.Action
	}
	if createLoadBalancerListenerPolicyOptions.Priority != nil {
		body["priority"] = createLoadBalancerListenerPolicyOptions.Priority
	}
	if createLoadBalancerListenerPolicyOptions.Name != nil {
		body["name"] = createLoadBalancerListenerPolicyOptions.Name
	}
	if createLoadBalancerListenerPolicyOptions.Rules != nil {
		body["rules"] = createLoadBalancerListenerPolicyOptions.Rules
	}
	if createLoadBalancerListenerPolicyOptions.Target != nil {
		body["target"] = createLoadBalancerListenerPolicyOptions.Target
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalLoadBalancerListenerPolicy)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// DeleteLoadBalancerListenerPolicy : Delete a policy of the load balancer listener
// Deletes a policy of the load balancer listener. This operation cannot be reversed.
func (vpc *VpcV1) DeleteLoadBalancerListenerPolicy(deleteLoadBalancerListenerPolicyOptions *DeleteLoadBalancerListenerPolicyOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteLoadBalancerListenerPolicyOptions, "deleteLoadBalancerListenerPolicyOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteLoadBalancerListenerPolicyOptions, "deleteLoadBalancerListenerPolicyOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"load_balancers", "listeners", "policies"}
	pathParameters := []string{*deleteLoadBalancerListenerPolicyOptions.LoadBalancerID, *deleteLoadBalancerListenerPolicyOptions.ListenerID, *deleteLoadBalancerListenerPolicyOptions.ID}

	builder := core.NewRequestBuilder(core.DELETE)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteLoadBalancerListenerPolicyOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteLoadBalancerListenerPolicy")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetLoadBalancerListenerPolicy : Retrieve a policy of the load balancer listener
// Retrieve a single policy specified by the identifier in the URL path.
func (vpc *VpcV1) GetLoadBalancerListenerPolicy(getLoadBalancerListenerPolicyOptions *GetLoadBalancerListenerPolicyOptions) (result *LoadBalancerListenerPolicy, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getLoadBalancerListenerPolicyOptions, "getLoadBalancerListenerPolicyOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getLoadBalancerListenerPolicyOptions, "getLoadBalancerListenerPolicyOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"load_balancers", "listeners", "policies"}
	pathParameters := []string{*getLoadBalancerListenerPolicyOptions.LoadBalancerID, *getLoadBalancerListenerPolicyOptions.ListenerID, *getLoadBalancerListenerPolicyOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getLoadBalancerListenerPolicyOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetLoadBalancerListenerPolicy")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalLoadBalancerListenerPolicy)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// UpdateLoadBalancerListenerPolicy : Update a policy of the load balancer listener
// Updates a policy from a policy patch.
func (vpc *VpcV1) UpdateLoadBalancerListenerPolicy(updateLoadBalancerListenerPolicyOptions *UpdateLoadBalancerListenerPolicyOptions) (result *LoadBalancerListenerPolicy, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateLoadBalancerListenerPolicyOptions, "updateLoadBalancerListenerPolicyOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateLoadBalancerListenerPolicyOptions, "updateLoadBalancerListenerPolicyOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"load_balancers", "listeners", "policies"}
	pathParameters := []string{*updateLoadBalancerListenerPolicyOptions.LoadBalancerID, *updateLoadBalancerListenerPolicyOptions.ListenerID, *updateLoadBalancerListenerPolicyOptions.ID}

	builder := core.NewRequestBuilder(core.PATCH)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateLoadBalancerListenerPolicyOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateLoadBalancerListenerPolicy")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if updateLoadBalancerListenerPolicyOptions.Name != nil {
		body["name"] = updateLoadBalancerListenerPolicyOptions.Name
	}
	if updateLoadBalancerListenerPolicyOptions.Priority != nil {
		body["priority"] = updateLoadBalancerListenerPolicyOptions.Priority
	}
	if updateLoadBalancerListenerPolicyOptions.Target != nil {
		body["target"] = updateLoadBalancerListenerPolicyOptions.Target
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalLoadBalancerListenerPolicy)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// ListLoadBalancerListenerPolicyRules : List all rules of the load balancer listener policy
// Retrieves a list of all rules belonging to the load balancer listener policy.
func (vpc *VpcV1) ListLoadBalancerListenerPolicyRules(listLoadBalancerListenerPolicyRulesOptions *ListLoadBalancerListenerPolicyRulesOptions) (result *LoadBalancerListenerPolicyRuleCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listLoadBalancerListenerPolicyRulesOptions, "listLoadBalancerListenerPolicyRulesOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listLoadBalancerListenerPolicyRulesOptions, "listLoadBalancerListenerPolicyRulesOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"load_balancers", "listeners", "policies", "rules"}
	pathParameters := []string{*listLoadBalancerListenerPolicyRulesOptions.LoadBalancerID, *listLoadBalancerListenerPolicyRulesOptions.ListenerID, *listLoadBalancerListenerPolicyRulesOptions.PolicyID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listLoadBalancerListenerPolicyRulesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListLoadBalancerListenerPolicyRules")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalLoadBalancerListenerPolicyRuleCollection)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// CreateLoadBalancerListenerPolicyRule : Create a rule for the load balancer listener policy
// Creates a new rule for the load balancer listener policy.
func (vpc *VpcV1) CreateLoadBalancerListenerPolicyRule(createLoadBalancerListenerPolicyRuleOptions *CreateLoadBalancerListenerPolicyRuleOptions) (result *LoadBalancerListenerPolicyRule, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createLoadBalancerListenerPolicyRuleOptions, "createLoadBalancerListenerPolicyRuleOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createLoadBalancerListenerPolicyRuleOptions, "createLoadBalancerListenerPolicyRuleOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"load_balancers", "listeners", "policies", "rules"}
	pathParameters := []string{*createLoadBalancerListenerPolicyRuleOptions.LoadBalancerID, *createLoadBalancerListenerPolicyRuleOptions.ListenerID, *createLoadBalancerListenerPolicyRuleOptions.PolicyID}

	builder := core.NewRequestBuilder(core.POST)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range createLoadBalancerListenerPolicyRuleOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateLoadBalancerListenerPolicyRule")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if createLoadBalancerListenerPolicyRuleOptions.Condition != nil {
		body["condition"] = createLoadBalancerListenerPolicyRuleOptions.Condition
	}
	if createLoadBalancerListenerPolicyRuleOptions.Type != nil {
		body["type"] = createLoadBalancerListenerPolicyRuleOptions.Type
	}
	if createLoadBalancerListenerPolicyRuleOptions.Value != nil {
		body["value"] = createLoadBalancerListenerPolicyRuleOptions.Value
	}
	if createLoadBalancerListenerPolicyRuleOptions.Field != nil {
		body["field"] = createLoadBalancerListenerPolicyRuleOptions.Field
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalLoadBalancerListenerPolicyRule)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// DeleteLoadBalancerListenerPolicyRule : Delete a rule from the load balancer listener policy
// Deletes a rule from the load balancer listener policy. This operation cannot be reversed.
func (vpc *VpcV1) DeleteLoadBalancerListenerPolicyRule(deleteLoadBalancerListenerPolicyRuleOptions *DeleteLoadBalancerListenerPolicyRuleOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteLoadBalancerListenerPolicyRuleOptions, "deleteLoadBalancerListenerPolicyRuleOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteLoadBalancerListenerPolicyRuleOptions, "deleteLoadBalancerListenerPolicyRuleOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"load_balancers", "listeners", "policies", "rules"}
	pathParameters := []string{*deleteLoadBalancerListenerPolicyRuleOptions.LoadBalancerID, *deleteLoadBalancerListenerPolicyRuleOptions.ListenerID, *deleteLoadBalancerListenerPolicyRuleOptions.PolicyID, *deleteLoadBalancerListenerPolicyRuleOptions.ID}

	builder := core.NewRequestBuilder(core.DELETE)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteLoadBalancerListenerPolicyRuleOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteLoadBalancerListenerPolicyRule")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetLoadBalancerListenerPolicyRule : Retrieve a rule of the load balancer listener policy
// Retrieves a single rule specified by the identifier in the URL path.
func (vpc *VpcV1) GetLoadBalancerListenerPolicyRule(getLoadBalancerListenerPolicyRuleOptions *GetLoadBalancerListenerPolicyRuleOptions) (result *LoadBalancerListenerPolicyRule, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getLoadBalancerListenerPolicyRuleOptions, "getLoadBalancerListenerPolicyRuleOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getLoadBalancerListenerPolicyRuleOptions, "getLoadBalancerListenerPolicyRuleOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"load_balancers", "listeners", "policies", "rules"}
	pathParameters := []string{*getLoadBalancerListenerPolicyRuleOptions.LoadBalancerID, *getLoadBalancerListenerPolicyRuleOptions.ListenerID, *getLoadBalancerListenerPolicyRuleOptions.PolicyID, *getLoadBalancerListenerPolicyRuleOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getLoadBalancerListenerPolicyRuleOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetLoadBalancerListenerPolicyRule")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalLoadBalancerListenerPolicyRule)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// UpdateLoadBalancerListenerPolicyRule : Update a rule of the load balancer listener policy
// Updates a rule of the load balancer listener policy.
func (vpc *VpcV1) UpdateLoadBalancerListenerPolicyRule(updateLoadBalancerListenerPolicyRuleOptions *UpdateLoadBalancerListenerPolicyRuleOptions) (result *LoadBalancerListenerPolicyRule, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateLoadBalancerListenerPolicyRuleOptions, "updateLoadBalancerListenerPolicyRuleOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateLoadBalancerListenerPolicyRuleOptions, "updateLoadBalancerListenerPolicyRuleOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"load_balancers", "listeners", "policies", "rules"}
	pathParameters := []string{*updateLoadBalancerListenerPolicyRuleOptions.LoadBalancerID, *updateLoadBalancerListenerPolicyRuleOptions.ListenerID, *updateLoadBalancerListenerPolicyRuleOptions.PolicyID, *updateLoadBalancerListenerPolicyRuleOptions.ID}

	builder := core.NewRequestBuilder(core.PATCH)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateLoadBalancerListenerPolicyRuleOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateLoadBalancerListenerPolicyRule")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if updateLoadBalancerListenerPolicyRuleOptions.Condition != nil {
		body["condition"] = updateLoadBalancerListenerPolicyRuleOptions.Condition
	}
	if updateLoadBalancerListenerPolicyRuleOptions.Field != nil {
		body["field"] = updateLoadBalancerListenerPolicyRuleOptions.Field
	}
	if updateLoadBalancerListenerPolicyRuleOptions.Type != nil {
		body["type"] = updateLoadBalancerListenerPolicyRuleOptions.Type
	}
	if updateLoadBalancerListenerPolicyRuleOptions.Value != nil {
		body["value"] = updateLoadBalancerListenerPolicyRuleOptions.Value
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalLoadBalancerListenerPolicyRule)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// ListLoadBalancerPools : List all pools of the load balancer
// This request lists all pools that belong to the load balancer.
func (vpc *VpcV1) ListLoadBalancerPools(listLoadBalancerPoolsOptions *ListLoadBalancerPoolsOptions) (result *LoadBalancerPoolCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listLoadBalancerPoolsOptions, "listLoadBalancerPoolsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listLoadBalancerPoolsOptions, "listLoadBalancerPoolsOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"load_balancers", "pools"}
	pathParameters := []string{*listLoadBalancerPoolsOptions.LoadBalancerID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listLoadBalancerPoolsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListLoadBalancerPools")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalLoadBalancerPoolCollection)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// CreateLoadBalancerPool : Create a load balancer pool
// This request creates a new pool from a pool prototype object.
func (vpc *VpcV1) CreateLoadBalancerPool(createLoadBalancerPoolOptions *CreateLoadBalancerPoolOptions) (result *LoadBalancerPool, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createLoadBalancerPoolOptions, "createLoadBalancerPoolOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createLoadBalancerPoolOptions, "createLoadBalancerPoolOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"load_balancers", "pools"}
	pathParameters := []string{*createLoadBalancerPoolOptions.LoadBalancerID}

	builder := core.NewRequestBuilder(core.POST)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range createLoadBalancerPoolOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateLoadBalancerPool")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if createLoadBalancerPoolOptions.Algorithm != nil {
		body["algorithm"] = createLoadBalancerPoolOptions.Algorithm
	}
	if createLoadBalancerPoolOptions.HealthMonitor != nil {
		body["health_monitor"] = createLoadBalancerPoolOptions.HealthMonitor
	}
	if createLoadBalancerPoolOptions.Protocol != nil {
		body["protocol"] = createLoadBalancerPoolOptions.Protocol
	}
	if createLoadBalancerPoolOptions.Members != nil {
		body["members"] = createLoadBalancerPoolOptions.Members
	}
	if createLoadBalancerPoolOptions.Name != nil {
		body["name"] = createLoadBalancerPoolOptions.Name
	}
	if createLoadBalancerPoolOptions.SessionPersistence != nil {
		body["session_persistence"] = createLoadBalancerPoolOptions.SessionPersistence
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalLoadBalancerPool)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// DeleteLoadBalancerPool : Delete a pool
// This request deletes a load balancer pool. This operation cannot be reversed.
func (vpc *VpcV1) DeleteLoadBalancerPool(deleteLoadBalancerPoolOptions *DeleteLoadBalancerPoolOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteLoadBalancerPoolOptions, "deleteLoadBalancerPoolOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteLoadBalancerPoolOptions, "deleteLoadBalancerPoolOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"load_balancers", "pools"}
	pathParameters := []string{*deleteLoadBalancerPoolOptions.LoadBalancerID, *deleteLoadBalancerPoolOptions.ID}

	builder := core.NewRequestBuilder(core.DELETE)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteLoadBalancerPoolOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteLoadBalancerPool")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetLoadBalancerPool : Retrieve a load balancer pool
// This request retrieves a single pool specified by the identifier in the URL path.
func (vpc *VpcV1) GetLoadBalancerPool(getLoadBalancerPoolOptions *GetLoadBalancerPoolOptions) (result *LoadBalancerPool, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getLoadBalancerPoolOptions, "getLoadBalancerPoolOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getLoadBalancerPoolOptions, "getLoadBalancerPoolOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"load_balancers", "pools"}
	pathParameters := []string{*getLoadBalancerPoolOptions.LoadBalancerID, *getLoadBalancerPoolOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getLoadBalancerPoolOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetLoadBalancerPool")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalLoadBalancerPool)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// UpdateLoadBalancerPool : Update a load balancer pool
// This request updates a load balancer pool from a pool patch.
func (vpc *VpcV1) UpdateLoadBalancerPool(updateLoadBalancerPoolOptions *UpdateLoadBalancerPoolOptions) (result *LoadBalancerPool, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateLoadBalancerPoolOptions, "updateLoadBalancerPoolOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateLoadBalancerPoolOptions, "updateLoadBalancerPoolOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"load_balancers", "pools"}
	pathParameters := []string{*updateLoadBalancerPoolOptions.LoadBalancerID, *updateLoadBalancerPoolOptions.ID}

	builder := core.NewRequestBuilder(core.PATCH)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateLoadBalancerPoolOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateLoadBalancerPool")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if updateLoadBalancerPoolOptions.Algorithm != nil {
		body["algorithm"] = updateLoadBalancerPoolOptions.Algorithm
	}
	if updateLoadBalancerPoolOptions.HealthMonitor != nil {
		body["health_monitor"] = updateLoadBalancerPoolOptions.HealthMonitor
	}
	if updateLoadBalancerPoolOptions.Name != nil {
		body["name"] = updateLoadBalancerPoolOptions.Name
	}
	if updateLoadBalancerPoolOptions.Protocol != nil {
		body["protocol"] = updateLoadBalancerPoolOptions.Protocol
	}
	if updateLoadBalancerPoolOptions.SessionPersistence != nil {
		body["session_persistence"] = updateLoadBalancerPoolOptions.SessionPersistence
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalLoadBalancerPool)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// ListLoadBalancerPoolMembers : List all members of the load balancer pool
// This request retrieves a paginated list of all members that belong to the pool.
func (vpc *VpcV1) ListLoadBalancerPoolMembers(listLoadBalancerPoolMembersOptions *ListLoadBalancerPoolMembersOptions) (result *LoadBalancerPoolMemberCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listLoadBalancerPoolMembersOptions, "listLoadBalancerPoolMembersOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listLoadBalancerPoolMembersOptions, "listLoadBalancerPoolMembersOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"load_balancers", "pools", "members"}
	pathParameters := []string{*listLoadBalancerPoolMembersOptions.LoadBalancerID, *listLoadBalancerPoolMembersOptions.PoolID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listLoadBalancerPoolMembersOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListLoadBalancerPoolMembers")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalLoadBalancerPoolMemberCollection)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// CreateLoadBalancerPoolMember : Create a member in the load balancer pool
// This request creates a new member and adds the member to the pool.
func (vpc *VpcV1) CreateLoadBalancerPoolMember(createLoadBalancerPoolMemberOptions *CreateLoadBalancerPoolMemberOptions) (result *LoadBalancerPoolMember, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createLoadBalancerPoolMemberOptions, "createLoadBalancerPoolMemberOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createLoadBalancerPoolMemberOptions, "createLoadBalancerPoolMemberOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"load_balancers", "pools", "members"}
	pathParameters := []string{*createLoadBalancerPoolMemberOptions.LoadBalancerID, *createLoadBalancerPoolMemberOptions.PoolID}

	builder := core.NewRequestBuilder(core.POST)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range createLoadBalancerPoolMemberOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateLoadBalancerPoolMember")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if createLoadBalancerPoolMemberOptions.Port != nil {
		body["port"] = createLoadBalancerPoolMemberOptions.Port
	}
	if createLoadBalancerPoolMemberOptions.Target != nil {
		body["target"] = createLoadBalancerPoolMemberOptions.Target
	}
	if createLoadBalancerPoolMemberOptions.Weight != nil {
		body["weight"] = createLoadBalancerPoolMemberOptions.Weight
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalLoadBalancerPoolMember)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// ReplaceLoadBalancerPoolMembers : Update members of the load balancer pool
// This request updates members of the load balancer pool from a collection of member prototype objects.
func (vpc *VpcV1) ReplaceLoadBalancerPoolMembers(replaceLoadBalancerPoolMembersOptions *ReplaceLoadBalancerPoolMembersOptions) (result *LoadBalancerPoolMemberCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(replaceLoadBalancerPoolMembersOptions, "replaceLoadBalancerPoolMembersOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(replaceLoadBalancerPoolMembersOptions, "replaceLoadBalancerPoolMembersOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"load_balancers", "pools", "members"}
	pathParameters := []string{*replaceLoadBalancerPoolMembersOptions.LoadBalancerID, *replaceLoadBalancerPoolMembersOptions.PoolID}

	builder := core.NewRequestBuilder(core.PUT)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range replaceLoadBalancerPoolMembersOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ReplaceLoadBalancerPoolMembers")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if replaceLoadBalancerPoolMembersOptions.Members != nil {
		body["members"] = replaceLoadBalancerPoolMembersOptions.Members
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalLoadBalancerPoolMemberCollection)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// DeleteLoadBalancerPoolMember : Delete a member from the load balancer pool
// This request deletes a member from the pool. This operation cannot be reversed.
func (vpc *VpcV1) DeleteLoadBalancerPoolMember(deleteLoadBalancerPoolMemberOptions *DeleteLoadBalancerPoolMemberOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteLoadBalancerPoolMemberOptions, "deleteLoadBalancerPoolMemberOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteLoadBalancerPoolMemberOptions, "deleteLoadBalancerPoolMemberOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"load_balancers", "pools", "members"}
	pathParameters := []string{*deleteLoadBalancerPoolMemberOptions.LoadBalancerID, *deleteLoadBalancerPoolMemberOptions.PoolID, *deleteLoadBalancerPoolMemberOptions.ID}

	builder := core.NewRequestBuilder(core.DELETE)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteLoadBalancerPoolMemberOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteLoadBalancerPoolMember")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetLoadBalancerPoolMember : Retrieve a member in the load balancer pool
// This request retrieves a single member specified by the identifier in the URL path.
func (vpc *VpcV1) GetLoadBalancerPoolMember(getLoadBalancerPoolMemberOptions *GetLoadBalancerPoolMemberOptions) (result *LoadBalancerPoolMember, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getLoadBalancerPoolMemberOptions, "getLoadBalancerPoolMemberOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getLoadBalancerPoolMemberOptions, "getLoadBalancerPoolMemberOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"load_balancers", "pools", "members"}
	pathParameters := []string{*getLoadBalancerPoolMemberOptions.LoadBalancerID, *getLoadBalancerPoolMemberOptions.PoolID, *getLoadBalancerPoolMemberOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getLoadBalancerPoolMemberOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetLoadBalancerPoolMember")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalLoadBalancerPoolMember)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// UpdateLoadBalancerPoolMember : Update a member in the load balancer pool
// This request updates an existing member from a member patch.
func (vpc *VpcV1) UpdateLoadBalancerPoolMember(updateLoadBalancerPoolMemberOptions *UpdateLoadBalancerPoolMemberOptions) (result *LoadBalancerPoolMember, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateLoadBalancerPoolMemberOptions, "updateLoadBalancerPoolMemberOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateLoadBalancerPoolMemberOptions, "updateLoadBalancerPoolMemberOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"load_balancers", "pools", "members"}
	pathParameters := []string{*updateLoadBalancerPoolMemberOptions.LoadBalancerID, *updateLoadBalancerPoolMemberOptions.PoolID, *updateLoadBalancerPoolMemberOptions.ID}

	builder := core.NewRequestBuilder(core.PATCH)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateLoadBalancerPoolMemberOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateLoadBalancerPoolMember")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if updateLoadBalancerPoolMemberOptions.Port != nil {
		body["port"] = updateLoadBalancerPoolMemberOptions.Port
	}
	if updateLoadBalancerPoolMemberOptions.Target != nil {
		body["target"] = updateLoadBalancerPoolMemberOptions.Target
	}
	if updateLoadBalancerPoolMemberOptions.Weight != nil {
		body["weight"] = updateLoadBalancerPoolMemberOptions.Weight
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalLoadBalancerPoolMember)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// ListNetworkAcls : List all network ACLs
// This request lists all network ACLs in the region. A network ACL defines a set of packet filtering (5-tuple) rules
// for all traffic in and out of a subnet. Both allow and deny rules can be defined, and rules are stateless such that
// reverse traffic in response to allowed traffic is not automatically permitted.
func (vpc *VpcV1) ListNetworkAcls(listNetworkAclsOptions *ListNetworkAclsOptions) (result *NetworkACLCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listNetworkAclsOptions, "listNetworkAclsOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"network_acls"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listNetworkAclsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListNetworkAcls")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listNetworkAclsOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listNetworkAclsOptions.Start))
	}
	if listNetworkAclsOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listNetworkAclsOptions.Limit))
	}
	if listNetworkAclsOptions.ResourceGroupID != nil {
		builder.AddQuery("resource_group.id", fmt.Sprint(*listNetworkAclsOptions.ResourceGroupID))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalNetworkACLCollection)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// CreateNetworkACL : Create a network ACL
// This request creates a new network ACL from a network ACL prototype object. The prototype object is structured in the
// same way as a retrieved network ACL, and contains the information necessary to create the new network ACL.
func (vpc *VpcV1) CreateNetworkACL(createNetworkACLOptions *CreateNetworkACLOptions) (result *NetworkACL, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(createNetworkACLOptions, "createNetworkACLOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"network_acls"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.POST)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range createNetworkACLOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateNetworkACL")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	if createNetworkACLOptions.NetworkACLPrototype != nil {
		_, err = builder.SetBodyContentJSON(createNetworkACLOptions.NetworkACLPrototype)
		if err != nil {
			return
		}
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalNetworkACL)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// DeleteNetworkACL : Delete specified network ACL
// This request deletes a network ACL. This operation cannot be reversed. For this request to succeed, the network ACL
// must not be the default network ACL for any VPCs, and the network ACL must not be attached to any subnets.
func (vpc *VpcV1) DeleteNetworkACL(deleteNetworkACLOptions *DeleteNetworkACLOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteNetworkACLOptions, "deleteNetworkACLOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteNetworkACLOptions, "deleteNetworkACLOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"network_acls"}
	pathParameters := []string{*deleteNetworkACLOptions.ID}

	builder := core.NewRequestBuilder(core.DELETE)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteNetworkACLOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteNetworkACL")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetNetworkACL : Retrieve specified network ACL
// This request retrieves a single network ACL specified by the identifier in the URL.
func (vpc *VpcV1) GetNetworkACL(getNetworkACLOptions *GetNetworkACLOptions) (result *NetworkACL, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getNetworkACLOptions, "getNetworkACLOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getNetworkACLOptions, "getNetworkACLOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"network_acls"}
	pathParameters := []string{*getNetworkACLOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getNetworkACLOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetNetworkACL")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalNetworkACL)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// UpdateNetworkACL : Update a network ACL
// This request updates a network ACL's name.
func (vpc *VpcV1) UpdateNetworkACL(updateNetworkACLOptions *UpdateNetworkACLOptions) (result *NetworkACL, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateNetworkACLOptions, "updateNetworkACLOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateNetworkACLOptions, "updateNetworkACLOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"network_acls"}
	pathParameters := []string{*updateNetworkACLOptions.ID}

	builder := core.NewRequestBuilder(core.PATCH)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateNetworkACLOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateNetworkACL")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if updateNetworkACLOptions.Name != nil {
		body["name"] = updateNetworkACLOptions.Name
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalNetworkACL)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// ListNetworkACLRules : List all rules for a network ACL
// This request lists all rules for a network ACL. These rules can allow or deny traffic between a source CIDR block and
// a destination CIDR block over a particular protocol and port range.
func (vpc *VpcV1) ListNetworkACLRules(listNetworkACLRulesOptions *ListNetworkACLRulesOptions) (result *NetworkACLRuleCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listNetworkACLRulesOptions, "listNetworkACLRulesOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listNetworkACLRulesOptions, "listNetworkACLRulesOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"network_acls", "rules"}
	pathParameters := []string{*listNetworkACLRulesOptions.NetworkACLID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listNetworkACLRulesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListNetworkACLRules")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listNetworkACLRulesOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listNetworkACLRulesOptions.Start))
	}
	if listNetworkACLRulesOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listNetworkACLRulesOptions.Limit))
	}
	if listNetworkACLRulesOptions.Direction != nil {
		builder.AddQuery("direction", fmt.Sprint(*listNetworkACLRulesOptions.Direction))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalNetworkACLRuleCollection)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// CreateNetworkACLRule : Create a rule
// This request creates a new rule from a network ACL rule prototype object. The prototype object is structured in the
// same way as a retrieved rule, and contains the information necessary to create the new rule.
func (vpc *VpcV1) CreateNetworkACLRule(createNetworkACLRuleOptions *CreateNetworkACLRuleOptions) (result NetworkACLRuleIntf, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createNetworkACLRuleOptions, "createNetworkACLRuleOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createNetworkACLRuleOptions, "createNetworkACLRuleOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"network_acls", "rules"}
	pathParameters := []string{*createNetworkACLRuleOptions.NetworkACLID}

	builder := core.NewRequestBuilder(core.POST)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range createNetworkACLRuleOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateNetworkACLRule")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(createNetworkACLRuleOptions.NetworkACLRulePrototype)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalNetworkACLRule)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// DeleteNetworkACLRule : Delete specified rule
// This request deletes a rule. This operation cannot be reversed.
func (vpc *VpcV1) DeleteNetworkACLRule(deleteNetworkACLRuleOptions *DeleteNetworkACLRuleOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteNetworkACLRuleOptions, "deleteNetworkACLRuleOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteNetworkACLRuleOptions, "deleteNetworkACLRuleOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"network_acls", "rules"}
	pathParameters := []string{*deleteNetworkACLRuleOptions.NetworkACLID, *deleteNetworkACLRuleOptions.ID}

	builder := core.NewRequestBuilder(core.DELETE)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteNetworkACLRuleOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteNetworkACLRule")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetNetworkACLRule : Retrieve specified rule
// This request retrieves a single rule specified by the identifier in the URL.
func (vpc *VpcV1) GetNetworkACLRule(getNetworkACLRuleOptions *GetNetworkACLRuleOptions) (result NetworkACLRuleIntf, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getNetworkACLRuleOptions, "getNetworkACLRuleOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getNetworkACLRuleOptions, "getNetworkACLRuleOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"network_acls", "rules"}
	pathParameters := []string{*getNetworkACLRuleOptions.NetworkACLID, *getNetworkACLRuleOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getNetworkACLRuleOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetNetworkACLRule")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalNetworkACLRule)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// UpdateNetworkACLRule : Update a rule
// This request updates a rule with the information in a provided rule patch. The rule patch object contains only the
// information to be updated. The request will fail if the information is not applicable to the rule's protocol.
func (vpc *VpcV1) UpdateNetworkACLRule(updateNetworkACLRuleOptions *UpdateNetworkACLRuleOptions) (result NetworkACLRuleIntf, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateNetworkACLRuleOptions, "updateNetworkACLRuleOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateNetworkACLRuleOptions, "updateNetworkACLRuleOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"network_acls", "rules"}
	pathParameters := []string{*updateNetworkACLRuleOptions.NetworkACLID, *updateNetworkACLRuleOptions.ID}

	builder := core.NewRequestBuilder(core.PATCH)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateNetworkACLRuleOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateNetworkACLRule")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if updateNetworkACLRuleOptions.Action != nil {
		body["action"] = updateNetworkACLRuleOptions.Action
	}
	if updateNetworkACLRuleOptions.Before != nil {
		body["before"] = updateNetworkACLRuleOptions.Before
	}
	if updateNetworkACLRuleOptions.Code != nil {
		body["code"] = updateNetworkACLRuleOptions.Code
	}
	if updateNetworkACLRuleOptions.Destination != nil {
		body["destination"] = updateNetworkACLRuleOptions.Destination
	}
	if updateNetworkACLRuleOptions.DestinationPortMax != nil {
		body["destination_port_max"] = updateNetworkACLRuleOptions.DestinationPortMax
	}
	if updateNetworkACLRuleOptions.DestinationPortMin != nil {
		body["destination_port_min"] = updateNetworkACLRuleOptions.DestinationPortMin
	}
	if updateNetworkACLRuleOptions.Direction != nil {
		body["direction"] = updateNetworkACLRuleOptions.Direction
	}
	if updateNetworkACLRuleOptions.Name != nil {
		body["name"] = updateNetworkACLRuleOptions.Name
	}
	if updateNetworkACLRuleOptions.Source != nil {
		body["source"] = updateNetworkACLRuleOptions.Source
	}
	if updateNetworkACLRuleOptions.SourcePortMax != nil {
		body["source_port_max"] = updateNetworkACLRuleOptions.SourcePortMax
	}
	if updateNetworkACLRuleOptions.SourcePortMin != nil {
		body["source_port_min"] = updateNetworkACLRuleOptions.SourcePortMin
	}
	if updateNetworkACLRuleOptions.Type != nil {
		body["type"] = updateNetworkACLRuleOptions.Type
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalNetworkACLRule)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// ListPublicGateways : List all public gateways
// This request lists all public gateways. A public gateway is a virtual network device associated with a VPC, which
// allows access to the Internet. A public gateway resides in a zone and can be connected to subnets in the same zone
// only.
func (vpc *VpcV1) ListPublicGateways(listPublicGatewaysOptions *ListPublicGatewaysOptions) (result *PublicGatewayCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listPublicGatewaysOptions, "listPublicGatewaysOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"public_gateways"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listPublicGatewaysOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListPublicGateways")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listPublicGatewaysOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listPublicGatewaysOptions.Start))
	}
	if listPublicGatewaysOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listPublicGatewaysOptions.Limit))
	}
	if listPublicGatewaysOptions.ResourceGroupID != nil {
		builder.AddQuery("resource_group.id", fmt.Sprint(*listPublicGatewaysOptions.ResourceGroupID))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalPublicGatewayCollection)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// CreatePublicGateway : Create a public gateway
// This request creates a new public gateway from a public gateway prototype object. If a floating IP is provided, it
// must be unbound. If a floating IP is not provided, one will be created and bound to the public gateway. Once a public
// gateway has been created, its floating IP cannot be unbound. A public gateway must be explicitly attached to each
// subnet it will provide connectivity for.
func (vpc *VpcV1) CreatePublicGateway(createPublicGatewayOptions *CreatePublicGatewayOptions) (result *PublicGateway, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createPublicGatewayOptions, "createPublicGatewayOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createPublicGatewayOptions, "createPublicGatewayOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"public_gateways"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.POST)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range createPublicGatewayOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreatePublicGateway")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if createPublicGatewayOptions.VPC != nil {
		body["vpc"] = createPublicGatewayOptions.VPC
	}
	if createPublicGatewayOptions.Zone != nil {
		body["zone"] = createPublicGatewayOptions.Zone
	}
	if createPublicGatewayOptions.FloatingIP != nil {
		body["floating_ip"] = createPublicGatewayOptions.FloatingIP
	}
	if createPublicGatewayOptions.Name != nil {
		body["name"] = createPublicGatewayOptions.Name
	}
	if createPublicGatewayOptions.ResourceGroup != nil {
		body["resource_group"] = createPublicGatewayOptions.ResourceGroup
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalPublicGateway)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// DeletePublicGateway : Delete specified public gateway
// This request deletes a public gateway. This operation cannot be reversed. For this request to succeed, the public
// gateway must not be attached to any subnets. The public gateway's floating IP will be automatically unbound. If the
// floating IP was created when the public gateway was created, it will be deleted.
func (vpc *VpcV1) DeletePublicGateway(deletePublicGatewayOptions *DeletePublicGatewayOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deletePublicGatewayOptions, "deletePublicGatewayOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deletePublicGatewayOptions, "deletePublicGatewayOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"public_gateways"}
	pathParameters := []string{*deletePublicGatewayOptions.ID}

	builder := core.NewRequestBuilder(core.DELETE)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range deletePublicGatewayOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeletePublicGateway")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetPublicGateway : Retrieve specified public gateway
// This request retrieves a single public gateway specified by the identifier in the URL.
func (vpc *VpcV1) GetPublicGateway(getPublicGatewayOptions *GetPublicGatewayOptions) (result *PublicGateway, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getPublicGatewayOptions, "getPublicGatewayOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getPublicGatewayOptions, "getPublicGatewayOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"public_gateways"}
	pathParameters := []string{*getPublicGatewayOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getPublicGatewayOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetPublicGateway")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalPublicGateway)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// UpdatePublicGateway : Update a public gateway's name
// This request updates a public gateway's name.
func (vpc *VpcV1) UpdatePublicGateway(updatePublicGatewayOptions *UpdatePublicGatewayOptions) (result *PublicGateway, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updatePublicGatewayOptions, "updatePublicGatewayOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updatePublicGatewayOptions, "updatePublicGatewayOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"public_gateways"}
	pathParameters := []string{*updatePublicGatewayOptions.ID}

	builder := core.NewRequestBuilder(core.PATCH)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range updatePublicGatewayOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdatePublicGateway")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if updatePublicGatewayOptions.Name != nil {
		body["name"] = updatePublicGatewayOptions.Name
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalPublicGateway)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// ListKeys : List all keys
// This request lists all keys. A key contains a public SSH key which may be installed on instances when they are
// created. Private keys are not stored.
func (vpc *VpcV1) ListKeys(listKeysOptions *ListKeysOptions) (result *KeyCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listKeysOptions, "listKeysOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"keys"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listKeysOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListKeys")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listKeysOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listKeysOptions.Start))
	}
	if listKeysOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listKeysOptions.Limit))
	}
	if listKeysOptions.ResourceGroupID != nil {
		builder.AddQuery("resource_group.id", fmt.Sprint(*listKeysOptions.ResourceGroupID))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalKeyCollection)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// CreateKey : Create a key
// This request creates a new SSH key from an key prototype object. The prototype object is structured in the same way
// as a retrieved key, and contains the information necessary to create the new key. The public key value must be
// provided.
func (vpc *VpcV1) CreateKey(createKeyOptions *CreateKeyOptions) (result *Key, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createKeyOptions, "createKeyOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createKeyOptions, "createKeyOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"keys"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.POST)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range createKeyOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateKey")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if createKeyOptions.PublicKey != nil {
		body["public_key"] = createKeyOptions.PublicKey
	}
	if createKeyOptions.Name != nil {
		body["name"] = createKeyOptions.Name
	}
	if createKeyOptions.ResourceGroup != nil {
		body["resource_group"] = createKeyOptions.ResourceGroup
	}
	if createKeyOptions.Type != nil {
		body["type"] = createKeyOptions.Type
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalKey)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// DeleteKey : Delete specified key
// This request deletes a key. This operation cannot be reversed.
func (vpc *VpcV1) DeleteKey(deleteKeyOptions *DeleteKeyOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteKeyOptions, "deleteKeyOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteKeyOptions, "deleteKeyOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"keys"}
	pathParameters := []string{*deleteKeyOptions.ID}

	builder := core.NewRequestBuilder(core.DELETE)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteKeyOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteKey")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetKey : Retrieve specified key
// This request retrieves a single key specified by the identifier in the URL.
func (vpc *VpcV1) GetKey(getKeyOptions *GetKeyOptions) (result *Key, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getKeyOptions, "getKeyOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getKeyOptions, "getKeyOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"keys"}
	pathParameters := []string{*getKeyOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getKeyOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetKey")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalKey)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// UpdateKey : Update specified key
// This request updates a key's name.
func (vpc *VpcV1) UpdateKey(updateKeyOptions *UpdateKeyOptions) (result *Key, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateKeyOptions, "updateKeyOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateKeyOptions, "updateKeyOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"keys"}
	pathParameters := []string{*updateKeyOptions.ID}

	builder := core.NewRequestBuilder(core.PATCH)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateKeyOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateKey")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if updateKeyOptions.Name != nil {
		body["name"] = updateKeyOptions.Name
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalKey)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// ListSecurityGroups : List all security groups
// This request lists all existing security groups. Security groups provide a convenient way to apply IP filtering rules
// to instances in the associated VPC. With security groups, all traffic is denied by default, and rules added to
// security groups define which traffic the security group permits. Security group rules are stateful such that reverse
// traffic in response to allowed traffic is automatically permitted.
func (vpc *VpcV1) ListSecurityGroups(listSecurityGroupsOptions *ListSecurityGroupsOptions) (result *SecurityGroupCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listSecurityGroupsOptions, "listSecurityGroupsOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"security_groups"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listSecurityGroupsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListSecurityGroups")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listSecurityGroupsOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listSecurityGroupsOptions.Start))
	}
	if listSecurityGroupsOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listSecurityGroupsOptions.Limit))
	}
	if listSecurityGroupsOptions.ResourceGroupID != nil {
		builder.AddQuery("resource_group.id", fmt.Sprint(*listSecurityGroupsOptions.ResourceGroupID))
	}
	if listSecurityGroupsOptions.VPCID != nil {
		builder.AddQuery("vpc.id", fmt.Sprint(*listSecurityGroupsOptions.VPCID))
	}
	if listSecurityGroupsOptions.VPCCRN != nil {
		builder.AddQuery("vpc.crn", fmt.Sprint(*listSecurityGroupsOptions.VPCCRN))
	}
	if listSecurityGroupsOptions.VPCName != nil {
		builder.AddQuery("vpc.name", fmt.Sprint(*listSecurityGroupsOptions.VPCName))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSecurityGroupCollection)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// CreateSecurityGroup : Create a security group
// This request creates a new security group from a security group prototype object. The prototype object is structured
// in the same way as a retrieved security group, and contains the information necessary to create the new security
// group. If security group rules are included in the protoype object, those rules will be added to the security group.
// Each security group is scoped to one VPC. Only network interfaces on instances in that VPC can be added to the
// security group.
func (vpc *VpcV1) CreateSecurityGroup(createSecurityGroupOptions *CreateSecurityGroupOptions) (result *SecurityGroup, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createSecurityGroupOptions, "createSecurityGroupOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createSecurityGroupOptions, "createSecurityGroupOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"security_groups"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.POST)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range createSecurityGroupOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateSecurityGroup")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if createSecurityGroupOptions.VPC != nil {
		body["vpc"] = createSecurityGroupOptions.VPC
	}
	if createSecurityGroupOptions.Name != nil {
		body["name"] = createSecurityGroupOptions.Name
	}
	if createSecurityGroupOptions.ResourceGroup != nil {
		body["resource_group"] = createSecurityGroupOptions.ResourceGroup
	}
	if createSecurityGroupOptions.Rules != nil {
		body["rules"] = createSecurityGroupOptions.Rules
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSecurityGroup)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// DeleteSecurityGroup : Delete a security group
// This request deletes a security group. A security group cannot be deleted if it is referenced by any network
// interfaces or other security group rules. Additionally, a VPC's default security group cannot be deleted. This
// operation cannot be reversed.
func (vpc *VpcV1) DeleteSecurityGroup(deleteSecurityGroupOptions *DeleteSecurityGroupOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteSecurityGroupOptions, "deleteSecurityGroupOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteSecurityGroupOptions, "deleteSecurityGroupOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"security_groups"}
	pathParameters := []string{*deleteSecurityGroupOptions.ID}

	builder := core.NewRequestBuilder(core.DELETE)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteSecurityGroupOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteSecurityGroup")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetSecurityGroup : Retrieve a security group
// This request retrieves a single security group specified by the identifier in the URL path.
func (vpc *VpcV1) GetSecurityGroup(getSecurityGroupOptions *GetSecurityGroupOptions) (result *SecurityGroup, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getSecurityGroupOptions, "getSecurityGroupOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getSecurityGroupOptions, "getSecurityGroupOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"security_groups"}
	pathParameters := []string{*getSecurityGroupOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getSecurityGroupOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetSecurityGroup")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSecurityGroup)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// UpdateSecurityGroup : Update a security group
// This request updates a security group with the information provided in a security group patch object. The security
// group patch object is structured in the same way as a retrieved security group and contains only the information to
// be updated.
func (vpc *VpcV1) UpdateSecurityGroup(updateSecurityGroupOptions *UpdateSecurityGroupOptions) (result *SecurityGroup, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateSecurityGroupOptions, "updateSecurityGroupOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateSecurityGroupOptions, "updateSecurityGroupOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"security_groups"}
	pathParameters := []string{*updateSecurityGroupOptions.ID}

	builder := core.NewRequestBuilder(core.PATCH)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateSecurityGroupOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateSecurityGroup")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if updateSecurityGroupOptions.Name != nil {
		body["name"] = updateSecurityGroupOptions.Name
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSecurityGroup)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// ListSecurityGroupNetworkInterfaces : List a security group's network interfaces
// This request lists all network interfaces associated with the security group, to which the rules in the security
// group are applied.
func (vpc *VpcV1) ListSecurityGroupNetworkInterfaces(listSecurityGroupNetworkInterfacesOptions *ListSecurityGroupNetworkInterfacesOptions) (result *NetworkInterfaceCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listSecurityGroupNetworkInterfacesOptions, "listSecurityGroupNetworkInterfacesOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listSecurityGroupNetworkInterfacesOptions, "listSecurityGroupNetworkInterfacesOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"security_groups", "network_interfaces"}
	pathParameters := []string{*listSecurityGroupNetworkInterfacesOptions.SecurityGroupID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listSecurityGroupNetworkInterfacesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListSecurityGroupNetworkInterfaces")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalNetworkInterfaceCollection)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// RemoveSecurityGroupNetworkInterface : Remove a network interface from a security group
// This request removes a network interface from a security group. Security groups are stateful, so any changes to a
// network interface's security groups are applied to new connections. Existing connections are not affected. If the
// network interface being removed has no other security groups, it will be attached to the VPC's default security
// group.
func (vpc *VpcV1) RemoveSecurityGroupNetworkInterface(removeSecurityGroupNetworkInterfaceOptions *RemoveSecurityGroupNetworkInterfaceOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(removeSecurityGroupNetworkInterfaceOptions, "removeSecurityGroupNetworkInterfaceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(removeSecurityGroupNetworkInterfaceOptions, "removeSecurityGroupNetworkInterfaceOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"security_groups", "network_interfaces"}
	pathParameters := []string{*removeSecurityGroupNetworkInterfaceOptions.SecurityGroupID, *removeSecurityGroupNetworkInterfaceOptions.ID}

	builder := core.NewRequestBuilder(core.DELETE)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range removeSecurityGroupNetworkInterfaceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "RemoveSecurityGroupNetworkInterface")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetSecurityGroupNetworkInterface : Retrieve a network interface in a security group
// This request retrieves a single network interface specified by the identifier in the URL path. The network interface
// must be an existing member of the security group.
func (vpc *VpcV1) GetSecurityGroupNetworkInterface(getSecurityGroupNetworkInterfaceOptions *GetSecurityGroupNetworkInterfaceOptions) (result *NetworkInterface, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getSecurityGroupNetworkInterfaceOptions, "getSecurityGroupNetworkInterfaceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getSecurityGroupNetworkInterfaceOptions, "getSecurityGroupNetworkInterfaceOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"security_groups", "network_interfaces"}
	pathParameters := []string{*getSecurityGroupNetworkInterfaceOptions.SecurityGroupID, *getSecurityGroupNetworkInterfaceOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getSecurityGroupNetworkInterfaceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetSecurityGroupNetworkInterface")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalNetworkInterface)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// AddSecurityGroupNetworkInterface : Add a network interface to a security group
// This request adds an existing network interface to an existing security group. When a network interface is added to a
// security group, the security group rules are applied to the network interface. A request body is not required, and if
// supplied, is ignored.
func (vpc *VpcV1) AddSecurityGroupNetworkInterface(addSecurityGroupNetworkInterfaceOptions *AddSecurityGroupNetworkInterfaceOptions) (result *NetworkInterface, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(addSecurityGroupNetworkInterfaceOptions, "addSecurityGroupNetworkInterfaceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(addSecurityGroupNetworkInterfaceOptions, "addSecurityGroupNetworkInterfaceOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"security_groups", "network_interfaces"}
	pathParameters := []string{*addSecurityGroupNetworkInterfaceOptions.SecurityGroupID, *addSecurityGroupNetworkInterfaceOptions.ID}

	builder := core.NewRequestBuilder(core.PUT)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range addSecurityGroupNetworkInterfaceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "AddSecurityGroupNetworkInterface")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalNetworkInterface)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// ListSecurityGroupRules : List all the rules of a security group
// This request lists all the security group rules for a particular security group. These rules define what traffic the
// security group permits. Security group rules are stateful, such that reverse traffic in response to allowed traffic
// is automatically permitted.
func (vpc *VpcV1) ListSecurityGroupRules(listSecurityGroupRulesOptions *ListSecurityGroupRulesOptions) (result *SecurityGroupRuleCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listSecurityGroupRulesOptions, "listSecurityGroupRulesOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listSecurityGroupRulesOptions, "listSecurityGroupRulesOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"security_groups", "rules"}
	pathParameters := []string{*listSecurityGroupRulesOptions.SecurityGroupID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listSecurityGroupRulesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListSecurityGroupRules")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSecurityGroupRuleCollection)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// CreateSecurityGroupRule : Create a security group rule
// This request creates a new security group rule from a security group rule prototype object. The prototype object is
// structured in the same way as a retrieved security group rule and contains the information necessary to create the
// rule. As part of creating a new rule in a security group, the rule is applied to all the networking interfaces in the
// security group. Rules specify which IP traffic a security group should allow. Security group rules are stateful, such
// that reverse traffic in response to allowed traffic is automatically permitted. A rule allowing inbound TCP traffic
// on port 80 also allows outbound TCP traffic on port 80 without the need for an additional rule.
func (vpc *VpcV1) CreateSecurityGroupRule(createSecurityGroupRuleOptions *CreateSecurityGroupRuleOptions) (result SecurityGroupRuleIntf, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createSecurityGroupRuleOptions, "createSecurityGroupRuleOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createSecurityGroupRuleOptions, "createSecurityGroupRuleOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"security_groups", "rules"}
	pathParameters := []string{*createSecurityGroupRuleOptions.SecurityGroupID}

	builder := core.NewRequestBuilder(core.POST)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range createSecurityGroupRuleOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateSecurityGroupRule")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(createSecurityGroupRuleOptions.SecurityGroupRulePrototype)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSecurityGroupRule)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// DeleteSecurityGroupRule : Delete a security group rule
// This request deletes a security group rule. This operation cannot be reversed. Removing a security group rule will
// not end existing connections allowed by that rule.
func (vpc *VpcV1) DeleteSecurityGroupRule(deleteSecurityGroupRuleOptions *DeleteSecurityGroupRuleOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteSecurityGroupRuleOptions, "deleteSecurityGroupRuleOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteSecurityGroupRuleOptions, "deleteSecurityGroupRuleOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"security_groups", "rules"}
	pathParameters := []string{*deleteSecurityGroupRuleOptions.SecurityGroupID, *deleteSecurityGroupRuleOptions.ID}

	builder := core.NewRequestBuilder(core.DELETE)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteSecurityGroupRuleOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteSecurityGroupRule")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetSecurityGroupRule : Retrieve a security group rule
// This request retrieves a single security group rule specified by the identifier in the URL path.
func (vpc *VpcV1) GetSecurityGroupRule(getSecurityGroupRuleOptions *GetSecurityGroupRuleOptions) (result SecurityGroupRuleIntf, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getSecurityGroupRuleOptions, "getSecurityGroupRuleOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getSecurityGroupRuleOptions, "getSecurityGroupRuleOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"security_groups", "rules"}
	pathParameters := []string{*getSecurityGroupRuleOptions.SecurityGroupID, *getSecurityGroupRuleOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getSecurityGroupRuleOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetSecurityGroupRule")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSecurityGroupRule)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// UpdateSecurityGroupRule : Update a security group rule
// This request updates a security group rule with the information in a provided rule patch object. The rule patch
// object contains only the information to be updated. The request will fail if the information is not applicable to the
// rule's protocol.
func (vpc *VpcV1) UpdateSecurityGroupRule(updateSecurityGroupRuleOptions *UpdateSecurityGroupRuleOptions) (result SecurityGroupRuleIntf, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateSecurityGroupRuleOptions, "updateSecurityGroupRuleOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateSecurityGroupRuleOptions, "updateSecurityGroupRuleOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"security_groups", "rules"}
	pathParameters := []string{*updateSecurityGroupRuleOptions.SecurityGroupID, *updateSecurityGroupRuleOptions.ID}

	builder := core.NewRequestBuilder(core.PATCH)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateSecurityGroupRuleOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateSecurityGroupRule")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if updateSecurityGroupRuleOptions.Code != nil {
		body["code"] = updateSecurityGroupRuleOptions.Code
	}
	if updateSecurityGroupRuleOptions.Direction != nil {
		body["direction"] = updateSecurityGroupRuleOptions.Direction
	}
	if updateSecurityGroupRuleOptions.IPVersion != nil {
		body["ip_version"] = updateSecurityGroupRuleOptions.IPVersion
	}
	if updateSecurityGroupRuleOptions.PortMax != nil {
		body["port_max"] = updateSecurityGroupRuleOptions.PortMax
	}
	if updateSecurityGroupRuleOptions.PortMin != nil {
		body["port_min"] = updateSecurityGroupRuleOptions.PortMin
	}
	if updateSecurityGroupRuleOptions.Remote != nil {
		body["remote"] = updateSecurityGroupRuleOptions.Remote
	}
	if updateSecurityGroupRuleOptions.Type != nil {
		body["type"] = updateSecurityGroupRuleOptions.Type
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSecurityGroupRule)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// ListSubnets : List all subnets
// This request lists all subnets in the region. Subnets are contiguous ranges of IP addresses specified in CIDR block
// notation. Each subnet is within a particular zone and cannot span multiple zones or regions.
func (vpc *VpcV1) ListSubnets(listSubnetsOptions *ListSubnetsOptions) (result *SubnetCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listSubnetsOptions, "listSubnetsOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"subnets"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listSubnetsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListSubnets")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listSubnetsOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listSubnetsOptions.Start))
	}
	if listSubnetsOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listSubnetsOptions.Limit))
	}
	if listSubnetsOptions.ResourceGroupID != nil {
		builder.AddQuery("resource_group.id", fmt.Sprint(*listSubnetsOptions.ResourceGroupID))
	}
	if listSubnetsOptions.RoutingTableID != nil {
		builder.AddQuery("routing_table.id", fmt.Sprint(*listSubnetsOptions.RoutingTableID))
	}
	if listSubnetsOptions.RoutingTableName != nil {
		builder.AddQuery("routing_table.name", fmt.Sprint(*listSubnetsOptions.RoutingTableName))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSubnetCollection)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// CreateSubnet : Create a subnet
// This request creates a new subnet from a subnet prototype object. The prototype object is structured in the same way
// as a retrieved subnet, and contains the information necessary to create the new subnet. For this request to succeed,
// the prototype's CIDR block must not overlap with an existing subnet in the VPC.
func (vpc *VpcV1) CreateSubnet(createSubnetOptions *CreateSubnetOptions) (result *Subnet, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createSubnetOptions, "createSubnetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createSubnetOptions, "createSubnetOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"subnets"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.POST)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range createSubnetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateSubnet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(createSubnetOptions.SubnetPrototype)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSubnet)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// DeleteSubnet : Delete specified subnet
// This request deletes a subnet. This operation cannot be reversed. For this request to succeed, the subnet must not be
// referenced by any network interfaces, VPN gateways, or load balancers. A delete operation automatically detaches the
// subnet from any network ACLs and public gateways. All flow log collectors with `auto_delete` set to `true` targeting
// the subnet or any resource in the subnet are automatically deleted.
func (vpc *VpcV1) DeleteSubnet(deleteSubnetOptions *DeleteSubnetOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteSubnetOptions, "deleteSubnetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteSubnetOptions, "deleteSubnetOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"subnets"}
	pathParameters := []string{*deleteSubnetOptions.ID}

	builder := core.NewRequestBuilder(core.DELETE)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteSubnetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteSubnet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetSubnet : Retrieve specified subnet
// This request retrieves a single subnet specified by the identifier in the URL.
func (vpc *VpcV1) GetSubnet(getSubnetOptions *GetSubnetOptions) (result *Subnet, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getSubnetOptions, "getSubnetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getSubnetOptions, "getSubnetOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"subnets"}
	pathParameters := []string{*getSubnetOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getSubnetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetSubnet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSubnet)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// UpdateSubnet : Update specified subnet
// This request updates a subnet with the information in a provided subnet patch. The subnet patch object is structured
// in the same way as a retrieved subnet and contains only the information to be updated.
func (vpc *VpcV1) UpdateSubnet(updateSubnetOptions *UpdateSubnetOptions) (result *Subnet, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateSubnetOptions, "updateSubnetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateSubnetOptions, "updateSubnetOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"subnets"}
	pathParameters := []string{*updateSubnetOptions.ID}

	builder := core.NewRequestBuilder(core.PATCH)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateSubnetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateSubnet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if updateSubnetOptions.Name != nil {
		body["name"] = updateSubnetOptions.Name
	}
	if updateSubnetOptions.NetworkACL != nil {
		body["network_acl"] = updateSubnetOptions.NetworkACL
	}
	if updateSubnetOptions.PublicGateway != nil {
		body["public_gateway"] = updateSubnetOptions.PublicGateway
	}
	if updateSubnetOptions.RoutingTable != nil {
		body["routing_table"] = updateSubnetOptions.RoutingTable
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSubnet)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// GetSubnetNetworkACL : Retrieve a subnet's attached network ACL
// This request retrieves the network ACL attached to the subnet specified by the identifier in the URL.
func (vpc *VpcV1) GetSubnetNetworkACL(getSubnetNetworkACLOptions *GetSubnetNetworkACLOptions) (result *NetworkACL, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getSubnetNetworkACLOptions, "getSubnetNetworkACLOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getSubnetNetworkACLOptions, "getSubnetNetworkACLOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"subnets", "network_acl"}
	pathParameters := []string{*getSubnetNetworkACLOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getSubnetNetworkACLOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetSubnetNetworkACL")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalNetworkACL)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// ReplaceSubnetNetworkACL : Attach a network ACL to a subnet
// This request attaches the network ACL, specified in the request body, to the subnet specified by the subnet
// identifier in the URL. This replaces the existing network ACL on the subnet.
func (vpc *VpcV1) ReplaceSubnetNetworkACL(replaceSubnetNetworkACLOptions *ReplaceSubnetNetworkACLOptions) (result *NetworkACL, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(replaceSubnetNetworkACLOptions, "replaceSubnetNetworkACLOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(replaceSubnetNetworkACLOptions, "replaceSubnetNetworkACLOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"subnets", "network_acl"}
	pathParameters := []string{*replaceSubnetNetworkACLOptions.ID}

	builder := core.NewRequestBuilder(core.PUT)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range replaceSubnetNetworkACLOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ReplaceSubnetNetworkACL")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(replaceSubnetNetworkACLOptions.NetworkACLIdentity)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalNetworkACL)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// UnsetSubnetPublicGateway : Detach a public gateway from a subnet
// This request detaches the public gateway from the subnet specified by the subnet identifier in the URL.
func (vpc *VpcV1) UnsetSubnetPublicGateway(unsetSubnetPublicGatewayOptions *UnsetSubnetPublicGatewayOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(unsetSubnetPublicGatewayOptions, "unsetSubnetPublicGatewayOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(unsetSubnetPublicGatewayOptions, "unsetSubnetPublicGatewayOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"subnets", "public_gateway"}
	pathParameters := []string{*unsetSubnetPublicGatewayOptions.ID}

	builder := core.NewRequestBuilder(core.DELETE)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range unsetSubnetPublicGatewayOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UnsetSubnetPublicGateway")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetSubnetPublicGateway : Retrieve a subnet's attached public gateway
// This request retrieves the public gateway attached to the subnet specified by the identifier in the URL.
func (vpc *VpcV1) GetSubnetPublicGateway(getSubnetPublicGatewayOptions *GetSubnetPublicGatewayOptions) (result *PublicGateway, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getSubnetPublicGatewayOptions, "getSubnetPublicGatewayOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getSubnetPublicGatewayOptions, "getSubnetPublicGatewayOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"subnets", "public_gateway"}
	pathParameters := []string{*getSubnetPublicGatewayOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getSubnetPublicGatewayOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetSubnetPublicGateway")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalPublicGateway)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// SetSubnetPublicGateway : Attach a public gateway to a subnet
// This request attaches the public gateway, specified in the request body, to the subnet specified by the subnet
// identifier in the URL. The public gateway must have the same VPC and zone as the subnet.
func (vpc *VpcV1) SetSubnetPublicGateway(setSubnetPublicGatewayOptions *SetSubnetPublicGatewayOptions) (result *PublicGateway, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(setSubnetPublicGatewayOptions, "setSubnetPublicGatewayOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(setSubnetPublicGatewayOptions, "setSubnetPublicGatewayOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"subnets", "public_gateway"}
	pathParameters := []string{*setSubnetPublicGatewayOptions.ID}

	builder := core.NewRequestBuilder(core.PUT)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range setSubnetPublicGatewayOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "SetSubnetPublicGateway")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(setSubnetPublicGatewayOptions.PublicGatewayIdentity)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalPublicGateway)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// GetSubnetRoutingTable : Retrieve a subnet's attached routing table
// This request retrieves the routing table attached to the subnet specified by the identifier in the URL.
func (vpc *VpcV1) GetSubnetRoutingTable(getSubnetRoutingTableOptions *GetSubnetRoutingTableOptions) (result *RoutingTable, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getSubnetRoutingTableOptions, "getSubnetRoutingTableOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getSubnetRoutingTableOptions, "getSubnetRoutingTableOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"subnets", "routing_table"}
	pathParameters := []string{*getSubnetRoutingTableOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getSubnetRoutingTableOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetSubnetRoutingTable")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalRoutingTable)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// ReplaceSubnetRoutingTable : Attach a routing table to a subnet
// This request attaches the routing table, specified in the request body, to the subnet specified by the subnet
// identifier in the URL. This replaces the existing routing table on the subnet.
func (vpc *VpcV1) ReplaceSubnetRoutingTable(replaceSubnetRoutingTableOptions *ReplaceSubnetRoutingTableOptions) (result *RoutingTable, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(replaceSubnetRoutingTableOptions, "replaceSubnetRoutingTableOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(replaceSubnetRoutingTableOptions, "replaceSubnetRoutingTableOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"subnets", "routing_table"}
	pathParameters := []string{*replaceSubnetRoutingTableOptions.ID}

	builder := core.NewRequestBuilder(core.PUT)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range replaceSubnetRoutingTableOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ReplaceSubnetRoutingTable")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(replaceSubnetRoutingTableOptions.RoutingTableIdentity)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalRoutingTable)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// ListVpcs : List all VPCs
// This request lists all VPCs. A VPC is a virtual network that belongs to an account and provides logical isolation
// from other networks. A VPC is made up of resources in one or more zones. VPCs are regional, and each VPC can contain
// resources in multiple zones in a region.
func (vpc *VpcV1) ListVpcs(listVpcsOptions *ListVpcsOptions) (result *VPCCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listVpcsOptions, "listVpcsOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpcs"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listVpcsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListVpcs")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listVpcsOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listVpcsOptions.Start))
	}
	if listVpcsOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listVpcsOptions.Limit))
	}
	if listVpcsOptions.ResourceGroupID != nil {
		builder.AddQuery("resource_group.id", fmt.Sprint(*listVpcsOptions.ResourceGroupID))
	}
	if listVpcsOptions.ClassicAccess != nil {
		builder.AddQuery("classic_access", fmt.Sprint(*listVpcsOptions.ClassicAccess))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVPCCollection)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// CreateVPC : Create a VPC
// This request creates a new VPC from a VPC prototype object. The prototype object is structured in the same way as a
// retrieved VPC, and contains the information necessary to create the new VPC.
func (vpc *VpcV1) CreateVPC(createVPCOptions *CreateVPCOptions) (result *VPC, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(createVPCOptions, "createVPCOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpcs"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.POST)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range createVPCOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateVPC")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if createVPCOptions.AddressPrefixManagement != nil {
		body["address_prefix_management"] = createVPCOptions.AddressPrefixManagement
	}
	if createVPCOptions.ClassicAccess != nil {
		body["classic_access"] = createVPCOptions.ClassicAccess
	}
	if createVPCOptions.Name != nil {
		body["name"] = createVPCOptions.Name
	}
	if createVPCOptions.ResourceGroup != nil {
		body["resource_group"] = createVPCOptions.ResourceGroup
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVPC)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// DeleteVPC : Delete specified VPC
// This request deletes a VPC. This operation cannot be reversed. For this request to succeed, the VPC must not contain
// any instances, subnets, or public gateways. All security groups and network ACLs associated with the VPC are
// automatically deleted. All flow log collectors with `auto_delete` set to `true` targeting the VPC or any resource in
// the VPC are automatically deleted.
func (vpc *VpcV1) DeleteVPC(deleteVPCOptions *DeleteVPCOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteVPCOptions, "deleteVPCOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteVPCOptions, "deleteVPCOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpcs"}
	pathParameters := []string{*deleteVPCOptions.ID}

	builder := core.NewRequestBuilder(core.DELETE)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteVPCOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteVPC")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetVPC : Retrieve specified VPC
// This request retrieves a single VPC specified by the identifier in the URL.
func (vpc *VpcV1) GetVPC(getVPCOptions *GetVPCOptions) (result *VPC, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getVPCOptions, "getVPCOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getVPCOptions, "getVPCOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpcs"}
	pathParameters := []string{*getVPCOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getVPCOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetVPC")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVPC)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// UpdateVPC : Update specified VPC
// This request updates a VPC's name.
func (vpc *VpcV1) UpdateVPC(updateVPCOptions *UpdateVPCOptions) (result *VPC, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateVPCOptions, "updateVPCOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateVPCOptions, "updateVPCOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpcs"}
	pathParameters := []string{*updateVPCOptions.ID}

	builder := core.NewRequestBuilder(core.PATCH)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateVPCOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateVPC")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if updateVPCOptions.Name != nil {
		body["name"] = updateVPCOptions.Name
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVPC)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// GetVPCDefaultNetworkACL : Retrieve a VPC's default network ACL
// This request retrieves the default network ACL for the VPC specified by the identifier in the URL. The default
// network ACL is applied to any new subnets in the VPC which do not specify a network ACL.
func (vpc *VpcV1) GetVPCDefaultNetworkACL(getVPCDefaultNetworkACLOptions *GetVPCDefaultNetworkACLOptions) (result *DefaultNetworkACL, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getVPCDefaultNetworkACLOptions, "getVPCDefaultNetworkACLOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getVPCDefaultNetworkACLOptions, "getVPCDefaultNetworkACLOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpcs", "default_network_acl"}
	pathParameters := []string{*getVPCDefaultNetworkACLOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getVPCDefaultNetworkACLOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetVPCDefaultNetworkACL")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalDefaultNetworkACL)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// GetVPCDefaultRoutingTable : Retrieve a VPC's default routing table
// This request retrieves the default routing table for the VPC specified by the identifier in the URL. The default
// routing table is associated with any subnets in the VPC which have not been explicitly associated with a user-defined
// routing table.
func (vpc *VpcV1) GetVPCDefaultRoutingTable(getVPCDefaultRoutingTableOptions *GetVPCDefaultRoutingTableOptions) (result *DefaultRoutingTable, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getVPCDefaultRoutingTableOptions, "getVPCDefaultRoutingTableOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getVPCDefaultRoutingTableOptions, "getVPCDefaultRoutingTableOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpcs", "default_routing_table"}
	pathParameters := []string{*getVPCDefaultRoutingTableOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getVPCDefaultRoutingTableOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetVPCDefaultRoutingTable")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalDefaultRoutingTable)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// GetVPCDefaultSecurityGroup : Retrieve a VPC's default security group
// This request retrieves the default security group for the VPC specified by the identifier in the URL. The default
// security group is applied to any new network interfaces in the VPC that do not specify a security group.
func (vpc *VpcV1) GetVPCDefaultSecurityGroup(getVPCDefaultSecurityGroupOptions *GetVPCDefaultSecurityGroupOptions) (result *DefaultSecurityGroup, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getVPCDefaultSecurityGroupOptions, "getVPCDefaultSecurityGroupOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getVPCDefaultSecurityGroupOptions, "getVPCDefaultSecurityGroupOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpcs", "default_security_group"}
	pathParameters := []string{*getVPCDefaultSecurityGroupOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getVPCDefaultSecurityGroupOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetVPCDefaultSecurityGroup")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalDefaultSecurityGroup)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// ListVPCAddressPrefixes : List all address pool prefixes for a VPC
// This request lists all address pool prefixes for a VPC.
func (vpc *VpcV1) ListVPCAddressPrefixes(listVPCAddressPrefixesOptions *ListVPCAddressPrefixesOptions) (result *AddressPrefixCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listVPCAddressPrefixesOptions, "listVPCAddressPrefixesOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listVPCAddressPrefixesOptions, "listVPCAddressPrefixesOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpcs", "address_prefixes"}
	pathParameters := []string{*listVPCAddressPrefixesOptions.VPCID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listVPCAddressPrefixesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListVPCAddressPrefixes")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listVPCAddressPrefixesOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listVPCAddressPrefixesOptions.Start))
	}
	if listVPCAddressPrefixesOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listVPCAddressPrefixesOptions.Limit))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalAddressPrefixCollection)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// CreateVPCAddressPrefix : Create an address pool prefix
// This request creates a new prefix from a prefix prototype object. The prototype object is structured in the same way
// as a retrieved prefix, and contains the information necessary to create the new prefix.
func (vpc *VpcV1) CreateVPCAddressPrefix(createVPCAddressPrefixOptions *CreateVPCAddressPrefixOptions) (result *AddressPrefix, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createVPCAddressPrefixOptions, "createVPCAddressPrefixOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createVPCAddressPrefixOptions, "createVPCAddressPrefixOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpcs", "address_prefixes"}
	pathParameters := []string{*createVPCAddressPrefixOptions.VPCID}

	builder := core.NewRequestBuilder(core.POST)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range createVPCAddressPrefixOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateVPCAddressPrefix")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if createVPCAddressPrefixOptions.CIDR != nil {
		body["cidr"] = createVPCAddressPrefixOptions.CIDR
	}
	if createVPCAddressPrefixOptions.Zone != nil {
		body["zone"] = createVPCAddressPrefixOptions.Zone
	}
	if createVPCAddressPrefixOptions.IsDefault != nil {
		body["is_default"] = createVPCAddressPrefixOptions.IsDefault
	}
	if createVPCAddressPrefixOptions.Name != nil {
		body["name"] = createVPCAddressPrefixOptions.Name
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalAddressPrefix)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// DeleteVPCAddressPrefix : Delete specified address pool prefix
// This request deletes a prefix. This operation cannot be reversed. The request will fail if any subnets use addresses
// from this prefix.
func (vpc *VpcV1) DeleteVPCAddressPrefix(deleteVPCAddressPrefixOptions *DeleteVPCAddressPrefixOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteVPCAddressPrefixOptions, "deleteVPCAddressPrefixOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteVPCAddressPrefixOptions, "deleteVPCAddressPrefixOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpcs", "address_prefixes"}
	pathParameters := []string{*deleteVPCAddressPrefixOptions.VPCID, *deleteVPCAddressPrefixOptions.ID}

	builder := core.NewRequestBuilder(core.DELETE)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteVPCAddressPrefixOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteVPCAddressPrefix")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetVPCAddressPrefix : Retrieve specified address pool prefix
// This request retrieves a single prefix specified by the identifier in the URL.
func (vpc *VpcV1) GetVPCAddressPrefix(getVPCAddressPrefixOptions *GetVPCAddressPrefixOptions) (result *AddressPrefix, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getVPCAddressPrefixOptions, "getVPCAddressPrefixOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getVPCAddressPrefixOptions, "getVPCAddressPrefixOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpcs", "address_prefixes"}
	pathParameters := []string{*getVPCAddressPrefixOptions.VPCID, *getVPCAddressPrefixOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getVPCAddressPrefixOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetVPCAddressPrefix")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalAddressPrefix)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// UpdateVPCAddressPrefix : Update an address pool prefix
// This request updates a prefix with the information in a provided prefix patch. The prefix patch object is structured
// in the same way as a retrieved prefix and contains only the information to be updated.
func (vpc *VpcV1) UpdateVPCAddressPrefix(updateVPCAddressPrefixOptions *UpdateVPCAddressPrefixOptions) (result *AddressPrefix, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateVPCAddressPrefixOptions, "updateVPCAddressPrefixOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateVPCAddressPrefixOptions, "updateVPCAddressPrefixOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpcs", "address_prefixes"}
	pathParameters := []string{*updateVPCAddressPrefixOptions.VPCID, *updateVPCAddressPrefixOptions.ID}

	builder := core.NewRequestBuilder(core.PATCH)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateVPCAddressPrefixOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateVPCAddressPrefix")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if updateVPCAddressPrefixOptions.IsDefault != nil {
		body["is_default"] = updateVPCAddressPrefixOptions.IsDefault
	}
	if updateVPCAddressPrefixOptions.Name != nil {
		body["name"] = updateVPCAddressPrefixOptions.Name
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalAddressPrefix)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// ListVPCRoutes : List all routes in the VPC's default routing table
// This request retrieves routes in the VPC's default routing table. For compatibility, routes with `action` values
// other than `deliver` are omitted. Each route is zone-specific and directs any packets matching its destination CIDR
// block to a `next_hop` IP address. The most specific route matching a packet's destination will be used. If multiple
// equally-specific routes exist, traffic will be distributed across them.
func (vpc *VpcV1) ListVPCRoutes(listVPCRoutesOptions *ListVPCRoutesOptions) (result *RouteCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listVPCRoutesOptions, "listVPCRoutesOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listVPCRoutesOptions, "listVPCRoutesOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpcs", "routes"}
	pathParameters := []string{*listVPCRoutesOptions.VPCID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listVPCRoutesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListVPCRoutes")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listVPCRoutesOptions.ZoneName != nil {
		builder.AddQuery("zone.name", fmt.Sprint(*listVPCRoutesOptions.ZoneName))
	}
	if listVPCRoutesOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listVPCRoutesOptions.Start))
	}
	if listVPCRoutesOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listVPCRoutesOptions.Limit))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalRouteCollection)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// CreateVPCRoute : Create a route in the VPC's default routing table
// This request creates a new route in the VPC's default routing table. The route prototype object is structured in the
// same way as a retrieved route, and contains the information necessary to create the new route. The request will fail
// if the new route will cause a loop.
func (vpc *VpcV1) CreateVPCRoute(createVPCRouteOptions *CreateVPCRouteOptions) (result *Route, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createVPCRouteOptions, "createVPCRouteOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createVPCRouteOptions, "createVPCRouteOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpcs", "routes"}
	pathParameters := []string{*createVPCRouteOptions.VPCID}

	builder := core.NewRequestBuilder(core.POST)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range createVPCRouteOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateVPCRoute")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if createVPCRouteOptions.Destination != nil {
		body["destination"] = createVPCRouteOptions.Destination
	}
	if createVPCRouteOptions.Zone != nil {
		body["zone"] = createVPCRouteOptions.Zone
	}
	if createVPCRouteOptions.Action != nil {
		body["action"] = createVPCRouteOptions.Action
	}
	if createVPCRouteOptions.Name != nil {
		body["name"] = createVPCRouteOptions.Name
	}
	if createVPCRouteOptions.NextHop != nil {
		body["next_hop"] = createVPCRouteOptions.NextHop
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalRoute)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// DeleteVPCRoute : Delete the specified route in the VPC's default routing table
// This request deletes a route. This operation cannot be reversed.
func (vpc *VpcV1) DeleteVPCRoute(deleteVPCRouteOptions *DeleteVPCRouteOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteVPCRouteOptions, "deleteVPCRouteOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteVPCRouteOptions, "deleteVPCRouteOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpcs", "routes"}
	pathParameters := []string{*deleteVPCRouteOptions.VPCID, *deleteVPCRouteOptions.ID}

	builder := core.NewRequestBuilder(core.DELETE)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteVPCRouteOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteVPCRoute")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetVPCRoute : Retrieve the specified route in the VPC's default routing table
// This request retrieves a single route specified by the identifier in the URL.
func (vpc *VpcV1) GetVPCRoute(getVPCRouteOptions *GetVPCRouteOptions) (result *Route, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getVPCRouteOptions, "getVPCRouteOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getVPCRouteOptions, "getVPCRouteOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpcs", "routes"}
	pathParameters := []string{*getVPCRouteOptions.VPCID, *getVPCRouteOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getVPCRouteOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetVPCRoute")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalRoute)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// UpdateVPCRoute : Update the specified route in the VPC's default routing table
// This request updates a route with the information in a provided route patch. The route patch object is structured in
// the same way as a retrieved route and contains only the information to be updated.
func (vpc *VpcV1) UpdateVPCRoute(updateVPCRouteOptions *UpdateVPCRouteOptions) (result *Route, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateVPCRouteOptions, "updateVPCRouteOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateVPCRouteOptions, "updateVPCRouteOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpcs", "routes"}
	pathParameters := []string{*updateVPCRouteOptions.VPCID, *updateVPCRouteOptions.ID}

	builder := core.NewRequestBuilder(core.PATCH)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateVPCRouteOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateVPCRoute")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if updateVPCRouteOptions.Name != nil {
		body["name"] = updateVPCRouteOptions.Name
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalRoute)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// ListVPCRoutingTables : List all routing tables for a VPC
// This request lists all user-defined routing tables for a VPC.  Each subnet in a VPC is associated with a routing
// table, which controls delivery of packets sent on that subnet according to the action of the most specific matching
// route in the table.  If multiple equally-specific routes exist, traffic will be distributed across them.  If no
// routes match, delivery will be controlled by the system's built-in routes.
func (vpc *VpcV1) ListVPCRoutingTables(listVPCRoutingTablesOptions *ListVPCRoutingTablesOptions) (result *RoutingTableCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listVPCRoutingTablesOptions, "listVPCRoutingTablesOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listVPCRoutingTablesOptions, "listVPCRoutingTablesOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpcs", "routing_tables"}
	pathParameters := []string{*listVPCRoutingTablesOptions.VPCID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listVPCRoutingTablesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListVPCRoutingTables")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listVPCRoutingTablesOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listVPCRoutingTablesOptions.Start))
	}
	if listVPCRoutingTablesOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listVPCRoutingTablesOptions.Limit))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalRoutingTableCollection)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// CreateVPCRoutingTable : Create a VPC routing table
// This request creates a user-defined routing table from a routing table prototype object. The prototype object is
// structured in the same way as a retrieved routing table, and contains the information necessary to create the new
// routing table.
func (vpc *VpcV1) CreateVPCRoutingTable(createVPCRoutingTableOptions *CreateVPCRoutingTableOptions) (result *RoutingTable, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createVPCRoutingTableOptions, "createVPCRoutingTableOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createVPCRoutingTableOptions, "createVPCRoutingTableOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpcs", "routing_tables"}
	pathParameters := []string{*createVPCRoutingTableOptions.VPCID}

	builder := core.NewRequestBuilder(core.POST)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range createVPCRoutingTableOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateVPCRoutingTable")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if createVPCRoutingTableOptions.Name != nil {
		body["name"] = createVPCRoutingTableOptions.Name
	}
	if createVPCRoutingTableOptions.Routes != nil {
		body["routes"] = createVPCRoutingTableOptions.Routes
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalRoutingTable)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// DeleteVPCRoutingTable : Delete specified VPC routing table
// This request deletes a routing table.  A routing table cannot be deleted if it is associated with any subnets in the
// VPC. Additionally, a VPC's default routing table cannot be deleted. This operation cannot be reversed.
func (vpc *VpcV1) DeleteVPCRoutingTable(deleteVPCRoutingTableOptions *DeleteVPCRoutingTableOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteVPCRoutingTableOptions, "deleteVPCRoutingTableOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteVPCRoutingTableOptions, "deleteVPCRoutingTableOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpcs", "routing_tables"}
	pathParameters := []string{*deleteVPCRoutingTableOptions.VPCID, *deleteVPCRoutingTableOptions.ID}

	builder := core.NewRequestBuilder(core.DELETE)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteVPCRoutingTableOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteVPCRoutingTable")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetVPCRoutingTable : Retrieve specified VPC routing table
// This request retrieves a single routing table specified by the identifier in the URL.
func (vpc *VpcV1) GetVPCRoutingTable(getVPCRoutingTableOptions *GetVPCRoutingTableOptions) (result *RoutingTable, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getVPCRoutingTableOptions, "getVPCRoutingTableOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getVPCRoutingTableOptions, "getVPCRoutingTableOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpcs", "routing_tables"}
	pathParameters := []string{*getVPCRoutingTableOptions.VPCID, *getVPCRoutingTableOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getVPCRoutingTableOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetVPCRoutingTable")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalRoutingTable)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// UpdateVPCRoutingTable : Update specified VPC routing table
// This request updates a routing table with the information in a provided routing table patch. The patch object is
// structured in the same way as a retrieved table and contains only the information to be updated.
func (vpc *VpcV1) UpdateVPCRoutingTable(updateVPCRoutingTableOptions *UpdateVPCRoutingTableOptions) (result *RoutingTable, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateVPCRoutingTableOptions, "updateVPCRoutingTableOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateVPCRoutingTableOptions, "updateVPCRoutingTableOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpcs", "routing_tables"}
	pathParameters := []string{*updateVPCRoutingTableOptions.VPCID, *updateVPCRoutingTableOptions.ID}

	builder := core.NewRequestBuilder(core.PATCH)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateVPCRoutingTableOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateVPCRoutingTable")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if updateVPCRoutingTableOptions.Name != nil {
		body["name"] = updateVPCRoutingTableOptions.Name
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalRoutingTable)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// ListVPCRoutingTableRoutes : List all the routes of a VPC routing table
// This request lists all the routes for the specified VPC routing table.  If a subnet has been associated with this
// routing table, delivery of packets sent on a subnet is performed according to the action of the most specific
// matching route in the table (provided the subnet and route are in the same zone).  If multiple equally-specific
// routes exist, traffic will be distributed across them.  If no routes match, delivery will be controlled by the
// system's built-in routes.
func (vpc *VpcV1) ListVPCRoutingTableRoutes(listVPCRoutingTableRoutesOptions *ListVPCRoutingTableRoutesOptions) (result *RouteCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listVPCRoutingTableRoutesOptions, "listVPCRoutingTableRoutesOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listVPCRoutingTableRoutesOptions, "listVPCRoutingTableRoutesOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpcs", "routing_tables", "routes"}
	pathParameters := []string{*listVPCRoutingTableRoutesOptions.VPCID, *listVPCRoutingTableRoutesOptions.RoutingTableID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listVPCRoutingTableRoutesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListVPCRoutingTableRoutes")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listVPCRoutingTableRoutesOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listVPCRoutingTableRoutesOptions.Start))
	}
	if listVPCRoutingTableRoutesOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listVPCRoutingTableRoutesOptions.Limit))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalRouteCollection)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// CreateVPCRoutingTableRoute : Create a VPC route
// This request creates a new VPC route from a VPC route prototype object. The prototype object is structured in the
// same way as a retrieved VPC route and contains the information necessary to create the route.
func (vpc *VpcV1) CreateVPCRoutingTableRoute(createVPCRoutingTableRouteOptions *CreateVPCRoutingTableRouteOptions) (result *Route, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createVPCRoutingTableRouteOptions, "createVPCRoutingTableRouteOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createVPCRoutingTableRouteOptions, "createVPCRoutingTableRouteOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpcs", "routing_tables", "routes"}
	pathParameters := []string{*createVPCRoutingTableRouteOptions.VPCID, *createVPCRoutingTableRouteOptions.RoutingTableID}

	builder := core.NewRequestBuilder(core.POST)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range createVPCRoutingTableRouteOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateVPCRoutingTableRoute")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if createVPCRoutingTableRouteOptions.Destination != nil {
		body["destination"] = createVPCRoutingTableRouteOptions.Destination
	}
	if createVPCRoutingTableRouteOptions.Zone != nil {
		body["zone"] = createVPCRoutingTableRouteOptions.Zone
	}
	if createVPCRoutingTableRouteOptions.Action != nil {
		body["action"] = createVPCRoutingTableRouteOptions.Action
	}
	if createVPCRoutingTableRouteOptions.Name != nil {
		body["name"] = createVPCRoutingTableRouteOptions.Name
	}
	if createVPCRoutingTableRouteOptions.NextHop != nil {
		body["next_hop"] = createVPCRoutingTableRouteOptions.NextHop
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalRoute)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// DeleteVPCRoutingTableRoute : Delete the specified VPC route
// This request deletes a VPC route. This operation cannot be reversed.
func (vpc *VpcV1) DeleteVPCRoutingTableRoute(deleteVPCRoutingTableRouteOptions *DeleteVPCRoutingTableRouteOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteVPCRoutingTableRouteOptions, "deleteVPCRoutingTableRouteOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteVPCRoutingTableRouteOptions, "deleteVPCRoutingTableRouteOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpcs", "routing_tables", "routes"}
	pathParameters := []string{*deleteVPCRoutingTableRouteOptions.VPCID, *deleteVPCRoutingTableRouteOptions.RoutingTableID, *deleteVPCRoutingTableRouteOptions.ID}

	builder := core.NewRequestBuilder(core.DELETE)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteVPCRoutingTableRouteOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteVPCRoutingTableRoute")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetVPCRoutingTableRoute : Retrieve the specified VPC route
// This request retrieves a single VPC route specified by the identifier in the URL path.
func (vpc *VpcV1) GetVPCRoutingTableRoute(getVPCRoutingTableRouteOptions *GetVPCRoutingTableRouteOptions) (result *Route, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getVPCRoutingTableRouteOptions, "getVPCRoutingTableRouteOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getVPCRoutingTableRouteOptions, "getVPCRoutingTableRouteOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpcs", "routing_tables", "routes"}
	pathParameters := []string{*getVPCRoutingTableRouteOptions.VPCID, *getVPCRoutingTableRouteOptions.RoutingTableID, *getVPCRoutingTableRouteOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getVPCRoutingTableRouteOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetVPCRoutingTableRoute")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalRoute)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// UpdateVPCRoutingTableRoute : Update the specified VPC route
// This request updates a VPC route with the information provided in a route patch object. The patch object is
// structured in the same way as a retrieved VPC route and needs to contain only the information to be updated.
func (vpc *VpcV1) UpdateVPCRoutingTableRoute(updateVPCRoutingTableRouteOptions *UpdateVPCRoutingTableRouteOptions) (result *Route, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateVPCRoutingTableRouteOptions, "updateVPCRoutingTableRouteOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateVPCRoutingTableRouteOptions, "updateVPCRoutingTableRouteOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpcs", "routing_tables", "routes"}
	pathParameters := []string{*updateVPCRoutingTableRouteOptions.VPCID, *updateVPCRoutingTableRouteOptions.RoutingTableID, *updateVPCRoutingTableRouteOptions.ID}

	builder := core.NewRequestBuilder(core.PATCH)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateVPCRoutingTableRouteOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateVPCRoutingTableRoute")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if updateVPCRoutingTableRouteOptions.Name != nil {
		body["name"] = updateVPCRoutingTableRouteOptions.Name
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalRoute)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// ListIkePolicies : List all IKE policies
// This request retrieves a paginated list of all IKE policies that belong to this account.
func (vpc *VpcV1) ListIkePolicies(listIkePoliciesOptions *ListIkePoliciesOptions) (result *IkePolicyCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listIkePoliciesOptions, "listIkePoliciesOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"ike_policies"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listIkePoliciesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListIkePolicies")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listIkePoliciesOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listIkePoliciesOptions.Start))
	}
	if listIkePoliciesOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listIkePoliciesOptions.Limit))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalIkePolicyCollection)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// CreateIkePolicy : Create an IKE policy
// This request creates a new IKE policy.
func (vpc *VpcV1) CreateIkePolicy(createIkePolicyOptions *CreateIkePolicyOptions) (result *IkePolicy, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createIkePolicyOptions, "createIkePolicyOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createIkePolicyOptions, "createIkePolicyOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"ike_policies"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.POST)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range createIkePolicyOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateIkePolicy")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if createIkePolicyOptions.AuthenticationAlgorithm != nil {
		body["authentication_algorithm"] = createIkePolicyOptions.AuthenticationAlgorithm
	}
	if createIkePolicyOptions.DhGroup != nil {
		body["dh_group"] = createIkePolicyOptions.DhGroup
	}
	if createIkePolicyOptions.EncryptionAlgorithm != nil {
		body["encryption_algorithm"] = createIkePolicyOptions.EncryptionAlgorithm
	}
	if createIkePolicyOptions.IkeVersion != nil {
		body["ike_version"] = createIkePolicyOptions.IkeVersion
	}
	if createIkePolicyOptions.KeyLifetime != nil {
		body["key_lifetime"] = createIkePolicyOptions.KeyLifetime
	}
	if createIkePolicyOptions.Name != nil {
		body["name"] = createIkePolicyOptions.Name
	}
	if createIkePolicyOptions.ResourceGroup != nil {
		body["resource_group"] = createIkePolicyOptions.ResourceGroup
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalIkePolicy)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// DeleteIkePolicy : Delete an IKE policy
// This request deletes an IKE policy. This operation cannot be reversed.
func (vpc *VpcV1) DeleteIkePolicy(deleteIkePolicyOptions *DeleteIkePolicyOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteIkePolicyOptions, "deleteIkePolicyOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteIkePolicyOptions, "deleteIkePolicyOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"ike_policies"}
	pathParameters := []string{*deleteIkePolicyOptions.ID}

	builder := core.NewRequestBuilder(core.DELETE)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteIkePolicyOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteIkePolicy")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetIkePolicy : Retrieve the specified IKE policy
// This request retrieves a single IKE policy specified by the identifier in the URL.
func (vpc *VpcV1) GetIkePolicy(getIkePolicyOptions *GetIkePolicyOptions) (result *IkePolicy, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getIkePolicyOptions, "getIkePolicyOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getIkePolicyOptions, "getIkePolicyOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"ike_policies"}
	pathParameters := []string{*getIkePolicyOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getIkePolicyOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetIkePolicy")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalIkePolicy)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// UpdateIkePolicy : Update an IKE policy
// This request updates the properties of an existing IKE policy.
func (vpc *VpcV1) UpdateIkePolicy(updateIkePolicyOptions *UpdateIkePolicyOptions) (result *IkePolicy, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateIkePolicyOptions, "updateIkePolicyOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateIkePolicyOptions, "updateIkePolicyOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"ike_policies"}
	pathParameters := []string{*updateIkePolicyOptions.ID}

	builder := core.NewRequestBuilder(core.PATCH)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateIkePolicyOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateIkePolicy")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if updateIkePolicyOptions.AuthenticationAlgorithm != nil {
		body["authentication_algorithm"] = updateIkePolicyOptions.AuthenticationAlgorithm
	}
	if updateIkePolicyOptions.DhGroup != nil {
		body["dh_group"] = updateIkePolicyOptions.DhGroup
	}
	if updateIkePolicyOptions.EncryptionAlgorithm != nil {
		body["encryption_algorithm"] = updateIkePolicyOptions.EncryptionAlgorithm
	}
	if updateIkePolicyOptions.IkeVersion != nil {
		body["ike_version"] = updateIkePolicyOptions.IkeVersion
	}
	if updateIkePolicyOptions.KeyLifetime != nil {
		body["key_lifetime"] = updateIkePolicyOptions.KeyLifetime
	}
	if updateIkePolicyOptions.Name != nil {
		body["name"] = updateIkePolicyOptions.Name
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalIkePolicy)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// ListIkePolicyConnections : List all connections that use the specified IKE policy
// This request lists all the connections that use the specified policy.
func (vpc *VpcV1) ListIkePolicyConnections(listIkePolicyConnectionsOptions *ListIkePolicyConnectionsOptions) (result *VPNGatewayConnectionCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listIkePolicyConnectionsOptions, "listIkePolicyConnectionsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listIkePolicyConnectionsOptions, "listIkePolicyConnectionsOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"ike_policies", "connections"}
	pathParameters := []string{*listIkePolicyConnectionsOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listIkePolicyConnectionsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListIkePolicyConnections")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVPNGatewayConnectionCollection)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// ListIpsecPolicies : List all IPsec policies
// This request retrieves a paginated list of all IPsec policies that belong to this account.
func (vpc *VpcV1) ListIpsecPolicies(listIpsecPoliciesOptions *ListIpsecPoliciesOptions) (result *IPsecPolicyCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listIpsecPoliciesOptions, "listIpsecPoliciesOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"ipsec_policies"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listIpsecPoliciesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListIpsecPolicies")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listIpsecPoliciesOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listIpsecPoliciesOptions.Start))
	}
	if listIpsecPoliciesOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listIpsecPoliciesOptions.Limit))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalIPsecPolicyCollection)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// CreateIpsecPolicy : Create an IPsec policy
// This request creates a new IPsec policy.
func (vpc *VpcV1) CreateIpsecPolicy(createIpsecPolicyOptions *CreateIpsecPolicyOptions) (result *IPsecPolicy, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createIpsecPolicyOptions, "createIpsecPolicyOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createIpsecPolicyOptions, "createIpsecPolicyOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"ipsec_policies"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.POST)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range createIpsecPolicyOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateIpsecPolicy")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if createIpsecPolicyOptions.AuthenticationAlgorithm != nil {
		body["authentication_algorithm"] = createIpsecPolicyOptions.AuthenticationAlgorithm
	}
	if createIpsecPolicyOptions.EncryptionAlgorithm != nil {
		body["encryption_algorithm"] = createIpsecPolicyOptions.EncryptionAlgorithm
	}
	if createIpsecPolicyOptions.Pfs != nil {
		body["pfs"] = createIpsecPolicyOptions.Pfs
	}
	if createIpsecPolicyOptions.KeyLifetime != nil {
		body["key_lifetime"] = createIpsecPolicyOptions.KeyLifetime
	}
	if createIpsecPolicyOptions.Name != nil {
		body["name"] = createIpsecPolicyOptions.Name
	}
	if createIpsecPolicyOptions.ResourceGroup != nil {
		body["resource_group"] = createIpsecPolicyOptions.ResourceGroup
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalIPsecPolicy)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// DeleteIpsecPolicy : Delete an IPsec policy
// This request deletes an IPsec policy. This operation cannot be reversed.
func (vpc *VpcV1) DeleteIpsecPolicy(deleteIpsecPolicyOptions *DeleteIpsecPolicyOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteIpsecPolicyOptions, "deleteIpsecPolicyOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteIpsecPolicyOptions, "deleteIpsecPolicyOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"ipsec_policies"}
	pathParameters := []string{*deleteIpsecPolicyOptions.ID}

	builder := core.NewRequestBuilder(core.DELETE)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteIpsecPolicyOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteIpsecPolicy")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetIpsecPolicy : Retrieve the specified IPsec policy
// This request retrieves a single IPsec policy specified by the identifier in the URL.
func (vpc *VpcV1) GetIpsecPolicy(getIpsecPolicyOptions *GetIpsecPolicyOptions) (result *IPsecPolicy, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getIpsecPolicyOptions, "getIpsecPolicyOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getIpsecPolicyOptions, "getIpsecPolicyOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"ipsec_policies"}
	pathParameters := []string{*getIpsecPolicyOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getIpsecPolicyOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetIpsecPolicy")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalIPsecPolicy)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// UpdateIpsecPolicy : Update an IPsec policy
// This request updates the properties of an existing IPsec policy.
func (vpc *VpcV1) UpdateIpsecPolicy(updateIpsecPolicyOptions *UpdateIpsecPolicyOptions) (result *IPsecPolicy, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateIpsecPolicyOptions, "updateIpsecPolicyOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateIpsecPolicyOptions, "updateIpsecPolicyOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"ipsec_policies"}
	pathParameters := []string{*updateIpsecPolicyOptions.ID}

	builder := core.NewRequestBuilder(core.PATCH)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateIpsecPolicyOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateIpsecPolicy")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if updateIpsecPolicyOptions.AuthenticationAlgorithm != nil {
		body["authentication_algorithm"] = updateIpsecPolicyOptions.AuthenticationAlgorithm
	}
	if updateIpsecPolicyOptions.EncryptionAlgorithm != nil {
		body["encryption_algorithm"] = updateIpsecPolicyOptions.EncryptionAlgorithm
	}
	if updateIpsecPolicyOptions.KeyLifetime != nil {
		body["key_lifetime"] = updateIpsecPolicyOptions.KeyLifetime
	}
	if updateIpsecPolicyOptions.Name != nil {
		body["name"] = updateIpsecPolicyOptions.Name
	}
	if updateIpsecPolicyOptions.Pfs != nil {
		body["pfs"] = updateIpsecPolicyOptions.Pfs
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalIPsecPolicy)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// ListIpsecPolicyConnections : List all connections that use the specified IPsec policy
// This request lists all the connections that use the specified policy.
func (vpc *VpcV1) ListIpsecPolicyConnections(listIpsecPolicyConnectionsOptions *ListIpsecPolicyConnectionsOptions) (result *VPNGatewayConnectionCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listIpsecPolicyConnectionsOptions, "listIpsecPolicyConnectionsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listIpsecPolicyConnectionsOptions, "listIpsecPolicyConnectionsOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"ipsec_policies", "connections"}
	pathParameters := []string{*listIpsecPolicyConnectionsOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listIpsecPolicyConnectionsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListIpsecPolicyConnections")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVPNGatewayConnectionCollection)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// ListVPNGateways : List all VPN gateways
// This request retrieves a paginated list of all VPN gateways that belong to this account.
func (vpc *VpcV1) ListVPNGateways(listVPNGatewaysOptions *ListVPNGatewaysOptions) (result *VPNGatewayCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listVPNGatewaysOptions, "listVPNGatewaysOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpn_gateways"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listVPNGatewaysOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListVPNGateways")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listVPNGatewaysOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listVPNGatewaysOptions.Start))
	}
	if listVPNGatewaysOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listVPNGatewaysOptions.Limit))
	}
	if listVPNGatewaysOptions.ResourceGroupID != nil {
		builder.AddQuery("resource_group.id", fmt.Sprint(*listVPNGatewaysOptions.ResourceGroupID))
	}
	if listVPNGatewaysOptions.Sort != nil {
		builder.AddQuery("sort", fmt.Sprint(*listVPNGatewaysOptions.Sort))
	}
	if listVPNGatewaysOptions.Mode != nil {
		builder.AddQuery("mode", fmt.Sprint(*listVPNGatewaysOptions.Mode))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVPNGatewayCollection)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// CreateVPNGateway : Create a VPN gateway
// This request creates a new VPN gateway.
func (vpc *VpcV1) CreateVPNGateway(createVPNGatewayOptions *CreateVPNGatewayOptions) (result *VPNGateway, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createVPNGatewayOptions, "createVPNGatewayOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createVPNGatewayOptions, "createVPNGatewayOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpn_gateways"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.POST)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range createVPNGatewayOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateVPNGateway")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if createVPNGatewayOptions.Subnet != nil {
		body["subnet"] = createVPNGatewayOptions.Subnet
	}
	if createVPNGatewayOptions.Mode != nil {
		body["mode"] = createVPNGatewayOptions.Mode
	}
	if createVPNGatewayOptions.Name != nil {
		body["name"] = createVPNGatewayOptions.Name
	}
	if createVPNGatewayOptions.ResourceGroup != nil {
		body["resource_group"] = createVPNGatewayOptions.ResourceGroup
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVPNGateway)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// DeleteVPNGateway : Delete a VPN gateway
// This request deletes a VPN gateway. A VPN gateway with a `status` of `pending` cannot be deleted. This operation
// deletes all VPN connections associated with this VPN gateway.  This operation cannot be reversed.
func (vpc *VpcV1) DeleteVPNGateway(deleteVPNGatewayOptions *DeleteVPNGatewayOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteVPNGatewayOptions, "deleteVPNGatewayOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteVPNGatewayOptions, "deleteVPNGatewayOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpn_gateways"}
	pathParameters := []string{*deleteVPNGatewayOptions.ID}

	builder := core.NewRequestBuilder(core.DELETE)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteVPNGatewayOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteVPNGateway")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetVPNGateway : Retrieve the specified VPN gateway
// This request retrieves a single VPN gateway specified by the identifier in the URL.
func (vpc *VpcV1) GetVPNGateway(getVPNGatewayOptions *GetVPNGatewayOptions) (result *VPNGateway, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getVPNGatewayOptions, "getVPNGatewayOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getVPNGatewayOptions, "getVPNGatewayOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpn_gateways"}
	pathParameters := []string{*getVPNGatewayOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getVPNGatewayOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetVPNGateway")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVPNGateway)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// UpdateVPNGateway : Update a VPN gateway
// This request updates the properties of an existing VPN gateway.
func (vpc *VpcV1) UpdateVPNGateway(updateVPNGatewayOptions *UpdateVPNGatewayOptions) (result *VPNGateway, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateVPNGatewayOptions, "updateVPNGatewayOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateVPNGatewayOptions, "updateVPNGatewayOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpn_gateways"}
	pathParameters := []string{*updateVPNGatewayOptions.ID}

	builder := core.NewRequestBuilder(core.PATCH)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateVPNGatewayOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateVPNGateway")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if updateVPNGatewayOptions.Name != nil {
		body["name"] = updateVPNGatewayOptions.Name
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVPNGateway)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// ListVPNGatewayConnections : List all connections of a VPN gateway
// This request lists all the connections of a particular VPN gateway.
func (vpc *VpcV1) ListVPNGatewayConnections(listVPNGatewayConnectionsOptions *ListVPNGatewayConnectionsOptions) (result *VPNGatewayConnectionCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listVPNGatewayConnectionsOptions, "listVPNGatewayConnectionsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listVPNGatewayConnectionsOptions, "listVPNGatewayConnectionsOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpn_gateways", "connections"}
	pathParameters := []string{*listVPNGatewayConnectionsOptions.VPNGatewayID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listVPNGatewayConnectionsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListVPNGatewayConnections")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listVPNGatewayConnectionsOptions.Status != nil {
		builder.AddQuery("status", fmt.Sprint(*listVPNGatewayConnectionsOptions.Status))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVPNGatewayConnectionCollection)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// CreateVPNGatewayConnection : Create a VPN connection
// This request creates a new VPN connection.
func (vpc *VpcV1) CreateVPNGatewayConnection(createVPNGatewayConnectionOptions *CreateVPNGatewayConnectionOptions) (result *VPNGatewayConnection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createVPNGatewayConnectionOptions, "createVPNGatewayConnectionOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createVPNGatewayConnectionOptions, "createVPNGatewayConnectionOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpn_gateways", "connections"}
	pathParameters := []string{*createVPNGatewayConnectionOptions.VPNGatewayID}

	builder := core.NewRequestBuilder(core.POST)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range createVPNGatewayConnectionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateVPNGatewayConnection")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if createVPNGatewayConnectionOptions.PeerAddress != nil {
		body["peer_address"] = createVPNGatewayConnectionOptions.PeerAddress
	}
	if createVPNGatewayConnectionOptions.Psk != nil {
		body["psk"] = createVPNGatewayConnectionOptions.Psk
	}
	if createVPNGatewayConnectionOptions.AdminStateUp != nil {
		body["admin_state_up"] = createVPNGatewayConnectionOptions.AdminStateUp
	}
	if createVPNGatewayConnectionOptions.DeadPeerDetection != nil {
		body["dead_peer_detection"] = createVPNGatewayConnectionOptions.DeadPeerDetection
	}
	if createVPNGatewayConnectionOptions.IkePolicy != nil {
		body["ike_policy"] = createVPNGatewayConnectionOptions.IkePolicy
	}
	if createVPNGatewayConnectionOptions.IpsecPolicy != nil {
		body["ipsec_policy"] = createVPNGatewayConnectionOptions.IpsecPolicy
	}
	if createVPNGatewayConnectionOptions.LocalCidrs != nil {
		body["local_cidrs"] = createVPNGatewayConnectionOptions.LocalCidrs
	}
	if createVPNGatewayConnectionOptions.Name != nil {
		body["name"] = createVPNGatewayConnectionOptions.Name
	}
	if createVPNGatewayConnectionOptions.PeerCidrs != nil {
		body["peer_cidrs"] = createVPNGatewayConnectionOptions.PeerCidrs
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVPNGatewayConnection)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// DeleteVPNGatewayConnection : Delete a VPN connection
// This request deletes a VPN connection. This operation cannot be reversed.
func (vpc *VpcV1) DeleteVPNGatewayConnection(deleteVPNGatewayConnectionOptions *DeleteVPNGatewayConnectionOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteVPNGatewayConnectionOptions, "deleteVPNGatewayConnectionOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteVPNGatewayConnectionOptions, "deleteVPNGatewayConnectionOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpn_gateways", "connections"}
	pathParameters := []string{*deleteVPNGatewayConnectionOptions.VPNGatewayID, *deleteVPNGatewayConnectionOptions.ID}

	builder := core.NewRequestBuilder(core.DELETE)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteVPNGatewayConnectionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteVPNGatewayConnection")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetVPNGatewayConnection : Retrieve the specified VPN connection
// This request retrieves a single VPN connection specified by the identifier in the URL.
func (vpc *VpcV1) GetVPNGatewayConnection(getVPNGatewayConnectionOptions *GetVPNGatewayConnectionOptions) (result *VPNGatewayConnection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getVPNGatewayConnectionOptions, "getVPNGatewayConnectionOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getVPNGatewayConnectionOptions, "getVPNGatewayConnectionOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpn_gateways", "connections"}
	pathParameters := []string{*getVPNGatewayConnectionOptions.VPNGatewayID, *getVPNGatewayConnectionOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getVPNGatewayConnectionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetVPNGatewayConnection")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVPNGatewayConnection)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// UpdateVPNGatewayConnection : Update a VPN connection
// This request updates the properties of an existing VPN connection.
func (vpc *VpcV1) UpdateVPNGatewayConnection(updateVPNGatewayConnectionOptions *UpdateVPNGatewayConnectionOptions) (result *VPNGatewayConnection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateVPNGatewayConnectionOptions, "updateVPNGatewayConnectionOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateVPNGatewayConnectionOptions, "updateVPNGatewayConnectionOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpn_gateways", "connections"}
	pathParameters := []string{*updateVPNGatewayConnectionOptions.VPNGatewayID, *updateVPNGatewayConnectionOptions.ID}

	builder := core.NewRequestBuilder(core.PATCH)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateVPNGatewayConnectionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateVPNGatewayConnection")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if updateVPNGatewayConnectionOptions.AdminStateUp != nil {
		body["admin_state_up"] = updateVPNGatewayConnectionOptions.AdminStateUp
	}
	if updateVPNGatewayConnectionOptions.DeadPeerDetection != nil {
		body["dead_peer_detection"] = updateVPNGatewayConnectionOptions.DeadPeerDetection
	}
	if updateVPNGatewayConnectionOptions.IkePolicy != nil {
		body["ike_policy"] = updateVPNGatewayConnectionOptions.IkePolicy
	}
	if updateVPNGatewayConnectionOptions.IpsecPolicy != nil {
		body["ipsec_policy"] = updateVPNGatewayConnectionOptions.IpsecPolicy
	}
	if updateVPNGatewayConnectionOptions.Name != nil {
		body["name"] = updateVPNGatewayConnectionOptions.Name
	}
	if updateVPNGatewayConnectionOptions.PeerAddress != nil {
		body["peer_address"] = updateVPNGatewayConnectionOptions.PeerAddress
	}
	if updateVPNGatewayConnectionOptions.Psk != nil {
		body["psk"] = updateVPNGatewayConnectionOptions.Psk
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVPNGatewayConnection)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// ListVPNGatewayConnectionLocalCidrs : List all local CIDRs for a VPN gateway connection
// This request lists all local CIDRs for a VPN gateway connection specified by the identifier in the URL.
func (vpc *VpcV1) ListVPNGatewayConnectionLocalCidrs(listVPNGatewayConnectionLocalCidrsOptions *ListVPNGatewayConnectionLocalCidrsOptions) (result *VPNGatewayConnectionLocalCidRs, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listVPNGatewayConnectionLocalCidrsOptions, "listVPNGatewayConnectionLocalCidrsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listVPNGatewayConnectionLocalCidrsOptions, "listVPNGatewayConnectionLocalCidrsOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpn_gateways", "connections", "local_cidrs"}
	pathParameters := []string{*listVPNGatewayConnectionLocalCidrsOptions.VPNGatewayID, *listVPNGatewayConnectionLocalCidrsOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listVPNGatewayConnectionLocalCidrsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListVPNGatewayConnectionLocalCidrs")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVPNGatewayConnectionLocalCidRs)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// RemoveVPNGatewayConnectionLocalCIDR : Remove a local CIDR from a VPN gateway connection
// This request removes a CIDR from a VPN gateway connection.
func (vpc *VpcV1) RemoveVPNGatewayConnectionLocalCIDR(removeVPNGatewayConnectionLocalCIDROptions *RemoveVPNGatewayConnectionLocalCIDROptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(removeVPNGatewayConnectionLocalCIDROptions, "removeVPNGatewayConnectionLocalCIDROptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(removeVPNGatewayConnectionLocalCIDROptions, "removeVPNGatewayConnectionLocalCIDROptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpn_gateways", "connections", "local_cidrs", ""}
	pathParameters := []string{*removeVPNGatewayConnectionLocalCIDROptions.VPNGatewayID, *removeVPNGatewayConnectionLocalCIDROptions.ID, *removeVPNGatewayConnectionLocalCIDROptions.CIDRPrefix, *removeVPNGatewayConnectionLocalCIDROptions.PrefixLength}

	builder := core.NewRequestBuilder(core.DELETE)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range removeVPNGatewayConnectionLocalCIDROptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "RemoveVPNGatewayConnectionLocalCIDR")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// CheckVPNGatewayConnectionLocalCIDR : Check if the specified local CIDR exists on a VPN gateway connection
// This request succeeds if a CIDR exists on the specified VPN gateway connection and fails otherwise.
func (vpc *VpcV1) CheckVPNGatewayConnectionLocalCIDR(checkVPNGatewayConnectionLocalCIDROptions *CheckVPNGatewayConnectionLocalCIDROptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(checkVPNGatewayConnectionLocalCIDROptions, "checkVPNGatewayConnectionLocalCIDROptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(checkVPNGatewayConnectionLocalCIDROptions, "checkVPNGatewayConnectionLocalCIDROptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpn_gateways", "connections", "local_cidrs", ""}
	pathParameters := []string{*checkVPNGatewayConnectionLocalCIDROptions.VPNGatewayID, *checkVPNGatewayConnectionLocalCIDROptions.ID, *checkVPNGatewayConnectionLocalCIDROptions.CIDRPrefix, *checkVPNGatewayConnectionLocalCIDROptions.PrefixLength}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range checkVPNGatewayConnectionLocalCIDROptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CheckVPNGatewayConnectionLocalCIDR")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// AddVPNGatewayConnectionLocalCIDR : Set a local CIDR on a VPN gateway connection
// This request adds the specified CIDR to the specified VPN gateway connection. A request body is not required, and if
// supplied, is ignored. This request succeeds if the CIDR already exists on the specified VPN gateway connection.
func (vpc *VpcV1) AddVPNGatewayConnectionLocalCIDR(addVPNGatewayConnectionLocalCIDROptions *AddVPNGatewayConnectionLocalCIDROptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(addVPNGatewayConnectionLocalCIDROptions, "addVPNGatewayConnectionLocalCIDROptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(addVPNGatewayConnectionLocalCIDROptions, "addVPNGatewayConnectionLocalCIDROptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpn_gateways", "connections", "local_cidrs", ""}
	pathParameters := []string{*addVPNGatewayConnectionLocalCIDROptions.VPNGatewayID, *addVPNGatewayConnectionLocalCIDROptions.ID, *addVPNGatewayConnectionLocalCIDROptions.CIDRPrefix, *addVPNGatewayConnectionLocalCIDROptions.PrefixLength}

	builder := core.NewRequestBuilder(core.PUT)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range addVPNGatewayConnectionLocalCIDROptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "AddVPNGatewayConnectionLocalCIDR")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// ListVPNGatewayConnectionPeerCidrs : List all peer CIDRs for a VPN gateway connection
// This request lists all peer CIDRs for a VPN gateway connection specified by the identifier in the URL.
func (vpc *VpcV1) ListVPNGatewayConnectionPeerCidrs(listVPNGatewayConnectionPeerCidrsOptions *ListVPNGatewayConnectionPeerCidrsOptions) (result *VPNGatewayConnectionPeerCidRs, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listVPNGatewayConnectionPeerCidrsOptions, "listVPNGatewayConnectionPeerCidrsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listVPNGatewayConnectionPeerCidrsOptions, "listVPNGatewayConnectionPeerCidrsOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpn_gateways", "connections", "peer_cidrs"}
	pathParameters := []string{*listVPNGatewayConnectionPeerCidrsOptions.VPNGatewayID, *listVPNGatewayConnectionPeerCidrsOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listVPNGatewayConnectionPeerCidrsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListVPNGatewayConnectionPeerCidrs")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVPNGatewayConnectionPeerCidRs)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// RemoveVPNGatewayConnectionPeerCIDR : Remove a peer CIDR from a VPN gateway connection
// This request removes a CIDR from a VPN gateway connection.
func (vpc *VpcV1) RemoveVPNGatewayConnectionPeerCIDR(removeVPNGatewayConnectionPeerCIDROptions *RemoveVPNGatewayConnectionPeerCIDROptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(removeVPNGatewayConnectionPeerCIDROptions, "removeVPNGatewayConnectionPeerCIDROptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(removeVPNGatewayConnectionPeerCIDROptions, "removeVPNGatewayConnectionPeerCIDROptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpn_gateways", "connections", "peer_cidrs", ""}
	pathParameters := []string{*removeVPNGatewayConnectionPeerCIDROptions.VPNGatewayID, *removeVPNGatewayConnectionPeerCIDROptions.ID, *removeVPNGatewayConnectionPeerCIDROptions.CIDRPrefix, *removeVPNGatewayConnectionPeerCIDROptions.PrefixLength}

	builder := core.NewRequestBuilder(core.DELETE)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range removeVPNGatewayConnectionPeerCIDROptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "RemoveVPNGatewayConnectionPeerCIDR")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// CheckVPNGatewayConnectionPeerCIDR : Check if the specified peer CIDR exists on a VPN gateway connection
// This request succeeds if a CIDR exists on the specified VPN gateway connection and fails otherwise.
func (vpc *VpcV1) CheckVPNGatewayConnectionPeerCIDR(checkVPNGatewayConnectionPeerCIDROptions *CheckVPNGatewayConnectionPeerCIDROptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(checkVPNGatewayConnectionPeerCIDROptions, "checkVPNGatewayConnectionPeerCIDROptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(checkVPNGatewayConnectionPeerCIDROptions, "checkVPNGatewayConnectionPeerCIDROptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpn_gateways", "connections", "peer_cidrs", ""}
	pathParameters := []string{*checkVPNGatewayConnectionPeerCIDROptions.VPNGatewayID, *checkVPNGatewayConnectionPeerCIDROptions.ID, *checkVPNGatewayConnectionPeerCIDROptions.CIDRPrefix, *checkVPNGatewayConnectionPeerCIDROptions.PrefixLength}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range checkVPNGatewayConnectionPeerCIDROptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CheckVPNGatewayConnectionPeerCIDR")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// AddVPNGatewayConnectionPeerCIDR : Set a peer CIDR on a VPN gateway connection
// This request adds the specified CIDR to the specified VPN gateway connection. A request body is not required, and if
// supplied, is ignored. This request succeeds if the CIDR already exists on the specified VPN gateway connection.
func (vpc *VpcV1) AddVPNGatewayConnectionPeerCIDR(addVPNGatewayConnectionPeerCIDROptions *AddVPNGatewayConnectionPeerCIDROptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(addVPNGatewayConnectionPeerCIDROptions, "addVPNGatewayConnectionPeerCIDROptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(addVPNGatewayConnectionPeerCIDROptions, "addVPNGatewayConnectionPeerCIDROptions")
	if err != nil {
		return
	}

	pathSegments := []string{"vpn_gateways", "connections", "peer_cidrs", ""}
	pathParameters := []string{*addVPNGatewayConnectionPeerCIDROptions.VPNGatewayID, *addVPNGatewayConnectionPeerCIDROptions.ID, *addVPNGatewayConnectionPeerCIDROptions.CIDRPrefix, *addVPNGatewayConnectionPeerCIDROptions.PrefixLength}

	builder := core.NewRequestBuilder(core.PUT)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range addVPNGatewayConnectionPeerCIDROptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "AddVPNGatewayConnectionPeerCIDR")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// ListVolumeProfiles : List all volume profiles
// This request lists all volume profiles available in the region. A volume profile specifies the performance
// characteristics and pricing model for a volume.
func (vpc *VpcV1) ListVolumeProfiles(listVolumeProfilesOptions *ListVolumeProfilesOptions) (result *VolumeProfileCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listVolumeProfilesOptions, "listVolumeProfilesOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"volume/profiles"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listVolumeProfilesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListVolumeProfiles")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listVolumeProfilesOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listVolumeProfilesOptions.Start))
	}
	if listVolumeProfilesOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listVolumeProfilesOptions.Limit))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVolumeProfileCollection)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// GetVolumeProfile : Retrieve specified volume profile
// This request retrieves a single volume profile specified by the name in the URL.
func (vpc *VpcV1) GetVolumeProfile(getVolumeProfileOptions *GetVolumeProfileOptions) (result *VolumeProfile, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getVolumeProfileOptions, "getVolumeProfileOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getVolumeProfileOptions, "getVolumeProfileOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"volume/profiles"}
	pathParameters := []string{*getVolumeProfileOptions.Name}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getVolumeProfileOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetVolumeProfile")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVolumeProfile)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// ListVolumes : List all volumes
// This request lists all volumes in the region. Volumes are network-connected block storage devices that may be
// attached to one or more instances in the same region.
func (vpc *VpcV1) ListVolumes(listVolumesOptions *ListVolumesOptions) (result *VolumeCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listVolumesOptions, "listVolumesOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"volumes"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range listVolumesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "ListVolumes")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))
	if listVolumesOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listVolumesOptions.Start))
	}
	if listVolumesOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listVolumesOptions.Limit))
	}
	if listVolumesOptions.Name != nil {
		builder.AddQuery("name", fmt.Sprint(*listVolumesOptions.Name))
	}
	if listVolumesOptions.ZoneName != nil {
		builder.AddQuery("zone.name", fmt.Sprint(*listVolumesOptions.ZoneName))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVolumeCollection)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// CreateVolume : Create a volume
// This request creates a new volume from a volume prototype object. The prototype object is structured in the same way
// as a retrieved volume, and contains the information necessary to create the new volume.
func (vpc *VpcV1) CreateVolume(createVolumeOptions *CreateVolumeOptions) (result *Volume, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createVolumeOptions, "createVolumeOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createVolumeOptions, "createVolumeOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"volumes"}
	pathParameters := []string{}

	builder := core.NewRequestBuilder(core.POST)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range createVolumeOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "CreateVolume")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	_, err = builder.SetBodyContentJSON(createVolumeOptions.VolumePrototype)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVolume)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// DeleteVolume : Delete specified volume
// This request deletes a volume. This operation cannot be reversed. For this request to succeed, the volume must not be
// attached to any instances.
func (vpc *VpcV1) DeleteVolume(deleteVolumeOptions *DeleteVolumeOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteVolumeOptions, "deleteVolumeOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteVolumeOptions, "deleteVolumeOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"volumes"}
	pathParameters := []string{*deleteVolumeOptions.ID}

	builder := core.NewRequestBuilder(core.DELETE)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteVolumeOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "DeleteVolume")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vpc.Service.Request(request, nil)

	return
}

// GetVolume : Retrieve specified volume
// This request retrieves a single volume specified by the identifier in the URL.
func (vpc *VpcV1) GetVolume(getVolumeOptions *GetVolumeOptions) (result *Volume, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getVolumeOptions, "getVolumeOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getVolumeOptions, "getVolumeOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"volumes"}
	pathParameters := []string{*getVolumeOptions.ID}

	builder := core.NewRequestBuilder(core.GET)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range getVolumeOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "GetVolume")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVolume)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// UpdateVolume : Update specified volume
// This request updates a volume with the information in a provided volume patch. The volume patch object is structured
// in the same way as a retrieved volume and contains only the information to be updated.
func (vpc *VpcV1) UpdateVolume(updateVolumeOptions *UpdateVolumeOptions) (result *Volume, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateVolumeOptions, "updateVolumeOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateVolumeOptions, "updateVolumeOptions")
	if err != nil {
		return
	}

	pathSegments := []string{"volumes"}
	pathParameters := []string{*updateVolumeOptions.ID}

	builder := core.NewRequestBuilder(core.PATCH)
	_, err = builder.ConstructHTTPURL(vpc.Service.Options.URL, pathSegments, pathParameters)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateVolumeOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vpc", "V1", "UpdateVolume")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*vpc.Version))
	builder.AddQuery("generation", fmt.Sprint(*vpc.generation))

	body := make(map[string]interface{})
	if updateVolumeOptions.Name != nil {
		body["name"] = updateVolumeOptions.Name
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vpc.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVolume)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// AddInstanceNetworkInterfaceFloatingIPOptions : The AddInstanceNetworkInterfaceFloatingIP options.
type AddInstanceNetworkInterfaceFloatingIPOptions struct {
	// The instance identifier.
	InstanceID *string `json:"instance_id" validate:"required"`

	// The network interface identifier.
	NetworkInterfaceID *string `json:"network_interface_id" validate:"required"`

	// The floating IP identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewAddInstanceNetworkInterfaceFloatingIPOptions : Instantiate AddInstanceNetworkInterfaceFloatingIPOptions
func (*VpcV1) NewAddInstanceNetworkInterfaceFloatingIPOptions(instanceID string, networkInterfaceID string, id string) *AddInstanceNetworkInterfaceFloatingIPOptions {
	return &AddInstanceNetworkInterfaceFloatingIPOptions{
		InstanceID:         core.StringPtr(instanceID),
		NetworkInterfaceID: core.StringPtr(networkInterfaceID),
		ID:                 core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (options *AddInstanceNetworkInterfaceFloatingIPOptions) SetInstanceID(instanceID string) *AddInstanceNetworkInterfaceFloatingIPOptions {
	options.InstanceID = core.StringPtr(instanceID)
	return options
}

// SetNetworkInterfaceID : Allow user to set NetworkInterfaceID
func (options *AddInstanceNetworkInterfaceFloatingIPOptions) SetNetworkInterfaceID(networkInterfaceID string) *AddInstanceNetworkInterfaceFloatingIPOptions {
	options.NetworkInterfaceID = core.StringPtr(networkInterfaceID)
	return options
}

// SetID : Allow user to set ID
func (options *AddInstanceNetworkInterfaceFloatingIPOptions) SetID(id string) *AddInstanceNetworkInterfaceFloatingIPOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *AddInstanceNetworkInterfaceFloatingIPOptions) SetHeaders(param map[string]string) *AddInstanceNetworkInterfaceFloatingIPOptions {
	options.Headers = param
	return options
}

// AddSecurityGroupNetworkInterfaceOptions : The AddSecurityGroupNetworkInterface options.
type AddSecurityGroupNetworkInterfaceOptions struct {
	// The security group identifier.
	SecurityGroupID *string `json:"security_group_id" validate:"required"`

	// The network interface identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewAddSecurityGroupNetworkInterfaceOptions : Instantiate AddSecurityGroupNetworkInterfaceOptions
func (*VpcV1) NewAddSecurityGroupNetworkInterfaceOptions(securityGroupID string, id string) *AddSecurityGroupNetworkInterfaceOptions {
	return &AddSecurityGroupNetworkInterfaceOptions{
		SecurityGroupID: core.StringPtr(securityGroupID),
		ID:              core.StringPtr(id),
	}
}

// SetSecurityGroupID : Allow user to set SecurityGroupID
func (options *AddSecurityGroupNetworkInterfaceOptions) SetSecurityGroupID(securityGroupID string) *AddSecurityGroupNetworkInterfaceOptions {
	options.SecurityGroupID = core.StringPtr(securityGroupID)
	return options
}

// SetID : Allow user to set ID
func (options *AddSecurityGroupNetworkInterfaceOptions) SetID(id string) *AddSecurityGroupNetworkInterfaceOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *AddSecurityGroupNetworkInterfaceOptions) SetHeaders(param map[string]string) *AddSecurityGroupNetworkInterfaceOptions {
	options.Headers = param
	return options
}

// AddVPNGatewayConnectionLocalCIDROptions : The AddVPNGatewayConnectionLocalCIDR options.
type AddVPNGatewayConnectionLocalCIDROptions struct {
	// The VPN gateway identifier.
	VPNGatewayID *string `json:"vpn_gateway_id" validate:"required"`

	// The VPN connection identifier.
	ID *string `json:"id" validate:"required"`

	// The address prefix part of the CIDR.
	CIDRPrefix *string `json:"cidr_prefix" validate:"required"`

	// The prefix length part of the CIDR.
	PrefixLength *string `json:"prefix_length" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewAddVPNGatewayConnectionLocalCIDROptions : Instantiate AddVPNGatewayConnectionLocalCIDROptions
func (*VpcV1) NewAddVPNGatewayConnectionLocalCIDROptions(vpnGatewayID string, id string, cidrPrefix string, prefixLength string) *AddVPNGatewayConnectionLocalCIDROptions {
	return &AddVPNGatewayConnectionLocalCIDROptions{
		VPNGatewayID: core.StringPtr(vpnGatewayID),
		ID:           core.StringPtr(id),
		CIDRPrefix:   core.StringPtr(cidrPrefix),
		PrefixLength: core.StringPtr(prefixLength),
	}
}

// SetVPNGatewayID : Allow user to set VPNGatewayID
func (options *AddVPNGatewayConnectionLocalCIDROptions) SetVPNGatewayID(vpnGatewayID string) *AddVPNGatewayConnectionLocalCIDROptions {
	options.VPNGatewayID = core.StringPtr(vpnGatewayID)
	return options
}

// SetID : Allow user to set ID
func (options *AddVPNGatewayConnectionLocalCIDROptions) SetID(id string) *AddVPNGatewayConnectionLocalCIDROptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetCIDRPrefix : Allow user to set CIDRPrefix
func (options *AddVPNGatewayConnectionLocalCIDROptions) SetCIDRPrefix(cidrPrefix string) *AddVPNGatewayConnectionLocalCIDROptions {
	options.CIDRPrefix = core.StringPtr(cidrPrefix)
	return options
}

// SetPrefixLength : Allow user to set PrefixLength
func (options *AddVPNGatewayConnectionLocalCIDROptions) SetPrefixLength(prefixLength string) *AddVPNGatewayConnectionLocalCIDROptions {
	options.PrefixLength = core.StringPtr(prefixLength)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *AddVPNGatewayConnectionLocalCIDROptions) SetHeaders(param map[string]string) *AddVPNGatewayConnectionLocalCIDROptions {
	options.Headers = param
	return options
}

// AddVPNGatewayConnectionPeerCIDROptions : The AddVPNGatewayConnectionPeerCIDR options.
type AddVPNGatewayConnectionPeerCIDROptions struct {
	// The VPN gateway identifier.
	VPNGatewayID *string `json:"vpn_gateway_id" validate:"required"`

	// The VPN connection identifier.
	ID *string `json:"id" validate:"required"`

	// The address prefix part of the CIDR.
	CIDRPrefix *string `json:"cidr_prefix" validate:"required"`

	// The prefix length part of the CIDR.
	PrefixLength *string `json:"prefix_length" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewAddVPNGatewayConnectionPeerCIDROptions : Instantiate AddVPNGatewayConnectionPeerCIDROptions
func (*VpcV1) NewAddVPNGatewayConnectionPeerCIDROptions(vpnGatewayID string, id string, cidrPrefix string, prefixLength string) *AddVPNGatewayConnectionPeerCIDROptions {
	return &AddVPNGatewayConnectionPeerCIDROptions{
		VPNGatewayID: core.StringPtr(vpnGatewayID),
		ID:           core.StringPtr(id),
		CIDRPrefix:   core.StringPtr(cidrPrefix),
		PrefixLength: core.StringPtr(prefixLength),
	}
}

// SetVPNGatewayID : Allow user to set VPNGatewayID
func (options *AddVPNGatewayConnectionPeerCIDROptions) SetVPNGatewayID(vpnGatewayID string) *AddVPNGatewayConnectionPeerCIDROptions {
	options.VPNGatewayID = core.StringPtr(vpnGatewayID)
	return options
}

// SetID : Allow user to set ID
func (options *AddVPNGatewayConnectionPeerCIDROptions) SetID(id string) *AddVPNGatewayConnectionPeerCIDROptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetCIDRPrefix : Allow user to set CIDRPrefix
func (options *AddVPNGatewayConnectionPeerCIDROptions) SetCIDRPrefix(cidrPrefix string) *AddVPNGatewayConnectionPeerCIDROptions {
	options.CIDRPrefix = core.StringPtr(cidrPrefix)
	return options
}

// SetPrefixLength : Allow user to set PrefixLength
func (options *AddVPNGatewayConnectionPeerCIDROptions) SetPrefixLength(prefixLength string) *AddVPNGatewayConnectionPeerCIDROptions {
	options.PrefixLength = core.StringPtr(prefixLength)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *AddVPNGatewayConnectionPeerCIDROptions) SetHeaders(param map[string]string) *AddVPNGatewayConnectionPeerCIDROptions {
	options.Headers = param
	return options
}

// AddressPrefix : AddressPrefix struct
type AddressPrefix struct {
	// The CIDR block for this prefix.
	CIDR *string `json:"cidr" validate:"required"`

	// The date and time that the prefix was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// Indicates whether subnets exist with addresses from this prefix.
	HasSubnets *bool `json:"has_subnets" validate:"required"`

	// The URL for this address prefix.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this address prefix.
	ID *string `json:"id" validate:"required"`

	// Indicates whether this is the default prefix for this zone in this VPC. If a default prefix was automatically
	// created when the VPC was created, the prefix is automatically named using a hyphenated list of randomly-selected
	// words, but may be updated with a user-specified name.
	IsDefault *bool `json:"is_default" validate:"required"`

	// The user-defined name for this address prefix. Names must be unique within the VPC the address prefix resides in.
	Name *string `json:"name" validate:"required"`

	// The zone this address prefix resides in.
	Zone *ZoneReference `json:"zone" validate:"required"`
}

// UnmarshalAddressPrefix unmarshals an instance of AddressPrefix from the specified map of raw messages.
func UnmarshalAddressPrefix(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(AddressPrefix)
	err = core.UnmarshalPrimitive(m, "cidr", &obj.CIDR)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "has_subnets", &obj.HasSubnets)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "is_default", &obj.IsDefault)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AddressPrefixCollection : AddressPrefixCollection struct
type AddressPrefixCollection struct {
	// Collection of address prefixes.
	AddressPrefixes []AddressPrefix `json:"address_prefixes" validate:"required"`

	// A reference to the first page of resources.
	First *AddressPrefixCollectionFirst `json:"first" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A reference to the next page of resources; this reference is included for all pages
	// except the last page.
	Next *AddressPrefixCollectionNext `json:"next,omitempty"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalAddressPrefixCollection unmarshals an instance of AddressPrefixCollection from the specified map of raw messages.
func UnmarshalAddressPrefixCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(AddressPrefixCollection)
	err = core.UnmarshalModel(m, "address_prefixes", &obj.AddressPrefixes, UnmarshalAddressPrefix)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalAddressPrefixCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalAddressPrefixCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AddressPrefixCollectionFirst : A reference to the first page of resources.
type AddressPrefixCollectionFirst struct {
	// The URL for the first page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalAddressPrefixCollectionFirst unmarshals an instance of AddressPrefixCollectionFirst from the specified map of raw messages.
func UnmarshalAddressPrefixCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(AddressPrefixCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AddressPrefixCollectionNext : A reference to the next page of resources; this reference is included for all pages except the last page.
type AddressPrefixCollectionNext struct {
	// The URL for the next page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalAddressPrefixCollectionNext unmarshals an instance of AddressPrefixCollectionNext from the specified map of raw messages.
func UnmarshalAddressPrefixCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(AddressPrefixCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CertificateInstanceIdentity : Identifies a certificate instance by a unique property.
// Models which "extend" this model:
// - CertificateInstanceIdentityByCRN
type CertificateInstanceIdentity struct {
	// The CRN for this certificate instance.
	CRN *string `json:"crn,omitempty"`
}

func (*CertificateInstanceIdentity) isaCertificateInstanceIdentity() bool {
	return true
}

type CertificateInstanceIdentityIntf interface {
	isaCertificateInstanceIdentity() bool
}

// UnmarshalCertificateInstanceIdentity unmarshals an instance of CertificateInstanceIdentity from the specified map of raw messages.
func UnmarshalCertificateInstanceIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CertificateInstanceIdentity)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CertificateInstanceReference : CertificateInstanceReference struct
type CertificateInstanceReference struct {
	// The CRN for this certificate instance.
	CRN *string `json:"crn" validate:"required"`
}

// UnmarshalCertificateInstanceReference unmarshals an instance of CertificateInstanceReference from the specified map of raw messages.
func UnmarshalCertificateInstanceReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CertificateInstanceReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CheckVPNGatewayConnectionLocalCIDROptions : The CheckVPNGatewayConnectionLocalCIDR options.
type CheckVPNGatewayConnectionLocalCIDROptions struct {
	// The VPN gateway identifier.
	VPNGatewayID *string `json:"vpn_gateway_id" validate:"required"`

	// The VPN connection identifier.
	ID *string `json:"id" validate:"required"`

	// The address prefix part of the CIDR.
	CIDRPrefix *string `json:"cidr_prefix" validate:"required"`

	// The prefix length part of the CIDR.
	PrefixLength *string `json:"prefix_length" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCheckVPNGatewayConnectionLocalCIDROptions : Instantiate CheckVPNGatewayConnectionLocalCIDROptions
func (*VpcV1) NewCheckVPNGatewayConnectionLocalCIDROptions(vpnGatewayID string, id string, cidrPrefix string, prefixLength string) *CheckVPNGatewayConnectionLocalCIDROptions {
	return &CheckVPNGatewayConnectionLocalCIDROptions{
		VPNGatewayID: core.StringPtr(vpnGatewayID),
		ID:           core.StringPtr(id),
		CIDRPrefix:   core.StringPtr(cidrPrefix),
		PrefixLength: core.StringPtr(prefixLength),
	}
}

// SetVPNGatewayID : Allow user to set VPNGatewayID
func (options *CheckVPNGatewayConnectionLocalCIDROptions) SetVPNGatewayID(vpnGatewayID string) *CheckVPNGatewayConnectionLocalCIDROptions {
	options.VPNGatewayID = core.StringPtr(vpnGatewayID)
	return options
}

// SetID : Allow user to set ID
func (options *CheckVPNGatewayConnectionLocalCIDROptions) SetID(id string) *CheckVPNGatewayConnectionLocalCIDROptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetCIDRPrefix : Allow user to set CIDRPrefix
func (options *CheckVPNGatewayConnectionLocalCIDROptions) SetCIDRPrefix(cidrPrefix string) *CheckVPNGatewayConnectionLocalCIDROptions {
	options.CIDRPrefix = core.StringPtr(cidrPrefix)
	return options
}

// SetPrefixLength : Allow user to set PrefixLength
func (options *CheckVPNGatewayConnectionLocalCIDROptions) SetPrefixLength(prefixLength string) *CheckVPNGatewayConnectionLocalCIDROptions {
	options.PrefixLength = core.StringPtr(prefixLength)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CheckVPNGatewayConnectionLocalCIDROptions) SetHeaders(param map[string]string) *CheckVPNGatewayConnectionLocalCIDROptions {
	options.Headers = param
	return options
}

// CheckVPNGatewayConnectionPeerCIDROptions : The CheckVPNGatewayConnectionPeerCIDR options.
type CheckVPNGatewayConnectionPeerCIDROptions struct {
	// The VPN gateway identifier.
	VPNGatewayID *string `json:"vpn_gateway_id" validate:"required"`

	// The VPN connection identifier.
	ID *string `json:"id" validate:"required"`

	// The address prefix part of the CIDR.
	CIDRPrefix *string `json:"cidr_prefix" validate:"required"`

	// The prefix length part of the CIDR.
	PrefixLength *string `json:"prefix_length" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCheckVPNGatewayConnectionPeerCIDROptions : Instantiate CheckVPNGatewayConnectionPeerCIDROptions
func (*VpcV1) NewCheckVPNGatewayConnectionPeerCIDROptions(vpnGatewayID string, id string, cidrPrefix string, prefixLength string) *CheckVPNGatewayConnectionPeerCIDROptions {
	return &CheckVPNGatewayConnectionPeerCIDROptions{
		VPNGatewayID: core.StringPtr(vpnGatewayID),
		ID:           core.StringPtr(id),
		CIDRPrefix:   core.StringPtr(cidrPrefix),
		PrefixLength: core.StringPtr(prefixLength),
	}
}

// SetVPNGatewayID : Allow user to set VPNGatewayID
func (options *CheckVPNGatewayConnectionPeerCIDROptions) SetVPNGatewayID(vpnGatewayID string) *CheckVPNGatewayConnectionPeerCIDROptions {
	options.VPNGatewayID = core.StringPtr(vpnGatewayID)
	return options
}

// SetID : Allow user to set ID
func (options *CheckVPNGatewayConnectionPeerCIDROptions) SetID(id string) *CheckVPNGatewayConnectionPeerCIDROptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetCIDRPrefix : Allow user to set CIDRPrefix
func (options *CheckVPNGatewayConnectionPeerCIDROptions) SetCIDRPrefix(cidrPrefix string) *CheckVPNGatewayConnectionPeerCIDROptions {
	options.CIDRPrefix = core.StringPtr(cidrPrefix)
	return options
}

// SetPrefixLength : Allow user to set PrefixLength
func (options *CheckVPNGatewayConnectionPeerCIDROptions) SetPrefixLength(prefixLength string) *CheckVPNGatewayConnectionPeerCIDROptions {
	options.PrefixLength = core.StringPtr(prefixLength)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CheckVPNGatewayConnectionPeerCIDROptions) SetHeaders(param map[string]string) *CheckVPNGatewayConnectionPeerCIDROptions {
	options.Headers = param
	return options
}

// CloudObjectStorageBucketIdentity : Identifies a Cloud Object Storage bucket by a unique property.
// Models which "extend" this model:
// - CloudObjectStorageBucketIdentityByName
type CloudObjectStorageBucketIdentity struct {
	// The globally unique name of this COS bucket.
	Name *string `json:"name,omitempty"`
}

func (*CloudObjectStorageBucketIdentity) isaCloudObjectStorageBucketIdentity() bool {
	return true
}

type CloudObjectStorageBucketIdentityIntf interface {
	isaCloudObjectStorageBucketIdentity() bool
}

// UnmarshalCloudObjectStorageBucketIdentity unmarshals an instance of CloudObjectStorageBucketIdentity from the specified map of raw messages.
func UnmarshalCloudObjectStorageBucketIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CloudObjectStorageBucketIdentity)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CloudObjectStorageBucketReference : CloudObjectStorageBucketReference struct
type CloudObjectStorageBucketReference struct {
	// The globally unique name of this COS bucket.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalCloudObjectStorageBucketReference unmarshals an instance of CloudObjectStorageBucketReference from the specified map of raw messages.
func UnmarshalCloudObjectStorageBucketReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CloudObjectStorageBucketReference)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CreateDedicatedHostGroupOptions : The CreateDedicatedHostGroup options.
type CreateDedicatedHostGroupOptions struct {
	// The unique user-defined name for this dedicated host group. If unspecified, the name will be a hyphenated list of
	// randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// The zone to provision the dedicated host group in.
	Zone ZoneIdentityIntf `json:"zone,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateDedicatedHostGroupOptions : Instantiate CreateDedicatedHostGroupOptions
func (*VpcV1) NewCreateDedicatedHostGroupOptions() *CreateDedicatedHostGroupOptions {
	return &CreateDedicatedHostGroupOptions{}
}

// SetName : Allow user to set Name
func (options *CreateDedicatedHostGroupOptions) SetName(name string) *CreateDedicatedHostGroupOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetResourceGroup : Allow user to set ResourceGroup
func (options *CreateDedicatedHostGroupOptions) SetResourceGroup(resourceGroup ResourceGroupIdentityIntf) *CreateDedicatedHostGroupOptions {
	options.ResourceGroup = resourceGroup
	return options
}

// SetZone : Allow user to set Zone
func (options *CreateDedicatedHostGroupOptions) SetZone(zone ZoneIdentityIntf) *CreateDedicatedHostGroupOptions {
	options.Zone = zone
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateDedicatedHostGroupOptions) SetHeaders(param map[string]string) *CreateDedicatedHostGroupOptions {
	options.Headers = param
	return options
}

// CreateDedicatedHostOptions : The CreateDedicatedHost options.
type CreateDedicatedHostOptions struct {
	// The dedicated host group for this dedicated host.
	Group DedicatedHostPrototypeGroupIntf `json:"group" validate:"required"`

	// The profile to use for this dedicated host.
	Profile DedicatedHostPrototypeProfileIntf `json:"profile" validate:"required"`

	// If set to true, instances can be placed on this dedicated host.
	InstancePlacementEnabled *bool `json:"instance_placement_enabled,omitempty"`

	// The unique user-defined name for this dedicated host. If unspecified, the name will be a hyphenated list of
	// randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateDedicatedHostOptions : Instantiate CreateDedicatedHostOptions
func (*VpcV1) NewCreateDedicatedHostOptions(group DedicatedHostPrototypeGroupIntf, profile DedicatedHostPrototypeProfileIntf) *CreateDedicatedHostOptions {
	return &CreateDedicatedHostOptions{
		Group:   group,
		Profile: profile,
	}
}

// SetGroup : Allow user to set Group
func (options *CreateDedicatedHostOptions) SetGroup(group DedicatedHostPrototypeGroupIntf) *CreateDedicatedHostOptions {
	options.Group = group
	return options
}

// SetProfile : Allow user to set Profile
func (options *CreateDedicatedHostOptions) SetProfile(profile DedicatedHostPrototypeProfileIntf) *CreateDedicatedHostOptions {
	options.Profile = profile
	return options
}

// SetInstancePlacementEnabled : Allow user to set InstancePlacementEnabled
func (options *CreateDedicatedHostOptions) SetInstancePlacementEnabled(instancePlacementEnabled bool) *CreateDedicatedHostOptions {
	options.InstancePlacementEnabled = core.BoolPtr(instancePlacementEnabled)
	return options
}

// SetName : Allow user to set Name
func (options *CreateDedicatedHostOptions) SetName(name string) *CreateDedicatedHostOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetResourceGroup : Allow user to set ResourceGroup
func (options *CreateDedicatedHostOptions) SetResourceGroup(resourceGroup ResourceGroupIdentityIntf) *CreateDedicatedHostOptions {
	options.ResourceGroup = resourceGroup
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateDedicatedHostOptions) SetHeaders(param map[string]string) *CreateDedicatedHostOptions {
	options.Headers = param
	return options
}

// CreateFloatingIPOptions : The CreateFloatingIP options.
type CreateFloatingIPOptions struct {
	// The floating IP prototype object.
	FloatingIPPrototype FloatingIPPrototypeIntf `json:"FloatingIPPrototype" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateFloatingIPOptions : Instantiate CreateFloatingIPOptions
func (*VpcV1) NewCreateFloatingIPOptions(floatingIPPrototype FloatingIPPrototypeIntf) *CreateFloatingIPOptions {
	return &CreateFloatingIPOptions{
		FloatingIPPrototype: floatingIPPrototype,
	}
}

// SetFloatingIPPrototype : Allow user to set FloatingIPPrototype
func (options *CreateFloatingIPOptions) SetFloatingIPPrototype(floatingIPPrototype FloatingIPPrototypeIntf) *CreateFloatingIPOptions {
	options.FloatingIPPrototype = floatingIPPrototype
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateFloatingIPOptions) SetHeaders(param map[string]string) *CreateFloatingIPOptions {
	options.Headers = param
	return options
}

// CreateFlowLogCollectorOptions : The CreateFlowLogCollector options.
type CreateFlowLogCollectorOptions struct {
	// The Cloud Object Storage bucket where the collected flows will be logged.
	// The bucket must exist and an IAM service authorization must grant
	// `IBM Cloud Flow Logs` resources of `VPC Infrastructure Services` writer
	// access to the bucket.
	StorageBucket CloudObjectStorageBucketIdentityIntf `json:"storage_bucket" validate:"required"`

	// The target this collector is to collect flow logs for. If the target is an instance,
	// subnet, or VPC, flow logs will not be collected for any network interfaces within the
	// target that are themselves the target of a more specific flow log collector.
	Target FlowLogCollectorPrototypeTargetIntf `json:"target" validate:"required"`

	// Indicates whether this collector is active. If false, this collector is created in inactive mode.
	Active *bool `json:"active,omitempty"`

	// The unique user-defined name for this flow log collector. If unspecified, the name will be a hyphenated list of
	// randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateFlowLogCollectorOptions : Instantiate CreateFlowLogCollectorOptions
func (*VpcV1) NewCreateFlowLogCollectorOptions(storageBucket CloudObjectStorageBucketIdentityIntf, target FlowLogCollectorPrototypeTargetIntf) *CreateFlowLogCollectorOptions {
	return &CreateFlowLogCollectorOptions{
		StorageBucket: storageBucket,
		Target:        target,
	}
}

// SetStorageBucket : Allow user to set StorageBucket
func (options *CreateFlowLogCollectorOptions) SetStorageBucket(storageBucket CloudObjectStorageBucketIdentityIntf) *CreateFlowLogCollectorOptions {
	options.StorageBucket = storageBucket
	return options
}

// SetTarget : Allow user to set Target
func (options *CreateFlowLogCollectorOptions) SetTarget(target FlowLogCollectorPrototypeTargetIntf) *CreateFlowLogCollectorOptions {
	options.Target = target
	return options
}

// SetActive : Allow user to set Active
func (options *CreateFlowLogCollectorOptions) SetActive(active bool) *CreateFlowLogCollectorOptions {
	options.Active = core.BoolPtr(active)
	return options
}

// SetName : Allow user to set Name
func (options *CreateFlowLogCollectorOptions) SetName(name string) *CreateFlowLogCollectorOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetResourceGroup : Allow user to set ResourceGroup
func (options *CreateFlowLogCollectorOptions) SetResourceGroup(resourceGroup ResourceGroupIdentityIntf) *CreateFlowLogCollectorOptions {
	options.ResourceGroup = resourceGroup
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateFlowLogCollectorOptions) SetHeaders(param map[string]string) *CreateFlowLogCollectorOptions {
	options.Headers = param
	return options
}

// CreateIkePolicyOptions : The CreateIkePolicy options.
type CreateIkePolicyOptions struct {
	// The authentication algorithm.
	AuthenticationAlgorithm *string `json:"authentication_algorithm" validate:"required"`

	// The Diffie-Hellman group.
	DhGroup *int64 `json:"dh_group" validate:"required"`

	// The encryption algorithm.
	EncryptionAlgorithm *string `json:"encryption_algorithm" validate:"required"`

	// The IKE protocol version.
	IkeVersion *int64 `json:"ike_version" validate:"required"`

	// The key lifetime in seconds.
	KeyLifetime *int64 `json:"key_lifetime,omitempty"`

	// The user-defined name for this IKE policy.
	Name *string `json:"name,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the CreateIkePolicyOptions.AuthenticationAlgorithm property.
// The authentication algorithm.
const (
	CreateIkePolicyOptionsAuthenticationAlgorithmMd5Const    = "md5"
	CreateIkePolicyOptionsAuthenticationAlgorithmSha1Const   = "sha1"
	CreateIkePolicyOptionsAuthenticationAlgorithmSha256Const = "sha256"
)

// Constants associated with the CreateIkePolicyOptions.EncryptionAlgorithm property.
// The encryption algorithm.
const (
	CreateIkePolicyOptionsEncryptionAlgorithmAes128Const    = "aes128"
	CreateIkePolicyOptionsEncryptionAlgorithmAes256Const    = "aes256"
	CreateIkePolicyOptionsEncryptionAlgorithmTripleDesConst = "triple_des"
)

// NewCreateIkePolicyOptions : Instantiate CreateIkePolicyOptions
func (*VpcV1) NewCreateIkePolicyOptions(authenticationAlgorithm string, dhGroup int64, encryptionAlgorithm string, ikeVersion int64) *CreateIkePolicyOptions {
	return &CreateIkePolicyOptions{
		AuthenticationAlgorithm: core.StringPtr(authenticationAlgorithm),
		DhGroup:                 core.Int64Ptr(dhGroup),
		EncryptionAlgorithm:     core.StringPtr(encryptionAlgorithm),
		IkeVersion:              core.Int64Ptr(ikeVersion),
	}
}

// SetAuthenticationAlgorithm : Allow user to set AuthenticationAlgorithm
func (options *CreateIkePolicyOptions) SetAuthenticationAlgorithm(authenticationAlgorithm string) *CreateIkePolicyOptions {
	options.AuthenticationAlgorithm = core.StringPtr(authenticationAlgorithm)
	return options
}

// SetDhGroup : Allow user to set DhGroup
func (options *CreateIkePolicyOptions) SetDhGroup(dhGroup int64) *CreateIkePolicyOptions {
	options.DhGroup = core.Int64Ptr(dhGroup)
	return options
}

// SetEncryptionAlgorithm : Allow user to set EncryptionAlgorithm
func (options *CreateIkePolicyOptions) SetEncryptionAlgorithm(encryptionAlgorithm string) *CreateIkePolicyOptions {
	options.EncryptionAlgorithm = core.StringPtr(encryptionAlgorithm)
	return options
}

// SetIkeVersion : Allow user to set IkeVersion
func (options *CreateIkePolicyOptions) SetIkeVersion(ikeVersion int64) *CreateIkePolicyOptions {
	options.IkeVersion = core.Int64Ptr(ikeVersion)
	return options
}

// SetKeyLifetime : Allow user to set KeyLifetime
func (options *CreateIkePolicyOptions) SetKeyLifetime(keyLifetime int64) *CreateIkePolicyOptions {
	options.KeyLifetime = core.Int64Ptr(keyLifetime)
	return options
}

// SetName : Allow user to set Name
func (options *CreateIkePolicyOptions) SetName(name string) *CreateIkePolicyOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetResourceGroup : Allow user to set ResourceGroup
func (options *CreateIkePolicyOptions) SetResourceGroup(resourceGroup ResourceGroupIdentityIntf) *CreateIkePolicyOptions {
	options.ResourceGroup = resourceGroup
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateIkePolicyOptions) SetHeaders(param map[string]string) *CreateIkePolicyOptions {
	options.Headers = param
	return options
}

// CreateImageOptions : The CreateImage options.
type CreateImageOptions struct {
	// The image prototype object.
	ImagePrototype ImagePrototypeIntf `json:"ImagePrototype" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateImageOptions : Instantiate CreateImageOptions
func (*VpcV1) NewCreateImageOptions(imagePrototype ImagePrototypeIntf) *CreateImageOptions {
	return &CreateImageOptions{
		ImagePrototype: imagePrototype,
	}
}

// SetImagePrototype : Allow user to set ImagePrototype
func (options *CreateImageOptions) SetImagePrototype(imagePrototype ImagePrototypeIntf) *CreateImageOptions {
	options.ImagePrototype = imagePrototype
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateImageOptions) SetHeaders(param map[string]string) *CreateImageOptions {
	options.Headers = param
	return options
}

// CreateInstanceActionOptions : The CreateInstanceAction options.
type CreateInstanceActionOptions struct {
	// The instance identifier.
	InstanceID *string `json:"instance_id" validate:"required"`

	// The type of action.
	Type *string `json:"type" validate:"required"`

	// If set to true, the action will be forced immediately, and all queued actions deleted. Ignored for the start action.
	Force *bool `json:"force,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the CreateInstanceActionOptions.Type property.
// The type of action.
const (
	CreateInstanceActionOptionsTypeRebootConst = "reboot"
	CreateInstanceActionOptionsTypeStartConst  = "start"
	CreateInstanceActionOptionsTypeStopConst   = "stop"
)

// NewCreateInstanceActionOptions : Instantiate CreateInstanceActionOptions
func (*VpcV1) NewCreateInstanceActionOptions(instanceID string, typeVar string) *CreateInstanceActionOptions {
	return &CreateInstanceActionOptions{
		InstanceID: core.StringPtr(instanceID),
		Type:       core.StringPtr(typeVar),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (options *CreateInstanceActionOptions) SetInstanceID(instanceID string) *CreateInstanceActionOptions {
	options.InstanceID = core.StringPtr(instanceID)
	return options
}

// SetType : Allow user to set Type
func (options *CreateInstanceActionOptions) SetType(typeVar string) *CreateInstanceActionOptions {
	options.Type = core.StringPtr(typeVar)
	return options
}

// SetForce : Allow user to set Force
func (options *CreateInstanceActionOptions) SetForce(force bool) *CreateInstanceActionOptions {
	options.Force = core.BoolPtr(force)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateInstanceActionOptions) SetHeaders(param map[string]string) *CreateInstanceActionOptions {
	options.Headers = param
	return options
}

// CreateInstanceGroupManagerOptions : The CreateInstanceGroupManager options.
type CreateInstanceGroupManagerOptions struct {
	// The instance group identifier.
	InstanceGroupID *string `json:"instance_group_id" validate:"required"`

	// The instance group manager prototype object.
	InstanceGroupManagerPrototype InstanceGroupManagerPrototypeIntf `json:"InstanceGroupManagerPrototype" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateInstanceGroupManagerOptions : Instantiate CreateInstanceGroupManagerOptions
func (*VpcV1) NewCreateInstanceGroupManagerOptions(instanceGroupID string, instanceGroupManagerPrototype InstanceGroupManagerPrototypeIntf) *CreateInstanceGroupManagerOptions {
	return &CreateInstanceGroupManagerOptions{
		InstanceGroupID:               core.StringPtr(instanceGroupID),
		InstanceGroupManagerPrototype: instanceGroupManagerPrototype,
	}
}

// SetInstanceGroupID : Allow user to set InstanceGroupID
func (options *CreateInstanceGroupManagerOptions) SetInstanceGroupID(instanceGroupID string) *CreateInstanceGroupManagerOptions {
	options.InstanceGroupID = core.StringPtr(instanceGroupID)
	return options
}

// SetInstanceGroupManagerPrototype : Allow user to set InstanceGroupManagerPrototype
func (options *CreateInstanceGroupManagerOptions) SetInstanceGroupManagerPrototype(instanceGroupManagerPrototype InstanceGroupManagerPrototypeIntf) *CreateInstanceGroupManagerOptions {
	options.InstanceGroupManagerPrototype = instanceGroupManagerPrototype
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateInstanceGroupManagerOptions) SetHeaders(param map[string]string) *CreateInstanceGroupManagerOptions {
	options.Headers = param
	return options
}

// CreateInstanceGroupManagerPolicyOptions : The CreateInstanceGroupManagerPolicy options.
type CreateInstanceGroupManagerPolicyOptions struct {
	// The instance group identifier.
	InstanceGroupID *string `json:"instance_group_id" validate:"required"`

	// The instance group manager identifier.
	InstanceGroupManagerID *string `json:"instance_group_manager_id" validate:"required"`

	// The instance group manager policy prototype object.
	InstanceGroupManagerPolicyPrototype InstanceGroupManagerPolicyPrototypeIntf `json:"InstanceGroupManagerPolicyPrototype" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateInstanceGroupManagerPolicyOptions : Instantiate CreateInstanceGroupManagerPolicyOptions
func (*VpcV1) NewCreateInstanceGroupManagerPolicyOptions(instanceGroupID string, instanceGroupManagerID string, instanceGroupManagerPolicyPrototype InstanceGroupManagerPolicyPrototypeIntf) *CreateInstanceGroupManagerPolicyOptions {
	return &CreateInstanceGroupManagerPolicyOptions{
		InstanceGroupID:                     core.StringPtr(instanceGroupID),
		InstanceGroupManagerID:              core.StringPtr(instanceGroupManagerID),
		InstanceGroupManagerPolicyPrototype: instanceGroupManagerPolicyPrototype,
	}
}

// SetInstanceGroupID : Allow user to set InstanceGroupID
func (options *CreateInstanceGroupManagerPolicyOptions) SetInstanceGroupID(instanceGroupID string) *CreateInstanceGroupManagerPolicyOptions {
	options.InstanceGroupID = core.StringPtr(instanceGroupID)
	return options
}

// SetInstanceGroupManagerID : Allow user to set InstanceGroupManagerID
func (options *CreateInstanceGroupManagerPolicyOptions) SetInstanceGroupManagerID(instanceGroupManagerID string) *CreateInstanceGroupManagerPolicyOptions {
	options.InstanceGroupManagerID = core.StringPtr(instanceGroupManagerID)
	return options
}

// SetInstanceGroupManagerPolicyPrototype : Allow user to set InstanceGroupManagerPolicyPrototype
func (options *CreateInstanceGroupManagerPolicyOptions) SetInstanceGroupManagerPolicyPrototype(instanceGroupManagerPolicyPrototype InstanceGroupManagerPolicyPrototypeIntf) *CreateInstanceGroupManagerPolicyOptions {
	options.InstanceGroupManagerPolicyPrototype = instanceGroupManagerPolicyPrototype
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateInstanceGroupManagerPolicyOptions) SetHeaders(param map[string]string) *CreateInstanceGroupManagerPolicyOptions {
	options.Headers = param
	return options
}

// CreateInstanceGroupOptions : The CreateInstanceGroup options.
type CreateInstanceGroupOptions struct {
	// Instance template to use when creating new instances.
	InstanceTemplate InstanceTemplateIdentityIntf `json:"instance_template" validate:"required"`

	// Array of identities to subnets to use when creating new instances.
	Subnets []SubnetIdentityIntf `json:"subnets" validate:"required"`

	// Required if specifying a load balancer pool only. Used by the instance group when scaling up instances to supply the
	// port for the load balancer pool member.
	ApplicationPort *int64 `json:"application_port,omitempty"`

	// The load balancer that the load balancer pool used by this group
	// is in. Must be supplied when using a load balancer pool.
	LoadBalancer LoadBalancerIdentityIntf `json:"load_balancer,omitempty"`

	// When specified, the load balancer pool will be managed by this
	// group. Instances created by this group will have a new load
	// balancer pool member in that pool created. Must be used with
	// `application_port`.
	LoadBalancerPool LoadBalancerPoolIdentityIntf `json:"load_balancer_pool,omitempty"`

	// The number of instances in the instance group.
	MembershipCount *int64 `json:"membership_count,omitempty"`

	// The user-defined name for this instance group.
	Name *string `json:"name,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateInstanceGroupOptions : Instantiate CreateInstanceGroupOptions
func (*VpcV1) NewCreateInstanceGroupOptions(instanceTemplate InstanceTemplateIdentityIntf, subnets []SubnetIdentityIntf) *CreateInstanceGroupOptions {
	return &CreateInstanceGroupOptions{
		InstanceTemplate: instanceTemplate,
		Subnets:          subnets,
	}
}

// SetInstanceTemplate : Allow user to set InstanceTemplate
func (options *CreateInstanceGroupOptions) SetInstanceTemplate(instanceTemplate InstanceTemplateIdentityIntf) *CreateInstanceGroupOptions {
	options.InstanceTemplate = instanceTemplate
	return options
}

// SetSubnets : Allow user to set Subnets
func (options *CreateInstanceGroupOptions) SetSubnets(subnets []SubnetIdentityIntf) *CreateInstanceGroupOptions {
	options.Subnets = subnets
	return options
}

// SetApplicationPort : Allow user to set ApplicationPort
func (options *CreateInstanceGroupOptions) SetApplicationPort(applicationPort int64) *CreateInstanceGroupOptions {
	options.ApplicationPort = core.Int64Ptr(applicationPort)
	return options
}

// SetLoadBalancer : Allow user to set LoadBalancer
func (options *CreateInstanceGroupOptions) SetLoadBalancer(loadBalancer LoadBalancerIdentityIntf) *CreateInstanceGroupOptions {
	options.LoadBalancer = loadBalancer
	return options
}

// SetLoadBalancerPool : Allow user to set LoadBalancerPool
func (options *CreateInstanceGroupOptions) SetLoadBalancerPool(loadBalancerPool LoadBalancerPoolIdentityIntf) *CreateInstanceGroupOptions {
	options.LoadBalancerPool = loadBalancerPool
	return options
}

// SetMembershipCount : Allow user to set MembershipCount
func (options *CreateInstanceGroupOptions) SetMembershipCount(membershipCount int64) *CreateInstanceGroupOptions {
	options.MembershipCount = core.Int64Ptr(membershipCount)
	return options
}

// SetName : Allow user to set Name
func (options *CreateInstanceGroupOptions) SetName(name string) *CreateInstanceGroupOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetResourceGroup : Allow user to set ResourceGroup
func (options *CreateInstanceGroupOptions) SetResourceGroup(resourceGroup ResourceGroupIdentityIntf) *CreateInstanceGroupOptions {
	options.ResourceGroup = resourceGroup
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateInstanceGroupOptions) SetHeaders(param map[string]string) *CreateInstanceGroupOptions {
	options.Headers = param
	return options
}

// CreateInstanceNetworkInterfaceOptions : The CreateInstanceNetworkInterface options.
type CreateInstanceNetworkInterfaceOptions struct {
	// The instance identifier.
	InstanceID *string `json:"instance_id" validate:"required"`

	// The associated subnet.
	Subnet SubnetIdentityIntf `json:"subnet" validate:"required"`

	// Indicates whether source IP spoofing is allowed on this interface. If false, source IP spoofing is prevented on this
	// interface. If true, source IP spoofing is allowed on this interface.
	AllowIPSpoofing *bool `json:"allow_ip_spoofing,omitempty"`

	// The user-defined name for this network interface. If unspecified, the name will be a hyphenated list of
	// randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The primary IPv4 address.
	PrimaryIpv4Address *string `json:"primary_ipv4_address,omitempty"`

	// Collection of security groups.
	SecurityGroups []SecurityGroupIdentityIntf `json:"security_groups,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateInstanceNetworkInterfaceOptions : Instantiate CreateInstanceNetworkInterfaceOptions
func (*VpcV1) NewCreateInstanceNetworkInterfaceOptions(instanceID string, subnet SubnetIdentityIntf) *CreateInstanceNetworkInterfaceOptions {
	return &CreateInstanceNetworkInterfaceOptions{
		InstanceID: core.StringPtr(instanceID),
		Subnet:     subnet,
	}
}

// SetInstanceID : Allow user to set InstanceID
func (options *CreateInstanceNetworkInterfaceOptions) SetInstanceID(instanceID string) *CreateInstanceNetworkInterfaceOptions {
	options.InstanceID = core.StringPtr(instanceID)
	return options
}

// SetSubnet : Allow user to set Subnet
func (options *CreateInstanceNetworkInterfaceOptions) SetSubnet(subnet SubnetIdentityIntf) *CreateInstanceNetworkInterfaceOptions {
	options.Subnet = subnet
	return options
}

// SetAllowIPSpoofing : Allow user to set AllowIPSpoofing
func (options *CreateInstanceNetworkInterfaceOptions) SetAllowIPSpoofing(allowIPSpoofing bool) *CreateInstanceNetworkInterfaceOptions {
	options.AllowIPSpoofing = core.BoolPtr(allowIPSpoofing)
	return options
}

// SetName : Allow user to set Name
func (options *CreateInstanceNetworkInterfaceOptions) SetName(name string) *CreateInstanceNetworkInterfaceOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetPrimaryIpv4Address : Allow user to set PrimaryIpv4Address
func (options *CreateInstanceNetworkInterfaceOptions) SetPrimaryIpv4Address(primaryIpv4Address string) *CreateInstanceNetworkInterfaceOptions {
	options.PrimaryIpv4Address = core.StringPtr(primaryIpv4Address)
	return options
}

// SetSecurityGroups : Allow user to set SecurityGroups
func (options *CreateInstanceNetworkInterfaceOptions) SetSecurityGroups(securityGroups []SecurityGroupIdentityIntf) *CreateInstanceNetworkInterfaceOptions {
	options.SecurityGroups = securityGroups
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateInstanceNetworkInterfaceOptions) SetHeaders(param map[string]string) *CreateInstanceNetworkInterfaceOptions {
	options.Headers = param
	return options
}

// CreateInstanceOptions : The CreateInstance options.
type CreateInstanceOptions struct {
	// The instance prototype object.
	InstancePrototype InstancePrototypeIntf `json:"InstancePrototype" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateInstanceOptions : Instantiate CreateInstanceOptions
func (*VpcV1) NewCreateInstanceOptions(instancePrototype InstancePrototypeIntf) *CreateInstanceOptions {
	return &CreateInstanceOptions{
		InstancePrototype: instancePrototype,
	}
}

// SetInstancePrototype : Allow user to set InstancePrototype
func (options *CreateInstanceOptions) SetInstancePrototype(instancePrototype InstancePrototypeIntf) *CreateInstanceOptions {
	options.InstancePrototype = instancePrototype
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateInstanceOptions) SetHeaders(param map[string]string) *CreateInstanceOptions {
	options.Headers = param
	return options
}

// CreateInstanceTemplateOptions : The CreateInstanceTemplate options.
type CreateInstanceTemplateOptions struct {
	// The instance template prototype object.
	InstanceTemplatePrototype InstanceTemplatePrototypeIntf `json:"InstanceTemplatePrototype" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateInstanceTemplateOptions : Instantiate CreateInstanceTemplateOptions
func (*VpcV1) NewCreateInstanceTemplateOptions(instanceTemplatePrototype InstanceTemplatePrototypeIntf) *CreateInstanceTemplateOptions {
	return &CreateInstanceTemplateOptions{
		InstanceTemplatePrototype: instanceTemplatePrototype,
	}
}

// SetInstanceTemplatePrototype : Allow user to set InstanceTemplatePrototype
func (options *CreateInstanceTemplateOptions) SetInstanceTemplatePrototype(instanceTemplatePrototype InstanceTemplatePrototypeIntf) *CreateInstanceTemplateOptions {
	options.InstanceTemplatePrototype = instanceTemplatePrototype
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateInstanceTemplateOptions) SetHeaders(param map[string]string) *CreateInstanceTemplateOptions {
	options.Headers = param
	return options
}

// CreateInstanceVolumeAttachmentOptions : The CreateInstanceVolumeAttachment options.
type CreateInstanceVolumeAttachmentOptions struct {
	// The instance identifier.
	InstanceID *string `json:"instance_id" validate:"required"`

	// The identity of the volume to attach to the instance.
	Volume VolumeIdentityIntf `json:"volume" validate:"required"`

	// If set to true, when deleting the instance the volume will also be deleted.
	DeleteVolumeOnInstanceDelete *bool `json:"delete_volume_on_instance_delete,omitempty"`

	// The user-defined name for this volume attachment. If unspecified, the name will be a hyphenated list of
	// randomly-selected words.
	Name *string `json:"name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateInstanceVolumeAttachmentOptions : Instantiate CreateInstanceVolumeAttachmentOptions
func (*VpcV1) NewCreateInstanceVolumeAttachmentOptions(instanceID string, volume VolumeIdentityIntf) *CreateInstanceVolumeAttachmentOptions {
	return &CreateInstanceVolumeAttachmentOptions{
		InstanceID: core.StringPtr(instanceID),
		Volume:     volume,
	}
}

// SetInstanceID : Allow user to set InstanceID
func (options *CreateInstanceVolumeAttachmentOptions) SetInstanceID(instanceID string) *CreateInstanceVolumeAttachmentOptions {
	options.InstanceID = core.StringPtr(instanceID)
	return options
}

// SetVolume : Allow user to set Volume
func (options *CreateInstanceVolumeAttachmentOptions) SetVolume(volume VolumeIdentityIntf) *CreateInstanceVolumeAttachmentOptions {
	options.Volume = volume
	return options
}

// SetDeleteVolumeOnInstanceDelete : Allow user to set DeleteVolumeOnInstanceDelete
func (options *CreateInstanceVolumeAttachmentOptions) SetDeleteVolumeOnInstanceDelete(deleteVolumeOnInstanceDelete bool) *CreateInstanceVolumeAttachmentOptions {
	options.DeleteVolumeOnInstanceDelete = core.BoolPtr(deleteVolumeOnInstanceDelete)
	return options
}

// SetName : Allow user to set Name
func (options *CreateInstanceVolumeAttachmentOptions) SetName(name string) *CreateInstanceVolumeAttachmentOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateInstanceVolumeAttachmentOptions) SetHeaders(param map[string]string) *CreateInstanceVolumeAttachmentOptions {
	options.Headers = param
	return options
}

// CreateIpsecPolicyOptions : The CreateIpsecPolicy options.
type CreateIpsecPolicyOptions struct {
	// The authentication algorithm.
	AuthenticationAlgorithm *string `json:"authentication_algorithm" validate:"required"`

	// The encryption algorithm.
	EncryptionAlgorithm *string `json:"encryption_algorithm" validate:"required"`

	// Perfect Forward Secrecy.
	Pfs *string `json:"pfs" validate:"required"`

	// The key lifetime in seconds.
	KeyLifetime *int64 `json:"key_lifetime,omitempty"`

	// The user-defined name for this IPsec policy.
	Name *string `json:"name,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the CreateIpsecPolicyOptions.AuthenticationAlgorithm property.
// The authentication algorithm.
const (
	CreateIpsecPolicyOptionsAuthenticationAlgorithmMd5Const    = "md5"
	CreateIpsecPolicyOptionsAuthenticationAlgorithmSha1Const   = "sha1"
	CreateIpsecPolicyOptionsAuthenticationAlgorithmSha256Const = "sha256"
)

// Constants associated with the CreateIpsecPolicyOptions.EncryptionAlgorithm property.
// The encryption algorithm.
const (
	CreateIpsecPolicyOptionsEncryptionAlgorithmAes128Const    = "aes128"
	CreateIpsecPolicyOptionsEncryptionAlgorithmAes256Const    = "aes256"
	CreateIpsecPolicyOptionsEncryptionAlgorithmTripleDesConst = "triple_des"
)

// Constants associated with the CreateIpsecPolicyOptions.Pfs property.
// Perfect Forward Secrecy.
const (
	CreateIpsecPolicyOptionsPfsDisabledConst = "disabled"
	CreateIpsecPolicyOptionsPfsGroup14Const  = "group_14"
	CreateIpsecPolicyOptionsPfsGroup2Const   = "group_2"
	CreateIpsecPolicyOptionsPfsGroup5Const   = "group_5"
)

// NewCreateIpsecPolicyOptions : Instantiate CreateIpsecPolicyOptions
func (*VpcV1) NewCreateIpsecPolicyOptions(authenticationAlgorithm string, encryptionAlgorithm string, pfs string) *CreateIpsecPolicyOptions {
	return &CreateIpsecPolicyOptions{
		AuthenticationAlgorithm: core.StringPtr(authenticationAlgorithm),
		EncryptionAlgorithm:     core.StringPtr(encryptionAlgorithm),
		Pfs:                     core.StringPtr(pfs),
	}
}

// SetAuthenticationAlgorithm : Allow user to set AuthenticationAlgorithm
func (options *CreateIpsecPolicyOptions) SetAuthenticationAlgorithm(authenticationAlgorithm string) *CreateIpsecPolicyOptions {
	options.AuthenticationAlgorithm = core.StringPtr(authenticationAlgorithm)
	return options
}

// SetEncryptionAlgorithm : Allow user to set EncryptionAlgorithm
func (options *CreateIpsecPolicyOptions) SetEncryptionAlgorithm(encryptionAlgorithm string) *CreateIpsecPolicyOptions {
	options.EncryptionAlgorithm = core.StringPtr(encryptionAlgorithm)
	return options
}

// SetPfs : Allow user to set Pfs
func (options *CreateIpsecPolicyOptions) SetPfs(pfs string) *CreateIpsecPolicyOptions {
	options.Pfs = core.StringPtr(pfs)
	return options
}

// SetKeyLifetime : Allow user to set KeyLifetime
func (options *CreateIpsecPolicyOptions) SetKeyLifetime(keyLifetime int64) *CreateIpsecPolicyOptions {
	options.KeyLifetime = core.Int64Ptr(keyLifetime)
	return options
}

// SetName : Allow user to set Name
func (options *CreateIpsecPolicyOptions) SetName(name string) *CreateIpsecPolicyOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetResourceGroup : Allow user to set ResourceGroup
func (options *CreateIpsecPolicyOptions) SetResourceGroup(resourceGroup ResourceGroupIdentityIntf) *CreateIpsecPolicyOptions {
	options.ResourceGroup = resourceGroup
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateIpsecPolicyOptions) SetHeaders(param map[string]string) *CreateIpsecPolicyOptions {
	options.Headers = param
	return options
}

// CreateKeyOptions : The CreateKey options.
type CreateKeyOptions struct {
	// A unique public SSH key to import, encoded in PEM format. The key (prior to encoding) must be either 2048 or 4096
	// bits long.
	PublicKey *string `json:"public_key" validate:"required"`

	// The unique user-defined name for this key. If unspecified, the name will be a hyphenated list of randomly-selected
	// words.
	Name *string `json:"name,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// The cryptosystem used by this key.
	Type *string `json:"type,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the CreateKeyOptions.Type property.
// The cryptosystem used by this key.
const (
	CreateKeyOptionsTypeRsaConst = "rsa"
)

// NewCreateKeyOptions : Instantiate CreateKeyOptions
func (*VpcV1) NewCreateKeyOptions(publicKey string) *CreateKeyOptions {
	return &CreateKeyOptions{
		PublicKey: core.StringPtr(publicKey),
	}
}

// SetPublicKey : Allow user to set PublicKey
func (options *CreateKeyOptions) SetPublicKey(publicKey string) *CreateKeyOptions {
	options.PublicKey = core.StringPtr(publicKey)
	return options
}

// SetName : Allow user to set Name
func (options *CreateKeyOptions) SetName(name string) *CreateKeyOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetResourceGroup : Allow user to set ResourceGroup
func (options *CreateKeyOptions) SetResourceGroup(resourceGroup ResourceGroupIdentityIntf) *CreateKeyOptions {
	options.ResourceGroup = resourceGroup
	return options
}

// SetType : Allow user to set Type
func (options *CreateKeyOptions) SetType(typeVar string) *CreateKeyOptions {
	options.Type = core.StringPtr(typeVar)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateKeyOptions) SetHeaders(param map[string]string) *CreateKeyOptions {
	options.Headers = param
	return options
}

// CreateLoadBalancerListenerOptions : The CreateLoadBalancerListener options.
type CreateLoadBalancerListenerOptions struct {
	// The load balancer identifier.
	LoadBalancerID *string `json:"load_balancer_id" validate:"required"`

	// The listener port number.
	Port *int64 `json:"port" validate:"required"`

	// The listener protocol. Load balancers in the `network` family support `tcp`. Load balancers in the `application`
	// family support `tcp`, `http`, and `https`.
	Protocol *string `json:"protocol" validate:"required"`

	// The certificate instance used for SSL termination. It is applicable only to `https`
	// protocol.
	CertificateInstance CertificateInstanceIdentityIntf `json:"certificate_instance,omitempty"`

	// The connection limit of the listener.
	ConnectionLimit *int64 `json:"connection_limit,omitempty"`

	// The default pool associated with the listener.
	DefaultPool LoadBalancerPoolIdentityIntf `json:"default_pool,omitempty"`

	// The list of policies of this listener.
	Policies []LoadBalancerListenerPolicyPrototype `json:"policies,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the CreateLoadBalancerListenerOptions.Protocol property.
// The listener protocol. Load balancers in the `network` family support `tcp`. Load balancers in the `application`
// family support `tcp`, `http`, and `https`.
const (
	CreateLoadBalancerListenerOptionsProtocolHTTPConst  = "http"
	CreateLoadBalancerListenerOptionsProtocolHTTPSConst = "https"
	CreateLoadBalancerListenerOptionsProtocolTCPConst   = "tcp"
)

// NewCreateLoadBalancerListenerOptions : Instantiate CreateLoadBalancerListenerOptions
func (*VpcV1) NewCreateLoadBalancerListenerOptions(loadBalancerID string, port int64, protocol string) *CreateLoadBalancerListenerOptions {
	return &CreateLoadBalancerListenerOptions{
		LoadBalancerID: core.StringPtr(loadBalancerID),
		Port:           core.Int64Ptr(port),
		Protocol:       core.StringPtr(protocol),
	}
}

// SetLoadBalancerID : Allow user to set LoadBalancerID
func (options *CreateLoadBalancerListenerOptions) SetLoadBalancerID(loadBalancerID string) *CreateLoadBalancerListenerOptions {
	options.LoadBalancerID = core.StringPtr(loadBalancerID)
	return options
}

// SetPort : Allow user to set Port
func (options *CreateLoadBalancerListenerOptions) SetPort(port int64) *CreateLoadBalancerListenerOptions {
	options.Port = core.Int64Ptr(port)
	return options
}

// SetProtocol : Allow user to set Protocol
func (options *CreateLoadBalancerListenerOptions) SetProtocol(protocol string) *CreateLoadBalancerListenerOptions {
	options.Protocol = core.StringPtr(protocol)
	return options
}

// SetCertificateInstance : Allow user to set CertificateInstance
func (options *CreateLoadBalancerListenerOptions) SetCertificateInstance(certificateInstance CertificateInstanceIdentityIntf) *CreateLoadBalancerListenerOptions {
	options.CertificateInstance = certificateInstance
	return options
}

// SetConnectionLimit : Allow user to set ConnectionLimit
func (options *CreateLoadBalancerListenerOptions) SetConnectionLimit(connectionLimit int64) *CreateLoadBalancerListenerOptions {
	options.ConnectionLimit = core.Int64Ptr(connectionLimit)
	return options
}

// SetDefaultPool : Allow user to set DefaultPool
func (options *CreateLoadBalancerListenerOptions) SetDefaultPool(defaultPool LoadBalancerPoolIdentityIntf) *CreateLoadBalancerListenerOptions {
	options.DefaultPool = defaultPool
	return options
}

// SetPolicies : Allow user to set Policies
func (options *CreateLoadBalancerListenerOptions) SetPolicies(policies []LoadBalancerListenerPolicyPrototype) *CreateLoadBalancerListenerOptions {
	options.Policies = policies
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateLoadBalancerListenerOptions) SetHeaders(param map[string]string) *CreateLoadBalancerListenerOptions {
	options.Headers = param
	return options
}

// CreateLoadBalancerListenerPolicyOptions : The CreateLoadBalancerListenerPolicy options.
type CreateLoadBalancerListenerPolicyOptions struct {
	// The load balancer identifier.
	LoadBalancerID *string `json:"load_balancer_id" validate:"required"`

	// The listener identifier.
	ListenerID *string `json:"listener_id" validate:"required"`

	// The policy action.
	Action *string `json:"action" validate:"required"`

	// Priority of the policy. Lower value indicates higher priority.
	Priority *int64 `json:"priority" validate:"required"`

	// The user-defined name for this policy. Names must be unique within the load balancer listener the policy resides in.
	Name *string `json:"name,omitempty"`

	// The list of rules of this policy.
	Rules []LoadBalancerListenerPolicyRulePrototype `json:"rules,omitempty"`

	// When `action` is `forward`, `LoadBalancerPoolIdentity` is required to specify which
	// pool the load balancer forwards the traffic to. When `action` is `redirect`,
	// `LoadBalancerListenerPolicyRedirectURLPrototype` is required to specify the url and
	// http status code used in the redirect response.
	Target LoadBalancerListenerPolicyPrototypeTargetIntf `json:"target,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the CreateLoadBalancerListenerPolicyOptions.Action property.
// The policy action.
const (
	CreateLoadBalancerListenerPolicyOptionsActionForwardConst  = "forward"
	CreateLoadBalancerListenerPolicyOptionsActionRedirectConst = "redirect"
	CreateLoadBalancerListenerPolicyOptionsActionRejectConst   = "reject"
)

// NewCreateLoadBalancerListenerPolicyOptions : Instantiate CreateLoadBalancerListenerPolicyOptions
func (*VpcV1) NewCreateLoadBalancerListenerPolicyOptions(loadBalancerID string, listenerID string, action string, priority int64) *CreateLoadBalancerListenerPolicyOptions {
	return &CreateLoadBalancerListenerPolicyOptions{
		LoadBalancerID: core.StringPtr(loadBalancerID),
		ListenerID:     core.StringPtr(listenerID),
		Action:         core.StringPtr(action),
		Priority:       core.Int64Ptr(priority),
	}
}

// SetLoadBalancerID : Allow user to set LoadBalancerID
func (options *CreateLoadBalancerListenerPolicyOptions) SetLoadBalancerID(loadBalancerID string) *CreateLoadBalancerListenerPolicyOptions {
	options.LoadBalancerID = core.StringPtr(loadBalancerID)
	return options
}

// SetListenerID : Allow user to set ListenerID
func (options *CreateLoadBalancerListenerPolicyOptions) SetListenerID(listenerID string) *CreateLoadBalancerListenerPolicyOptions {
	options.ListenerID = core.StringPtr(listenerID)
	return options
}

// SetAction : Allow user to set Action
func (options *CreateLoadBalancerListenerPolicyOptions) SetAction(action string) *CreateLoadBalancerListenerPolicyOptions {
	options.Action = core.StringPtr(action)
	return options
}

// SetPriority : Allow user to set Priority
func (options *CreateLoadBalancerListenerPolicyOptions) SetPriority(priority int64) *CreateLoadBalancerListenerPolicyOptions {
	options.Priority = core.Int64Ptr(priority)
	return options
}

// SetName : Allow user to set Name
func (options *CreateLoadBalancerListenerPolicyOptions) SetName(name string) *CreateLoadBalancerListenerPolicyOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetRules : Allow user to set Rules
func (options *CreateLoadBalancerListenerPolicyOptions) SetRules(rules []LoadBalancerListenerPolicyRulePrototype) *CreateLoadBalancerListenerPolicyOptions {
	options.Rules = rules
	return options
}

// SetTarget : Allow user to set Target
func (options *CreateLoadBalancerListenerPolicyOptions) SetTarget(target LoadBalancerListenerPolicyPrototypeTargetIntf) *CreateLoadBalancerListenerPolicyOptions {
	options.Target = target
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateLoadBalancerListenerPolicyOptions) SetHeaders(param map[string]string) *CreateLoadBalancerListenerPolicyOptions {
	options.Headers = param
	return options
}

// CreateLoadBalancerListenerPolicyRuleOptions : The CreateLoadBalancerListenerPolicyRule options.
type CreateLoadBalancerListenerPolicyRuleOptions struct {
	// The load balancer identifier.
	LoadBalancerID *string `json:"load_balancer_id" validate:"required"`

	// The listener identifier.
	ListenerID *string `json:"listener_id" validate:"required"`

	// The policy identifier.
	PolicyID *string `json:"policy_id" validate:"required"`

	// The condition of the rule.
	Condition *string `json:"condition" validate:"required"`

	// The type of the rule.
	Type *string `json:"type" validate:"required"`

	// Value to be matched for rule condition.
	Value *string `json:"value" validate:"required"`

	// HTTP header field. This is only applicable to "header" rule type.
	Field *string `json:"field,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the CreateLoadBalancerListenerPolicyRuleOptions.Condition property.
// The condition of the rule.
const (
	CreateLoadBalancerListenerPolicyRuleOptionsConditionContainsConst     = "contains"
	CreateLoadBalancerListenerPolicyRuleOptionsConditionEqualsConst       = "equals"
	CreateLoadBalancerListenerPolicyRuleOptionsConditionMatchesRegexConst = "matches_regex"
)

// Constants associated with the CreateLoadBalancerListenerPolicyRuleOptions.Type property.
// The type of the rule.
const (
	CreateLoadBalancerListenerPolicyRuleOptionsTypeHeaderConst   = "header"
	CreateLoadBalancerListenerPolicyRuleOptionsTypeHostnameConst = "hostname"
	CreateLoadBalancerListenerPolicyRuleOptionsTypePathConst     = "path"
)

// NewCreateLoadBalancerListenerPolicyRuleOptions : Instantiate CreateLoadBalancerListenerPolicyRuleOptions
func (*VpcV1) NewCreateLoadBalancerListenerPolicyRuleOptions(loadBalancerID string, listenerID string, policyID string, condition string, typeVar string, value string) *CreateLoadBalancerListenerPolicyRuleOptions {
	return &CreateLoadBalancerListenerPolicyRuleOptions{
		LoadBalancerID: core.StringPtr(loadBalancerID),
		ListenerID:     core.StringPtr(listenerID),
		PolicyID:       core.StringPtr(policyID),
		Condition:      core.StringPtr(condition),
		Type:           core.StringPtr(typeVar),
		Value:          core.StringPtr(value),
	}
}

// SetLoadBalancerID : Allow user to set LoadBalancerID
func (options *CreateLoadBalancerListenerPolicyRuleOptions) SetLoadBalancerID(loadBalancerID string) *CreateLoadBalancerListenerPolicyRuleOptions {
	options.LoadBalancerID = core.StringPtr(loadBalancerID)
	return options
}

// SetListenerID : Allow user to set ListenerID
func (options *CreateLoadBalancerListenerPolicyRuleOptions) SetListenerID(listenerID string) *CreateLoadBalancerListenerPolicyRuleOptions {
	options.ListenerID = core.StringPtr(listenerID)
	return options
}

// SetPolicyID : Allow user to set PolicyID
func (options *CreateLoadBalancerListenerPolicyRuleOptions) SetPolicyID(policyID string) *CreateLoadBalancerListenerPolicyRuleOptions {
	options.PolicyID = core.StringPtr(policyID)
	return options
}

// SetCondition : Allow user to set Condition
func (options *CreateLoadBalancerListenerPolicyRuleOptions) SetCondition(condition string) *CreateLoadBalancerListenerPolicyRuleOptions {
	options.Condition = core.StringPtr(condition)
	return options
}

// SetType : Allow user to set Type
func (options *CreateLoadBalancerListenerPolicyRuleOptions) SetType(typeVar string) *CreateLoadBalancerListenerPolicyRuleOptions {
	options.Type = core.StringPtr(typeVar)
	return options
}

// SetValue : Allow user to set Value
func (options *CreateLoadBalancerListenerPolicyRuleOptions) SetValue(value string) *CreateLoadBalancerListenerPolicyRuleOptions {
	options.Value = core.StringPtr(value)
	return options
}

// SetField : Allow user to set Field
func (options *CreateLoadBalancerListenerPolicyRuleOptions) SetField(field string) *CreateLoadBalancerListenerPolicyRuleOptions {
	options.Field = core.StringPtr(field)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateLoadBalancerListenerPolicyRuleOptions) SetHeaders(param map[string]string) *CreateLoadBalancerListenerPolicyRuleOptions {
	options.Headers = param
	return options
}

// CreateLoadBalancerOptions : The CreateLoadBalancer options.
type CreateLoadBalancerOptions struct {
	// The type of this load balancer, public or private.
	IsPublic *bool `json:"is_public" validate:"required"`

	// The subnets to provision this load balancer.
	Subnets []SubnetIdentityIntf `json:"subnets" validate:"required"`

	// The listeners of this load balancer.
	Listeners []LoadBalancerListenerPrototypeLoadBalancerContext `json:"listeners,omitempty"`

	// The user-defined name for this load balancer. If unspecified, the name will be a hyphenated list of
	// randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The pools of this load balancer.
	Pools []LoadBalancerPoolPrototype `json:"pools,omitempty"`

	// The profile to use for this load balancer.
	Profile LoadBalancerProfileIdentityIntf `json:"profile,omitempty"`

	// The resource group for this load balancer.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateLoadBalancerOptions : Instantiate CreateLoadBalancerOptions
func (*VpcV1) NewCreateLoadBalancerOptions(isPublic bool, subnets []SubnetIdentityIntf) *CreateLoadBalancerOptions {
	return &CreateLoadBalancerOptions{
		IsPublic: core.BoolPtr(isPublic),
		Subnets:  subnets,
	}
}

// SetIsPublic : Allow user to set IsPublic
func (options *CreateLoadBalancerOptions) SetIsPublic(isPublic bool) *CreateLoadBalancerOptions {
	options.IsPublic = core.BoolPtr(isPublic)
	return options
}

// SetSubnets : Allow user to set Subnets
func (options *CreateLoadBalancerOptions) SetSubnets(subnets []SubnetIdentityIntf) *CreateLoadBalancerOptions {
	options.Subnets = subnets
	return options
}

// SetListeners : Allow user to set Listeners
func (options *CreateLoadBalancerOptions) SetListeners(listeners []LoadBalancerListenerPrototypeLoadBalancerContext) *CreateLoadBalancerOptions {
	options.Listeners = listeners
	return options
}

// SetName : Allow user to set Name
func (options *CreateLoadBalancerOptions) SetName(name string) *CreateLoadBalancerOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetPools : Allow user to set Pools
func (options *CreateLoadBalancerOptions) SetPools(pools []LoadBalancerPoolPrototype) *CreateLoadBalancerOptions {
	options.Pools = pools
	return options
}

// SetProfile : Allow user to set Profile
func (options *CreateLoadBalancerOptions) SetProfile(profile LoadBalancerProfileIdentityIntf) *CreateLoadBalancerOptions {
	options.Profile = profile
	return options
}

// SetResourceGroup : Allow user to set ResourceGroup
func (options *CreateLoadBalancerOptions) SetResourceGroup(resourceGroup ResourceGroupIdentityIntf) *CreateLoadBalancerOptions {
	options.ResourceGroup = resourceGroup
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateLoadBalancerOptions) SetHeaders(param map[string]string) *CreateLoadBalancerOptions {
	options.Headers = param
	return options
}

// CreateLoadBalancerPoolMemberOptions : The CreateLoadBalancerPoolMember options.
type CreateLoadBalancerPoolMemberOptions struct {
	// The load balancer identifier.
	LoadBalancerID *string `json:"load_balancer_id" validate:"required"`

	// The pool identifier.
	PoolID *string `json:"pool_id" validate:"required"`

	// The port number of the application running in the server member.
	Port *int64 `json:"port" validate:"required"`

	// The pool member target. Load balancers in the `network` family
	// support instances. Load balancers in the `application` family support
	// IP addresses.
	Target LoadBalancerPoolMemberTargetPrototypeIntf `json:"target" validate:"required"`

	// Weight of the server member. This takes effect only when the load balancing algorithm of its belonging pool is
	// `weighted_round_robin`.
	Weight *int64 `json:"weight,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateLoadBalancerPoolMemberOptions : Instantiate CreateLoadBalancerPoolMemberOptions
func (*VpcV1) NewCreateLoadBalancerPoolMemberOptions(loadBalancerID string, poolID string, port int64, target LoadBalancerPoolMemberTargetPrototypeIntf) *CreateLoadBalancerPoolMemberOptions {
	return &CreateLoadBalancerPoolMemberOptions{
		LoadBalancerID: core.StringPtr(loadBalancerID),
		PoolID:         core.StringPtr(poolID),
		Port:           core.Int64Ptr(port),
		Target:         target,
	}
}

// SetLoadBalancerID : Allow user to set LoadBalancerID
func (options *CreateLoadBalancerPoolMemberOptions) SetLoadBalancerID(loadBalancerID string) *CreateLoadBalancerPoolMemberOptions {
	options.LoadBalancerID = core.StringPtr(loadBalancerID)
	return options
}

// SetPoolID : Allow user to set PoolID
func (options *CreateLoadBalancerPoolMemberOptions) SetPoolID(poolID string) *CreateLoadBalancerPoolMemberOptions {
	options.PoolID = core.StringPtr(poolID)
	return options
}

// SetPort : Allow user to set Port
func (options *CreateLoadBalancerPoolMemberOptions) SetPort(port int64) *CreateLoadBalancerPoolMemberOptions {
	options.Port = core.Int64Ptr(port)
	return options
}

// SetTarget : Allow user to set Target
func (options *CreateLoadBalancerPoolMemberOptions) SetTarget(target LoadBalancerPoolMemberTargetPrototypeIntf) *CreateLoadBalancerPoolMemberOptions {
	options.Target = target
	return options
}

// SetWeight : Allow user to set Weight
func (options *CreateLoadBalancerPoolMemberOptions) SetWeight(weight int64) *CreateLoadBalancerPoolMemberOptions {
	options.Weight = core.Int64Ptr(weight)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateLoadBalancerPoolMemberOptions) SetHeaders(param map[string]string) *CreateLoadBalancerPoolMemberOptions {
	options.Headers = param
	return options
}

// CreateLoadBalancerPoolOptions : The CreateLoadBalancerPool options.
type CreateLoadBalancerPoolOptions struct {
	// The load balancer identifier.
	LoadBalancerID *string `json:"load_balancer_id" validate:"required"`

	// The load balancing algorithm.
	Algorithm *string `json:"algorithm" validate:"required"`

	// The health monitor of this pool.
	HealthMonitor *LoadBalancerPoolHealthMonitorPrototype `json:"health_monitor" validate:"required"`

	// The protocol used for this load balancer pool.
	//
	// The enumerated values for this property are expected to expand in the future. When processing this property, check
	// for and log unknown values. Optionally halt processing and surface the error, or bypass the pool on which the
	// unexpected property value was encountered.
	Protocol *string `json:"protocol" validate:"required"`

	// The members for this load balancer pool. For load balancers in the `network` family, the same `port` and `target`
	// tuple cannot be shared by a member of any other load balancer.
	Members []LoadBalancerPoolMemberPrototype `json:"members,omitempty"`

	// The user-defined name for this load balancer pool. If unspecified, the name will be a hyphenated list of
	// randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The session persistence of this pool.
	SessionPersistence *LoadBalancerPoolSessionPersistencePrototype `json:"session_persistence,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the CreateLoadBalancerPoolOptions.Algorithm property.
// The load balancing algorithm.
const (
	CreateLoadBalancerPoolOptionsAlgorithmLeastConnectionsConst   = "least_connections"
	CreateLoadBalancerPoolOptionsAlgorithmRoundRobinConst         = "round_robin"
	CreateLoadBalancerPoolOptionsAlgorithmWeightedRoundRobinConst = "weighted_round_robin"
)

// Constants associated with the CreateLoadBalancerPoolOptions.Protocol property.
// The protocol used for this load balancer pool.
//
// The enumerated values for this property are expected to expand in the future. When processing this property, check
// for and log unknown values. Optionally halt processing and surface the error, or bypass the pool on which the
// unexpected property value was encountered.
const (
	CreateLoadBalancerPoolOptionsProtocolHTTPConst  = "http"
	CreateLoadBalancerPoolOptionsProtocolHTTPSConst = "https"
	CreateLoadBalancerPoolOptionsProtocolTCPConst   = "tcp"
)

// NewCreateLoadBalancerPoolOptions : Instantiate CreateLoadBalancerPoolOptions
func (*VpcV1) NewCreateLoadBalancerPoolOptions(loadBalancerID string, algorithm string, healthMonitor *LoadBalancerPoolHealthMonitorPrototype, protocol string) *CreateLoadBalancerPoolOptions {
	return &CreateLoadBalancerPoolOptions{
		LoadBalancerID: core.StringPtr(loadBalancerID),
		Algorithm:      core.StringPtr(algorithm),
		HealthMonitor:  healthMonitor,
		Protocol:       core.StringPtr(protocol),
	}
}

// SetLoadBalancerID : Allow user to set LoadBalancerID
func (options *CreateLoadBalancerPoolOptions) SetLoadBalancerID(loadBalancerID string) *CreateLoadBalancerPoolOptions {
	options.LoadBalancerID = core.StringPtr(loadBalancerID)
	return options
}

// SetAlgorithm : Allow user to set Algorithm
func (options *CreateLoadBalancerPoolOptions) SetAlgorithm(algorithm string) *CreateLoadBalancerPoolOptions {
	options.Algorithm = core.StringPtr(algorithm)
	return options
}

// SetHealthMonitor : Allow user to set HealthMonitor
func (options *CreateLoadBalancerPoolOptions) SetHealthMonitor(healthMonitor *LoadBalancerPoolHealthMonitorPrototype) *CreateLoadBalancerPoolOptions {
	options.HealthMonitor = healthMonitor
	return options
}

// SetProtocol : Allow user to set Protocol
func (options *CreateLoadBalancerPoolOptions) SetProtocol(protocol string) *CreateLoadBalancerPoolOptions {
	options.Protocol = core.StringPtr(protocol)
	return options
}

// SetMembers : Allow user to set Members
func (options *CreateLoadBalancerPoolOptions) SetMembers(members []LoadBalancerPoolMemberPrototype) *CreateLoadBalancerPoolOptions {
	options.Members = members
	return options
}

// SetName : Allow user to set Name
func (options *CreateLoadBalancerPoolOptions) SetName(name string) *CreateLoadBalancerPoolOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetSessionPersistence : Allow user to set SessionPersistence
func (options *CreateLoadBalancerPoolOptions) SetSessionPersistence(sessionPersistence *LoadBalancerPoolSessionPersistencePrototype) *CreateLoadBalancerPoolOptions {
	options.SessionPersistence = sessionPersistence
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateLoadBalancerPoolOptions) SetHeaders(param map[string]string) *CreateLoadBalancerPoolOptions {
	options.Headers = param
	return options
}

// CreateNetworkACLOptions : The CreateNetworkACL options.
type CreateNetworkACLOptions struct {
	// The network ACL prototype object.
	NetworkACLPrototype NetworkACLPrototypeIntf `json:"NetworkACLPrototype,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateNetworkACLOptions : Instantiate CreateNetworkACLOptions
func (*VpcV1) NewCreateNetworkACLOptions() *CreateNetworkACLOptions {
	return &CreateNetworkACLOptions{}
}

// SetNetworkACLPrototype : Allow user to set NetworkACLPrototype
func (options *CreateNetworkACLOptions) SetNetworkACLPrototype(networkACLPrototype NetworkACLPrototypeIntf) *CreateNetworkACLOptions {
	options.NetworkACLPrototype = networkACLPrototype
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateNetworkACLOptions) SetHeaders(param map[string]string) *CreateNetworkACLOptions {
	options.Headers = param
	return options
}

// CreateNetworkACLRuleOptions : The CreateNetworkACLRule options.
type CreateNetworkACLRuleOptions struct {
	// The network ACL identifier.
	NetworkACLID *string `json:"network_acl_id" validate:"required"`

	// The network ACL rule prototype object.
	NetworkACLRulePrototype NetworkACLRulePrototypeIntf `json:"NetworkACLRulePrototype" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateNetworkACLRuleOptions : Instantiate CreateNetworkACLRuleOptions
func (*VpcV1) NewCreateNetworkACLRuleOptions(networkACLID string, networkACLRulePrototype NetworkACLRulePrototypeIntf) *CreateNetworkACLRuleOptions {
	return &CreateNetworkACLRuleOptions{
		NetworkACLID:            core.StringPtr(networkACLID),
		NetworkACLRulePrototype: networkACLRulePrototype,
	}
}

// SetNetworkACLID : Allow user to set NetworkACLID
func (options *CreateNetworkACLRuleOptions) SetNetworkACLID(networkACLID string) *CreateNetworkACLRuleOptions {
	options.NetworkACLID = core.StringPtr(networkACLID)
	return options
}

// SetNetworkACLRulePrototype : Allow user to set NetworkACLRulePrototype
func (options *CreateNetworkACLRuleOptions) SetNetworkACLRulePrototype(networkACLRulePrototype NetworkACLRulePrototypeIntf) *CreateNetworkACLRuleOptions {
	options.NetworkACLRulePrototype = networkACLRulePrototype
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateNetworkACLRuleOptions) SetHeaders(param map[string]string) *CreateNetworkACLRuleOptions {
	options.Headers = param
	return options
}

// CreatePublicGatewayOptions : The CreatePublicGateway options.
type CreatePublicGatewayOptions struct {
	// The VPC this public gateway will serve.
	VPC VPCIdentityIntf `json:"vpc" validate:"required"`

	// The zone where this public gateway will be created.
	Zone ZoneIdentityIntf `json:"zone" validate:"required"`

	FloatingIP PublicGatewayPrototypeFloatingIPIntf `json:"floating_ip,omitempty"`

	// The user-defined name for this public gateway. Names must be unique within the VPC the public gateway resides in. If
	// unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreatePublicGatewayOptions : Instantiate CreatePublicGatewayOptions
func (*VpcV1) NewCreatePublicGatewayOptions(vpc VPCIdentityIntf, zone ZoneIdentityIntf) *CreatePublicGatewayOptions {
	return &CreatePublicGatewayOptions{
		VPC:  vpc,
		Zone: zone,
	}
}

// SetVPC : Allow user to set VPC
func (options *CreatePublicGatewayOptions) SetVPC(vpc VPCIdentityIntf) *CreatePublicGatewayOptions {
	options.VPC = vpc
	return options
}

// SetZone : Allow user to set Zone
func (options *CreatePublicGatewayOptions) SetZone(zone ZoneIdentityIntf) *CreatePublicGatewayOptions {
	options.Zone = zone
	return options
}

// SetFloatingIP : Allow user to set FloatingIP
func (options *CreatePublicGatewayOptions) SetFloatingIP(floatingIP PublicGatewayPrototypeFloatingIPIntf) *CreatePublicGatewayOptions {
	options.FloatingIP = floatingIP
	return options
}

// SetName : Allow user to set Name
func (options *CreatePublicGatewayOptions) SetName(name string) *CreatePublicGatewayOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetResourceGroup : Allow user to set ResourceGroup
func (options *CreatePublicGatewayOptions) SetResourceGroup(resourceGroup ResourceGroupIdentityIntf) *CreatePublicGatewayOptions {
	options.ResourceGroup = resourceGroup
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreatePublicGatewayOptions) SetHeaders(param map[string]string) *CreatePublicGatewayOptions {
	options.Headers = param
	return options
}

// CreateSecurityGroupOptions : The CreateSecurityGroup options.
type CreateSecurityGroupOptions struct {
	// The VPC this security group is to be a part of.
	VPC VPCIdentityIntf `json:"vpc" validate:"required"`

	// The user-defined name for this security group. If unspecified, the name will be a hyphenated list of
	// randomly-selected words. Names must be unique within the VPC the security group resides in.
	Name *string `json:"name,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// Array of rule prototype objects for rules to be created for this security group. If unspecified, no rules will be
	// created, resulting in all traffic being denied.
	Rules []SecurityGroupRulePrototypeIntf `json:"rules,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateSecurityGroupOptions : Instantiate CreateSecurityGroupOptions
func (*VpcV1) NewCreateSecurityGroupOptions(vpc VPCIdentityIntf) *CreateSecurityGroupOptions {
	return &CreateSecurityGroupOptions{
		VPC: vpc,
	}
}

// SetVPC : Allow user to set VPC
func (options *CreateSecurityGroupOptions) SetVPC(vpc VPCIdentityIntf) *CreateSecurityGroupOptions {
	options.VPC = vpc
	return options
}

// SetName : Allow user to set Name
func (options *CreateSecurityGroupOptions) SetName(name string) *CreateSecurityGroupOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetResourceGroup : Allow user to set ResourceGroup
func (options *CreateSecurityGroupOptions) SetResourceGroup(resourceGroup ResourceGroupIdentityIntf) *CreateSecurityGroupOptions {
	options.ResourceGroup = resourceGroup
	return options
}

// SetRules : Allow user to set Rules
func (options *CreateSecurityGroupOptions) SetRules(rules []SecurityGroupRulePrototypeIntf) *CreateSecurityGroupOptions {
	options.Rules = rules
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateSecurityGroupOptions) SetHeaders(param map[string]string) *CreateSecurityGroupOptions {
	options.Headers = param
	return options
}

// CreateSecurityGroupRuleOptions : The CreateSecurityGroupRule options.
type CreateSecurityGroupRuleOptions struct {
	// The security group identifier.
	SecurityGroupID *string `json:"security_group_id" validate:"required"`

	// The properties of the security group rule to be created.
	SecurityGroupRulePrototype SecurityGroupRulePrototypeIntf `json:"SecurityGroupRulePrototype" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateSecurityGroupRuleOptions : Instantiate CreateSecurityGroupRuleOptions
func (*VpcV1) NewCreateSecurityGroupRuleOptions(securityGroupID string, securityGroupRulePrototype SecurityGroupRulePrototypeIntf) *CreateSecurityGroupRuleOptions {
	return &CreateSecurityGroupRuleOptions{
		SecurityGroupID:            core.StringPtr(securityGroupID),
		SecurityGroupRulePrototype: securityGroupRulePrototype,
	}
}

// SetSecurityGroupID : Allow user to set SecurityGroupID
func (options *CreateSecurityGroupRuleOptions) SetSecurityGroupID(securityGroupID string) *CreateSecurityGroupRuleOptions {
	options.SecurityGroupID = core.StringPtr(securityGroupID)
	return options
}

// SetSecurityGroupRulePrototype : Allow user to set SecurityGroupRulePrototype
func (options *CreateSecurityGroupRuleOptions) SetSecurityGroupRulePrototype(securityGroupRulePrototype SecurityGroupRulePrototypeIntf) *CreateSecurityGroupRuleOptions {
	options.SecurityGroupRulePrototype = securityGroupRulePrototype
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateSecurityGroupRuleOptions) SetHeaders(param map[string]string) *CreateSecurityGroupRuleOptions {
	options.Headers = param
	return options
}

// CreateSubnetOptions : The CreateSubnet options.
type CreateSubnetOptions struct {
	// The subnet prototype object.
	SubnetPrototype SubnetPrototypeIntf `json:"SubnetPrototype" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateSubnetOptions : Instantiate CreateSubnetOptions
func (*VpcV1) NewCreateSubnetOptions(subnetPrototype SubnetPrototypeIntf) *CreateSubnetOptions {
	return &CreateSubnetOptions{
		SubnetPrototype: subnetPrototype,
	}
}

// SetSubnetPrototype : Allow user to set SubnetPrototype
func (options *CreateSubnetOptions) SetSubnetPrototype(subnetPrototype SubnetPrototypeIntf) *CreateSubnetOptions {
	options.SubnetPrototype = subnetPrototype
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateSubnetOptions) SetHeaders(param map[string]string) *CreateSubnetOptions {
	options.Headers = param
	return options
}

// CreateVolumeOptions : The CreateVolume options.
type CreateVolumeOptions struct {
	// The volume prototype object.
	VolumePrototype VolumePrototypeIntf `json:"VolumePrototype" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateVolumeOptions : Instantiate CreateVolumeOptions
func (*VpcV1) NewCreateVolumeOptions(volumePrototype VolumePrototypeIntf) *CreateVolumeOptions {
	return &CreateVolumeOptions{
		VolumePrototype: volumePrototype,
	}
}

// SetVolumePrototype : Allow user to set VolumePrototype
func (options *CreateVolumeOptions) SetVolumePrototype(volumePrototype VolumePrototypeIntf) *CreateVolumeOptions {
	options.VolumePrototype = volumePrototype
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateVolumeOptions) SetHeaders(param map[string]string) *CreateVolumeOptions {
	options.Headers = param
	return options
}

// CreateVPCAddressPrefixOptions : The CreateVPCAddressPrefix options.
type CreateVPCAddressPrefixOptions struct {
	// The VPC identifier.
	VPCID *string `json:"vpc_id" validate:"required"`

	// The IPv4 range of the address prefix, expressed in CIDR format. The request must not overlap with any existing
	// address prefixes in the VPC, and must fall within the [RFC 1918](https://tools.ietf.org/html/rfc1918) address
	// ranges. The prefix length of the address prefix's CIDR must be between `/8` (16,777,216 addresses) and `/29` (8
	// addresses).
	CIDR *string `json:"cidr" validate:"required"`

	// The zone this address prefix is to belong to.
	Zone ZoneIdentityIntf `json:"zone" validate:"required"`

	// Indicates whether this is the default prefix for this zone in this VPC. If true, this prefix will become the default
	// prefix for this zone in this VPC. This fails if the VPC currently has a default address prefix for this zone.
	IsDefault *bool `json:"is_default,omitempty"`

	// The user-defined name for this address prefix. Names must be unique within the VPC the address prefix resides in. If
	// unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateVPCAddressPrefixOptions : Instantiate CreateVPCAddressPrefixOptions
func (*VpcV1) NewCreateVPCAddressPrefixOptions(vpcID string, cidr string, zone ZoneIdentityIntf) *CreateVPCAddressPrefixOptions {
	return &CreateVPCAddressPrefixOptions{
		VPCID: core.StringPtr(vpcID),
		CIDR:  core.StringPtr(cidr),
		Zone:  zone,
	}
}

// SetVPCID : Allow user to set VPCID
func (options *CreateVPCAddressPrefixOptions) SetVPCID(vpcID string) *CreateVPCAddressPrefixOptions {
	options.VPCID = core.StringPtr(vpcID)
	return options
}

// SetCIDR : Allow user to set CIDR
func (options *CreateVPCAddressPrefixOptions) SetCIDR(cidr string) *CreateVPCAddressPrefixOptions {
	options.CIDR = core.StringPtr(cidr)
	return options
}

// SetZone : Allow user to set Zone
func (options *CreateVPCAddressPrefixOptions) SetZone(zone ZoneIdentityIntf) *CreateVPCAddressPrefixOptions {
	options.Zone = zone
	return options
}

// SetIsDefault : Allow user to set IsDefault
func (options *CreateVPCAddressPrefixOptions) SetIsDefault(isDefault bool) *CreateVPCAddressPrefixOptions {
	options.IsDefault = core.BoolPtr(isDefault)
	return options
}

// SetName : Allow user to set Name
func (options *CreateVPCAddressPrefixOptions) SetName(name string) *CreateVPCAddressPrefixOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateVPCAddressPrefixOptions) SetHeaders(param map[string]string) *CreateVPCAddressPrefixOptions {
	options.Headers = param
	return options
}

// CreateVPCOptions : The CreateVPC options.
type CreateVPCOptions struct {
	// Indicates whether a default address prefix should be automatically created for each zone in this VPC. If `manual`,
	// this VPC will be created with no default address prefixes.
	AddressPrefixManagement *string `json:"address_prefix_management,omitempty"`

	// Indicates whether this VPC should be connected to Classic Infrastructure. If true, this VPC's resources will have
	// private network connectivity to the account's Classic Infrastructure resources. Only one VPC, per region, may be
	// connected in this way. This value is set at creation and subsequently immutable.
	ClassicAccess *bool `json:"classic_access,omitempty"`

	// The unique user-defined name for this VPC. If unspecified, the name will be a hyphenated list of randomly-selected
	// words.
	Name *string `json:"name,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the CreateVPCOptions.AddressPrefixManagement property.
// Indicates whether a default address prefix should be automatically created for each zone in this VPC. If `manual`,
// this VPC will be created with no default address prefixes.
const (
	CreateVPCOptionsAddressPrefixManagementAutoConst   = "auto"
	CreateVPCOptionsAddressPrefixManagementManualConst = "manual"
)

// NewCreateVPCOptions : Instantiate CreateVPCOptions
func (*VpcV1) NewCreateVPCOptions() *CreateVPCOptions {
	return &CreateVPCOptions{}
}

// SetAddressPrefixManagement : Allow user to set AddressPrefixManagement
func (options *CreateVPCOptions) SetAddressPrefixManagement(addressPrefixManagement string) *CreateVPCOptions {
	options.AddressPrefixManagement = core.StringPtr(addressPrefixManagement)
	return options
}

// SetClassicAccess : Allow user to set ClassicAccess
func (options *CreateVPCOptions) SetClassicAccess(classicAccess bool) *CreateVPCOptions {
	options.ClassicAccess = core.BoolPtr(classicAccess)
	return options
}

// SetName : Allow user to set Name
func (options *CreateVPCOptions) SetName(name string) *CreateVPCOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetResourceGroup : Allow user to set ResourceGroup
func (options *CreateVPCOptions) SetResourceGroup(resourceGroup ResourceGroupIdentityIntf) *CreateVPCOptions {
	options.ResourceGroup = resourceGroup
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateVPCOptions) SetHeaders(param map[string]string) *CreateVPCOptions {
	options.Headers = param
	return options
}

// CreateVPCRouteOptions : The CreateVPCRoute options.
type CreateVPCRouteOptions struct {
	// The VPC identifier.
	VPCID *string `json:"vpc_id" validate:"required"`

	// The destination of the route. At most two routes per `zone` in a table can have the same destination, and only if
	// both routes have an `action` of `deliver`.
	Destination *string `json:"destination" validate:"required"`

	// The zone to apply the route to. (Traffic from subnets in this zone will be
	// subject to this route.).
	Zone ZoneIdentityIntf `json:"zone" validate:"required"`

	// The action to perform with a packet matching the route:
	// - `delegate`: delegate to the system's built-in routes
	// - `deliver`: deliver the packet to the specified `next_hop`
	// - `drop`: drop the packet.
	Action *string `json:"action,omitempty"`

	// The user-defined name for this route. If unspecified, the name will be a hyphenated list of randomly-selected words.
	// Names must be unique within the VPC routing table the route resides in.
	Name *string `json:"name,omitempty"`

	// If `action` is `deliver`, the next hop that packets will be delivered to.  For
	// other `action` values, its `address` will be `0.0.0.0`.
	NextHop RouteNextHopPrototypeIntf `json:"next_hop,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the CreateVPCRouteOptions.Action property.
// The action to perform with a packet matching the route:
// - `delegate`: delegate to the system's built-in routes
// - `deliver`: deliver the packet to the specified `next_hop`
// - `drop`: drop the packet.
const (
	CreateVPCRouteOptionsActionDelegateConst = "delegate"
	CreateVPCRouteOptionsActionDeliverConst  = "deliver"
	CreateVPCRouteOptionsActionDropConst     = "drop"
)

// NewCreateVPCRouteOptions : Instantiate CreateVPCRouteOptions
func (*VpcV1) NewCreateVPCRouteOptions(vpcID string, destination string, zone ZoneIdentityIntf) *CreateVPCRouteOptions {
	return &CreateVPCRouteOptions{
		VPCID:       core.StringPtr(vpcID),
		Destination: core.StringPtr(destination),
		Zone:        zone,
	}
}

// SetVPCID : Allow user to set VPCID
func (options *CreateVPCRouteOptions) SetVPCID(vpcID string) *CreateVPCRouteOptions {
	options.VPCID = core.StringPtr(vpcID)
	return options
}

// SetDestination : Allow user to set Destination
func (options *CreateVPCRouteOptions) SetDestination(destination string) *CreateVPCRouteOptions {
	options.Destination = core.StringPtr(destination)
	return options
}

// SetZone : Allow user to set Zone
func (options *CreateVPCRouteOptions) SetZone(zone ZoneIdentityIntf) *CreateVPCRouteOptions {
	options.Zone = zone
	return options
}

// SetAction : Allow user to set Action
func (options *CreateVPCRouteOptions) SetAction(action string) *CreateVPCRouteOptions {
	options.Action = core.StringPtr(action)
	return options
}

// SetName : Allow user to set Name
func (options *CreateVPCRouteOptions) SetName(name string) *CreateVPCRouteOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetNextHop : Allow user to set NextHop
func (options *CreateVPCRouteOptions) SetNextHop(nextHop RouteNextHopPrototypeIntf) *CreateVPCRouteOptions {
	options.NextHop = nextHop
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateVPCRouteOptions) SetHeaders(param map[string]string) *CreateVPCRouteOptions {
	options.Headers = param
	return options
}

// CreateVPCRoutingTableOptions : The CreateVPCRoutingTable options.
type CreateVPCRoutingTableOptions struct {
	// The VPC identifier.
	VPCID *string `json:"vpc_id" validate:"required"`

	// The user-defined name for this routing table. Names must be unique within the VPC the routing table resides in. If
	// unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// Array of route prototype objects for routes to create for this routing table. If unspecified, the routing table will
	// be created with no routes.
	Routes []RoutePrototype `json:"routes,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateVPCRoutingTableOptions : Instantiate CreateVPCRoutingTableOptions
func (*VpcV1) NewCreateVPCRoutingTableOptions(vpcID string) *CreateVPCRoutingTableOptions {
	return &CreateVPCRoutingTableOptions{
		VPCID: core.StringPtr(vpcID),
	}
}

// SetVPCID : Allow user to set VPCID
func (options *CreateVPCRoutingTableOptions) SetVPCID(vpcID string) *CreateVPCRoutingTableOptions {
	options.VPCID = core.StringPtr(vpcID)
	return options
}

// SetName : Allow user to set Name
func (options *CreateVPCRoutingTableOptions) SetName(name string) *CreateVPCRoutingTableOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetRoutes : Allow user to set Routes
func (options *CreateVPCRoutingTableOptions) SetRoutes(routes []RoutePrototype) *CreateVPCRoutingTableOptions {
	options.Routes = routes
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateVPCRoutingTableOptions) SetHeaders(param map[string]string) *CreateVPCRoutingTableOptions {
	options.Headers = param
	return options
}

// CreateVPCRoutingTableRouteOptions : The CreateVPCRoutingTableRoute options.
type CreateVPCRoutingTableRouteOptions struct {
	// The VPC identifier.
	VPCID *string `json:"vpc_id" validate:"required"`

	// The routing table identifier.
	RoutingTableID *string `json:"routing_table_id" validate:"required"`

	// The destination of the route. At most two routes per `zone` in a table can have the same destination, and only if
	// both routes have an `action` of `deliver`.
	Destination *string `json:"destination" validate:"required"`

	// The zone to apply the route to. (Traffic from subnets in this zone will be
	// subject to this route.).
	Zone ZoneIdentityIntf `json:"zone" validate:"required"`

	// The action to perform with a packet matching the route:
	// - `delegate`: delegate to the system's built-in routes
	// - `deliver`: deliver the packet to the specified `next_hop`
	// - `drop`: drop the packet.
	Action *string `json:"action,omitempty"`

	// The user-defined name for this route. If unspecified, the name will be a hyphenated list of randomly-selected words.
	// Names must be unique within the VPC routing table the route resides in.
	Name *string `json:"name,omitempty"`

	// If `action` is `deliver`, the next hop that packets will be delivered to.  For
	// other `action` values, its `address` will be `0.0.0.0`.
	NextHop RouteNextHopPrototypeIntf `json:"next_hop,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the CreateVPCRoutingTableRouteOptions.Action property.
// The action to perform with a packet matching the route:
// - `delegate`: delegate to the system's built-in routes
// - `deliver`: deliver the packet to the specified `next_hop`
// - `drop`: drop the packet.
const (
	CreateVPCRoutingTableRouteOptionsActionDelegateConst = "delegate"
	CreateVPCRoutingTableRouteOptionsActionDeliverConst  = "deliver"
	CreateVPCRoutingTableRouteOptionsActionDropConst     = "drop"
)

// NewCreateVPCRoutingTableRouteOptions : Instantiate CreateVPCRoutingTableRouteOptions
func (*VpcV1) NewCreateVPCRoutingTableRouteOptions(vpcID string, routingTableID string, destination string, zone ZoneIdentityIntf) *CreateVPCRoutingTableRouteOptions {
	return &CreateVPCRoutingTableRouteOptions{
		VPCID:          core.StringPtr(vpcID),
		RoutingTableID: core.StringPtr(routingTableID),
		Destination:    core.StringPtr(destination),
		Zone:           zone,
	}
}

// SetVPCID : Allow user to set VPCID
func (options *CreateVPCRoutingTableRouteOptions) SetVPCID(vpcID string) *CreateVPCRoutingTableRouteOptions {
	options.VPCID = core.StringPtr(vpcID)
	return options
}

// SetRoutingTableID : Allow user to set RoutingTableID
func (options *CreateVPCRoutingTableRouteOptions) SetRoutingTableID(routingTableID string) *CreateVPCRoutingTableRouteOptions {
	options.RoutingTableID = core.StringPtr(routingTableID)
	return options
}

// SetDestination : Allow user to set Destination
func (options *CreateVPCRoutingTableRouteOptions) SetDestination(destination string) *CreateVPCRoutingTableRouteOptions {
	options.Destination = core.StringPtr(destination)
	return options
}

// SetZone : Allow user to set Zone
func (options *CreateVPCRoutingTableRouteOptions) SetZone(zone ZoneIdentityIntf) *CreateVPCRoutingTableRouteOptions {
	options.Zone = zone
	return options
}

// SetAction : Allow user to set Action
func (options *CreateVPCRoutingTableRouteOptions) SetAction(action string) *CreateVPCRoutingTableRouteOptions {
	options.Action = core.StringPtr(action)
	return options
}

// SetName : Allow user to set Name
func (options *CreateVPCRoutingTableRouteOptions) SetName(name string) *CreateVPCRoutingTableRouteOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetNextHop : Allow user to set NextHop
func (options *CreateVPCRoutingTableRouteOptions) SetNextHop(nextHop RouteNextHopPrototypeIntf) *CreateVPCRoutingTableRouteOptions {
	options.NextHop = nextHop
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateVPCRoutingTableRouteOptions) SetHeaders(param map[string]string) *CreateVPCRoutingTableRouteOptions {
	options.Headers = param
	return options
}

// CreateVPNGatewayConnectionOptions : The CreateVPNGatewayConnection options.
type CreateVPNGatewayConnectionOptions struct {
	// The VPN gateway identifier.
	VPNGatewayID *string `json:"vpn_gateway_id" validate:"required"`

	// The IP address of the peer VPN gateway.
	PeerAddress *string `json:"peer_address" validate:"required"`

	// The preshared key.
	Psk *string `json:"psk" validate:"required"`

	// If set to false, the VPN connection is shut down.
	AdminStateUp *bool `json:"admin_state_up,omitempty"`

	// The Dead Peer Detection settings.
	DeadPeerDetection *VPNGatewayConnectionDpdPrototype `json:"dead_peer_detection,omitempty"`

	// Optional IKE policy configuration. The absence of a policy indicates autonegotiation.
	IkePolicy IkePolicyIdentityIntf `json:"ike_policy,omitempty"`

	// Optional IPsec policy configuration. The absence of a policy indicates
	// autonegotiation.
	IpsecPolicy IPsecPolicyIdentityIntf `json:"ipsec_policy,omitempty"`

	// A collection of local CIDRs for this resource.
	LocalCidrs []string `json:"local_cidrs,omitempty"`

	// The user-defined name for this VPN connection.
	Name *string `json:"name,omitempty"`

	// A collection of peer CIDRs for this resource.
	PeerCidrs []string `json:"peer_cidrs,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateVPNGatewayConnectionOptions : Instantiate CreateVPNGatewayConnectionOptions
func (*VpcV1) NewCreateVPNGatewayConnectionOptions(vpnGatewayID string, peerAddress string, psk string) *CreateVPNGatewayConnectionOptions {
	return &CreateVPNGatewayConnectionOptions{
		VPNGatewayID: core.StringPtr(vpnGatewayID),
		PeerAddress:  core.StringPtr(peerAddress),
		Psk:          core.StringPtr(psk),
	}
}

// SetVPNGatewayID : Allow user to set VPNGatewayID
func (options *CreateVPNGatewayConnectionOptions) SetVPNGatewayID(vpnGatewayID string) *CreateVPNGatewayConnectionOptions {
	options.VPNGatewayID = core.StringPtr(vpnGatewayID)
	return options
}

// SetPeerAddress : Allow user to set PeerAddress
func (options *CreateVPNGatewayConnectionOptions) SetPeerAddress(peerAddress string) *CreateVPNGatewayConnectionOptions {
	options.PeerAddress = core.StringPtr(peerAddress)
	return options
}

// SetPsk : Allow user to set Psk
func (options *CreateVPNGatewayConnectionOptions) SetPsk(psk string) *CreateVPNGatewayConnectionOptions {
	options.Psk = core.StringPtr(psk)
	return options
}

// SetAdminStateUp : Allow user to set AdminStateUp
func (options *CreateVPNGatewayConnectionOptions) SetAdminStateUp(adminStateUp bool) *CreateVPNGatewayConnectionOptions {
	options.AdminStateUp = core.BoolPtr(adminStateUp)
	return options
}

// SetDeadPeerDetection : Allow user to set DeadPeerDetection
func (options *CreateVPNGatewayConnectionOptions) SetDeadPeerDetection(deadPeerDetection *VPNGatewayConnectionDpdPrototype) *CreateVPNGatewayConnectionOptions {
	options.DeadPeerDetection = deadPeerDetection
	return options
}

// SetIkePolicy : Allow user to set IkePolicy
func (options *CreateVPNGatewayConnectionOptions) SetIkePolicy(ikePolicy IkePolicyIdentityIntf) *CreateVPNGatewayConnectionOptions {
	options.IkePolicy = ikePolicy
	return options
}

// SetIpsecPolicy : Allow user to set IpsecPolicy
func (options *CreateVPNGatewayConnectionOptions) SetIpsecPolicy(ipsecPolicy IPsecPolicyIdentityIntf) *CreateVPNGatewayConnectionOptions {
	options.IpsecPolicy = ipsecPolicy
	return options
}

// SetLocalCidrs : Allow user to set LocalCidrs
func (options *CreateVPNGatewayConnectionOptions) SetLocalCidrs(localCidrs []string) *CreateVPNGatewayConnectionOptions {
	options.LocalCidrs = localCidrs
	return options
}

// SetName : Allow user to set Name
func (options *CreateVPNGatewayConnectionOptions) SetName(name string) *CreateVPNGatewayConnectionOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetPeerCidrs : Allow user to set PeerCidrs
func (options *CreateVPNGatewayConnectionOptions) SetPeerCidrs(peerCidrs []string) *CreateVPNGatewayConnectionOptions {
	options.PeerCidrs = peerCidrs
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateVPNGatewayConnectionOptions) SetHeaders(param map[string]string) *CreateVPNGatewayConnectionOptions {
	options.Headers = param
	return options
}

// CreateVPNGatewayOptions : The CreateVPNGateway options.
type CreateVPNGatewayOptions struct {
	// Identifies a subnet by a unique property.
	Subnet SubnetIdentityIntf `json:"subnet" validate:"required"`

	// The mode of the VPN gateway.
	Mode *string `json:"mode,omitempty"`

	// The user-defined name for this VPN gateway.
	Name *string `json:"name,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the CreateVPNGatewayOptions.Mode property.
// The mode of the VPN gateway.
const (
	CreateVPNGatewayOptionsModePolicyConst = "policy"
	CreateVPNGatewayOptionsModeRouteConst  = "route"
)

// NewCreateVPNGatewayOptions : Instantiate CreateVPNGatewayOptions
func (*VpcV1) NewCreateVPNGatewayOptions(subnet SubnetIdentityIntf) *CreateVPNGatewayOptions {
	return &CreateVPNGatewayOptions{
		Subnet: subnet,
	}
}

// SetSubnet : Allow user to set Subnet
func (options *CreateVPNGatewayOptions) SetSubnet(subnet SubnetIdentityIntf) *CreateVPNGatewayOptions {
	options.Subnet = subnet
	return options
}

// SetMode : Allow user to set Mode
func (options *CreateVPNGatewayOptions) SetMode(mode string) *CreateVPNGatewayOptions {
	options.Mode = core.StringPtr(mode)
	return options
}

// SetName : Allow user to set Name
func (options *CreateVPNGatewayOptions) SetName(name string) *CreateVPNGatewayOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetResourceGroup : Allow user to set ResourceGroup
func (options *CreateVPNGatewayOptions) SetResourceGroup(resourceGroup ResourceGroupIdentityIntf) *CreateVPNGatewayOptions {
	options.ResourceGroup = resourceGroup
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateVPNGatewayOptions) SetHeaders(param map[string]string) *CreateVPNGatewayOptions {
	options.Headers = param
	return options
}

// DedicatedHost : DedicatedHost struct
type DedicatedHost struct {
	// The administrative state of the dedicated host.
	AdminState *string `json:"admin_state" validate:"required"`

	// The amount of memory in gibibytes that is currently available for instances.
	AvailableMemory *int64 `json:"available_memory" validate:"required"`

	// The available VCPU for the dedicated host.
	AvailableVcpu *DedicatedHostAvailableVcpu `json:"available_vcpu" validate:"required"`

	// The date and time that the dedicated host was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The CRN for this dedicated host.
	CRN *string `json:"crn" validate:"required"`

	// The dedicated host group this dedicated host is in.
	Group *DedicatedHostGroupReference `json:"group" validate:"required"`

	// The URL for this dedicated host.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this dedicated host.
	ID *string `json:"id" validate:"required"`

	// If set to true, instances can be placed on this dedicated host.
	InstancePlacementEnabled *bool `json:"instance_placement_enabled" validate:"required"`

	// Instances that are allocated to this dedicated host.
	Instances []InstanceReference `json:"instances" validate:"required"`

	// The lifecycle state of the dedicated host resource.
	LifecycleState *string `json:"lifecycle_state" validate:"required"`

	// The unique user-defined name for this dedicated host. If unspecified, the name will be a hyphenated list of
	// randomly-selected words.
	Name *string `json:"name" validate:"required"`

	// The profile this dedicated host uses.
	Profile *DedicatedHostProfileReference `json:"profile" validate:"required"`

	// The resource group for this dedicated host.
	ResourceGroup *ResourceGroupReference `json:"resource_group" validate:"required"`

	// The reference of the zone to provision the dedicated host in.
	Zone *ZoneReference `json:"zone" validate:"required"`
}

// Constants associated with the DedicatedHost.AdminState property.
// The administrative state of the dedicated host.
const (
	DedicatedHostAdminStateAvailableConst   = "available"
	DedicatedHostAdminStateMigratingConst   = "migrating"
	DedicatedHostAdminStateUnavailableConst = "unavailable"
)

// Constants associated with the DedicatedHost.LifecycleState property.
// The lifecycle state of the dedicated host resource.
const (
	DedicatedHostLifecycleStateDeletingConst = "deleting"
	DedicatedHostLifecycleStateFailedConst   = "failed"
	DedicatedHostLifecycleStatePendingConst  = "pending"
	DedicatedHostLifecycleStateStableConst   = "stable"
	DedicatedHostLifecycleStateUpdatingConst = "updating"
	DedicatedHostLifecycleStateWaitingConst  = "waiting"
)

// UnmarshalDedicatedHost unmarshals an instance of DedicatedHost from the specified map of raw messages.
func UnmarshalDedicatedHost(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHost)
	err = core.UnmarshalPrimitive(m, "admin_state", &obj.AdminState)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "available_memory", &obj.AvailableMemory)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "available_vcpu", &obj.AvailableVcpu, UnmarshalDedicatedHostAvailableVcpu)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "group", &obj.Group, UnmarshalDedicatedHostGroupReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "instance_placement_enabled", &obj.InstancePlacementEnabled)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "instances", &obj.Instances, UnmarshalInstanceReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "lifecycle_state", &obj.LifecycleState)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "profile", &obj.Profile, UnmarshalDedicatedHostProfileReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostAvailableVcpu : The available VCPU for the dedicated host.
type DedicatedHostAvailableVcpu struct {
	// The VCPU architecture.
	Architecture *string `json:"architecture" validate:"required"`

	// The number of VCPUs assigned.
	Count *int64 `json:"count" validate:"required"`
}

// UnmarshalDedicatedHostAvailableVcpu unmarshals an instance of DedicatedHostAvailableVcpu from the specified map of raw messages.
func UnmarshalDedicatedHostAvailableVcpu(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostAvailableVcpu)
	err = core.UnmarshalPrimitive(m, "architecture", &obj.Architecture)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "count", &obj.Count)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostCollection : DedicatedHostCollection struct
type DedicatedHostCollection struct {
	// Collection of dedicated hosts.
	DedicatedHosts []DedicatedHost `json:"dedicated_hosts" validate:"required"`

	// A reference to the first page of resources.
	First *DedicatedHostCollectionFirst `json:"first" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A reference to the next page of resources; this reference is included for all pages
	// except the last page.
	Next *DedicatedHostCollectionNext `json:"next,omitempty"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalDedicatedHostCollection unmarshals an instance of DedicatedHostCollection from the specified map of raw messages.
func UnmarshalDedicatedHostCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostCollection)
	err = core.UnmarshalModel(m, "dedicated_hosts", &obj.DedicatedHosts, UnmarshalDedicatedHost)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalDedicatedHostCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalDedicatedHostCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostCollectionFirst : A reference to the first page of resources.
type DedicatedHostCollectionFirst struct {
	// The URL for the first page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalDedicatedHostCollectionFirst unmarshals an instance of DedicatedHostCollectionFirst from the specified map of raw messages.
func UnmarshalDedicatedHostCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostCollectionNext : A reference to the next page of resources; this reference is included for all pages except the last page.
type DedicatedHostCollectionNext struct {
	// The URL for the next page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalDedicatedHostCollectionNext unmarshals an instance of DedicatedHostCollectionNext from the specified map of raw messages.
func UnmarshalDedicatedHostCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostGroup : DedicatedHostGroup struct
type DedicatedHostGroup struct {
	// The date and time that the dedicated host group was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The CRN for this dedicated host group.
	CRN *string `json:"crn" validate:"required"`

	// The dedicated hosts that are in this dedicated host group.
	DedicatedHosts []DedicatedHostReference `json:"dedicated_hosts" validate:"required"`

	// The URL for this dedicated host group.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this dedicated host group.
	ID *string `json:"id" validate:"required"`

	// The unique user-defined name for this dedicated host group. If unspecified, the name will be a hyphenated list of
	// randomly-selected words.
	Name *string `json:"name" validate:"required"`

	// The resource group for this dedicated host group.
	ResourceGroup *ResourceGroupReference `json:"resource_group" validate:"required"`

	// The zone the dedicated host group resides in.
	Zone *DedicatedHostGroupZone `json:"zone" validate:"required"`
}

// UnmarshalDedicatedHostGroup unmarshals an instance of DedicatedHostGroup from the specified map of raw messages.
func UnmarshalDedicatedHostGroup(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostGroup)
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "dedicated_hosts", &obj.DedicatedHosts, UnmarshalDedicatedHostReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalDedicatedHostGroupZone)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostGroupCollection : DedicatedHostGroupCollection struct
type DedicatedHostGroupCollection struct {
	// A reference to the first page of resources.
	First *DedicatedHostGroupCollectionFirst `json:"first" validate:"required"`

	// Collection of dedicated host groups.
	Groups []DedicatedHostGroup `json:"groups" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A reference to the next page of resources; this reference is included for all pages
	// except the last page.
	Next *DedicatedHostGroupCollectionNext `json:"next,omitempty"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalDedicatedHostGroupCollection unmarshals an instance of DedicatedHostGroupCollection from the specified map of raw messages.
func UnmarshalDedicatedHostGroupCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostGroupCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalDedicatedHostGroupCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "groups", &obj.Groups, UnmarshalDedicatedHostGroup)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalDedicatedHostGroupCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostGroupCollectionFirst : A reference to the first page of resources.
type DedicatedHostGroupCollectionFirst struct {
	// The URL for the first page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalDedicatedHostGroupCollectionFirst unmarshals an instance of DedicatedHostGroupCollectionFirst from the specified map of raw messages.
func UnmarshalDedicatedHostGroupCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostGroupCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostGroupCollectionNext : A reference to the next page of resources; this reference is included for all pages except the last page.
type DedicatedHostGroupCollectionNext struct {
	// The URL for the next page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalDedicatedHostGroupCollectionNext unmarshals an instance of DedicatedHostGroupCollectionNext from the specified map of raw messages.
func UnmarshalDedicatedHostGroupCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostGroupCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostGroupReference : DedicatedHostGroupReference struct
type DedicatedHostGroupReference struct {
	// The CRN for this dedicated host group.
	CRN *string `json:"crn" validate:"required"`

	// The URL for this dedicated host group.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this dedicated host group.
	ID *string `json:"id" validate:"required"`

	// The unique user-defined name for this dedicated host group. If unspecified, the name will be a hyphenated list of
	// randomly-selected words.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalDedicatedHostGroupReference unmarshals an instance of DedicatedHostGroupReference from the specified map of raw messages.
func UnmarshalDedicatedHostGroupReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostGroupReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostGroupZone : The zone the dedicated host group resides in.
type DedicatedHostGroupZone struct {
	// The URL for this zone.
	Href *string `json:"href" validate:"required"`

	// The name for this zone.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalDedicatedHostGroupZone unmarshals an instance of DedicatedHostGroupZone from the specified map of raw messages.
func UnmarshalDedicatedHostGroupZone(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostGroupZone)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostProfile : DedicatedHostProfile struct
type DedicatedHostProfile struct {
	// The URL for this dedicated host.
	Href *string `json:"href" validate:"required"`

	Memory DedicatedHostProfileMemoryIntf `json:"memory" validate:"required"`

	// The name for this dedicated host profile.
	Name *string `json:"name" validate:"required"`

	PortSpeed DedicatedHostProfilePortSpeedIntf `json:"port_speed" validate:"required"`

	SocketCount DedicatedHostProfileSocketIntf `json:"socket_count" validate:"required"`

	VcpuArchitecture *DedicatedHostProfileVcpuArchitecture `json:"vcpu_architecture" validate:"required"`

	VcpuCount DedicatedHostProfileVcpuIntf `json:"vcpu_count" validate:"required"`
}

// UnmarshalDedicatedHostProfile unmarshals an instance of DedicatedHostProfile from the specified map of raw messages.
func UnmarshalDedicatedHostProfile(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostProfile)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "memory", &obj.Memory, UnmarshalDedicatedHostProfileMemory)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "port_speed", &obj.PortSpeed, UnmarshalDedicatedHostProfilePortSpeed)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "socket_count", &obj.SocketCount, UnmarshalDedicatedHostProfileSocket)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vcpu_architecture", &obj.VcpuArchitecture, UnmarshalDedicatedHostProfileVcpuArchitecture)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vcpu_count", &obj.VcpuCount, UnmarshalDedicatedHostProfileVcpu)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostProfileCollection : DedicatedHostProfileCollection struct
type DedicatedHostProfileCollection struct {
	// A reference to the first page of resources.
	First *DedicatedHostProfileCollectionFirst `json:"first" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A reference to the next page of resources; this reference is included for all pages
	// except the last page.
	Next *DedicatedHostProfileCollectionNext `json:"next,omitempty"`

	// Collection of dedicated host profiles.
	Profiles []DedicatedHostProfile `json:"profiles" validate:"required"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalDedicatedHostProfileCollection unmarshals an instance of DedicatedHostProfileCollection from the specified map of raw messages.
func UnmarshalDedicatedHostProfileCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostProfileCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalDedicatedHostProfileCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalDedicatedHostProfileCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "profiles", &obj.Profiles, UnmarshalDedicatedHostProfile)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostProfileCollectionFirst : A reference to the first page of resources.
type DedicatedHostProfileCollectionFirst struct {
	// The URL for the first page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalDedicatedHostProfileCollectionFirst unmarshals an instance of DedicatedHostProfileCollectionFirst from the specified map of raw messages.
func UnmarshalDedicatedHostProfileCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostProfileCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostProfileCollectionNext : A reference to the next page of resources; this reference is included for all pages except the last page.
type DedicatedHostProfileCollectionNext struct {
	// The URL for the next page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalDedicatedHostProfileCollectionNext unmarshals an instance of DedicatedHostProfileCollectionNext from the specified map of raw messages.
func UnmarshalDedicatedHostProfileCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostProfileCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostProfileMemory : DedicatedHostProfileMemory struct
// Models which "extend" this model:
// - DedicatedHostProfileMemoryFixed
// - DedicatedHostProfileMemoryRange
// - DedicatedHostProfileMemoryEnum
// - DedicatedHostProfileMemoryDependent
type DedicatedHostProfileMemory struct {
	// The type for this profile field.
	Type *string `json:"type,omitempty"`

	// The value for this profile field.
	Value *int64 `json:"value,omitempty"`

	// The default value for this profile field.
	Default *int64 `json:"default,omitempty"`

	// The maximum value for this profile field.
	Max *int64 `json:"max,omitempty"`

	// The minimum value for this profile field.
	Min *int64 `json:"min,omitempty"`

	// The increment step value for this profile field.
	Step *int64 `json:"step,omitempty"`

	// The permitted values for this profile field.
	Values []int64 `json:"values,omitempty"`
}

// Constants associated with the DedicatedHostProfileMemory.Type property.
// The type for this profile field.
const (
	DedicatedHostProfileMemoryTypeFixedConst = "fixed"
)

func (*DedicatedHostProfileMemory) isaDedicatedHostProfileMemory() bool {
	return true
}

type DedicatedHostProfileMemoryIntf interface {
	isaDedicatedHostProfileMemory() bool
}

// UnmarshalDedicatedHostProfileMemory unmarshals an instance of DedicatedHostProfileMemory from the specified map of raw messages.
func UnmarshalDedicatedHostProfileMemory(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostProfileMemory)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "max", &obj.Max)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "min", &obj.Min)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "step", &obj.Step)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "values", &obj.Values)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostProfilePortSpeed : DedicatedHostProfilePortSpeed struct
// Models which "extend" this model:
// - DedicatedHostProfilePortSpeedFixed
// - DedicatedHostProfilePortSpeedDependent
type DedicatedHostProfilePortSpeed struct {
	// The type for this profile field.
	Type *string `json:"type,omitempty"`

	// The value for this profile field.
	Value *int64 `json:"value,omitempty"`
}

// Constants associated with the DedicatedHostProfilePortSpeed.Type property.
// The type for this profile field.
const (
	DedicatedHostProfilePortSpeedTypeFixedConst = "fixed"
)

func (*DedicatedHostProfilePortSpeed) isaDedicatedHostProfilePortSpeed() bool {
	return true
}

type DedicatedHostProfilePortSpeedIntf interface {
	isaDedicatedHostProfilePortSpeed() bool
}

// UnmarshalDedicatedHostProfilePortSpeed unmarshals an instance of DedicatedHostProfilePortSpeed from the specified map of raw messages.
func UnmarshalDedicatedHostProfilePortSpeed(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostProfilePortSpeed)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostProfileReference : DedicatedHostProfileReference struct
type DedicatedHostProfileReference struct {
	// The URL for this dedicated host.
	Href *string `json:"href" validate:"required"`

	// The name for this dedicated host profile.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalDedicatedHostProfileReference unmarshals an instance of DedicatedHostProfileReference from the specified map of raw messages.
func UnmarshalDedicatedHostProfileReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostProfileReference)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostProfileSocket : DedicatedHostProfileSocket struct
// Models which "extend" this model:
// - DedicatedHostProfileSocketFixed
// - DedicatedHostProfileSocketRange
// - DedicatedHostProfileSocketEnum
// - DedicatedHostProfileSocketDependent
type DedicatedHostProfileSocket struct {
	// The type for this profile field.
	Type *string `json:"type,omitempty"`

	// The value for this profile field.
	Value *int64 `json:"value,omitempty"`

	// The default value for this profile field.
	Default *int64 `json:"default,omitempty"`

	// The maximum value for this profile field.
	Max *int64 `json:"max,omitempty"`

	// The minimum value for this profile field.
	Min *int64 `json:"min,omitempty"`

	// The increment step value for this profile field.
	Step *int64 `json:"step,omitempty"`

	// The permitted values for this profile field.
	Values []int64 `json:"values,omitempty"`
}

// Constants associated with the DedicatedHostProfileSocket.Type property.
// The type for this profile field.
const (
	DedicatedHostProfileSocketTypeFixedConst = "fixed"
)

func (*DedicatedHostProfileSocket) isaDedicatedHostProfileSocket() bool {
	return true
}

type DedicatedHostProfileSocketIntf interface {
	isaDedicatedHostProfileSocket() bool
}

// UnmarshalDedicatedHostProfileSocket unmarshals an instance of DedicatedHostProfileSocket from the specified map of raw messages.
func UnmarshalDedicatedHostProfileSocket(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostProfileSocket)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "max", &obj.Max)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "min", &obj.Min)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "step", &obj.Step)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "values", &obj.Values)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostProfileVcpu : DedicatedHostProfileVcpu struct
// Models which "extend" this model:
// - DedicatedHostProfileVcpuFixed
// - DedicatedHostProfileVcpuRange
// - DedicatedHostProfileVcpuEnum
// - DedicatedHostProfileVcpuDependent
type DedicatedHostProfileVcpu struct {
	// The type for this profile field.
	Type *string `json:"type,omitempty"`

	// The value for this profile field.
	Value *int64 `json:"value,omitempty"`

	// The default value for this profile field.
	Default *int64 `json:"default,omitempty"`

	// The maximum value for this profile field.
	Max *int64 `json:"max,omitempty"`

	// The minimum value for this profile field.
	Min *int64 `json:"min,omitempty"`

	// The increment step value for this profile field.
	Step *int64 `json:"step,omitempty"`

	// The permitted values for this profile field.
	Values []int64 `json:"values,omitempty"`
}

// Constants associated with the DedicatedHostProfileVcpu.Type property.
// The type for this profile field.
const (
	DedicatedHostProfileVcpuTypeFixedConst = "fixed"
)

func (*DedicatedHostProfileVcpu) isaDedicatedHostProfileVcpu() bool {
	return true
}

type DedicatedHostProfileVcpuIntf interface {
	isaDedicatedHostProfileVcpu() bool
}

// UnmarshalDedicatedHostProfileVcpu unmarshals an instance of DedicatedHostProfileVcpu from the specified map of raw messages.
func UnmarshalDedicatedHostProfileVcpu(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostProfileVcpu)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "max", &obj.Max)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "min", &obj.Min)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "step", &obj.Step)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "values", &obj.Values)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostProfileVcpuArchitecture : DedicatedHostProfileVcpuArchitecture struct
type DedicatedHostProfileVcpuArchitecture struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The VCPU architecture for a dedicated host with this profile.
	Value *string `json:"value" validate:"required"`
}

// Constants associated with the DedicatedHostProfileVcpuArchitecture.Type property.
// The type for this profile field.
const (
	DedicatedHostProfileVcpuArchitectureTypeFixedConst = "fixed"
)

// UnmarshalDedicatedHostProfileVcpuArchitecture unmarshals an instance of DedicatedHostProfileVcpuArchitecture from the specified map of raw messages.
func UnmarshalDedicatedHostProfileVcpuArchitecture(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostProfileVcpuArchitecture)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostPrototypeGroup : The dedicated host group for this dedicated host.
// Models which "extend" this model:
// - DedicatedHostPrototypeGroupDedicatedHostGroupIdentityByID
// - DedicatedHostPrototypeGroupDedicatedHostGroupIdentityByCRN
// - DedicatedHostPrototypeGroupDedicatedHostGroupIdentityByHref
type DedicatedHostPrototypeGroup struct {
	// The unique identifier for this dedicated host group.
	ID *string `json:"id,omitempty"`

	// The CRN for this dedicated host group.
	CRN *string `json:"crn,omitempty"`

	// The URL for this dedicated host group.
	Href *string `json:"href,omitempty"`
}

func (*DedicatedHostPrototypeGroup) isaDedicatedHostPrototypeGroup() bool {
	return true
}

type DedicatedHostPrototypeGroupIntf interface {
	isaDedicatedHostPrototypeGroup() bool
}

// UnmarshalDedicatedHostPrototypeGroup unmarshals an instance of DedicatedHostPrototypeGroup from the specified map of raw messages.
func UnmarshalDedicatedHostPrototypeGroup(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostPrototypeGroup)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostPrototypeProfile : The profile to use for this dedicated host.
// Models which "extend" this model:
// - DedicatedHostPrototypeProfileDedicatedHostProfileIdentityByName
// - DedicatedHostPrototypeProfileDedicatedHostProfileIdentityByHref
type DedicatedHostPrototypeProfile struct {
	// The name for this dedicated host profile.
	Name *string `json:"name,omitempty"`

	// The URL for this dedicated host profile.
	Href *string `json:"href,omitempty"`
}

func (*DedicatedHostPrototypeProfile) isaDedicatedHostPrototypeProfile() bool {
	return true
}

type DedicatedHostPrototypeProfileIntf interface {
	isaDedicatedHostPrototypeProfile() bool
}

// UnmarshalDedicatedHostPrototypeProfile unmarshals an instance of DedicatedHostPrototypeProfile from the specified map of raw messages.
func UnmarshalDedicatedHostPrototypeProfile(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostPrototypeProfile)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostReference : DedicatedHostReference struct
type DedicatedHostReference struct {
	// The CRN for this dedicated host.
	CRN *string `json:"crn" validate:"required"`

	// The URL for this dedicated host.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this dedicated host.
	ID *string `json:"id" validate:"required"`

	// The unique user-defined name for this dedicated host. If unspecified, the name will be a hyphenated list of
	// randomly-selected words.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalDedicatedHostReference unmarshals an instance of DedicatedHostReference from the specified map of raw messages.
func UnmarshalDedicatedHostReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DefaultNetworkACL : DefaultNetworkACL struct
type DefaultNetworkACL struct {
	// The date and time that the network ACL was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The CRN for this network ACL.
	CRN *string `json:"crn" validate:"required"`

	// The URL for this network ACL.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this network ACL.
	ID *string `json:"id" validate:"required"`

	// The name of the default network ACL created for a VPC. The name will be a hyphenated list of randomly-selected words
	// at creation, but may be user-specified with a subsequent request.
	Name *string `json:"name" validate:"required"`

	// The resource group for the default network ACL for a VPC. Set to the VPC's
	// resource group at creation.
	ResourceGroup *ResourceGroupReference `json:"resource_group" validate:"required"`

	// The ordered rules for the default network ACL for a VPC.  Defaults to two rules which allow all inbound and outbound
	// traffic, respectively.  Rules for the default network ACL may be changed, added, or removed.
	Rules []NetworkACLRuleItemIntf `json:"rules" validate:"required"`

	// The subnets to which this network ACL is attached.
	Subnets []SubnetReference `json:"subnets" validate:"required"`

	// The VPC this network ACL is a part of.
	VPC *VPCReference `json:"vpc" validate:"required"`
}

// UnmarshalDefaultNetworkACL unmarshals an instance of DefaultNetworkACL from the specified map of raw messages.
func UnmarshalDefaultNetworkACL(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DefaultNetworkACL)
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "rules", &obj.Rules, UnmarshalNetworkACLRuleItem)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "subnets", &obj.Subnets, UnmarshalSubnetReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vpc", &obj.VPC, UnmarshalVPCReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DefaultRoutingTable : DefaultRoutingTable struct
type DefaultRoutingTable struct {
	// The date and time that this routing table was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The URL for this routing table.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this routing table.
	ID *string `json:"id" validate:"required"`

	// The lifecycle state of the routing table.
	LifecycleState *string `json:"lifecycle_state" validate:"required"`

	// The name of the default routing table created for this VPC. The name will be a hyphenated list of randomly-selected
	// words at creation, but may be user-specified with a subsequent request.
	Name *string `json:"name" validate:"required"`

	// The type of resource referenced.
	ResourceType *string `json:"resource_type" validate:"required"`

	// The routes for the default routing table for this VPC. The table is created with no routes, but routes may be added,
	// changed, or removed with a subsequent request.
	Routes []RouteReference `json:"routes" validate:"required"`

	// The subnets to which this routing table is attached.
	Subnets []SubnetReference `json:"subnets" validate:"required"`
}

// Constants associated with the DefaultRoutingTable.LifecycleState property.
// The lifecycle state of the routing table.
const (
	DefaultRoutingTableLifecycleStateDeletedConst  = "deleted"
	DefaultRoutingTableLifecycleStateDeletingConst = "deleting"
	DefaultRoutingTableLifecycleStateFailedConst   = "failed"
	DefaultRoutingTableLifecycleStatePendingConst  = "pending"
	DefaultRoutingTableLifecycleStateStableConst   = "stable"
	DefaultRoutingTableLifecycleStateUpdatingConst = "updating"
	DefaultRoutingTableLifecycleStateWaitingConst  = "waiting"
)

// Constants associated with the DefaultRoutingTable.ResourceType property.
// The type of resource referenced.
const (
	DefaultRoutingTableResourceTypeRoutingTableConst = "routing_table"
)

// UnmarshalDefaultRoutingTable unmarshals an instance of DefaultRoutingTable from the specified map of raw messages.
func UnmarshalDefaultRoutingTable(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DefaultRoutingTable)
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "lifecycle_state", &obj.LifecycleState)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "routes", &obj.Routes, UnmarshalRouteReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "subnets", &obj.Subnets, UnmarshalSubnetReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DefaultSecurityGroup : Collection of rules in a default security group.
type DefaultSecurityGroup struct {
	// The date and time that this security group was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The security group's CRN.
	CRN *string `json:"crn" validate:"required"`

	// The security group's canonical URL.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this security group.
	ID *string `json:"id" validate:"required"`

	// The name of the default security group created for a VPC. The name will be a hyphenated list of randomly-selected
	// words at creation, but may be user-specified with a subsequent request.
	Name *string `json:"name" validate:"required"`

	// The resource group for this security group.
	ResourceGroup *ResourceGroupReference `json:"resource_group" validate:"required"`

	// Array of rules for the default security group for a VPC. Defaults to allowing all outbound traffic, and allowing all
	// inbound traffic from other interfaces in the VPCs default security group. Rules in the default security group may
	// be changed, added or removed.
	Rules []SecurityGroupRuleIntf `json:"rules" validate:"required"`

	// The VPC this security group is a part of.
	VPC *VPCReference `json:"vpc" validate:"required"`
}

// UnmarshalDefaultSecurityGroup unmarshals an instance of DefaultSecurityGroup from the specified map of raw messages.
func UnmarshalDefaultSecurityGroup(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DefaultSecurityGroup)
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "rules", &obj.Rules, UnmarshalSecurityGroupRule)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vpc", &obj.VPC, UnmarshalVPCReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DeleteDedicatedHostGroupOptions : The DeleteDedicatedHostGroup options.
type DeleteDedicatedHostGroupOptions struct {
	// The dedicated host group identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteDedicatedHostGroupOptions : Instantiate DeleteDedicatedHostGroupOptions
func (*VpcV1) NewDeleteDedicatedHostGroupOptions(id string) *DeleteDedicatedHostGroupOptions {
	return &DeleteDedicatedHostGroupOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *DeleteDedicatedHostGroupOptions) SetID(id string) *DeleteDedicatedHostGroupOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteDedicatedHostGroupOptions) SetHeaders(param map[string]string) *DeleteDedicatedHostGroupOptions {
	options.Headers = param
	return options
}

// DeleteDedicatedHostOptions : The DeleteDedicatedHost options.
type DeleteDedicatedHostOptions struct {
	// The dedicated host identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteDedicatedHostOptions : Instantiate DeleteDedicatedHostOptions
func (*VpcV1) NewDeleteDedicatedHostOptions(id string) *DeleteDedicatedHostOptions {
	return &DeleteDedicatedHostOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *DeleteDedicatedHostOptions) SetID(id string) *DeleteDedicatedHostOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteDedicatedHostOptions) SetHeaders(param map[string]string) *DeleteDedicatedHostOptions {
	options.Headers = param
	return options
}

// DeleteFloatingIPOptions : The DeleteFloatingIP options.
type DeleteFloatingIPOptions struct {
	// The floating IP identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteFloatingIPOptions : Instantiate DeleteFloatingIPOptions
func (*VpcV1) NewDeleteFloatingIPOptions(id string) *DeleteFloatingIPOptions {
	return &DeleteFloatingIPOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *DeleteFloatingIPOptions) SetID(id string) *DeleteFloatingIPOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteFloatingIPOptions) SetHeaders(param map[string]string) *DeleteFloatingIPOptions {
	options.Headers = param
	return options
}

// DeleteFlowLogCollectorOptions : The DeleteFlowLogCollector options.
type DeleteFlowLogCollectorOptions struct {
	// The flow log collector identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteFlowLogCollectorOptions : Instantiate DeleteFlowLogCollectorOptions
func (*VpcV1) NewDeleteFlowLogCollectorOptions(id string) *DeleteFlowLogCollectorOptions {
	return &DeleteFlowLogCollectorOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *DeleteFlowLogCollectorOptions) SetID(id string) *DeleteFlowLogCollectorOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteFlowLogCollectorOptions) SetHeaders(param map[string]string) *DeleteFlowLogCollectorOptions {
	options.Headers = param
	return options
}

// DeleteIkePolicyOptions : The DeleteIkePolicy options.
type DeleteIkePolicyOptions struct {
	// The IKE policy identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteIkePolicyOptions : Instantiate DeleteIkePolicyOptions
func (*VpcV1) NewDeleteIkePolicyOptions(id string) *DeleteIkePolicyOptions {
	return &DeleteIkePolicyOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *DeleteIkePolicyOptions) SetID(id string) *DeleteIkePolicyOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteIkePolicyOptions) SetHeaders(param map[string]string) *DeleteIkePolicyOptions {
	options.Headers = param
	return options
}

// DeleteImageOptions : The DeleteImage options.
type DeleteImageOptions struct {
	// The image identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteImageOptions : Instantiate DeleteImageOptions
func (*VpcV1) NewDeleteImageOptions(id string) *DeleteImageOptions {
	return &DeleteImageOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *DeleteImageOptions) SetID(id string) *DeleteImageOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteImageOptions) SetHeaders(param map[string]string) *DeleteImageOptions {
	options.Headers = param
	return options
}

// DeleteInstanceGroupLoadBalancerOptions : The DeleteInstanceGroupLoadBalancer options.
type DeleteInstanceGroupLoadBalancerOptions struct {
	// The instance group identifier.
	InstanceGroupID *string `json:"instance_group_id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteInstanceGroupLoadBalancerOptions : Instantiate DeleteInstanceGroupLoadBalancerOptions
func (*VpcV1) NewDeleteInstanceGroupLoadBalancerOptions(instanceGroupID string) *DeleteInstanceGroupLoadBalancerOptions {
	return &DeleteInstanceGroupLoadBalancerOptions{
		InstanceGroupID: core.StringPtr(instanceGroupID),
	}
}

// SetInstanceGroupID : Allow user to set InstanceGroupID
func (options *DeleteInstanceGroupLoadBalancerOptions) SetInstanceGroupID(instanceGroupID string) *DeleteInstanceGroupLoadBalancerOptions {
	options.InstanceGroupID = core.StringPtr(instanceGroupID)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteInstanceGroupLoadBalancerOptions) SetHeaders(param map[string]string) *DeleteInstanceGroupLoadBalancerOptions {
	options.Headers = param
	return options
}

// DeleteInstanceGroupManagerOptions : The DeleteInstanceGroupManager options.
type DeleteInstanceGroupManagerOptions struct {
	// The instance group identifier.
	InstanceGroupID *string `json:"instance_group_id" validate:"required"`

	// The instance group manager identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteInstanceGroupManagerOptions : Instantiate DeleteInstanceGroupManagerOptions
func (*VpcV1) NewDeleteInstanceGroupManagerOptions(instanceGroupID string, id string) *DeleteInstanceGroupManagerOptions {
	return &DeleteInstanceGroupManagerOptions{
		InstanceGroupID: core.StringPtr(instanceGroupID),
		ID:              core.StringPtr(id),
	}
}

// SetInstanceGroupID : Allow user to set InstanceGroupID
func (options *DeleteInstanceGroupManagerOptions) SetInstanceGroupID(instanceGroupID string) *DeleteInstanceGroupManagerOptions {
	options.InstanceGroupID = core.StringPtr(instanceGroupID)
	return options
}

// SetID : Allow user to set ID
func (options *DeleteInstanceGroupManagerOptions) SetID(id string) *DeleteInstanceGroupManagerOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteInstanceGroupManagerOptions) SetHeaders(param map[string]string) *DeleteInstanceGroupManagerOptions {
	options.Headers = param
	return options
}

// DeleteInstanceGroupManagerPolicyOptions : The DeleteInstanceGroupManagerPolicy options.
type DeleteInstanceGroupManagerPolicyOptions struct {
	// The instance group identifier.
	InstanceGroupID *string `json:"instance_group_id" validate:"required"`

	// The instance group manager identifier.
	InstanceGroupManagerID *string `json:"instance_group_manager_id" validate:"required"`

	// The instance group manager policy identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteInstanceGroupManagerPolicyOptions : Instantiate DeleteInstanceGroupManagerPolicyOptions
func (*VpcV1) NewDeleteInstanceGroupManagerPolicyOptions(instanceGroupID string, instanceGroupManagerID string, id string) *DeleteInstanceGroupManagerPolicyOptions {
	return &DeleteInstanceGroupManagerPolicyOptions{
		InstanceGroupID:        core.StringPtr(instanceGroupID),
		InstanceGroupManagerID: core.StringPtr(instanceGroupManagerID),
		ID:                     core.StringPtr(id),
	}
}

// SetInstanceGroupID : Allow user to set InstanceGroupID
func (options *DeleteInstanceGroupManagerPolicyOptions) SetInstanceGroupID(instanceGroupID string) *DeleteInstanceGroupManagerPolicyOptions {
	options.InstanceGroupID = core.StringPtr(instanceGroupID)
	return options
}

// SetInstanceGroupManagerID : Allow user to set InstanceGroupManagerID
func (options *DeleteInstanceGroupManagerPolicyOptions) SetInstanceGroupManagerID(instanceGroupManagerID string) *DeleteInstanceGroupManagerPolicyOptions {
	options.InstanceGroupManagerID = core.StringPtr(instanceGroupManagerID)
	return options
}

// SetID : Allow user to set ID
func (options *DeleteInstanceGroupManagerPolicyOptions) SetID(id string) *DeleteInstanceGroupManagerPolicyOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteInstanceGroupManagerPolicyOptions) SetHeaders(param map[string]string) *DeleteInstanceGroupManagerPolicyOptions {
	options.Headers = param
	return options
}

// DeleteInstanceGroupMembershipOptions : The DeleteInstanceGroupMembership options.
type DeleteInstanceGroupMembershipOptions struct {
	// The instance group identifier.
	InstanceGroupID *string `json:"instance_group_id" validate:"required"`

	// The instance group membership identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteInstanceGroupMembershipOptions : Instantiate DeleteInstanceGroupMembershipOptions
func (*VpcV1) NewDeleteInstanceGroupMembershipOptions(instanceGroupID string, id string) *DeleteInstanceGroupMembershipOptions {
	return &DeleteInstanceGroupMembershipOptions{
		InstanceGroupID: core.StringPtr(instanceGroupID),
		ID:              core.StringPtr(id),
	}
}

// SetInstanceGroupID : Allow user to set InstanceGroupID
func (options *DeleteInstanceGroupMembershipOptions) SetInstanceGroupID(instanceGroupID string) *DeleteInstanceGroupMembershipOptions {
	options.InstanceGroupID = core.StringPtr(instanceGroupID)
	return options
}

// SetID : Allow user to set ID
func (options *DeleteInstanceGroupMembershipOptions) SetID(id string) *DeleteInstanceGroupMembershipOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteInstanceGroupMembershipOptions) SetHeaders(param map[string]string) *DeleteInstanceGroupMembershipOptions {
	options.Headers = param
	return options
}

// DeleteInstanceGroupMembershipsOptions : The DeleteInstanceGroupMemberships options.
type DeleteInstanceGroupMembershipsOptions struct {
	// The instance group identifier.
	InstanceGroupID *string `json:"instance_group_id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteInstanceGroupMembershipsOptions : Instantiate DeleteInstanceGroupMembershipsOptions
func (*VpcV1) NewDeleteInstanceGroupMembershipsOptions(instanceGroupID string) *DeleteInstanceGroupMembershipsOptions {
	return &DeleteInstanceGroupMembershipsOptions{
		InstanceGroupID: core.StringPtr(instanceGroupID),
	}
}

// SetInstanceGroupID : Allow user to set InstanceGroupID
func (options *DeleteInstanceGroupMembershipsOptions) SetInstanceGroupID(instanceGroupID string) *DeleteInstanceGroupMembershipsOptions {
	options.InstanceGroupID = core.StringPtr(instanceGroupID)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteInstanceGroupMembershipsOptions) SetHeaders(param map[string]string) *DeleteInstanceGroupMembershipsOptions {
	options.Headers = param
	return options
}

// DeleteInstanceGroupOptions : The DeleteInstanceGroup options.
type DeleteInstanceGroupOptions struct {
	// The instance group identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteInstanceGroupOptions : Instantiate DeleteInstanceGroupOptions
func (*VpcV1) NewDeleteInstanceGroupOptions(id string) *DeleteInstanceGroupOptions {
	return &DeleteInstanceGroupOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *DeleteInstanceGroupOptions) SetID(id string) *DeleteInstanceGroupOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteInstanceGroupOptions) SetHeaders(param map[string]string) *DeleteInstanceGroupOptions {
	options.Headers = param
	return options
}

// DeleteInstanceNetworkInterfaceOptions : The DeleteInstanceNetworkInterface options.
type DeleteInstanceNetworkInterfaceOptions struct {
	// The instance identifier.
	InstanceID *string `json:"instance_id" validate:"required"`

	// The network interface identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteInstanceNetworkInterfaceOptions : Instantiate DeleteInstanceNetworkInterfaceOptions
func (*VpcV1) NewDeleteInstanceNetworkInterfaceOptions(instanceID string, id string) *DeleteInstanceNetworkInterfaceOptions {
	return &DeleteInstanceNetworkInterfaceOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (options *DeleteInstanceNetworkInterfaceOptions) SetInstanceID(instanceID string) *DeleteInstanceNetworkInterfaceOptions {
	options.InstanceID = core.StringPtr(instanceID)
	return options
}

// SetID : Allow user to set ID
func (options *DeleteInstanceNetworkInterfaceOptions) SetID(id string) *DeleteInstanceNetworkInterfaceOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteInstanceNetworkInterfaceOptions) SetHeaders(param map[string]string) *DeleteInstanceNetworkInterfaceOptions {
	options.Headers = param
	return options
}

// DeleteInstanceOptions : The DeleteInstance options.
type DeleteInstanceOptions struct {
	// The instance identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteInstanceOptions : Instantiate DeleteInstanceOptions
func (*VpcV1) NewDeleteInstanceOptions(id string) *DeleteInstanceOptions {
	return &DeleteInstanceOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *DeleteInstanceOptions) SetID(id string) *DeleteInstanceOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteInstanceOptions) SetHeaders(param map[string]string) *DeleteInstanceOptions {
	options.Headers = param
	return options
}

// DeleteInstanceTemplateOptions : The DeleteInstanceTemplate options.
type DeleteInstanceTemplateOptions struct {
	// The instance template identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteInstanceTemplateOptions : Instantiate DeleteInstanceTemplateOptions
func (*VpcV1) NewDeleteInstanceTemplateOptions(id string) *DeleteInstanceTemplateOptions {
	return &DeleteInstanceTemplateOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *DeleteInstanceTemplateOptions) SetID(id string) *DeleteInstanceTemplateOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteInstanceTemplateOptions) SetHeaders(param map[string]string) *DeleteInstanceTemplateOptions {
	options.Headers = param
	return options
}

// DeleteInstanceVolumeAttachmentOptions : The DeleteInstanceVolumeAttachment options.
type DeleteInstanceVolumeAttachmentOptions struct {
	// The instance identifier.
	InstanceID *string `json:"instance_id" validate:"required"`

	// The volume attachment identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteInstanceVolumeAttachmentOptions : Instantiate DeleteInstanceVolumeAttachmentOptions
func (*VpcV1) NewDeleteInstanceVolumeAttachmentOptions(instanceID string, id string) *DeleteInstanceVolumeAttachmentOptions {
	return &DeleteInstanceVolumeAttachmentOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (options *DeleteInstanceVolumeAttachmentOptions) SetInstanceID(instanceID string) *DeleteInstanceVolumeAttachmentOptions {
	options.InstanceID = core.StringPtr(instanceID)
	return options
}

// SetID : Allow user to set ID
func (options *DeleteInstanceVolumeAttachmentOptions) SetID(id string) *DeleteInstanceVolumeAttachmentOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteInstanceVolumeAttachmentOptions) SetHeaders(param map[string]string) *DeleteInstanceVolumeAttachmentOptions {
	options.Headers = param
	return options
}

// DeleteIpsecPolicyOptions : The DeleteIpsecPolicy options.
type DeleteIpsecPolicyOptions struct {
	// The IPsec policy identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteIpsecPolicyOptions : Instantiate DeleteIpsecPolicyOptions
func (*VpcV1) NewDeleteIpsecPolicyOptions(id string) *DeleteIpsecPolicyOptions {
	return &DeleteIpsecPolicyOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *DeleteIpsecPolicyOptions) SetID(id string) *DeleteIpsecPolicyOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteIpsecPolicyOptions) SetHeaders(param map[string]string) *DeleteIpsecPolicyOptions {
	options.Headers = param
	return options
}

// DeleteKeyOptions : The DeleteKey options.
type DeleteKeyOptions struct {
	// The key identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteKeyOptions : Instantiate DeleteKeyOptions
func (*VpcV1) NewDeleteKeyOptions(id string) *DeleteKeyOptions {
	return &DeleteKeyOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *DeleteKeyOptions) SetID(id string) *DeleteKeyOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteKeyOptions) SetHeaders(param map[string]string) *DeleteKeyOptions {
	options.Headers = param
	return options
}

// DeleteLoadBalancerListenerOptions : The DeleteLoadBalancerListener options.
type DeleteLoadBalancerListenerOptions struct {
	// The load balancer identifier.
	LoadBalancerID *string `json:"load_balancer_id" validate:"required"`

	// The listener identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteLoadBalancerListenerOptions : Instantiate DeleteLoadBalancerListenerOptions
func (*VpcV1) NewDeleteLoadBalancerListenerOptions(loadBalancerID string, id string) *DeleteLoadBalancerListenerOptions {
	return &DeleteLoadBalancerListenerOptions{
		LoadBalancerID: core.StringPtr(loadBalancerID),
		ID:             core.StringPtr(id),
	}
}

// SetLoadBalancerID : Allow user to set LoadBalancerID
func (options *DeleteLoadBalancerListenerOptions) SetLoadBalancerID(loadBalancerID string) *DeleteLoadBalancerListenerOptions {
	options.LoadBalancerID = core.StringPtr(loadBalancerID)
	return options
}

// SetID : Allow user to set ID
func (options *DeleteLoadBalancerListenerOptions) SetID(id string) *DeleteLoadBalancerListenerOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteLoadBalancerListenerOptions) SetHeaders(param map[string]string) *DeleteLoadBalancerListenerOptions {
	options.Headers = param
	return options
}

// DeleteLoadBalancerListenerPolicyOptions : The DeleteLoadBalancerListenerPolicy options.
type DeleteLoadBalancerListenerPolicyOptions struct {
	// The load balancer identifier.
	LoadBalancerID *string `json:"load_balancer_id" validate:"required"`

	// The listener identifier.
	ListenerID *string `json:"listener_id" validate:"required"`

	// The policy identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteLoadBalancerListenerPolicyOptions : Instantiate DeleteLoadBalancerListenerPolicyOptions
func (*VpcV1) NewDeleteLoadBalancerListenerPolicyOptions(loadBalancerID string, listenerID string, id string) *DeleteLoadBalancerListenerPolicyOptions {
	return &DeleteLoadBalancerListenerPolicyOptions{
		LoadBalancerID: core.StringPtr(loadBalancerID),
		ListenerID:     core.StringPtr(listenerID),
		ID:             core.StringPtr(id),
	}
}

// SetLoadBalancerID : Allow user to set LoadBalancerID
func (options *DeleteLoadBalancerListenerPolicyOptions) SetLoadBalancerID(loadBalancerID string) *DeleteLoadBalancerListenerPolicyOptions {
	options.LoadBalancerID = core.StringPtr(loadBalancerID)
	return options
}

// SetListenerID : Allow user to set ListenerID
func (options *DeleteLoadBalancerListenerPolicyOptions) SetListenerID(listenerID string) *DeleteLoadBalancerListenerPolicyOptions {
	options.ListenerID = core.StringPtr(listenerID)
	return options
}

// SetID : Allow user to set ID
func (options *DeleteLoadBalancerListenerPolicyOptions) SetID(id string) *DeleteLoadBalancerListenerPolicyOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteLoadBalancerListenerPolicyOptions) SetHeaders(param map[string]string) *DeleteLoadBalancerListenerPolicyOptions {
	options.Headers = param
	return options
}

// DeleteLoadBalancerListenerPolicyRuleOptions : The DeleteLoadBalancerListenerPolicyRule options.
type DeleteLoadBalancerListenerPolicyRuleOptions struct {
	// The load balancer identifier.
	LoadBalancerID *string `json:"load_balancer_id" validate:"required"`

	// The listener identifier.
	ListenerID *string `json:"listener_id" validate:"required"`

	// The policy identifier.
	PolicyID *string `json:"policy_id" validate:"required"`

	// The rule identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteLoadBalancerListenerPolicyRuleOptions : Instantiate DeleteLoadBalancerListenerPolicyRuleOptions
func (*VpcV1) NewDeleteLoadBalancerListenerPolicyRuleOptions(loadBalancerID string, listenerID string, policyID string, id string) *DeleteLoadBalancerListenerPolicyRuleOptions {
	return &DeleteLoadBalancerListenerPolicyRuleOptions{
		LoadBalancerID: core.StringPtr(loadBalancerID),
		ListenerID:     core.StringPtr(listenerID),
		PolicyID:       core.StringPtr(policyID),
		ID:             core.StringPtr(id),
	}
}

// SetLoadBalancerID : Allow user to set LoadBalancerID
func (options *DeleteLoadBalancerListenerPolicyRuleOptions) SetLoadBalancerID(loadBalancerID string) *DeleteLoadBalancerListenerPolicyRuleOptions {
	options.LoadBalancerID = core.StringPtr(loadBalancerID)
	return options
}

// SetListenerID : Allow user to set ListenerID
func (options *DeleteLoadBalancerListenerPolicyRuleOptions) SetListenerID(listenerID string) *DeleteLoadBalancerListenerPolicyRuleOptions {
	options.ListenerID = core.StringPtr(listenerID)
	return options
}

// SetPolicyID : Allow user to set PolicyID
func (options *DeleteLoadBalancerListenerPolicyRuleOptions) SetPolicyID(policyID string) *DeleteLoadBalancerListenerPolicyRuleOptions {
	options.PolicyID = core.StringPtr(policyID)
	return options
}

// SetID : Allow user to set ID
func (options *DeleteLoadBalancerListenerPolicyRuleOptions) SetID(id string) *DeleteLoadBalancerListenerPolicyRuleOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteLoadBalancerListenerPolicyRuleOptions) SetHeaders(param map[string]string) *DeleteLoadBalancerListenerPolicyRuleOptions {
	options.Headers = param
	return options
}

// DeleteLoadBalancerOptions : The DeleteLoadBalancer options.
type DeleteLoadBalancerOptions struct {
	// The load balancer identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteLoadBalancerOptions : Instantiate DeleteLoadBalancerOptions
func (*VpcV1) NewDeleteLoadBalancerOptions(id string) *DeleteLoadBalancerOptions {
	return &DeleteLoadBalancerOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *DeleteLoadBalancerOptions) SetID(id string) *DeleteLoadBalancerOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteLoadBalancerOptions) SetHeaders(param map[string]string) *DeleteLoadBalancerOptions {
	options.Headers = param
	return options
}

// DeleteLoadBalancerPoolMemberOptions : The DeleteLoadBalancerPoolMember options.
type DeleteLoadBalancerPoolMemberOptions struct {
	// The load balancer identifier.
	LoadBalancerID *string `json:"load_balancer_id" validate:"required"`

	// The pool identifier.
	PoolID *string `json:"pool_id" validate:"required"`

	// The member identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteLoadBalancerPoolMemberOptions : Instantiate DeleteLoadBalancerPoolMemberOptions
func (*VpcV1) NewDeleteLoadBalancerPoolMemberOptions(loadBalancerID string, poolID string, id string) *DeleteLoadBalancerPoolMemberOptions {
	return &DeleteLoadBalancerPoolMemberOptions{
		LoadBalancerID: core.StringPtr(loadBalancerID),
		PoolID:         core.StringPtr(poolID),
		ID:             core.StringPtr(id),
	}
}

// SetLoadBalancerID : Allow user to set LoadBalancerID
func (options *DeleteLoadBalancerPoolMemberOptions) SetLoadBalancerID(loadBalancerID string) *DeleteLoadBalancerPoolMemberOptions {
	options.LoadBalancerID = core.StringPtr(loadBalancerID)
	return options
}

// SetPoolID : Allow user to set PoolID
func (options *DeleteLoadBalancerPoolMemberOptions) SetPoolID(poolID string) *DeleteLoadBalancerPoolMemberOptions {
	options.PoolID = core.StringPtr(poolID)
	return options
}

// SetID : Allow user to set ID
func (options *DeleteLoadBalancerPoolMemberOptions) SetID(id string) *DeleteLoadBalancerPoolMemberOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteLoadBalancerPoolMemberOptions) SetHeaders(param map[string]string) *DeleteLoadBalancerPoolMemberOptions {
	options.Headers = param
	return options
}

// DeleteLoadBalancerPoolOptions : The DeleteLoadBalancerPool options.
type DeleteLoadBalancerPoolOptions struct {
	// The load balancer identifier.
	LoadBalancerID *string `json:"load_balancer_id" validate:"required"`

	// The pool identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteLoadBalancerPoolOptions : Instantiate DeleteLoadBalancerPoolOptions
func (*VpcV1) NewDeleteLoadBalancerPoolOptions(loadBalancerID string, id string) *DeleteLoadBalancerPoolOptions {
	return &DeleteLoadBalancerPoolOptions{
		LoadBalancerID: core.StringPtr(loadBalancerID),
		ID:             core.StringPtr(id),
	}
}

// SetLoadBalancerID : Allow user to set LoadBalancerID
func (options *DeleteLoadBalancerPoolOptions) SetLoadBalancerID(loadBalancerID string) *DeleteLoadBalancerPoolOptions {
	options.LoadBalancerID = core.StringPtr(loadBalancerID)
	return options
}

// SetID : Allow user to set ID
func (options *DeleteLoadBalancerPoolOptions) SetID(id string) *DeleteLoadBalancerPoolOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteLoadBalancerPoolOptions) SetHeaders(param map[string]string) *DeleteLoadBalancerPoolOptions {
	options.Headers = param
	return options
}

// DeleteNetworkACLOptions : The DeleteNetworkACL options.
type DeleteNetworkACLOptions struct {
	// The network ACL identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteNetworkACLOptions : Instantiate DeleteNetworkACLOptions
func (*VpcV1) NewDeleteNetworkACLOptions(id string) *DeleteNetworkACLOptions {
	return &DeleteNetworkACLOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *DeleteNetworkACLOptions) SetID(id string) *DeleteNetworkACLOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteNetworkACLOptions) SetHeaders(param map[string]string) *DeleteNetworkACLOptions {
	options.Headers = param
	return options
}

// DeleteNetworkACLRuleOptions : The DeleteNetworkACLRule options.
type DeleteNetworkACLRuleOptions struct {
	// The network ACL identifier.
	NetworkACLID *string `json:"network_acl_id" validate:"required"`

	// The rule identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteNetworkACLRuleOptions : Instantiate DeleteNetworkACLRuleOptions
func (*VpcV1) NewDeleteNetworkACLRuleOptions(networkACLID string, id string) *DeleteNetworkACLRuleOptions {
	return &DeleteNetworkACLRuleOptions{
		NetworkACLID: core.StringPtr(networkACLID),
		ID:           core.StringPtr(id),
	}
}

// SetNetworkACLID : Allow user to set NetworkACLID
func (options *DeleteNetworkACLRuleOptions) SetNetworkACLID(networkACLID string) *DeleteNetworkACLRuleOptions {
	options.NetworkACLID = core.StringPtr(networkACLID)
	return options
}

// SetID : Allow user to set ID
func (options *DeleteNetworkACLRuleOptions) SetID(id string) *DeleteNetworkACLRuleOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteNetworkACLRuleOptions) SetHeaders(param map[string]string) *DeleteNetworkACLRuleOptions {
	options.Headers = param
	return options
}

// DeletePublicGatewayOptions : The DeletePublicGateway options.
type DeletePublicGatewayOptions struct {
	// The public gateway identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeletePublicGatewayOptions : Instantiate DeletePublicGatewayOptions
func (*VpcV1) NewDeletePublicGatewayOptions(id string) *DeletePublicGatewayOptions {
	return &DeletePublicGatewayOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *DeletePublicGatewayOptions) SetID(id string) *DeletePublicGatewayOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeletePublicGatewayOptions) SetHeaders(param map[string]string) *DeletePublicGatewayOptions {
	options.Headers = param
	return options
}

// DeleteSecurityGroupOptions : The DeleteSecurityGroup options.
type DeleteSecurityGroupOptions struct {
	// The security group identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteSecurityGroupOptions : Instantiate DeleteSecurityGroupOptions
func (*VpcV1) NewDeleteSecurityGroupOptions(id string) *DeleteSecurityGroupOptions {
	return &DeleteSecurityGroupOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *DeleteSecurityGroupOptions) SetID(id string) *DeleteSecurityGroupOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteSecurityGroupOptions) SetHeaders(param map[string]string) *DeleteSecurityGroupOptions {
	options.Headers = param
	return options
}

// DeleteSecurityGroupRuleOptions : The DeleteSecurityGroupRule options.
type DeleteSecurityGroupRuleOptions struct {
	// The security group identifier.
	SecurityGroupID *string `json:"security_group_id" validate:"required"`

	// The rule identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteSecurityGroupRuleOptions : Instantiate DeleteSecurityGroupRuleOptions
func (*VpcV1) NewDeleteSecurityGroupRuleOptions(securityGroupID string, id string) *DeleteSecurityGroupRuleOptions {
	return &DeleteSecurityGroupRuleOptions{
		SecurityGroupID: core.StringPtr(securityGroupID),
		ID:              core.StringPtr(id),
	}
}

// SetSecurityGroupID : Allow user to set SecurityGroupID
func (options *DeleteSecurityGroupRuleOptions) SetSecurityGroupID(securityGroupID string) *DeleteSecurityGroupRuleOptions {
	options.SecurityGroupID = core.StringPtr(securityGroupID)
	return options
}

// SetID : Allow user to set ID
func (options *DeleteSecurityGroupRuleOptions) SetID(id string) *DeleteSecurityGroupRuleOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteSecurityGroupRuleOptions) SetHeaders(param map[string]string) *DeleteSecurityGroupRuleOptions {
	options.Headers = param
	return options
}

// DeleteSubnetOptions : The DeleteSubnet options.
type DeleteSubnetOptions struct {
	// The subnet identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteSubnetOptions : Instantiate DeleteSubnetOptions
func (*VpcV1) NewDeleteSubnetOptions(id string) *DeleteSubnetOptions {
	return &DeleteSubnetOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *DeleteSubnetOptions) SetID(id string) *DeleteSubnetOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteSubnetOptions) SetHeaders(param map[string]string) *DeleteSubnetOptions {
	options.Headers = param
	return options
}

// DeleteVolumeOptions : The DeleteVolume options.
type DeleteVolumeOptions struct {
	// The volume identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteVolumeOptions : Instantiate DeleteVolumeOptions
func (*VpcV1) NewDeleteVolumeOptions(id string) *DeleteVolumeOptions {
	return &DeleteVolumeOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *DeleteVolumeOptions) SetID(id string) *DeleteVolumeOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteVolumeOptions) SetHeaders(param map[string]string) *DeleteVolumeOptions {
	options.Headers = param
	return options
}

// DeleteVPCAddressPrefixOptions : The DeleteVPCAddressPrefix options.
type DeleteVPCAddressPrefixOptions struct {
	// The VPC identifier.
	VPCID *string `json:"vpc_id" validate:"required"`

	// The prefix identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteVPCAddressPrefixOptions : Instantiate DeleteVPCAddressPrefixOptions
func (*VpcV1) NewDeleteVPCAddressPrefixOptions(vpcID string, id string) *DeleteVPCAddressPrefixOptions {
	return &DeleteVPCAddressPrefixOptions{
		VPCID: core.StringPtr(vpcID),
		ID:    core.StringPtr(id),
	}
}

// SetVPCID : Allow user to set VPCID
func (options *DeleteVPCAddressPrefixOptions) SetVPCID(vpcID string) *DeleteVPCAddressPrefixOptions {
	options.VPCID = core.StringPtr(vpcID)
	return options
}

// SetID : Allow user to set ID
func (options *DeleteVPCAddressPrefixOptions) SetID(id string) *DeleteVPCAddressPrefixOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteVPCAddressPrefixOptions) SetHeaders(param map[string]string) *DeleteVPCAddressPrefixOptions {
	options.Headers = param
	return options
}

// DeleteVPCOptions : The DeleteVPC options.
type DeleteVPCOptions struct {
	// The VPC identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteVPCOptions : Instantiate DeleteVPCOptions
func (*VpcV1) NewDeleteVPCOptions(id string) *DeleteVPCOptions {
	return &DeleteVPCOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *DeleteVPCOptions) SetID(id string) *DeleteVPCOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteVPCOptions) SetHeaders(param map[string]string) *DeleteVPCOptions {
	options.Headers = param
	return options
}

// DeleteVPCRouteOptions : The DeleteVPCRoute options.
type DeleteVPCRouteOptions struct {
	// The VPC identifier.
	VPCID *string `json:"vpc_id" validate:"required"`

	// The route identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteVPCRouteOptions : Instantiate DeleteVPCRouteOptions
func (*VpcV1) NewDeleteVPCRouteOptions(vpcID string, id string) *DeleteVPCRouteOptions {
	return &DeleteVPCRouteOptions{
		VPCID: core.StringPtr(vpcID),
		ID:    core.StringPtr(id),
	}
}

// SetVPCID : Allow user to set VPCID
func (options *DeleteVPCRouteOptions) SetVPCID(vpcID string) *DeleteVPCRouteOptions {
	options.VPCID = core.StringPtr(vpcID)
	return options
}

// SetID : Allow user to set ID
func (options *DeleteVPCRouteOptions) SetID(id string) *DeleteVPCRouteOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteVPCRouteOptions) SetHeaders(param map[string]string) *DeleteVPCRouteOptions {
	options.Headers = param
	return options
}

// DeleteVPCRoutingTableOptions : The DeleteVPCRoutingTable options.
type DeleteVPCRoutingTableOptions struct {
	// The VPC identifier.
	VPCID *string `json:"vpc_id" validate:"required"`

	// The routing table identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteVPCRoutingTableOptions : Instantiate DeleteVPCRoutingTableOptions
func (*VpcV1) NewDeleteVPCRoutingTableOptions(vpcID string, id string) *DeleteVPCRoutingTableOptions {
	return &DeleteVPCRoutingTableOptions{
		VPCID: core.StringPtr(vpcID),
		ID:    core.StringPtr(id),
	}
}

// SetVPCID : Allow user to set VPCID
func (options *DeleteVPCRoutingTableOptions) SetVPCID(vpcID string) *DeleteVPCRoutingTableOptions {
	options.VPCID = core.StringPtr(vpcID)
	return options
}

// SetID : Allow user to set ID
func (options *DeleteVPCRoutingTableOptions) SetID(id string) *DeleteVPCRoutingTableOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteVPCRoutingTableOptions) SetHeaders(param map[string]string) *DeleteVPCRoutingTableOptions {
	options.Headers = param
	return options
}

// DeleteVPCRoutingTableRouteOptions : The DeleteVPCRoutingTableRoute options.
type DeleteVPCRoutingTableRouteOptions struct {
	// The VPC identifier.
	VPCID *string `json:"vpc_id" validate:"required"`

	// The routing table identifier.
	RoutingTableID *string `json:"routing_table_id" validate:"required"`

	// The VPC routing table route identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteVPCRoutingTableRouteOptions : Instantiate DeleteVPCRoutingTableRouteOptions
func (*VpcV1) NewDeleteVPCRoutingTableRouteOptions(vpcID string, routingTableID string, id string) *DeleteVPCRoutingTableRouteOptions {
	return &DeleteVPCRoutingTableRouteOptions{
		VPCID:          core.StringPtr(vpcID),
		RoutingTableID: core.StringPtr(routingTableID),
		ID:             core.StringPtr(id),
	}
}

// SetVPCID : Allow user to set VPCID
func (options *DeleteVPCRoutingTableRouteOptions) SetVPCID(vpcID string) *DeleteVPCRoutingTableRouteOptions {
	options.VPCID = core.StringPtr(vpcID)
	return options
}

// SetRoutingTableID : Allow user to set RoutingTableID
func (options *DeleteVPCRoutingTableRouteOptions) SetRoutingTableID(routingTableID string) *DeleteVPCRoutingTableRouteOptions {
	options.RoutingTableID = core.StringPtr(routingTableID)
	return options
}

// SetID : Allow user to set ID
func (options *DeleteVPCRoutingTableRouteOptions) SetID(id string) *DeleteVPCRoutingTableRouteOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteVPCRoutingTableRouteOptions) SetHeaders(param map[string]string) *DeleteVPCRoutingTableRouteOptions {
	options.Headers = param
	return options
}

// DeleteVPNGatewayConnectionOptions : The DeleteVPNGatewayConnection options.
type DeleteVPNGatewayConnectionOptions struct {
	// The VPN gateway identifier.
	VPNGatewayID *string `json:"vpn_gateway_id" validate:"required"`

	// The VPN connection identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteVPNGatewayConnectionOptions : Instantiate DeleteVPNGatewayConnectionOptions
func (*VpcV1) NewDeleteVPNGatewayConnectionOptions(vpnGatewayID string, id string) *DeleteVPNGatewayConnectionOptions {
	return &DeleteVPNGatewayConnectionOptions{
		VPNGatewayID: core.StringPtr(vpnGatewayID),
		ID:           core.StringPtr(id),
	}
}

// SetVPNGatewayID : Allow user to set VPNGatewayID
func (options *DeleteVPNGatewayConnectionOptions) SetVPNGatewayID(vpnGatewayID string) *DeleteVPNGatewayConnectionOptions {
	options.VPNGatewayID = core.StringPtr(vpnGatewayID)
	return options
}

// SetID : Allow user to set ID
func (options *DeleteVPNGatewayConnectionOptions) SetID(id string) *DeleteVPNGatewayConnectionOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteVPNGatewayConnectionOptions) SetHeaders(param map[string]string) *DeleteVPNGatewayConnectionOptions {
	options.Headers = param
	return options
}

// DeleteVPNGatewayOptions : The DeleteVPNGateway options.
type DeleteVPNGatewayOptions struct {
	// The VPN gateway identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteVPNGatewayOptions : Instantiate DeleteVPNGatewayOptions
func (*VpcV1) NewDeleteVPNGatewayOptions(id string) *DeleteVPNGatewayOptions {
	return &DeleteVPNGatewayOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *DeleteVPNGatewayOptions) SetID(id string) *DeleteVPNGatewayOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteVPNGatewayOptions) SetHeaders(param map[string]string) *DeleteVPNGatewayOptions {
	options.Headers = param
	return options
}

// EncryptionKeyIdentity : Identifies an encryption key by a unique property.
// Models which "extend" this model:
// - EncryptionKeyIdentityByCRN
type EncryptionKeyIdentity struct {
	// The CRN of the [Key Protect Root
	// Key](https://cloud.ibm.com/docs/key-protect?topic=key-protect-getting-started-tutorial) or [Hyper Protect Crypto
	// Service Root Key](https://cloud.ibm.com/docs/hs-crypto?topic=hs-crypto-get-started) for this resource.
	CRN *string `json:"crn,omitempty"`
}

func (*EncryptionKeyIdentity) isaEncryptionKeyIdentity() bool {
	return true
}

type EncryptionKeyIdentityIntf interface {
	isaEncryptionKeyIdentity() bool
}

// UnmarshalEncryptionKeyIdentity unmarshals an instance of EncryptionKeyIdentity from the specified map of raw messages.
func UnmarshalEncryptionKeyIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(EncryptionKeyIdentity)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// EncryptionKeyReference : EncryptionKeyReference struct
type EncryptionKeyReference struct {
	// The CRN of the [Key Protect Root
	// Key](https://cloud.ibm.com/docs/key-protect?topic=key-protect-getting-started-tutorial) or [Hyper Protect Crypto
	// Service Root Key](https://cloud.ibm.com/docs/hs-crypto?topic=hs-crypto-get-started) for this resource.
	CRN *string `json:"crn" validate:"required"`
}

// UnmarshalEncryptionKeyReference unmarshals an instance of EncryptionKeyReference from the specified map of raw messages.
func UnmarshalEncryptionKeyReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(EncryptionKeyReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FloatingIP : FloatingIP struct
type FloatingIP struct {
	// The globally unique IP address.
	Address *string `json:"address" validate:"required"`

	// The date and time that the floating IP was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The CRN for this floating IP.
	CRN *string `json:"crn" validate:"required"`

	// The URL for this floating IP.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this floating IP.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this floating IP.
	Name *string `json:"name" validate:"required"`

	// The resource group for this floating IP.
	ResourceGroup *ResourceGroupReference `json:"resource_group" validate:"required"`

	// The status of the floating IP.
	Status *string `json:"status" validate:"required"`

	// The target of this floating IP.
	Target FloatingIPTargetIntf `json:"target,omitempty"`

	// The zone the floating IP resides in.
	Zone *ZoneReference `json:"zone" validate:"required"`
}

// Constants associated with the FloatingIP.Status property.
// The status of the floating IP.
const (
	FloatingIPStatusAvailableConst = "available"
	FloatingIPStatusDeletingConst  = "deleting"
	FloatingIPStatusFailedConst    = "failed"
	FloatingIPStatusPendingConst   = "pending"
)

// UnmarshalFloatingIP unmarshals an instance of FloatingIP from the specified map of raw messages.
func UnmarshalFloatingIP(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FloatingIP)
	err = core.UnmarshalPrimitive(m, "address", &obj.Address)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "target", &obj.Target, UnmarshalFloatingIPTarget)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FloatingIPCollection : FloatingIPCollection struct
type FloatingIPCollection struct {
	// A reference to the first page of resources.
	First *FloatingIPCollectionFirst `json:"first" validate:"required"`

	// Collection of floating IPs.
	FloatingIps []FloatingIP `json:"floating_ips" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A reference to the next page of resources; this reference is included for all pages
	// except the last page.
	Next *FloatingIPCollectionNext `json:"next,omitempty"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalFloatingIPCollection unmarshals an instance of FloatingIPCollection from the specified map of raw messages.
func UnmarshalFloatingIPCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FloatingIPCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalFloatingIPCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "floating_ips", &obj.FloatingIps, UnmarshalFloatingIP)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalFloatingIPCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FloatingIPCollectionFirst : A reference to the first page of resources.
type FloatingIPCollectionFirst struct {
	// The URL for the first page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalFloatingIPCollectionFirst unmarshals an instance of FloatingIPCollectionFirst from the specified map of raw messages.
func UnmarshalFloatingIPCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FloatingIPCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FloatingIPCollectionNext : A reference to the next page of resources; this reference is included for all pages except the last page.
type FloatingIPCollectionNext struct {
	// The URL for the next page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalFloatingIPCollectionNext unmarshals an instance of FloatingIPCollectionNext from the specified map of raw messages.
func UnmarshalFloatingIPCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FloatingIPCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FloatingIPPrototype : FloatingIPPrototype struct
// Models which "extend" this model:
// - FloatingIPPrototypeFloatingIPByZone
// - FloatingIPPrototypeFloatingIPByTarget
type FloatingIPPrototype struct {
	// The unique user-defined name for this floating IP. If unspecified, the name will be a hyphenated list of
	// randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// The identity of the zone to provision a floating IP in.
	Zone ZoneIdentityIntf `json:"zone,omitempty"`

	// The target this address is to be bound to.
	Target NetworkInterfaceIdentityIntf `json:"target,omitempty"`
}

func (*FloatingIPPrototype) isaFloatingIPPrototype() bool {
	return true
}

type FloatingIPPrototypeIntf interface {
	isaFloatingIPPrototype() bool
}

// UnmarshalFloatingIPPrototype unmarshals an instance of FloatingIPPrototype from the specified map of raw messages.
func UnmarshalFloatingIPPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FloatingIPPrototype)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "target", &obj.Target, UnmarshalNetworkInterfaceIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FloatingIPReference : FloatingIPReference struct
type FloatingIPReference struct {
	// The globally unique IP address.
	Address *string `json:"address" validate:"required"`

	// The CRN for this floating IP.
	CRN *string `json:"crn" validate:"required"`

	// The URL for this floating IP.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this floating IP.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this floating IP.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalFloatingIPReference unmarshals an instance of FloatingIPReference from the specified map of raw messages.
func UnmarshalFloatingIPReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FloatingIPReference)
	err = core.UnmarshalPrimitive(m, "address", &obj.Address)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FloatingIPTarget : The target of this floating IP.
// Models which "extend" this model:
// - FloatingIPTargetNetworkInterfaceReference
// - FloatingIPTargetPublicGatewayReference
type FloatingIPTarget struct {
	// The URL for this network interface.
	Href *string `json:"href,omitempty"`

	// The unique identifier for this network interface.
	ID *string `json:"id,omitempty"`

	// The user-defined name for this network interface.
	Name *string `json:"name,omitempty"`

	// The primary IPv4 address.
	PrimaryIpv4Address *string `json:"primary_ipv4_address,omitempty"`

	// The type of resource referenced.
	ResourceType *string `json:"resource_type,omitempty"`

	// The CRN for this public gateway.
	CRN *string `json:"crn,omitempty"`
}

// Constants associated with the FloatingIPTarget.ResourceType property.
// The type of resource referenced.
const (
	FloatingIPTargetResourceTypeNetworkInterfaceConst = "network_interface"
)

func (*FloatingIPTarget) isaFloatingIPTarget() bool {
	return true
}

type FloatingIPTargetIntf interface {
	isaFloatingIPTarget() bool
}

// UnmarshalFloatingIPTarget unmarshals an instance of FloatingIPTarget from the specified map of raw messages.
func UnmarshalFloatingIPTarget(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FloatingIPTarget)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "primary_ipv4_address", &obj.PrimaryIpv4Address)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FloatingIPUnpaginatedCollection : FloatingIPUnpaginatedCollection struct
type FloatingIPUnpaginatedCollection struct {
	// Collection of floating IPs.
	FloatingIps []FloatingIP `json:"floating_ips" validate:"required"`
}

// UnmarshalFloatingIPUnpaginatedCollection unmarshals an instance of FloatingIPUnpaginatedCollection from the specified map of raw messages.
func UnmarshalFloatingIPUnpaginatedCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FloatingIPUnpaginatedCollection)
	err = core.UnmarshalModel(m, "floating_ips", &obj.FloatingIps, UnmarshalFloatingIP)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FlowLogCollector : FlowLogCollector struct
type FlowLogCollector struct {
	// Indicates whether this collector is active.
	Active *bool `json:"active" validate:"required"`

	// If set to `true`, this flow log collector will be automatically deleted when the target is deleted.
	AutoDelete *bool `json:"auto_delete" validate:"required"`

	// The date and time that the flow log collector was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The CRN for this flow log collector.
	CRN *string `json:"crn" validate:"required"`

	// The URL for this flow log collector.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this flow log collector.
	ID *string `json:"id" validate:"required"`

	// The lifecycle state of the flow log collector.
	LifecycleState *string `json:"lifecycle_state" validate:"required"`

	// The user-defined name for this flow log collector.
	Name *string `json:"name" validate:"required"`

	// The resource group for this flow log collector.
	ResourceGroup *ResourceGroupReference `json:"resource_group" validate:"required"`

	// The Cloud Object Storage bucket where the collected flows are logged.
	StorageBucket *CloudObjectStorageBucketReference `json:"storage_bucket" validate:"required"`

	// The target this collector is collecting flow logs for. If the target is an instance,
	// subnet, or VPC, flow logs will not be collected for any network interfaces within the
	// target that are themselves the target of a more specific flow log collector.
	Target FlowLogCollectorTargetIntf `json:"target" validate:"required"`

	// The VPC this flow log collector is associated with.
	VPC *VPCReference `json:"vpc" validate:"required"`
}

// Constants associated with the FlowLogCollector.LifecycleState property.
// The lifecycle state of the flow log collector.
const (
	FlowLogCollectorLifecycleStateDeletedConst  = "deleted"
	FlowLogCollectorLifecycleStateDeletingConst = "deleting"
	FlowLogCollectorLifecycleStateFailedConst   = "failed"
	FlowLogCollectorLifecycleStatePendingConst  = "pending"
	FlowLogCollectorLifecycleStateStableConst   = "stable"
	FlowLogCollectorLifecycleStateUpdatingConst = "updating"
	FlowLogCollectorLifecycleStateWaitingConst  = "waiting"
)

// UnmarshalFlowLogCollector unmarshals an instance of FlowLogCollector from the specified map of raw messages.
func UnmarshalFlowLogCollector(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FlowLogCollector)
	err = core.UnmarshalPrimitive(m, "active", &obj.Active)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "auto_delete", &obj.AutoDelete)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "lifecycle_state", &obj.LifecycleState)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "storage_bucket", &obj.StorageBucket, UnmarshalCloudObjectStorageBucketReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "target", &obj.Target, UnmarshalFlowLogCollectorTarget)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vpc", &obj.VPC, UnmarshalVPCReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FlowLogCollectorCollection : FlowLogCollectorCollection struct
type FlowLogCollectorCollection struct {
	// A reference to the first page of resources.
	First *FlowLogCollectorCollectionFirst `json:"first" validate:"required"`

	// Collection of flow log collectors.
	FlowLogCollectors []FlowLogCollector `json:"flow_log_collectors" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A reference to the next page of resources; this reference is included for all pages
	// except the last page.
	Next *FlowLogCollectorCollectionNext `json:"next,omitempty"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalFlowLogCollectorCollection unmarshals an instance of FlowLogCollectorCollection from the specified map of raw messages.
func UnmarshalFlowLogCollectorCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FlowLogCollectorCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalFlowLogCollectorCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "flow_log_collectors", &obj.FlowLogCollectors, UnmarshalFlowLogCollector)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalFlowLogCollectorCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FlowLogCollectorCollectionFirst : A reference to the first page of resources.
type FlowLogCollectorCollectionFirst struct {
	// The URL for the first page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalFlowLogCollectorCollectionFirst unmarshals an instance of FlowLogCollectorCollectionFirst from the specified map of raw messages.
func UnmarshalFlowLogCollectorCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FlowLogCollectorCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FlowLogCollectorCollectionNext : A reference to the next page of resources; this reference is included for all pages except the last page.
type FlowLogCollectorCollectionNext struct {
	// The URL for the next page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalFlowLogCollectorCollectionNext unmarshals an instance of FlowLogCollectorCollectionNext from the specified map of raw messages.
func UnmarshalFlowLogCollectorCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FlowLogCollectorCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FlowLogCollectorPrototypeTarget : The target this collector is to collect flow logs for. If the target is an instance, subnet, or VPC, flow logs will
// not be collected for any network interfaces within the target that are themselves the target of a more specific flow
// log collector.
// Models which "extend" this model:
// - FlowLogCollectorPrototypeTargetNetworkInterfaceIdentity
// - FlowLogCollectorPrototypeTargetInstanceIdentity
// - FlowLogCollectorPrototypeTargetSubnetIdentity
// - FlowLogCollectorPrototypeTargetVPCIdentity
type FlowLogCollectorPrototypeTarget struct {
	// The unique identifier for this network interface.
	ID *string `json:"id,omitempty"`

	// The URL for this network interface.
	Href *string `json:"href,omitempty"`

	// The CRN for this virtual server instance.
	CRN *string `json:"crn,omitempty"`
}

func (*FlowLogCollectorPrototypeTarget) isaFlowLogCollectorPrototypeTarget() bool {
	return true
}

type FlowLogCollectorPrototypeTargetIntf interface {
	isaFlowLogCollectorPrototypeTarget() bool
}

// UnmarshalFlowLogCollectorPrototypeTarget unmarshals an instance of FlowLogCollectorPrototypeTarget from the specified map of raw messages.
func UnmarshalFlowLogCollectorPrototypeTarget(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FlowLogCollectorPrototypeTarget)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FlowLogCollectorTarget : The target this collector is collecting flow logs for. If the target is an instance, subnet, or VPC, flow logs will
// not be collected for any network interfaces within the target that are themselves the target of a more specific flow
// log collector.
// Models which "extend" this model:
// - FlowLogCollectorTargetNetworkInterfaceReferenceTargetContext
// - FlowLogCollectorTargetInstanceReference
// - FlowLogCollectorTargetSubnetReference
// - FlowLogCollectorTargetVPCReference
type FlowLogCollectorTarget struct {
	// The URL for this network interface.
	Href *string `json:"href,omitempty"`

	// The unique identifier for this network interface.
	ID *string `json:"id,omitempty"`

	// The user-defined name for this network interface.
	Name *string `json:"name,omitempty"`

	// The type of resource referenced.
	ResourceType *string `json:"resource_type,omitempty"`

	// The CRN for this virtual server instance.
	CRN *string `json:"crn,omitempty"`
}

// Constants associated with the FlowLogCollectorTarget.ResourceType property.
// The type of resource referenced.
const (
	FlowLogCollectorTargetResourceTypeNetworkInterfaceConst = "network_interface"
)

func (*FlowLogCollectorTarget) isaFlowLogCollectorTarget() bool {
	return true
}

type FlowLogCollectorTargetIntf interface {
	isaFlowLogCollectorTarget() bool
}

// UnmarshalFlowLogCollectorTarget unmarshals an instance of FlowLogCollectorTarget from the specified map of raw messages.
func UnmarshalFlowLogCollectorTarget(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FlowLogCollectorTarget)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GetDedicatedHostGroupOptions : The GetDedicatedHostGroup options.
type GetDedicatedHostGroupOptions struct {
	// The dedicated host group identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetDedicatedHostGroupOptions : Instantiate GetDedicatedHostGroupOptions
func (*VpcV1) NewGetDedicatedHostGroupOptions(id string) *GetDedicatedHostGroupOptions {
	return &GetDedicatedHostGroupOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *GetDedicatedHostGroupOptions) SetID(id string) *GetDedicatedHostGroupOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetDedicatedHostGroupOptions) SetHeaders(param map[string]string) *GetDedicatedHostGroupOptions {
	options.Headers = param
	return options
}

// GetDedicatedHostOptions : The GetDedicatedHost options.
type GetDedicatedHostOptions struct {
	// The dedicated host identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetDedicatedHostOptions : Instantiate GetDedicatedHostOptions
func (*VpcV1) NewGetDedicatedHostOptions(id string) *GetDedicatedHostOptions {
	return &GetDedicatedHostOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *GetDedicatedHostOptions) SetID(id string) *GetDedicatedHostOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetDedicatedHostOptions) SetHeaders(param map[string]string) *GetDedicatedHostOptions {
	options.Headers = param
	return options
}

// GetDedicatedHostProfileOptions : The GetDedicatedHostProfile options.
type GetDedicatedHostProfileOptions struct {
	// The dedicated host profile name.
	Name *string `json:"name" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetDedicatedHostProfileOptions : Instantiate GetDedicatedHostProfileOptions
func (*VpcV1) NewGetDedicatedHostProfileOptions(name string) *GetDedicatedHostProfileOptions {
	return &GetDedicatedHostProfileOptions{
		Name: core.StringPtr(name),
	}
}

// SetName : Allow user to set Name
func (options *GetDedicatedHostProfileOptions) SetName(name string) *GetDedicatedHostProfileOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetDedicatedHostProfileOptions) SetHeaders(param map[string]string) *GetDedicatedHostProfileOptions {
	options.Headers = param
	return options
}

// GetFloatingIPOptions : The GetFloatingIP options.
type GetFloatingIPOptions struct {
	// The floating IP identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetFloatingIPOptions : Instantiate GetFloatingIPOptions
func (*VpcV1) NewGetFloatingIPOptions(id string) *GetFloatingIPOptions {
	return &GetFloatingIPOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *GetFloatingIPOptions) SetID(id string) *GetFloatingIPOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetFloatingIPOptions) SetHeaders(param map[string]string) *GetFloatingIPOptions {
	options.Headers = param
	return options
}

// GetFlowLogCollectorOptions : The GetFlowLogCollector options.
type GetFlowLogCollectorOptions struct {
	// The flow log collector identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetFlowLogCollectorOptions : Instantiate GetFlowLogCollectorOptions
func (*VpcV1) NewGetFlowLogCollectorOptions(id string) *GetFlowLogCollectorOptions {
	return &GetFlowLogCollectorOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *GetFlowLogCollectorOptions) SetID(id string) *GetFlowLogCollectorOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetFlowLogCollectorOptions) SetHeaders(param map[string]string) *GetFlowLogCollectorOptions {
	options.Headers = param
	return options
}

// GetIkePolicyOptions : The GetIkePolicy options.
type GetIkePolicyOptions struct {
	// The IKE policy identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetIkePolicyOptions : Instantiate GetIkePolicyOptions
func (*VpcV1) NewGetIkePolicyOptions(id string) *GetIkePolicyOptions {
	return &GetIkePolicyOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *GetIkePolicyOptions) SetID(id string) *GetIkePolicyOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetIkePolicyOptions) SetHeaders(param map[string]string) *GetIkePolicyOptions {
	options.Headers = param
	return options
}

// GetImageOptions : The GetImage options.
type GetImageOptions struct {
	// The image identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetImageOptions : Instantiate GetImageOptions
func (*VpcV1) NewGetImageOptions(id string) *GetImageOptions {
	return &GetImageOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *GetImageOptions) SetID(id string) *GetImageOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetImageOptions) SetHeaders(param map[string]string) *GetImageOptions {
	options.Headers = param
	return options
}

// GetInstanceGroupManagerOptions : The GetInstanceGroupManager options.
type GetInstanceGroupManagerOptions struct {
	// The instance group identifier.
	InstanceGroupID *string `json:"instance_group_id" validate:"required"`

	// The instance group manager identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetInstanceGroupManagerOptions : Instantiate GetInstanceGroupManagerOptions
func (*VpcV1) NewGetInstanceGroupManagerOptions(instanceGroupID string, id string) *GetInstanceGroupManagerOptions {
	return &GetInstanceGroupManagerOptions{
		InstanceGroupID: core.StringPtr(instanceGroupID),
		ID:              core.StringPtr(id),
	}
}

// SetInstanceGroupID : Allow user to set InstanceGroupID
func (options *GetInstanceGroupManagerOptions) SetInstanceGroupID(instanceGroupID string) *GetInstanceGroupManagerOptions {
	options.InstanceGroupID = core.StringPtr(instanceGroupID)
	return options
}

// SetID : Allow user to set ID
func (options *GetInstanceGroupManagerOptions) SetID(id string) *GetInstanceGroupManagerOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetInstanceGroupManagerOptions) SetHeaders(param map[string]string) *GetInstanceGroupManagerOptions {
	options.Headers = param
	return options
}

// GetInstanceGroupManagerPolicyOptions : The GetInstanceGroupManagerPolicy options.
type GetInstanceGroupManagerPolicyOptions struct {
	// The instance group identifier.
	InstanceGroupID *string `json:"instance_group_id" validate:"required"`

	// The instance group manager identifier.
	InstanceGroupManagerID *string `json:"instance_group_manager_id" validate:"required"`

	// The instance group manager policy identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetInstanceGroupManagerPolicyOptions : Instantiate GetInstanceGroupManagerPolicyOptions
func (*VpcV1) NewGetInstanceGroupManagerPolicyOptions(instanceGroupID string, instanceGroupManagerID string, id string) *GetInstanceGroupManagerPolicyOptions {
	return &GetInstanceGroupManagerPolicyOptions{
		InstanceGroupID:        core.StringPtr(instanceGroupID),
		InstanceGroupManagerID: core.StringPtr(instanceGroupManagerID),
		ID:                     core.StringPtr(id),
	}
}

// SetInstanceGroupID : Allow user to set InstanceGroupID
func (options *GetInstanceGroupManagerPolicyOptions) SetInstanceGroupID(instanceGroupID string) *GetInstanceGroupManagerPolicyOptions {
	options.InstanceGroupID = core.StringPtr(instanceGroupID)
	return options
}

// SetInstanceGroupManagerID : Allow user to set InstanceGroupManagerID
func (options *GetInstanceGroupManagerPolicyOptions) SetInstanceGroupManagerID(instanceGroupManagerID string) *GetInstanceGroupManagerPolicyOptions {
	options.InstanceGroupManagerID = core.StringPtr(instanceGroupManagerID)
	return options
}

// SetID : Allow user to set ID
func (options *GetInstanceGroupManagerPolicyOptions) SetID(id string) *GetInstanceGroupManagerPolicyOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetInstanceGroupManagerPolicyOptions) SetHeaders(param map[string]string) *GetInstanceGroupManagerPolicyOptions {
	options.Headers = param
	return options
}

// GetInstanceGroupMembershipOptions : The GetInstanceGroupMembership options.
type GetInstanceGroupMembershipOptions struct {
	// The instance group identifier.
	InstanceGroupID *string `json:"instance_group_id" validate:"required"`

	// The instance group membership identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetInstanceGroupMembershipOptions : Instantiate GetInstanceGroupMembershipOptions
func (*VpcV1) NewGetInstanceGroupMembershipOptions(instanceGroupID string, id string) *GetInstanceGroupMembershipOptions {
	return &GetInstanceGroupMembershipOptions{
		InstanceGroupID: core.StringPtr(instanceGroupID),
		ID:              core.StringPtr(id),
	}
}

// SetInstanceGroupID : Allow user to set InstanceGroupID
func (options *GetInstanceGroupMembershipOptions) SetInstanceGroupID(instanceGroupID string) *GetInstanceGroupMembershipOptions {
	options.InstanceGroupID = core.StringPtr(instanceGroupID)
	return options
}

// SetID : Allow user to set ID
func (options *GetInstanceGroupMembershipOptions) SetID(id string) *GetInstanceGroupMembershipOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetInstanceGroupMembershipOptions) SetHeaders(param map[string]string) *GetInstanceGroupMembershipOptions {
	options.Headers = param
	return options
}

// GetInstanceGroupOptions : The GetInstanceGroup options.
type GetInstanceGroupOptions struct {
	// The instance group identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetInstanceGroupOptions : Instantiate GetInstanceGroupOptions
func (*VpcV1) NewGetInstanceGroupOptions(id string) *GetInstanceGroupOptions {
	return &GetInstanceGroupOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *GetInstanceGroupOptions) SetID(id string) *GetInstanceGroupOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetInstanceGroupOptions) SetHeaders(param map[string]string) *GetInstanceGroupOptions {
	options.Headers = param
	return options
}

// GetInstanceInitializationOptions : The GetInstanceInitialization options.
type GetInstanceInitializationOptions struct {
	// The instance identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetInstanceInitializationOptions : Instantiate GetInstanceInitializationOptions
func (*VpcV1) NewGetInstanceInitializationOptions(id string) *GetInstanceInitializationOptions {
	return &GetInstanceInitializationOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *GetInstanceInitializationOptions) SetID(id string) *GetInstanceInitializationOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetInstanceInitializationOptions) SetHeaders(param map[string]string) *GetInstanceInitializationOptions {
	options.Headers = param
	return options
}

// GetInstanceNetworkInterfaceFloatingIPOptions : The GetInstanceNetworkInterfaceFloatingIP options.
type GetInstanceNetworkInterfaceFloatingIPOptions struct {
	// The instance identifier.
	InstanceID *string `json:"instance_id" validate:"required"`

	// The network interface identifier.
	NetworkInterfaceID *string `json:"network_interface_id" validate:"required"`

	// The floating IP identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetInstanceNetworkInterfaceFloatingIPOptions : Instantiate GetInstanceNetworkInterfaceFloatingIPOptions
func (*VpcV1) NewGetInstanceNetworkInterfaceFloatingIPOptions(instanceID string, networkInterfaceID string, id string) *GetInstanceNetworkInterfaceFloatingIPOptions {
	return &GetInstanceNetworkInterfaceFloatingIPOptions{
		InstanceID:         core.StringPtr(instanceID),
		NetworkInterfaceID: core.StringPtr(networkInterfaceID),
		ID:                 core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (options *GetInstanceNetworkInterfaceFloatingIPOptions) SetInstanceID(instanceID string) *GetInstanceNetworkInterfaceFloatingIPOptions {
	options.InstanceID = core.StringPtr(instanceID)
	return options
}

// SetNetworkInterfaceID : Allow user to set NetworkInterfaceID
func (options *GetInstanceNetworkInterfaceFloatingIPOptions) SetNetworkInterfaceID(networkInterfaceID string) *GetInstanceNetworkInterfaceFloatingIPOptions {
	options.NetworkInterfaceID = core.StringPtr(networkInterfaceID)
	return options
}

// SetID : Allow user to set ID
func (options *GetInstanceNetworkInterfaceFloatingIPOptions) SetID(id string) *GetInstanceNetworkInterfaceFloatingIPOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetInstanceNetworkInterfaceFloatingIPOptions) SetHeaders(param map[string]string) *GetInstanceNetworkInterfaceFloatingIPOptions {
	options.Headers = param
	return options
}

// GetInstanceNetworkInterfaceOptions : The GetInstanceNetworkInterface options.
type GetInstanceNetworkInterfaceOptions struct {
	// The instance identifier.
	InstanceID *string `json:"instance_id" validate:"required"`

	// The network interface identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetInstanceNetworkInterfaceOptions : Instantiate GetInstanceNetworkInterfaceOptions
func (*VpcV1) NewGetInstanceNetworkInterfaceOptions(instanceID string, id string) *GetInstanceNetworkInterfaceOptions {
	return &GetInstanceNetworkInterfaceOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (options *GetInstanceNetworkInterfaceOptions) SetInstanceID(instanceID string) *GetInstanceNetworkInterfaceOptions {
	options.InstanceID = core.StringPtr(instanceID)
	return options
}

// SetID : Allow user to set ID
func (options *GetInstanceNetworkInterfaceOptions) SetID(id string) *GetInstanceNetworkInterfaceOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetInstanceNetworkInterfaceOptions) SetHeaders(param map[string]string) *GetInstanceNetworkInterfaceOptions {
	options.Headers = param
	return options
}

// GetInstanceOptions : The GetInstance options.
type GetInstanceOptions struct {
	// The instance identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetInstanceOptions : Instantiate GetInstanceOptions
func (*VpcV1) NewGetInstanceOptions(id string) *GetInstanceOptions {
	return &GetInstanceOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *GetInstanceOptions) SetID(id string) *GetInstanceOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetInstanceOptions) SetHeaders(param map[string]string) *GetInstanceOptions {
	options.Headers = param
	return options
}

// GetInstanceProfileOptions : The GetInstanceProfile options.
type GetInstanceProfileOptions struct {
	// The instance profile name.
	Name *string `json:"name" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetInstanceProfileOptions : Instantiate GetInstanceProfileOptions
func (*VpcV1) NewGetInstanceProfileOptions(name string) *GetInstanceProfileOptions {
	return &GetInstanceProfileOptions{
		Name: core.StringPtr(name),
	}
}

// SetName : Allow user to set Name
func (options *GetInstanceProfileOptions) SetName(name string) *GetInstanceProfileOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetInstanceProfileOptions) SetHeaders(param map[string]string) *GetInstanceProfileOptions {
	options.Headers = param
	return options
}

// GetInstanceTemplateOptions : The GetInstanceTemplate options.
type GetInstanceTemplateOptions struct {
	// The instance template identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetInstanceTemplateOptions : Instantiate GetInstanceTemplateOptions
func (*VpcV1) NewGetInstanceTemplateOptions(id string) *GetInstanceTemplateOptions {
	return &GetInstanceTemplateOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *GetInstanceTemplateOptions) SetID(id string) *GetInstanceTemplateOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetInstanceTemplateOptions) SetHeaders(param map[string]string) *GetInstanceTemplateOptions {
	options.Headers = param
	return options
}

// GetInstanceVolumeAttachmentOptions : The GetInstanceVolumeAttachment options.
type GetInstanceVolumeAttachmentOptions struct {
	// The instance identifier.
	InstanceID *string `json:"instance_id" validate:"required"`

	// The volume attachment identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetInstanceVolumeAttachmentOptions : Instantiate GetInstanceVolumeAttachmentOptions
func (*VpcV1) NewGetInstanceVolumeAttachmentOptions(instanceID string, id string) *GetInstanceVolumeAttachmentOptions {
	return &GetInstanceVolumeAttachmentOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (options *GetInstanceVolumeAttachmentOptions) SetInstanceID(instanceID string) *GetInstanceVolumeAttachmentOptions {
	options.InstanceID = core.StringPtr(instanceID)
	return options
}

// SetID : Allow user to set ID
func (options *GetInstanceVolumeAttachmentOptions) SetID(id string) *GetInstanceVolumeAttachmentOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetInstanceVolumeAttachmentOptions) SetHeaders(param map[string]string) *GetInstanceVolumeAttachmentOptions {
	options.Headers = param
	return options
}

// GetIpsecPolicyOptions : The GetIpsecPolicy options.
type GetIpsecPolicyOptions struct {
	// The IPsec policy identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetIpsecPolicyOptions : Instantiate GetIpsecPolicyOptions
func (*VpcV1) NewGetIpsecPolicyOptions(id string) *GetIpsecPolicyOptions {
	return &GetIpsecPolicyOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *GetIpsecPolicyOptions) SetID(id string) *GetIpsecPolicyOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetIpsecPolicyOptions) SetHeaders(param map[string]string) *GetIpsecPolicyOptions {
	options.Headers = param
	return options
}

// GetKeyOptions : The GetKey options.
type GetKeyOptions struct {
	// The key identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetKeyOptions : Instantiate GetKeyOptions
func (*VpcV1) NewGetKeyOptions(id string) *GetKeyOptions {
	return &GetKeyOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *GetKeyOptions) SetID(id string) *GetKeyOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetKeyOptions) SetHeaders(param map[string]string) *GetKeyOptions {
	options.Headers = param
	return options
}

// GetLoadBalancerListenerOptions : The GetLoadBalancerListener options.
type GetLoadBalancerListenerOptions struct {
	// The load balancer identifier.
	LoadBalancerID *string `json:"load_balancer_id" validate:"required"`

	// The listener identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetLoadBalancerListenerOptions : Instantiate GetLoadBalancerListenerOptions
func (*VpcV1) NewGetLoadBalancerListenerOptions(loadBalancerID string, id string) *GetLoadBalancerListenerOptions {
	return &GetLoadBalancerListenerOptions{
		LoadBalancerID: core.StringPtr(loadBalancerID),
		ID:             core.StringPtr(id),
	}
}

// SetLoadBalancerID : Allow user to set LoadBalancerID
func (options *GetLoadBalancerListenerOptions) SetLoadBalancerID(loadBalancerID string) *GetLoadBalancerListenerOptions {
	options.LoadBalancerID = core.StringPtr(loadBalancerID)
	return options
}

// SetID : Allow user to set ID
func (options *GetLoadBalancerListenerOptions) SetID(id string) *GetLoadBalancerListenerOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetLoadBalancerListenerOptions) SetHeaders(param map[string]string) *GetLoadBalancerListenerOptions {
	options.Headers = param
	return options
}

// GetLoadBalancerListenerPolicyOptions : The GetLoadBalancerListenerPolicy options.
type GetLoadBalancerListenerPolicyOptions struct {
	// The load balancer identifier.
	LoadBalancerID *string `json:"load_balancer_id" validate:"required"`

	// The listener identifier.
	ListenerID *string `json:"listener_id" validate:"required"`

	// The policy identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetLoadBalancerListenerPolicyOptions : Instantiate GetLoadBalancerListenerPolicyOptions
func (*VpcV1) NewGetLoadBalancerListenerPolicyOptions(loadBalancerID string, listenerID string, id string) *GetLoadBalancerListenerPolicyOptions {
	return &GetLoadBalancerListenerPolicyOptions{
		LoadBalancerID: core.StringPtr(loadBalancerID),
		ListenerID:     core.StringPtr(listenerID),
		ID:             core.StringPtr(id),
	}
}

// SetLoadBalancerID : Allow user to set LoadBalancerID
func (options *GetLoadBalancerListenerPolicyOptions) SetLoadBalancerID(loadBalancerID string) *GetLoadBalancerListenerPolicyOptions {
	options.LoadBalancerID = core.StringPtr(loadBalancerID)
	return options
}

// SetListenerID : Allow user to set ListenerID
func (options *GetLoadBalancerListenerPolicyOptions) SetListenerID(listenerID string) *GetLoadBalancerListenerPolicyOptions {
	options.ListenerID = core.StringPtr(listenerID)
	return options
}

// SetID : Allow user to set ID
func (options *GetLoadBalancerListenerPolicyOptions) SetID(id string) *GetLoadBalancerListenerPolicyOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetLoadBalancerListenerPolicyOptions) SetHeaders(param map[string]string) *GetLoadBalancerListenerPolicyOptions {
	options.Headers = param
	return options
}

// GetLoadBalancerListenerPolicyRuleOptions : The GetLoadBalancerListenerPolicyRule options.
type GetLoadBalancerListenerPolicyRuleOptions struct {
	// The load balancer identifier.
	LoadBalancerID *string `json:"load_balancer_id" validate:"required"`

	// The listener identifier.
	ListenerID *string `json:"listener_id" validate:"required"`

	// The policy identifier.
	PolicyID *string `json:"policy_id" validate:"required"`

	// The rule identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetLoadBalancerListenerPolicyRuleOptions : Instantiate GetLoadBalancerListenerPolicyRuleOptions
func (*VpcV1) NewGetLoadBalancerListenerPolicyRuleOptions(loadBalancerID string, listenerID string, policyID string, id string) *GetLoadBalancerListenerPolicyRuleOptions {
	return &GetLoadBalancerListenerPolicyRuleOptions{
		LoadBalancerID: core.StringPtr(loadBalancerID),
		ListenerID:     core.StringPtr(listenerID),
		PolicyID:       core.StringPtr(policyID),
		ID:             core.StringPtr(id),
	}
}

// SetLoadBalancerID : Allow user to set LoadBalancerID
func (options *GetLoadBalancerListenerPolicyRuleOptions) SetLoadBalancerID(loadBalancerID string) *GetLoadBalancerListenerPolicyRuleOptions {
	options.LoadBalancerID = core.StringPtr(loadBalancerID)
	return options
}

// SetListenerID : Allow user to set ListenerID
func (options *GetLoadBalancerListenerPolicyRuleOptions) SetListenerID(listenerID string) *GetLoadBalancerListenerPolicyRuleOptions {
	options.ListenerID = core.StringPtr(listenerID)
	return options
}

// SetPolicyID : Allow user to set PolicyID
func (options *GetLoadBalancerListenerPolicyRuleOptions) SetPolicyID(policyID string) *GetLoadBalancerListenerPolicyRuleOptions {
	options.PolicyID = core.StringPtr(policyID)
	return options
}

// SetID : Allow user to set ID
func (options *GetLoadBalancerListenerPolicyRuleOptions) SetID(id string) *GetLoadBalancerListenerPolicyRuleOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetLoadBalancerListenerPolicyRuleOptions) SetHeaders(param map[string]string) *GetLoadBalancerListenerPolicyRuleOptions {
	options.Headers = param
	return options
}

// GetLoadBalancerOptions : The GetLoadBalancer options.
type GetLoadBalancerOptions struct {
	// The load balancer identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetLoadBalancerOptions : Instantiate GetLoadBalancerOptions
func (*VpcV1) NewGetLoadBalancerOptions(id string) *GetLoadBalancerOptions {
	return &GetLoadBalancerOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *GetLoadBalancerOptions) SetID(id string) *GetLoadBalancerOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetLoadBalancerOptions) SetHeaders(param map[string]string) *GetLoadBalancerOptions {
	options.Headers = param
	return options
}

// GetLoadBalancerPoolMemberOptions : The GetLoadBalancerPoolMember options.
type GetLoadBalancerPoolMemberOptions struct {
	// The load balancer identifier.
	LoadBalancerID *string `json:"load_balancer_id" validate:"required"`

	// The pool identifier.
	PoolID *string `json:"pool_id" validate:"required"`

	// The member identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetLoadBalancerPoolMemberOptions : Instantiate GetLoadBalancerPoolMemberOptions
func (*VpcV1) NewGetLoadBalancerPoolMemberOptions(loadBalancerID string, poolID string, id string) *GetLoadBalancerPoolMemberOptions {
	return &GetLoadBalancerPoolMemberOptions{
		LoadBalancerID: core.StringPtr(loadBalancerID),
		PoolID:         core.StringPtr(poolID),
		ID:             core.StringPtr(id),
	}
}

// SetLoadBalancerID : Allow user to set LoadBalancerID
func (options *GetLoadBalancerPoolMemberOptions) SetLoadBalancerID(loadBalancerID string) *GetLoadBalancerPoolMemberOptions {
	options.LoadBalancerID = core.StringPtr(loadBalancerID)
	return options
}

// SetPoolID : Allow user to set PoolID
func (options *GetLoadBalancerPoolMemberOptions) SetPoolID(poolID string) *GetLoadBalancerPoolMemberOptions {
	options.PoolID = core.StringPtr(poolID)
	return options
}

// SetID : Allow user to set ID
func (options *GetLoadBalancerPoolMemberOptions) SetID(id string) *GetLoadBalancerPoolMemberOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetLoadBalancerPoolMemberOptions) SetHeaders(param map[string]string) *GetLoadBalancerPoolMemberOptions {
	options.Headers = param
	return options
}

// GetLoadBalancerPoolOptions : The GetLoadBalancerPool options.
type GetLoadBalancerPoolOptions struct {
	// The load balancer identifier.
	LoadBalancerID *string `json:"load_balancer_id" validate:"required"`

	// The pool identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetLoadBalancerPoolOptions : Instantiate GetLoadBalancerPoolOptions
func (*VpcV1) NewGetLoadBalancerPoolOptions(loadBalancerID string, id string) *GetLoadBalancerPoolOptions {
	return &GetLoadBalancerPoolOptions{
		LoadBalancerID: core.StringPtr(loadBalancerID),
		ID:             core.StringPtr(id),
	}
}

// SetLoadBalancerID : Allow user to set LoadBalancerID
func (options *GetLoadBalancerPoolOptions) SetLoadBalancerID(loadBalancerID string) *GetLoadBalancerPoolOptions {
	options.LoadBalancerID = core.StringPtr(loadBalancerID)
	return options
}

// SetID : Allow user to set ID
func (options *GetLoadBalancerPoolOptions) SetID(id string) *GetLoadBalancerPoolOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetLoadBalancerPoolOptions) SetHeaders(param map[string]string) *GetLoadBalancerPoolOptions {
	options.Headers = param
	return options
}

// GetLoadBalancerProfileOptions : The GetLoadBalancerProfile options.
type GetLoadBalancerProfileOptions struct {
	// The load balancer profile name.
	Name *string `json:"name" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetLoadBalancerProfileOptions : Instantiate GetLoadBalancerProfileOptions
func (*VpcV1) NewGetLoadBalancerProfileOptions(name string) *GetLoadBalancerProfileOptions {
	return &GetLoadBalancerProfileOptions{
		Name: core.StringPtr(name),
	}
}

// SetName : Allow user to set Name
func (options *GetLoadBalancerProfileOptions) SetName(name string) *GetLoadBalancerProfileOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetLoadBalancerProfileOptions) SetHeaders(param map[string]string) *GetLoadBalancerProfileOptions {
	options.Headers = param
	return options
}

// GetLoadBalancerStatisticsOptions : The GetLoadBalancerStatistics options.
type GetLoadBalancerStatisticsOptions struct {
	// The load balancer identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetLoadBalancerStatisticsOptions : Instantiate GetLoadBalancerStatisticsOptions
func (*VpcV1) NewGetLoadBalancerStatisticsOptions(id string) *GetLoadBalancerStatisticsOptions {
	return &GetLoadBalancerStatisticsOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *GetLoadBalancerStatisticsOptions) SetID(id string) *GetLoadBalancerStatisticsOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetLoadBalancerStatisticsOptions) SetHeaders(param map[string]string) *GetLoadBalancerStatisticsOptions {
	options.Headers = param
	return options
}

// GetNetworkACLOptions : The GetNetworkACL options.
type GetNetworkACLOptions struct {
	// The network ACL identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetNetworkACLOptions : Instantiate GetNetworkACLOptions
func (*VpcV1) NewGetNetworkACLOptions(id string) *GetNetworkACLOptions {
	return &GetNetworkACLOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *GetNetworkACLOptions) SetID(id string) *GetNetworkACLOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetNetworkACLOptions) SetHeaders(param map[string]string) *GetNetworkACLOptions {
	options.Headers = param
	return options
}

// GetNetworkACLRuleOptions : The GetNetworkACLRule options.
type GetNetworkACLRuleOptions struct {
	// The network ACL identifier.
	NetworkACLID *string `json:"network_acl_id" validate:"required"`

	// The rule identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetNetworkACLRuleOptions : Instantiate GetNetworkACLRuleOptions
func (*VpcV1) NewGetNetworkACLRuleOptions(networkACLID string, id string) *GetNetworkACLRuleOptions {
	return &GetNetworkACLRuleOptions{
		NetworkACLID: core.StringPtr(networkACLID),
		ID:           core.StringPtr(id),
	}
}

// SetNetworkACLID : Allow user to set NetworkACLID
func (options *GetNetworkACLRuleOptions) SetNetworkACLID(networkACLID string) *GetNetworkACLRuleOptions {
	options.NetworkACLID = core.StringPtr(networkACLID)
	return options
}

// SetID : Allow user to set ID
func (options *GetNetworkACLRuleOptions) SetID(id string) *GetNetworkACLRuleOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetNetworkACLRuleOptions) SetHeaders(param map[string]string) *GetNetworkACLRuleOptions {
	options.Headers = param
	return options
}

// GetOperatingSystemOptions : The GetOperatingSystem options.
type GetOperatingSystemOptions struct {
	// The operating system name.
	Name *string `json:"name" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetOperatingSystemOptions : Instantiate GetOperatingSystemOptions
func (*VpcV1) NewGetOperatingSystemOptions(name string) *GetOperatingSystemOptions {
	return &GetOperatingSystemOptions{
		Name: core.StringPtr(name),
	}
}

// SetName : Allow user to set Name
func (options *GetOperatingSystemOptions) SetName(name string) *GetOperatingSystemOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetOperatingSystemOptions) SetHeaders(param map[string]string) *GetOperatingSystemOptions {
	options.Headers = param
	return options
}

// GetPublicGatewayOptions : The GetPublicGateway options.
type GetPublicGatewayOptions struct {
	// The public gateway identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetPublicGatewayOptions : Instantiate GetPublicGatewayOptions
func (*VpcV1) NewGetPublicGatewayOptions(id string) *GetPublicGatewayOptions {
	return &GetPublicGatewayOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *GetPublicGatewayOptions) SetID(id string) *GetPublicGatewayOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetPublicGatewayOptions) SetHeaders(param map[string]string) *GetPublicGatewayOptions {
	options.Headers = param
	return options
}

// GetRegionOptions : The GetRegion options.
type GetRegionOptions struct {
	// The region name.
	Name *string `json:"name" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetRegionOptions : Instantiate GetRegionOptions
func (*VpcV1) NewGetRegionOptions(name string) *GetRegionOptions {
	return &GetRegionOptions{
		Name: core.StringPtr(name),
	}
}

// SetName : Allow user to set Name
func (options *GetRegionOptions) SetName(name string) *GetRegionOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetRegionOptions) SetHeaders(param map[string]string) *GetRegionOptions {
	options.Headers = param
	return options
}

// GetRegionZoneOptions : The GetRegionZone options.
type GetRegionZoneOptions struct {
	// The region name.
	RegionName *string `json:"region_name" validate:"required"`

	// The zone name.
	ZoneName *string `json:"zone_name" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetRegionZoneOptions : Instantiate GetRegionZoneOptions
func (*VpcV1) NewGetRegionZoneOptions(regionName string, zoneName string) *GetRegionZoneOptions {
	return &GetRegionZoneOptions{
		RegionName: core.StringPtr(regionName),
		ZoneName:   core.StringPtr(zoneName),
	}
}

// SetRegionName : Allow user to set RegionName
func (options *GetRegionZoneOptions) SetRegionName(regionName string) *GetRegionZoneOptions {
	options.RegionName = core.StringPtr(regionName)
	return options
}

// SetZoneName : Allow user to set ZoneName
func (options *GetRegionZoneOptions) SetZoneName(zoneName string) *GetRegionZoneOptions {
	options.ZoneName = core.StringPtr(zoneName)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetRegionZoneOptions) SetHeaders(param map[string]string) *GetRegionZoneOptions {
	options.Headers = param
	return options
}

// GetSecurityGroupNetworkInterfaceOptions : The GetSecurityGroupNetworkInterface options.
type GetSecurityGroupNetworkInterfaceOptions struct {
	// The security group identifier.
	SecurityGroupID *string `json:"security_group_id" validate:"required"`

	// The network interface identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetSecurityGroupNetworkInterfaceOptions : Instantiate GetSecurityGroupNetworkInterfaceOptions
func (*VpcV1) NewGetSecurityGroupNetworkInterfaceOptions(securityGroupID string, id string) *GetSecurityGroupNetworkInterfaceOptions {
	return &GetSecurityGroupNetworkInterfaceOptions{
		SecurityGroupID: core.StringPtr(securityGroupID),
		ID:              core.StringPtr(id),
	}
}

// SetSecurityGroupID : Allow user to set SecurityGroupID
func (options *GetSecurityGroupNetworkInterfaceOptions) SetSecurityGroupID(securityGroupID string) *GetSecurityGroupNetworkInterfaceOptions {
	options.SecurityGroupID = core.StringPtr(securityGroupID)
	return options
}

// SetID : Allow user to set ID
func (options *GetSecurityGroupNetworkInterfaceOptions) SetID(id string) *GetSecurityGroupNetworkInterfaceOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetSecurityGroupNetworkInterfaceOptions) SetHeaders(param map[string]string) *GetSecurityGroupNetworkInterfaceOptions {
	options.Headers = param
	return options
}

// GetSecurityGroupOptions : The GetSecurityGroup options.
type GetSecurityGroupOptions struct {
	// The security group identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetSecurityGroupOptions : Instantiate GetSecurityGroupOptions
func (*VpcV1) NewGetSecurityGroupOptions(id string) *GetSecurityGroupOptions {
	return &GetSecurityGroupOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *GetSecurityGroupOptions) SetID(id string) *GetSecurityGroupOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetSecurityGroupOptions) SetHeaders(param map[string]string) *GetSecurityGroupOptions {
	options.Headers = param
	return options
}

// GetSecurityGroupRuleOptions : The GetSecurityGroupRule options.
type GetSecurityGroupRuleOptions struct {
	// The security group identifier.
	SecurityGroupID *string `json:"security_group_id" validate:"required"`

	// The rule identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetSecurityGroupRuleOptions : Instantiate GetSecurityGroupRuleOptions
func (*VpcV1) NewGetSecurityGroupRuleOptions(securityGroupID string, id string) *GetSecurityGroupRuleOptions {
	return &GetSecurityGroupRuleOptions{
		SecurityGroupID: core.StringPtr(securityGroupID),
		ID:              core.StringPtr(id),
	}
}

// SetSecurityGroupID : Allow user to set SecurityGroupID
func (options *GetSecurityGroupRuleOptions) SetSecurityGroupID(securityGroupID string) *GetSecurityGroupRuleOptions {
	options.SecurityGroupID = core.StringPtr(securityGroupID)
	return options
}

// SetID : Allow user to set ID
func (options *GetSecurityGroupRuleOptions) SetID(id string) *GetSecurityGroupRuleOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetSecurityGroupRuleOptions) SetHeaders(param map[string]string) *GetSecurityGroupRuleOptions {
	options.Headers = param
	return options
}

// GetSubnetNetworkACLOptions : The GetSubnetNetworkACL options.
type GetSubnetNetworkACLOptions struct {
	// The subnet identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetSubnetNetworkACLOptions : Instantiate GetSubnetNetworkACLOptions
func (*VpcV1) NewGetSubnetNetworkACLOptions(id string) *GetSubnetNetworkACLOptions {
	return &GetSubnetNetworkACLOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *GetSubnetNetworkACLOptions) SetID(id string) *GetSubnetNetworkACLOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetSubnetNetworkACLOptions) SetHeaders(param map[string]string) *GetSubnetNetworkACLOptions {
	options.Headers = param
	return options
}

// GetSubnetOptions : The GetSubnet options.
type GetSubnetOptions struct {
	// The subnet identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetSubnetOptions : Instantiate GetSubnetOptions
func (*VpcV1) NewGetSubnetOptions(id string) *GetSubnetOptions {
	return &GetSubnetOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *GetSubnetOptions) SetID(id string) *GetSubnetOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetSubnetOptions) SetHeaders(param map[string]string) *GetSubnetOptions {
	options.Headers = param
	return options
}

// GetSubnetPublicGatewayOptions : The GetSubnetPublicGateway options.
type GetSubnetPublicGatewayOptions struct {
	// The subnet identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetSubnetPublicGatewayOptions : Instantiate GetSubnetPublicGatewayOptions
func (*VpcV1) NewGetSubnetPublicGatewayOptions(id string) *GetSubnetPublicGatewayOptions {
	return &GetSubnetPublicGatewayOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *GetSubnetPublicGatewayOptions) SetID(id string) *GetSubnetPublicGatewayOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetSubnetPublicGatewayOptions) SetHeaders(param map[string]string) *GetSubnetPublicGatewayOptions {
	options.Headers = param
	return options
}

// GetSubnetRoutingTableOptions : The GetSubnetRoutingTable options.
type GetSubnetRoutingTableOptions struct {
	// The subnet identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetSubnetRoutingTableOptions : Instantiate GetSubnetRoutingTableOptions
func (*VpcV1) NewGetSubnetRoutingTableOptions(id string) *GetSubnetRoutingTableOptions {
	return &GetSubnetRoutingTableOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *GetSubnetRoutingTableOptions) SetID(id string) *GetSubnetRoutingTableOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetSubnetRoutingTableOptions) SetHeaders(param map[string]string) *GetSubnetRoutingTableOptions {
	options.Headers = param
	return options
}

// GetVolumeOptions : The GetVolume options.
type GetVolumeOptions struct {
	// The volume identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetVolumeOptions : Instantiate GetVolumeOptions
func (*VpcV1) NewGetVolumeOptions(id string) *GetVolumeOptions {
	return &GetVolumeOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *GetVolumeOptions) SetID(id string) *GetVolumeOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetVolumeOptions) SetHeaders(param map[string]string) *GetVolumeOptions {
	options.Headers = param
	return options
}

// GetVolumeProfileOptions : The GetVolumeProfile options.
type GetVolumeProfileOptions struct {
	// The volume profile name.
	Name *string `json:"name" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetVolumeProfileOptions : Instantiate GetVolumeProfileOptions
func (*VpcV1) NewGetVolumeProfileOptions(name string) *GetVolumeProfileOptions {
	return &GetVolumeProfileOptions{
		Name: core.StringPtr(name),
	}
}

// SetName : Allow user to set Name
func (options *GetVolumeProfileOptions) SetName(name string) *GetVolumeProfileOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetVolumeProfileOptions) SetHeaders(param map[string]string) *GetVolumeProfileOptions {
	options.Headers = param
	return options
}

// GetVPCAddressPrefixOptions : The GetVPCAddressPrefix options.
type GetVPCAddressPrefixOptions struct {
	// The VPC identifier.
	VPCID *string `json:"vpc_id" validate:"required"`

	// The prefix identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetVPCAddressPrefixOptions : Instantiate GetVPCAddressPrefixOptions
func (*VpcV1) NewGetVPCAddressPrefixOptions(vpcID string, id string) *GetVPCAddressPrefixOptions {
	return &GetVPCAddressPrefixOptions{
		VPCID: core.StringPtr(vpcID),
		ID:    core.StringPtr(id),
	}
}

// SetVPCID : Allow user to set VPCID
func (options *GetVPCAddressPrefixOptions) SetVPCID(vpcID string) *GetVPCAddressPrefixOptions {
	options.VPCID = core.StringPtr(vpcID)
	return options
}

// SetID : Allow user to set ID
func (options *GetVPCAddressPrefixOptions) SetID(id string) *GetVPCAddressPrefixOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetVPCAddressPrefixOptions) SetHeaders(param map[string]string) *GetVPCAddressPrefixOptions {
	options.Headers = param
	return options
}

// GetVPCDefaultNetworkACLOptions : The GetVPCDefaultNetworkACL options.
type GetVPCDefaultNetworkACLOptions struct {
	// The VPC identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetVPCDefaultNetworkACLOptions : Instantiate GetVPCDefaultNetworkACLOptions
func (*VpcV1) NewGetVPCDefaultNetworkACLOptions(id string) *GetVPCDefaultNetworkACLOptions {
	return &GetVPCDefaultNetworkACLOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *GetVPCDefaultNetworkACLOptions) SetID(id string) *GetVPCDefaultNetworkACLOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetVPCDefaultNetworkACLOptions) SetHeaders(param map[string]string) *GetVPCDefaultNetworkACLOptions {
	options.Headers = param
	return options
}

// GetVPCDefaultRoutingTableOptions : The GetVPCDefaultRoutingTable options.
type GetVPCDefaultRoutingTableOptions struct {
	// The VPC identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetVPCDefaultRoutingTableOptions : Instantiate GetVPCDefaultRoutingTableOptions
func (*VpcV1) NewGetVPCDefaultRoutingTableOptions(id string) *GetVPCDefaultRoutingTableOptions {
	return &GetVPCDefaultRoutingTableOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *GetVPCDefaultRoutingTableOptions) SetID(id string) *GetVPCDefaultRoutingTableOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetVPCDefaultRoutingTableOptions) SetHeaders(param map[string]string) *GetVPCDefaultRoutingTableOptions {
	options.Headers = param
	return options
}

// GetVPCDefaultSecurityGroupOptions : The GetVPCDefaultSecurityGroup options.
type GetVPCDefaultSecurityGroupOptions struct {
	// The VPC identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetVPCDefaultSecurityGroupOptions : Instantiate GetVPCDefaultSecurityGroupOptions
func (*VpcV1) NewGetVPCDefaultSecurityGroupOptions(id string) *GetVPCDefaultSecurityGroupOptions {
	return &GetVPCDefaultSecurityGroupOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *GetVPCDefaultSecurityGroupOptions) SetID(id string) *GetVPCDefaultSecurityGroupOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetVPCDefaultSecurityGroupOptions) SetHeaders(param map[string]string) *GetVPCDefaultSecurityGroupOptions {
	options.Headers = param
	return options
}

// GetVPCOptions : The GetVPC options.
type GetVPCOptions struct {
	// The VPC identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetVPCOptions : Instantiate GetVPCOptions
func (*VpcV1) NewGetVPCOptions(id string) *GetVPCOptions {
	return &GetVPCOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *GetVPCOptions) SetID(id string) *GetVPCOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetVPCOptions) SetHeaders(param map[string]string) *GetVPCOptions {
	options.Headers = param
	return options
}

// GetVPCRouteOptions : The GetVPCRoute options.
type GetVPCRouteOptions struct {
	// The VPC identifier.
	VPCID *string `json:"vpc_id" validate:"required"`

	// The route identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetVPCRouteOptions : Instantiate GetVPCRouteOptions
func (*VpcV1) NewGetVPCRouteOptions(vpcID string, id string) *GetVPCRouteOptions {
	return &GetVPCRouteOptions{
		VPCID: core.StringPtr(vpcID),
		ID:    core.StringPtr(id),
	}
}

// SetVPCID : Allow user to set VPCID
func (options *GetVPCRouteOptions) SetVPCID(vpcID string) *GetVPCRouteOptions {
	options.VPCID = core.StringPtr(vpcID)
	return options
}

// SetID : Allow user to set ID
func (options *GetVPCRouteOptions) SetID(id string) *GetVPCRouteOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetVPCRouteOptions) SetHeaders(param map[string]string) *GetVPCRouteOptions {
	options.Headers = param
	return options
}

// GetVPCRoutingTableOptions : The GetVPCRoutingTable options.
type GetVPCRoutingTableOptions struct {
	// The VPC identifier.
	VPCID *string `json:"vpc_id" validate:"required"`

	// The routing table identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetVPCRoutingTableOptions : Instantiate GetVPCRoutingTableOptions
func (*VpcV1) NewGetVPCRoutingTableOptions(vpcID string, id string) *GetVPCRoutingTableOptions {
	return &GetVPCRoutingTableOptions{
		VPCID: core.StringPtr(vpcID),
		ID:    core.StringPtr(id),
	}
}

// SetVPCID : Allow user to set VPCID
func (options *GetVPCRoutingTableOptions) SetVPCID(vpcID string) *GetVPCRoutingTableOptions {
	options.VPCID = core.StringPtr(vpcID)
	return options
}

// SetID : Allow user to set ID
func (options *GetVPCRoutingTableOptions) SetID(id string) *GetVPCRoutingTableOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetVPCRoutingTableOptions) SetHeaders(param map[string]string) *GetVPCRoutingTableOptions {
	options.Headers = param
	return options
}

// GetVPCRoutingTableRouteOptions : The GetVPCRoutingTableRoute options.
type GetVPCRoutingTableRouteOptions struct {
	// The VPC identifier.
	VPCID *string `json:"vpc_id" validate:"required"`

	// The routing table identifier.
	RoutingTableID *string `json:"routing_table_id" validate:"required"`

	// The VPC routing table route identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetVPCRoutingTableRouteOptions : Instantiate GetVPCRoutingTableRouteOptions
func (*VpcV1) NewGetVPCRoutingTableRouteOptions(vpcID string, routingTableID string, id string) *GetVPCRoutingTableRouteOptions {
	return &GetVPCRoutingTableRouteOptions{
		VPCID:          core.StringPtr(vpcID),
		RoutingTableID: core.StringPtr(routingTableID),
		ID:             core.StringPtr(id),
	}
}

// SetVPCID : Allow user to set VPCID
func (options *GetVPCRoutingTableRouteOptions) SetVPCID(vpcID string) *GetVPCRoutingTableRouteOptions {
	options.VPCID = core.StringPtr(vpcID)
	return options
}

// SetRoutingTableID : Allow user to set RoutingTableID
func (options *GetVPCRoutingTableRouteOptions) SetRoutingTableID(routingTableID string) *GetVPCRoutingTableRouteOptions {
	options.RoutingTableID = core.StringPtr(routingTableID)
	return options
}

// SetID : Allow user to set ID
func (options *GetVPCRoutingTableRouteOptions) SetID(id string) *GetVPCRoutingTableRouteOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetVPCRoutingTableRouteOptions) SetHeaders(param map[string]string) *GetVPCRoutingTableRouteOptions {
	options.Headers = param
	return options
}

// GetVPNGatewayConnectionOptions : The GetVPNGatewayConnection options.
type GetVPNGatewayConnectionOptions struct {
	// The VPN gateway identifier.
	VPNGatewayID *string `json:"vpn_gateway_id" validate:"required"`

	// The VPN connection identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetVPNGatewayConnectionOptions : Instantiate GetVPNGatewayConnectionOptions
func (*VpcV1) NewGetVPNGatewayConnectionOptions(vpnGatewayID string, id string) *GetVPNGatewayConnectionOptions {
	return &GetVPNGatewayConnectionOptions{
		VPNGatewayID: core.StringPtr(vpnGatewayID),
		ID:           core.StringPtr(id),
	}
}

// SetVPNGatewayID : Allow user to set VPNGatewayID
func (options *GetVPNGatewayConnectionOptions) SetVPNGatewayID(vpnGatewayID string) *GetVPNGatewayConnectionOptions {
	options.VPNGatewayID = core.StringPtr(vpnGatewayID)
	return options
}

// SetID : Allow user to set ID
func (options *GetVPNGatewayConnectionOptions) SetID(id string) *GetVPNGatewayConnectionOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetVPNGatewayConnectionOptions) SetHeaders(param map[string]string) *GetVPNGatewayConnectionOptions {
	options.Headers = param
	return options
}

// GetVPNGatewayOptions : The GetVPNGateway options.
type GetVPNGatewayOptions struct {
	// The VPN gateway identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetVPNGatewayOptions : Instantiate GetVPNGatewayOptions
func (*VpcV1) NewGetVPNGatewayOptions(id string) *GetVPNGatewayOptions {
	return &GetVPNGatewayOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *GetVPNGatewayOptions) SetID(id string) *GetVPNGatewayOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetVPNGatewayOptions) SetHeaders(param map[string]string) *GetVPNGatewayOptions {
	options.Headers = param
	return options
}

// IkePolicy : IkePolicy struct
type IkePolicy struct {
	// The authentication algorithm.
	AuthenticationAlgorithm *string `json:"authentication_algorithm" validate:"required"`

	// Collection of references to VPN connections that use this IKE policy.
	Connections []VPNGatewayConnectionReference `json:"connections" validate:"required"`

	// The date and time that this IKE policy was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The Diffie-Hellman group.
	DhGroup *int64 `json:"dh_group" validate:"required"`

	// The encryption algorithm.
	EncryptionAlgorithm *string `json:"encryption_algorithm" validate:"required"`

	// The IKE policy's canonical URL.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this IKE policy.
	ID *string `json:"id" validate:"required"`

	// The IKE protocol version.
	IkeVersion *int64 `json:"ike_version" validate:"required"`

	// The key lifetime in seconds.
	KeyLifetime *int64 `json:"key_lifetime" validate:"required"`

	// The user-defined name for this IKE policy.
	Name *string `json:"name" validate:"required"`

	// The IKE negotiation mode. Only `main` is supported.
	NegotiationMode *string `json:"negotiation_mode" validate:"required"`

	// The resource group for this IKE policy.
	ResourceGroup *ResourceGroupReference `json:"resource_group" validate:"required"`
}

// Constants associated with the IkePolicy.AuthenticationAlgorithm property.
// The authentication algorithm.
const (
	IkePolicyAuthenticationAlgorithmMd5Const    = "md5"
	IkePolicyAuthenticationAlgorithmSha1Const   = "sha1"
	IkePolicyAuthenticationAlgorithmSha256Const = "sha256"
)

// Constants associated with the IkePolicy.EncryptionAlgorithm property.
// The encryption algorithm.
const (
	IkePolicyEncryptionAlgorithmAes128Const    = "aes128"
	IkePolicyEncryptionAlgorithmAes256Const    = "aes256"
	IkePolicyEncryptionAlgorithmTripleDesConst = "triple_des"
)

// Constants associated with the IkePolicy.NegotiationMode property.
// The IKE negotiation mode. Only `main` is supported.
const (
	IkePolicyNegotiationModeMainConst = "main"
)

// UnmarshalIkePolicy unmarshals an instance of IkePolicy from the specified map of raw messages.
func UnmarshalIkePolicy(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(IkePolicy)
	err = core.UnmarshalPrimitive(m, "authentication_algorithm", &obj.AuthenticationAlgorithm)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "connections", &obj.Connections, UnmarshalVPNGatewayConnectionReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "dh_group", &obj.DhGroup)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "encryption_algorithm", &obj.EncryptionAlgorithm)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ike_version", &obj.IkeVersion)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "key_lifetime", &obj.KeyLifetime)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "negotiation_mode", &obj.NegotiationMode)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// IkePolicyCollection : IkePolicyCollection struct
type IkePolicyCollection struct {
	// A reference to the first page of resources.
	First *IkePolicyCollectionFirst `json:"first" validate:"required"`

	// Collection of IKE policies.
	IkePolicies []IkePolicy `json:"ike_policies" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A reference to the next page of resources; this reference is included for all pages
	// except the last page.
	Next *IkePolicyCollectionNext `json:"next,omitempty"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalIkePolicyCollection unmarshals an instance of IkePolicyCollection from the specified map of raw messages.
func UnmarshalIkePolicyCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(IkePolicyCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalIkePolicyCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "ike_policies", &obj.IkePolicies, UnmarshalIkePolicy)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalIkePolicyCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// IkePolicyIdentity : Identifies an IKE policy by a unique property.
// Models which "extend" this model:
// - IkePolicyIdentityByID
// - IkePolicyIdentityByHref
type IkePolicyIdentity struct {
	// The unique identifier for this IKE policy.
	ID *string `json:"id,omitempty"`

	// The IKE policy's canonical URL.
	Href *string `json:"href,omitempty"`
}

func (*IkePolicyIdentity) isaIkePolicyIdentity() bool {
	return true
}

type IkePolicyIdentityIntf interface {
	isaIkePolicyIdentity() bool
}

// UnmarshalIkePolicyIdentity unmarshals an instance of IkePolicyIdentity from the specified map of raw messages.
func UnmarshalIkePolicyIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(IkePolicyIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// IP : IP struct
type IP struct {
	// The IP address. This property may add support for IPv6 addresses in the future. When processing a value in this
	// property, verify that the address is in an expected format. If it is not, log an error. Optionally halt processing
	// and surface the error, or bypass the resource on which the unexpected IP address format was encountered.
	Address *string `json:"address" validate:"required"`
}

// UnmarshalIP unmarshals an instance of IP from the specified map of raw messages.
func UnmarshalIP(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(IP)
	err = core.UnmarshalPrimitive(m, "address", &obj.Address)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// IPsecPolicy : IPsecPolicy struct
type IPsecPolicy struct {
	// The authentication algorithm.
	AuthenticationAlgorithm *string `json:"authentication_algorithm" validate:"required"`

	// Collection of references to VPN connections that use this IPsec policy.
	Connections []VPNGatewayConnectionReference `json:"connections" validate:"required"`

	// The date and time that this IPsec policy was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The encapsulation mode used. Only `tunnel` is supported.
	EncapsulationMode *string `json:"encapsulation_mode" validate:"required"`

	// The encryption algorithm.
	EncryptionAlgorithm *string `json:"encryption_algorithm" validate:"required"`

	// The IPsec policy's canonical URL.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this IPsec policy.
	ID *string `json:"id" validate:"required"`

	// The key lifetime in seconds.
	KeyLifetime *int64 `json:"key_lifetime" validate:"required"`

	// The user-defined name for this IPsec policy.
	Name *string `json:"name" validate:"required"`

	// Perfect Forward Secrecy.
	Pfs *string `json:"pfs" validate:"required"`

	// The resource group for this IPsec policy.
	ResourceGroup *ResourceGroupReference `json:"resource_group" validate:"required"`

	// The transform protocol used. Only `esp` is supported.
	TransformProtocol *string `json:"transform_protocol" validate:"required"`
}

// Constants associated with the IPsecPolicy.AuthenticationAlgorithm property.
// The authentication algorithm.
const (
	IPsecPolicyAuthenticationAlgorithmMd5Const    = "md5"
	IPsecPolicyAuthenticationAlgorithmSha1Const   = "sha1"
	IPsecPolicyAuthenticationAlgorithmSha256Const = "sha256"
)

// Constants associated with the IPsecPolicy.EncapsulationMode property.
// The encapsulation mode used. Only `tunnel` is supported.
const (
	IPsecPolicyEncapsulationModeTunnelConst = "tunnel"
)

// Constants associated with the IPsecPolicy.EncryptionAlgorithm property.
// The encryption algorithm.
const (
	IPsecPolicyEncryptionAlgorithmAes128Const    = "aes128"
	IPsecPolicyEncryptionAlgorithmAes256Const    = "aes256"
	IPsecPolicyEncryptionAlgorithmTripleDesConst = "triple_des"
)

// Constants associated with the IPsecPolicy.Pfs property.
// Perfect Forward Secrecy.
const (
	IPsecPolicyPfsDisabledConst = "disabled"
	IPsecPolicyPfsGroup14Const  = "group_14"
	IPsecPolicyPfsGroup2Const   = "group_2"
	IPsecPolicyPfsGroup5Const   = "group_5"
)

// Constants associated with the IPsecPolicy.TransformProtocol property.
// The transform protocol used. Only `esp` is supported.
const (
	IPsecPolicyTransformProtocolEspConst = "esp"
)

// UnmarshalIPsecPolicy unmarshals an instance of IPsecPolicy from the specified map of raw messages.
func UnmarshalIPsecPolicy(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(IPsecPolicy)
	err = core.UnmarshalPrimitive(m, "authentication_algorithm", &obj.AuthenticationAlgorithm)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "connections", &obj.Connections, UnmarshalVPNGatewayConnectionReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "encapsulation_mode", &obj.EncapsulationMode)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "encryption_algorithm", &obj.EncryptionAlgorithm)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "key_lifetime", &obj.KeyLifetime)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "pfs", &obj.Pfs)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "transform_protocol", &obj.TransformProtocol)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// IPsecPolicyCollection : IPsecPolicyCollection struct
type IPsecPolicyCollection struct {
	// A reference to the first page of resources.
	First *IPsecPolicyCollectionFirst `json:"first" validate:"required"`

	// Collection of IPsec policies.
	IpsecPolicies []IPsecPolicy `json:"ipsec_policies" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A reference to the next page of resources; this reference is included for all pages
	// except the last page.
	Next *IPsecPolicyCollectionNext `json:"next,omitempty"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalIPsecPolicyCollection unmarshals an instance of IPsecPolicyCollection from the specified map of raw messages.
func UnmarshalIPsecPolicyCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(IPsecPolicyCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalIPsecPolicyCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "ipsec_policies", &obj.IpsecPolicies, UnmarshalIPsecPolicy)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalIPsecPolicyCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// IPsecPolicyCollectionFirst : A reference to the first page of resources.
type IPsecPolicyCollectionFirst struct {
	// The URL for the first page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalIPsecPolicyCollectionFirst unmarshals an instance of IPsecPolicyCollectionFirst from the specified map of raw messages.
func UnmarshalIPsecPolicyCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(IPsecPolicyCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// IPsecPolicyCollectionNext : A reference to the next page of resources; this reference is included for all pages except the last page.
type IPsecPolicyCollectionNext struct {
	// The URL for the next page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalIPsecPolicyCollectionNext unmarshals an instance of IPsecPolicyCollectionNext from the specified map of raw messages.
func UnmarshalIPsecPolicyCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(IPsecPolicyCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// IPsecPolicyIdentity : Identifies an IPsec policy by a unique property.
// Models which "extend" this model:
// - IPsecPolicyIdentityByID
// - IPsecPolicyIdentityByHref
type IPsecPolicyIdentity struct {
	// The unique identifier for this IPsec policy.
	ID *string `json:"id,omitempty"`

	// The IPsec policy's canonical URL.
	Href *string `json:"href,omitempty"`
}

func (*IPsecPolicyIdentity) isaIPsecPolicyIdentity() bool {
	return true
}

type IPsecPolicyIdentityIntf interface {
	isaIPsecPolicyIdentity() bool
}

// UnmarshalIPsecPolicyIdentity unmarshals an instance of IPsecPolicyIdentity from the specified map of raw messages.
func UnmarshalIPsecPolicyIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(IPsecPolicyIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// IkePolicyCollectionFirst : A reference to the first page of resources.
type IkePolicyCollectionFirst struct {
	// The URL for the first page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalIkePolicyCollectionFirst unmarshals an instance of IkePolicyCollectionFirst from the specified map of raw messages.
func UnmarshalIkePolicyCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(IkePolicyCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// IkePolicyCollectionNext : A reference to the next page of resources; this reference is included for all pages except the last page.
type IkePolicyCollectionNext struct {
	// The URL for the next page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalIkePolicyCollectionNext unmarshals an instance of IkePolicyCollectionNext from the specified map of raw messages.
func UnmarshalIkePolicyCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(IkePolicyCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Image : Image struct
type Image struct {
	// The date and time that the image was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The CRN for this image.
	CRN *string `json:"crn" validate:"required"`

	// Details for the stored image file.
	File *ImageFile `json:"file" validate:"required"`

	// The URL for this image.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this image.
	ID *string `json:"id" validate:"required"`

	// The minimum size (in gigabytes) of a volume onto which this image may be provisioned.
	//
	// This property may be absent if the image has a `status` of `pending`, `tentative`, or
	// `failed`.
	MinimumProvisionedSize *int64 `json:"minimum_provisioned_size,omitempty"`

	// The user-defined or system-provided name for this image.
	Name *string `json:"name" validate:"required"`

	// The operating system included in this image.
	OperatingSystem *OperatingSystem `json:"operating_system,omitempty"`

	// The resource group for this image.
	ResourceGroup *ResourceGroupReference `json:"resource_group" validate:"required"`

	// The status of this image.
	Status *string `json:"status" validate:"required"`

	// Whether the image is publicly visible or private to the account.
	Visibility *string `json:"visibility" validate:"required"`
}

// Constants associated with the Image.Status property.
// The status of this image.
const (
	ImageStatusAvailableConst  = "available"
	ImageStatusDeletingConst   = "deleting"
	ImageStatusDeprecatedConst = "deprecated"
	ImageStatusFailedConst     = "failed"
	ImageStatusPendingConst    = "pending"
	ImageStatusTentativeConst  = "tentative"
)

// Constants associated with the Image.Visibility property.
// Whether the image is publicly visible or private to the account.
const (
	ImageVisibilityPrivateConst = "private"
	ImageVisibilityPublicConst  = "public"
)

// UnmarshalImage unmarshals an instance of Image from the specified map of raw messages.
func UnmarshalImage(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Image)
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "file", &obj.File, UnmarshalImageFile)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "minimum_provisioned_size", &obj.MinimumProvisionedSize)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "operating_system", &obj.OperatingSystem, UnmarshalOperatingSystem)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "visibility", &obj.Visibility)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ImageCollection : ImageCollection struct
type ImageCollection struct {
	// A reference to the first page of resources.
	First *ImageCollectionFirst `json:"first" validate:"required"`

	// Collection of images.
	Images []Image `json:"images" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A reference to the next page of resources; this reference is included for all pages
	// except the last page.
	Next *ImageCollectionNext `json:"next,omitempty"`
}

// UnmarshalImageCollection unmarshals an instance of ImageCollection from the specified map of raw messages.
func UnmarshalImageCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ImageCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalImageCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "images", &obj.Images, UnmarshalImage)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalImageCollectionNext)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ImageCollectionFirst : A reference to the first page of resources.
type ImageCollectionFirst struct {
	// The URL for the first page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalImageCollectionFirst unmarshals an instance of ImageCollectionFirst from the specified map of raw messages.
func UnmarshalImageCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ImageCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ImageCollectionNext : A reference to the next page of resources; this reference is included for all pages except the last page.
type ImageCollectionNext struct {
	// The URL for the next page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalImageCollectionNext unmarshals an instance of ImageCollectionNext from the specified map of raw messages.
func UnmarshalImageCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ImageCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ImageFile : ImageFile struct
type ImageFile struct {
	// The size of the stored image file rounded up to the next gigabyte.
	//
	// This property may be absent if the associated image has a `status` of `pending` or
	// `failed`.
	Size *int64 `json:"size,omitempty"`
}

// UnmarshalImageFile unmarshals an instance of ImageFile from the specified map of raw messages.
func UnmarshalImageFile(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ImageFile)
	err = core.UnmarshalPrimitive(m, "size", &obj.Size)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ImageFilePrototype : ImageFilePrototype struct
type ImageFilePrototype struct {
	// The Cloud Object Store (COS) location of the image file.
	Href *string `json:"href" validate:"required"`
}

// NewImageFilePrototype : Instantiate ImageFilePrototype (Generic Model Constructor)
func (*VpcV1) NewImageFilePrototype(href string) (model *ImageFilePrototype, err error) {
	model = &ImageFilePrototype{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

// UnmarshalImageFilePrototype unmarshals an instance of ImageFilePrototype from the specified map of raw messages.
func UnmarshalImageFilePrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ImageFilePrototype)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ImageIdentity : Identifies an image by a unique property.
// Models which "extend" this model:
// - ImageIdentityByID
// - ImageIdentityByCRN
// - ImageIdentityByHref
type ImageIdentity struct {
	// The unique identifier for this image.
	ID *string `json:"id,omitempty"`

	// The CRN for this image.
	CRN *string `json:"crn,omitempty"`

	// The URL for this image.
	Href *string `json:"href,omitempty"`
}

func (*ImageIdentity) isaImageIdentity() bool {
	return true
}

type ImageIdentityIntf interface {
	isaImageIdentity() bool
}

// UnmarshalImageIdentity unmarshals an instance of ImageIdentity from the specified map of raw messages.
func UnmarshalImageIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ImageIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ImagePrototype : ImagePrototype struct
// Models which "extend" this model:
// - ImagePrototypeImageByFile
type ImagePrototype struct {
	// The unique user-defined name for this image. Names starting with "ibm-" are not allowed. If unspecified, the name
	// will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// The file from which to create the image.
	File *ImageFilePrototype `json:"file,omitempty"`

	// The operating system included in this image.
	OperatingSystem OperatingSystemIdentityIntf `json:"operating_system,omitempty"`
}

func (*ImagePrototype) isaImagePrototype() bool {
	return true
}

type ImagePrototypeIntf interface {
	isaImagePrototype() bool
}

// UnmarshalImagePrototype unmarshals an instance of ImagePrototype from the specified map of raw messages.
func UnmarshalImagePrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ImagePrototype)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "file", &obj.File, UnmarshalImageFilePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "operating_system", &obj.OperatingSystem, UnmarshalOperatingSystemIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ImageReference : ImageReference struct
type ImageReference struct {
	// The CRN for this image.
	CRN *string `json:"crn" validate:"required"`

	// The URL for this image.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this image.
	ID *string `json:"id" validate:"required"`

	// The user-defined or system-provided name for this image.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalImageReference unmarshals an instance of ImageReference from the specified map of raw messages.
func UnmarshalImageReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ImageReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Instance : Instance struct
type Instance struct {
	// The total bandwidth (in megabits per second) shared across the virtual server instance's network interfaces.
	Bandwidth *int64 `json:"bandwidth" validate:"required"`

	// Boot volume attachment.
	BootVolumeAttachment *VolumeAttachmentReferenceInstanceContext `json:"boot_volume_attachment" validate:"required"`

	// The date and time that the virtual server instance was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The CRN for this virtual server instance.
	CRN *string `json:"crn" validate:"required"`

	DedicatedHost *DedicatedHostReference `json:"dedicated_host,omitempty"`

	// The virtual server instance GPU configuration.
	Gpu *InstanceGpu `json:"gpu,omitempty"`

	// The URL for this virtual server instance.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this virtual server instance.
	ID *string `json:"id" validate:"required"`

	// The image the virtual server instance was provisioned from.
	Image *ImageReference `json:"image,omitempty"`

	// The amount of memory in gibibytes.
	Memory *int64 `json:"memory" validate:"required"`

	// The user-defined name for this virtual server instance (and default system hostname).
	Name *string `json:"name" validate:"required"`

	// Collection of the virtual server instance's network interfaces, including the primary network interface.
	NetworkInterfaces []NetworkInterfaceInstanceContextReference `json:"network_interfaces" validate:"required"`

	// The placement restrictions for the virtual server instance.
	PlacementTarget InstancePlacementIntf `json:"placement_target,omitempty"`

	// Primary network interface.
	PrimaryNetworkInterface *NetworkInterfaceInstanceContextReference `json:"primary_network_interface" validate:"required"`

	// The profile this virtual server instance uses.
	Profile *InstanceProfileReference `json:"profile" validate:"required"`

	// The resource group for this instance.
	ResourceGroup *ResourceGroupReference `json:"resource_group" validate:"required"`

	// The type of resource referenced.
	ResourceType *string `json:"resource_type" validate:"required"`

	// The status of the virtual server instance.
	Status *string `json:"status" validate:"required"`

	// The virtual server instance VCPU configuration.
	Vcpu *InstanceVcpu `json:"vcpu" validate:"required"`

	// Collection of the virtual server instance's volume attachments, including the boot volume attachment.
	VolumeAttachments []VolumeAttachmentReferenceInstanceContext `json:"volume_attachments" validate:"required"`

	// The VPC the virtual server instance resides in.
	VPC *VPCReference `json:"vpc" validate:"required"`

	// The zone the virtual server instance resides in.
	Zone *ZoneReference `json:"zone" validate:"required"`
}

// Constants associated with the Instance.ResourceType property.
// The type of resource referenced.
const (
	InstanceResourceTypeInstanceConst = "instance"
)

// Constants associated with the Instance.Status property.
// The status of the virtual server instance.
const (
	InstanceStatusFailedConst     = "failed"
	InstanceStatusPausedConst     = "paused"
	InstanceStatusPausingConst    = "pausing"
	InstanceStatusPendingConst    = "pending"
	InstanceStatusRestartingConst = "restarting"
	InstanceStatusResumingConst   = "resuming"
	InstanceStatusRunningConst    = "running"
	InstanceStatusStartingConst   = "starting"
	InstanceStatusStoppedConst    = "stopped"
	InstanceStatusStoppingConst   = "stopping"
)

// UnmarshalInstance unmarshals an instance of Instance from the specified map of raw messages.
func UnmarshalInstance(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Instance)
	err = core.UnmarshalPrimitive(m, "bandwidth", &obj.Bandwidth)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "boot_volume_attachment", &obj.BootVolumeAttachment, UnmarshalVolumeAttachmentReferenceInstanceContext)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "dedicated_host", &obj.DedicatedHost, UnmarshalDedicatedHostReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "gpu", &obj.Gpu, UnmarshalInstanceGpu)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "image", &obj.Image, UnmarshalImageReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "memory", &obj.Memory)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "network_interfaces", &obj.NetworkInterfaces, UnmarshalNetworkInterfaceInstanceContextReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "placement_target", &obj.PlacementTarget, UnmarshalInstancePlacement)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "primary_network_interface", &obj.PrimaryNetworkInterface, UnmarshalNetworkInterfaceInstanceContextReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "profile", &obj.Profile, UnmarshalInstanceProfileReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vcpu", &obj.Vcpu, UnmarshalInstanceVcpu)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "volume_attachments", &obj.VolumeAttachments, UnmarshalVolumeAttachmentReferenceInstanceContext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vpc", &obj.VPC, UnmarshalVPCReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceAction : InstanceAction struct
type InstanceAction struct {
	// The date and time that the action was completed.
	CompletedAt *strfmt.DateTime `json:"completed_at,omitempty"`

	// The date and time that the action was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// If set to true, the action will be forced immediately, and all queued actions deleted. Ignored for the start action.
	Force *bool `json:"force,omitempty"`

	// The URL for this instance action.
	Href *string `json:"href" validate:"required"`

	// The identifier for this instance action.
	ID *string `json:"id" validate:"required"`

	// The date and time that the action was started.
	StartedAt *strfmt.DateTime `json:"started_at,omitempty"`

	// The current status of this action.
	Status *string `json:"status" validate:"required"`

	// The type of action.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the InstanceAction.Status property.
// The current status of this action.
const (
	InstanceActionStatusCompletedConst = "completed"
	InstanceActionStatusFailedConst    = "failed"
	InstanceActionStatusPendingConst   = "pending"
	InstanceActionStatusRunningConst   = "running"
)

// Constants associated with the InstanceAction.Type property.
// The type of action.
const (
	InstanceActionTypeRebootConst = "reboot"
	InstanceActionTypeStartConst  = "start"
	InstanceActionTypeStopConst   = "stop"
)

// UnmarshalInstanceAction unmarshals an instance of InstanceAction from the specified map of raw messages.
func UnmarshalInstanceAction(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceAction)
	err = core.UnmarshalPrimitive(m, "completed_at", &obj.CompletedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "force", &obj.Force)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "started_at", &obj.StartedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceCollection : InstanceCollection struct
type InstanceCollection struct {
	// A reference to the first page of resources.
	First *InstanceCollectionFirst `json:"first" validate:"required"`

	// Collection of virtual server instances.
	Instances []Instance `json:"instances" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A reference to the next page of resources; this reference is included for all pages
	// except the last page.
	Next *InstanceCollectionNext `json:"next,omitempty"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalInstanceCollection unmarshals an instance of InstanceCollection from the specified map of raw messages.
func UnmarshalInstanceCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalInstanceCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "instances", &obj.Instances, UnmarshalInstance)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalInstanceCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceCollectionFirst : A reference to the first page of resources.
type InstanceCollectionFirst struct {
	// The URL for the first page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalInstanceCollectionFirst unmarshals an instance of InstanceCollectionFirst from the specified map of raw messages.
func UnmarshalInstanceCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceCollectionNext : A reference to the next page of resources; this reference is included for all pages except the last page.
type InstanceCollectionNext struct {
	// The URL for the next page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalInstanceCollectionNext unmarshals an instance of InstanceCollectionNext from the specified map of raw messages.
func UnmarshalInstanceCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceGpu : The virtual server instance GPU configuration.
type InstanceGpu struct {
	// The number of GPUs assigned to the instance.
	Count *int64 `json:"count" validate:"required"`

	// The GPU manufacturer.
	Manufacturer *string `json:"manufacturer" validate:"required"`

	// The overall amount of GPU memory in GiB (gibibytes).
	Memory *int64 `json:"memory" validate:"required"`

	// The GPU model.
	Model *string `json:"model" validate:"required"`
}

// UnmarshalInstanceGpu unmarshals an instance of InstanceGpu from the specified map of raw messages.
func UnmarshalInstanceGpu(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGpu)
	err = core.UnmarshalPrimitive(m, "count", &obj.Count)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "manufacturer", &obj.Manufacturer)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "memory", &obj.Memory)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "model", &obj.Model)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceGroup : InstanceGroup struct
type InstanceGroup struct {
	// Required if specifying a load balancer pool only. Used by the instance group when scaling up instances to supply the
	// port for the load balancer pool member.
	ApplicationPort *int64 `json:"application_port,omitempty"`

	// The date and time that the instance group was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The CRN for this instance group.
	CRN *string `json:"crn" validate:"required"`

	// The URL for this instance group.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this instance group.
	ID *string `json:"id" validate:"required"`

	// The template used to create new instances for this group.
	InstanceTemplate *InstanceTemplateReference `json:"instance_template" validate:"required"`

	// The load balancer pool managed by this group. Instances created
	// by this group will have a new load balancer pool member in that
	// pool created.
	LoadBalancerPool *LoadBalancerPoolReference `json:"load_balancer_pool,omitempty"`

	// Array of references to managers for the instance group.
	Managers []InstanceGroupManagerReference `json:"managers" validate:"required"`

	// The number of instances in the instance group.
	MembershipCount *int64 `json:"membership_count" validate:"required"`

	// The user-defined name for this instance group.
	Name *string `json:"name" validate:"required"`

	ResourceGroup *ResourceGroupReference `json:"resource_group" validate:"required"`

	// The status of the instance group
	// - `deleting`: Group is being deleted
	// - `healthy`: Group has `membership_count` instances
	// - `scaling`: Instances in the group are being created or deleted to reach
	//              `membership_count`
	// - `unhealthy`: Group is unable to reach `membership_count` instances.
	Status *string `json:"status" validate:"required"`

	// Array of references to subnets to use when creating new instances.
	Subnets []SubnetReference `json:"subnets" validate:"required"`

	// The VPC the instance group resides in.
	VPC *VPCReference `json:"vpc" validate:"required"`
}

// Constants associated with the InstanceGroup.Status property.
// The status of the instance group
// - `deleting`: Group is being deleted
// - `healthy`: Group has `membership_count` instances
// - `scaling`: Instances in the group are being created or deleted to reach
//              `membership_count`
// - `unhealthy`: Group is unable to reach `membership_count` instances.
const (
	InstanceGroupStatusDeletingConst  = "deleting"
	InstanceGroupStatusHealthyConst   = "healthy"
	InstanceGroupStatusScalingConst   = "scaling"
	InstanceGroupStatusUnhealthyConst = "unhealthy"
)

// UnmarshalInstanceGroup unmarshals an instance of InstanceGroup from the specified map of raw messages.
func UnmarshalInstanceGroup(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroup)
	err = core.UnmarshalPrimitive(m, "application_port", &obj.ApplicationPort)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "instance_template", &obj.InstanceTemplate, UnmarshalInstanceTemplateReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "load_balancer_pool", &obj.LoadBalancerPool, UnmarshalLoadBalancerPoolReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "managers", &obj.Managers, UnmarshalInstanceGroupManagerReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "membership_count", &obj.MembershipCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "subnets", &obj.Subnets, UnmarshalSubnetReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vpc", &obj.VPC, UnmarshalVPCReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceGroupCollection : InstanceGroupCollection struct
type InstanceGroupCollection struct {
	// A reference to the first page of resources.
	First *InstanceGroupCollectionFirst `json:"first" validate:"required"`

	// Collection of instance groups.
	InstanceGroups []InstanceGroup `json:"instance_groups" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A reference to the next page of resources; this reference is included for all pages
	// except the last page.
	Next *InstanceGroupCollectionNext `json:"next,omitempty"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalInstanceGroupCollection unmarshals an instance of InstanceGroupCollection from the specified map of raw messages.
func UnmarshalInstanceGroupCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalInstanceGroupCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "instance_groups", &obj.InstanceGroups, UnmarshalInstanceGroup)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalInstanceGroupCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceGroupCollectionFirst : A reference to the first page of resources.
type InstanceGroupCollectionFirst struct {
	// The URL for the first page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalInstanceGroupCollectionFirst unmarshals an instance of InstanceGroupCollectionFirst from the specified map of raw messages.
func UnmarshalInstanceGroupCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceGroupCollectionNext : A reference to the next page of resources; this reference is included for all pages except the last page.
type InstanceGroupCollectionNext struct {
	// The URL for the next page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalInstanceGroupCollectionNext unmarshals an instance of InstanceGroupCollectionNext from the specified map of raw messages.
func UnmarshalInstanceGroupCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceGroupManager : InstanceGroupManager struct
type InstanceGroupManager struct {
	// The time window in seconds to aggregate metrics prior to evaluation.
	AggregationWindow *int64 `json:"aggregation_window,omitempty"`

	// The duration of time in seconds to pause further scale actions after scaling has taken place.
	Cooldown *int64 `json:"cooldown,omitempty"`

	// The URL for this instance group manager.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this instance group manager.
	ID *string `json:"id" validate:"required"`

	// If set to `true`, this manager will control the instance group.
	ManagementEnabled *bool `json:"management_enabled" validate:"required"`

	// The type of instance group manager.
	ManagerType *string `json:"manager_type" validate:"required"`

	// The maximum number of members in a managed instance group.
	MaxMembershipCount *int64 `json:"max_membership_count,omitempty"`

	// The minimum number of members in a managed instance group.
	MinMembershipCount *int64 `json:"min_membership_count,omitempty"`

	// The user-defined name for this instance group manager. Names must be unique within the instance group.
	Name *string `json:"name" validate:"required"`

	// The policies of the instance group manager.
	Policies []InstanceGroupManagerPolicyReference `json:"policies" validate:"required"`
}

// Constants associated with the InstanceGroupManager.ManagerType property.
// The type of instance group manager.
const (
	InstanceGroupManagerManagerTypeAutoscaleConst = "autoscale"
)

// UnmarshalInstanceGroupManager unmarshals an instance of InstanceGroupManager from the specified map of raw messages.
func UnmarshalInstanceGroupManager(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupManager)
	err = core.UnmarshalPrimitive(m, "aggregation_window", &obj.AggregationWindow)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "cooldown", &obj.Cooldown)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "management_enabled", &obj.ManagementEnabled)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "manager_type", &obj.ManagerType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "max_membership_count", &obj.MaxMembershipCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "min_membership_count", &obj.MinMembershipCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "policies", &obj.Policies, UnmarshalInstanceGroupManagerPolicyReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceGroupManagerCollection : InstanceGroupManagerCollection struct
type InstanceGroupManagerCollection struct {
	// A reference to the first page of resources.
	First *InstanceGroupManagerCollectionFirst `json:"first" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// Collection of instance group managers.
	Managers []InstanceGroupManager `json:"managers" validate:"required"`

	// A reference to the next page of resources; this reference is included for all pages
	// except the last page.
	Next *InstanceGroupManagerCollectionNext `json:"next,omitempty"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalInstanceGroupManagerCollection unmarshals an instance of InstanceGroupManagerCollection from the specified map of raw messages.
func UnmarshalInstanceGroupManagerCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupManagerCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalInstanceGroupManagerCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "managers", &obj.Managers, UnmarshalInstanceGroupManager)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalInstanceGroupManagerCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceGroupManagerCollectionFirst : A reference to the first page of resources.
type InstanceGroupManagerCollectionFirst struct {
	// The URL for the first page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalInstanceGroupManagerCollectionFirst unmarshals an instance of InstanceGroupManagerCollectionFirst from the specified map of raw messages.
func UnmarshalInstanceGroupManagerCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupManagerCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceGroupManagerCollectionNext : A reference to the next page of resources; this reference is included for all pages except the last page.
type InstanceGroupManagerCollectionNext struct {
	// The URL for the next page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalInstanceGroupManagerCollectionNext unmarshals an instance of InstanceGroupManagerCollectionNext from the specified map of raw messages.
func UnmarshalInstanceGroupManagerCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupManagerCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceGroupManagerPolicy : InstanceGroupManagerPolicy struct
// Models which "extend" this model:
// - InstanceGroupManagerPolicyInstanceGroupManagerTargetPolicy
type InstanceGroupManagerPolicy struct {
	// The URL for this instance group manager policy.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this instance group manager policy.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this instance group manager policy. Names must be unique within the instance group
	// manager.
	Name *string `json:"name" validate:"required"`

	// The type of metric to be evaluated.
	MetricType *string `json:"metric_type,omitempty"`

	// The metric value to be evaluated.
	MetricValue *int64 `json:"metric_value,omitempty"`

	// The type of Policy for the Instance Group.
	PolicyType *string `json:"policy_type,omitempty"`
}

// Constants associated with the InstanceGroupManagerPolicy.MetricType property.
// The type of metric to be evaluated.
const (
	InstanceGroupManagerPolicyMetricTypeCpuConst        = "cpu"
	InstanceGroupManagerPolicyMetricTypeMemoryConst     = "memory"
	InstanceGroupManagerPolicyMetricTypeNetworkInConst  = "network_in"
	InstanceGroupManagerPolicyMetricTypeNetworkOutConst = "network_out"
)

// Constants associated with the InstanceGroupManagerPolicy.PolicyType property.
// The type of Policy for the Instance Group.
const (
	InstanceGroupManagerPolicyPolicyTypeTargetConst = "target"
)

func (*InstanceGroupManagerPolicy) isaInstanceGroupManagerPolicy() bool {
	return true
}

type InstanceGroupManagerPolicyIntf interface {
	isaInstanceGroupManagerPolicy() bool
}

// UnmarshalInstanceGroupManagerPolicy unmarshals an instance of InstanceGroupManagerPolicy from the specified map of raw messages.
func UnmarshalInstanceGroupManagerPolicy(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupManagerPolicy)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "metric_type", &obj.MetricType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "metric_value", &obj.MetricValue)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "policy_type", &obj.PolicyType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceGroupManagerPolicyCollection : InstanceGroupManagerPolicyCollection struct
type InstanceGroupManagerPolicyCollection struct {
	// A reference to the first page of resources.
	First *InstanceGroupManagerPolicyCollectionFirst `json:"first" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A reference to the next page of resources; this reference is included for all pages
	// except the last page.
	Next *InstanceGroupManagerPolicyCollectionNext `json:"next,omitempty"`

	// Collection of instance group manager policies.
	Policies []InstanceGroupManagerPolicyIntf `json:"policies" validate:"required"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalInstanceGroupManagerPolicyCollection unmarshals an instance of InstanceGroupManagerPolicyCollection from the specified map of raw messages.
func UnmarshalInstanceGroupManagerPolicyCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupManagerPolicyCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalInstanceGroupManagerPolicyCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalInstanceGroupManagerPolicyCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "policies", &obj.Policies, UnmarshalInstanceGroupManagerPolicy)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceGroupManagerPolicyCollectionFirst : A reference to the first page of resources.
type InstanceGroupManagerPolicyCollectionFirst struct {
	// The URL for the first page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalInstanceGroupManagerPolicyCollectionFirst unmarshals an instance of InstanceGroupManagerPolicyCollectionFirst from the specified map of raw messages.
func UnmarshalInstanceGroupManagerPolicyCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupManagerPolicyCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceGroupManagerPolicyCollectionNext : A reference to the next page of resources; this reference is included for all pages except the last page.
type InstanceGroupManagerPolicyCollectionNext struct {
	// The URL for the next page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalInstanceGroupManagerPolicyCollectionNext unmarshals an instance of InstanceGroupManagerPolicyCollectionNext from the specified map of raw messages.
func UnmarshalInstanceGroupManagerPolicyCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupManagerPolicyCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceGroupManagerPolicyPrototype : InstanceGroupManagerPolicyPrototype struct
// Models which "extend" this model:
// - InstanceGroupManagerPolicyPrototypeInstanceGroupManagerTargetPolicyPrototype
type InstanceGroupManagerPolicyPrototype struct {
	// The user-defined name for this instance group manager policy. Names must be unique within the instance group
	// manager.
	Name *string `json:"name,omitempty"`

	// The type of metric to be evaluated.
	MetricType *string `json:"metric_type,omitempty"`

	// The metric value to be evaluated.
	MetricValue *int64 `json:"metric_value,omitempty"`

	// The type of Policy for the Instance Group.
	PolicyType *string `json:"policy_type,omitempty"`
}

// Constants associated with the InstanceGroupManagerPolicyPrototype.MetricType property.
// The type of metric to be evaluated.
const (
	InstanceGroupManagerPolicyPrototypeMetricTypeCpuConst        = "cpu"
	InstanceGroupManagerPolicyPrototypeMetricTypeMemoryConst     = "memory"
	InstanceGroupManagerPolicyPrototypeMetricTypeNetworkInConst  = "network_in"
	InstanceGroupManagerPolicyPrototypeMetricTypeNetworkOutConst = "network_out"
)

// Constants associated with the InstanceGroupManagerPolicyPrototype.PolicyType property.
// The type of Policy for the Instance Group.
const (
	InstanceGroupManagerPolicyPrototypePolicyTypeTargetConst = "target"
)

func (*InstanceGroupManagerPolicyPrototype) isaInstanceGroupManagerPolicyPrototype() bool {
	return true
}

type InstanceGroupManagerPolicyPrototypeIntf interface {
	isaInstanceGroupManagerPolicyPrototype() bool
}

// UnmarshalInstanceGroupManagerPolicyPrototype unmarshals an instance of InstanceGroupManagerPolicyPrototype from the specified map of raw messages.
func UnmarshalInstanceGroupManagerPolicyPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupManagerPolicyPrototype)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "metric_type", &obj.MetricType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "metric_value", &obj.MetricValue)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "policy_type", &obj.PolicyType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceGroupManagerPolicyReference : InstanceGroupManagerPolicyReference struct
type InstanceGroupManagerPolicyReference struct {
	// The URL for this instance group manager policy.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this instance group manager policy.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this instance group manager policy. Names must be unique within the instance group
	// manager.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalInstanceGroupManagerPolicyReference unmarshals an instance of InstanceGroupManagerPolicyReference from the specified map of raw messages.
func UnmarshalInstanceGroupManagerPolicyReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupManagerPolicyReference)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceGroupManagerPrototype : InstanceGroupManagerPrototype struct
// Models which "extend" this model:
// - InstanceGroupManagerPrototypeInstanceGroupManagerAutoScalePrototype
type InstanceGroupManagerPrototype struct {
	// If set to `true`, this manager will control the instance group.
	ManagementEnabled *bool `json:"management_enabled,omitempty"`

	// The user-defined name for this instance group manager. Names must be unique within the instance group.
	Name *string `json:"name,omitempty"`

	// The time window in seconds to aggregate metrics prior to evaluation.
	AggregationWindow *int64 `json:"aggregation_window,omitempty"`

	// The duration of time in seconds to pause further scale actions after scaling has taken place.
	Cooldown *int64 `json:"cooldown,omitempty"`

	// The type of instance group manager.
	ManagerType *string `json:"manager_type,omitempty"`

	// The maximum number of members in a managed instance group.
	MaxMembershipCount *int64 `json:"max_membership_count,omitempty"`

	// The minimum number of members in a managed instance group.
	MinMembershipCount *int64 `json:"min_membership_count,omitempty"`
}

// Constants associated with the InstanceGroupManagerPrototype.ManagerType property.
// The type of instance group manager.
const (
	InstanceGroupManagerPrototypeManagerTypeAutoscaleConst = "autoscale"
)

func (*InstanceGroupManagerPrototype) isaInstanceGroupManagerPrototype() bool {
	return true
}

type InstanceGroupManagerPrototypeIntf interface {
	isaInstanceGroupManagerPrototype() bool
}

// UnmarshalInstanceGroupManagerPrototype unmarshals an instance of InstanceGroupManagerPrototype from the specified map of raw messages.
func UnmarshalInstanceGroupManagerPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupManagerPrototype)
	err = core.UnmarshalPrimitive(m, "management_enabled", &obj.ManagementEnabled)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "aggregation_window", &obj.AggregationWindow)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "cooldown", &obj.Cooldown)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "manager_type", &obj.ManagerType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "max_membership_count", &obj.MaxMembershipCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "min_membership_count", &obj.MinMembershipCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceGroupManagerReference : InstanceGroupManagerReference struct
type InstanceGroupManagerReference struct {
	// The URL for this instance group manager.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this instance group manager.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this instance group manager. Names must be unique within the instance group.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalInstanceGroupManagerReference unmarshals an instance of InstanceGroupManagerReference from the specified map of raw messages.
func UnmarshalInstanceGroupManagerReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupManagerReference)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceGroupMembership : InstanceGroupMembership struct
type InstanceGroupMembership struct {
	// If set to true, when deleting the membership the instance will also be deleted.
	DeleteInstanceOnMembershipDelete *bool `json:"delete_instance_on_membership_delete" validate:"required"`

	// The URL for this instance group membership.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this instance group membership.
	ID *string `json:"id" validate:"required"`

	Instance *InstanceReference `json:"instance" validate:"required"`

	InstanceTemplate *InstanceTemplateReference `json:"instance_template" validate:"required"`

	// The user-defined name for this instance group membership. Names must be unique within the instance group.
	Name *string `json:"name" validate:"required"`

	PoolMember *LoadBalancerPoolMemberReference `json:"pool_member,omitempty"`

	// The status of the instance group membership
	// - `deleting`: Membership is deleting dependent resources
	// - `failed`: Membership was unable to maintain dependent resources
	// - `healthy`: Membership is active and serving in the group
	// - `pending`: Membership is waiting for dependent resources
	// - `unhealthy`: Membership has unhealthy dependent resources.
	Status *string `json:"status" validate:"required"`
}

// Constants associated with the InstanceGroupMembership.Status property.
// The status of the instance group membership
// - `deleting`: Membership is deleting dependent resources
// - `failed`: Membership was unable to maintain dependent resources
// - `healthy`: Membership is active and serving in the group
// - `pending`: Membership is waiting for dependent resources
// - `unhealthy`: Membership has unhealthy dependent resources.
const (
	InstanceGroupMembershipStatusDeletingConst  = "deleting"
	InstanceGroupMembershipStatusFailedConst    = "failed"
	InstanceGroupMembershipStatusHealthyConst   = "healthy"
	InstanceGroupMembershipStatusPendingConst   = "pending"
	InstanceGroupMembershipStatusUnhealthyConst = "unhealthy"
)

// UnmarshalInstanceGroupMembership unmarshals an instance of InstanceGroupMembership from the specified map of raw messages.
func UnmarshalInstanceGroupMembership(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupMembership)
	err = core.UnmarshalPrimitive(m, "delete_instance_on_membership_delete", &obj.DeleteInstanceOnMembershipDelete)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "instance", &obj.Instance, UnmarshalInstanceReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "instance_template", &obj.InstanceTemplate, UnmarshalInstanceTemplateReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "pool_member", &obj.PoolMember, UnmarshalLoadBalancerPoolMemberReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceGroupMembershipCollection : InstanceGroupMembershipCollection struct
type InstanceGroupMembershipCollection struct {
	// A reference to the first page of resources.
	First *InstanceGroupMembershipCollectionFirst `json:"first" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// Collection of instance group memberships.
	Memberships []InstanceGroupMembership `json:"memberships" validate:"required"`

	// A reference to the next page of resources; this reference is included for all pages
	// except the last page.
	Next *InstanceGroupMembershipCollectionNext `json:"next,omitempty"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalInstanceGroupMembershipCollection unmarshals an instance of InstanceGroupMembershipCollection from the specified map of raw messages.
func UnmarshalInstanceGroupMembershipCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupMembershipCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalInstanceGroupMembershipCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "memberships", &obj.Memberships, UnmarshalInstanceGroupMembership)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalInstanceGroupMembershipCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceGroupMembershipCollectionFirst : A reference to the first page of resources.
type InstanceGroupMembershipCollectionFirst struct {
	// The URL for the first page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalInstanceGroupMembershipCollectionFirst unmarshals an instance of InstanceGroupMembershipCollectionFirst from the specified map of raw messages.
func UnmarshalInstanceGroupMembershipCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupMembershipCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceGroupMembershipCollectionNext : A reference to the next page of resources; this reference is included for all pages except the last page.
type InstanceGroupMembershipCollectionNext struct {
	// The URL for the next page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalInstanceGroupMembershipCollectionNext unmarshals an instance of InstanceGroupMembershipCollectionNext from the specified map of raw messages.
func UnmarshalInstanceGroupMembershipCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupMembershipCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceGroupReference : InstanceGroupReference struct
type InstanceGroupReference struct {
	// The CRN for this instance group.
	CRN *string `json:"crn" validate:"required"`

	// The URL for this instance group.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this instance group.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this instance group.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalInstanceGroupReference unmarshals an instance of InstanceGroupReference from the specified map of raw messages.
func UnmarshalInstanceGroupReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceInitialization : InstanceInitialization struct
type InstanceInitialization struct {
	// Collection of references to public SSH keys used at instance initialization.
	Keys []KeyReferenceInstanceInitializationContextIntf `json:"keys" validate:"required"`

	Password *InstanceInitializationPassword `json:"password,omitempty"`
}

// UnmarshalInstanceInitialization unmarshals an instance of InstanceInitialization from the specified map of raw messages.
func UnmarshalInstanceInitialization(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceInitialization)
	err = core.UnmarshalModel(m, "keys", &obj.Keys, UnmarshalKeyReferenceInstanceInitializationContext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "password", &obj.Password, UnmarshalInstanceInitializationPassword)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceInitializationPassword : InstanceInitializationPassword struct
type InstanceInitializationPassword struct {
	// The administrator password at initialization, encrypted using `encryption_key`, and returned base64-encoded.
	EncryptedPassword *[]byte `json:"encrypted_password" validate:"required"`

	// The reference to the public SSH key used to encrypt the administrator password.
	EncryptionKey KeyReferenceInstanceInitializationContextIntf `json:"encryption_key" validate:"required"`
}

// UnmarshalInstanceInitializationPassword unmarshals an instance of InstanceInitializationPassword from the specified map of raw messages.
func UnmarshalInstanceInitializationPassword(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceInitializationPassword)
	err = core.UnmarshalPrimitive(m, "encrypted_password", &obj.EncryptedPassword)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "encryption_key", &obj.EncryptionKey, UnmarshalKeyReferenceInstanceInitializationContext)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstancePlacement : InstancePlacement struct
// Models which "extend" this model:
// - InstancePlacementDedicatedHostGroupReference
// - InstancePlacementDedicatedHostReference
type InstancePlacement struct {
	// The CRN for this dedicated host group.
	CRN *string `json:"crn,omitempty"`

	// The URL for this dedicated host group.
	Href *string `json:"href,omitempty"`

	// The unique identifier for this dedicated host group.
	ID *string `json:"id,omitempty"`

	// The unique user-defined name for this dedicated host group. If unspecified, the name will be a hyphenated list of
	// randomly-selected words.
	Name *string `json:"name,omitempty"`

	// Type of placement resource.
	ResourceType *string `json:"resource_type,omitempty"`
}

// Constants associated with the InstancePlacement.ResourceType property.
// Type of placement resource.
const (
	InstancePlacementResourceTypeDedicatedHostGroupConst = "dedicated_host_group"
)

func (*InstancePlacement) isaInstancePlacement() bool {
	return true
}

type InstancePlacementIntf interface {
	isaInstancePlacement() bool
}

// UnmarshalInstancePlacement unmarshals an instance of InstancePlacement from the specified map of raw messages.
func UnmarshalInstancePlacement(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstancePlacement)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstancePlacementPrototype : InstancePlacementPrototype struct
// Models which "extend" this model:
// - InstancePlacementPrototypeDedicatedHostIdentity
// - InstancePlacementPrototypeDedicatedHostGroupIdentity
type InstancePlacementPrototype struct {
	// The unique identifier for this dedicated host.
	ID *string `json:"id,omitempty"`

	// The CRN for this dedicated host.
	CRN *string `json:"crn,omitempty"`

	// The URL for this dedicated host.
	Href *string `json:"href,omitempty"`
}

func (*InstancePlacementPrototype) isaInstancePlacementPrototype() bool {
	return true
}

type InstancePlacementPrototypeIntf interface {
	isaInstancePlacementPrototype() bool
}

// UnmarshalInstancePlacementPrototype unmarshals an instance of InstancePlacementPrototype from the specified map of raw messages.
func UnmarshalInstancePlacementPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstancePlacementPrototype)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfile : InstanceProfile struct
type InstanceProfile struct {
	Bandwidth InstanceProfileBandwidthIntf `json:"bandwidth" validate:"required"`

	// The product family this virtual server instance profile belongs to.
	Family *string `json:"family,omitempty"`

	GpuCount InstanceProfileGpuIntf `json:"gpu_count,omitempty"`

	GpuManufacturer *InstanceProfileGpuManufacturer `json:"gpu_manufacturer,omitempty"`

	GpuMemory InstanceProfileGpuMemoryIntf `json:"gpu_memory,omitempty"`

	GpuModel *InstanceProfileGpuModel `json:"gpu_model,omitempty"`

	// The URL for this virtual server instance profile.
	Href *string `json:"href" validate:"required"`

	Memory InstanceProfileMemoryIntf `json:"memory" validate:"required"`

	// The name for this virtual server instance profile.
	Name *string `json:"name" validate:"required"`

	OsArchitecture *InstanceProfileOsArchitecture `json:"os_architecture" validate:"required"`

	PortSpeed InstanceProfilePortSpeedIntf `json:"port_speed" validate:"required"`

	VcpuArchitecture *InstanceProfileVcpuArchitecture `json:"vcpu_architecture" validate:"required"`

	VcpuCount InstanceProfileVcpuIntf `json:"vcpu_count" validate:"required"`
}

// UnmarshalInstanceProfile unmarshals an instance of InstanceProfile from the specified map of raw messages.
func UnmarshalInstanceProfile(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfile)
	err = core.UnmarshalModel(m, "bandwidth", &obj.Bandwidth, UnmarshalInstanceProfileBandwidth)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "family", &obj.Family)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "gpu_count", &obj.GpuCount, UnmarshalInstanceProfileGpu)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "gpu_manufacturer", &obj.GpuManufacturer, UnmarshalInstanceProfileGpuManufacturer)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "gpu_memory", &obj.GpuMemory, UnmarshalInstanceProfileGpuMemory)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "gpu_model", &obj.GpuModel, UnmarshalInstanceProfileGpuModel)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "memory", &obj.Memory, UnmarshalInstanceProfileMemory)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "os_architecture", &obj.OsArchitecture, UnmarshalInstanceProfileOsArchitecture)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "port_speed", &obj.PortSpeed, UnmarshalInstanceProfilePortSpeed)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vcpu_architecture", &obj.VcpuArchitecture, UnmarshalInstanceProfileVcpuArchitecture)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vcpu_count", &obj.VcpuCount, UnmarshalInstanceProfileVcpu)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileBandwidth : InstanceProfileBandwidth struct
// Models which "extend" this model:
// - InstanceProfileBandwidthFixed
// - InstanceProfileBandwidthRange
// - InstanceProfileBandwidthEnum
// - InstanceProfileBandwidthDependent
type InstanceProfileBandwidth struct {
	// The type for this profile field.
	Type *string `json:"type,omitempty"`

	// The value for this profile field.
	Value *int64 `json:"value,omitempty"`

	// The default value for this profile field.
	Default *int64 `json:"default,omitempty"`

	// The maximum value for this profile field.
	Max *int64 `json:"max,omitempty"`

	// The minimum value for this profile field.
	Min *int64 `json:"min,omitempty"`

	// The increment step value for this profile field.
	Step *int64 `json:"step,omitempty"`

	// The permitted values for this profile field.
	Values []int64 `json:"values,omitempty"`
}

// Constants associated with the InstanceProfileBandwidth.Type property.
// The type for this profile field.
const (
	InstanceProfileBandwidthTypeFixedConst = "fixed"
)

func (*InstanceProfileBandwidth) isaInstanceProfileBandwidth() bool {
	return true
}

type InstanceProfileBandwidthIntf interface {
	isaInstanceProfileBandwidth() bool
}

// UnmarshalInstanceProfileBandwidth unmarshals an instance of InstanceProfileBandwidth from the specified map of raw messages.
func UnmarshalInstanceProfileBandwidth(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileBandwidth)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "max", &obj.Max)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "min", &obj.Min)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "step", &obj.Step)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "values", &obj.Values)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileCollection : InstanceProfileCollection struct
type InstanceProfileCollection struct {
	// A reference to the first page of resources.
	First *InstanceProfileCollectionFirst `json:"first" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A reference to the next page of resources; this reference is included for all pages
	// except the last page.
	Next *InstanceProfileCollectionNext `json:"next,omitempty"`

	// Collection of virtual server instance profiles.
	Profiles []InstanceProfile `json:"profiles" validate:"required"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalInstanceProfileCollection unmarshals an instance of InstanceProfileCollection from the specified map of raw messages.
func UnmarshalInstanceProfileCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalInstanceProfileCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalInstanceProfileCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "profiles", &obj.Profiles, UnmarshalInstanceProfile)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileCollectionFirst : A reference to the first page of resources.
type InstanceProfileCollectionFirst struct {
	// The URL for the first page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalInstanceProfileCollectionFirst unmarshals an instance of InstanceProfileCollectionFirst from the specified map of raw messages.
func UnmarshalInstanceProfileCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileCollectionNext : A reference to the next page of resources; this reference is included for all pages except the last page.
type InstanceProfileCollectionNext struct {
	// The URL for the next page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalInstanceProfileCollectionNext unmarshals an instance of InstanceProfileCollectionNext from the specified map of raw messages.
func UnmarshalInstanceProfileCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileGpu : InstanceProfileGpu struct
// Models which "extend" this model:
// - InstanceProfileGpuFixed
// - InstanceProfileGpuRange
// - InstanceProfileGpuEnum
// - InstanceProfileGpuDependent
type InstanceProfileGpu struct {
	// The type for this profile field.
	Type *string `json:"type,omitempty"`

	// The value for this profile field.
	Value *int64 `json:"value,omitempty"`

	// The default value for this profile field.
	Default *int64 `json:"default,omitempty"`

	// The maximum value for this profile field.
	Max *int64 `json:"max,omitempty"`

	// The minimum value for this profile field.
	Min *int64 `json:"min,omitempty"`

	// The increment step value for this profile field.
	Step *int64 `json:"step,omitempty"`

	// The permitted values for this profile field.
	Values []int64 `json:"values,omitempty"`
}

// Constants associated with the InstanceProfileGpu.Type property.
// The type for this profile field.
const (
	InstanceProfileGpuTypeFixedConst = "fixed"
)

func (*InstanceProfileGpu) isaInstanceProfileGpu() bool {
	return true
}

type InstanceProfileGpuIntf interface {
	isaInstanceProfileGpu() bool
}

// UnmarshalInstanceProfileGpu unmarshals an instance of InstanceProfileGpu from the specified map of raw messages.
func UnmarshalInstanceProfileGpu(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileGpu)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "max", &obj.Max)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "min", &obj.Min)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "step", &obj.Step)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "values", &obj.Values)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileGpuManufacturer : InstanceProfileGpuManufacturer struct
type InstanceProfileGpuManufacturer struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The possible GPU manufacturer(s) for an instance with this profile.
	Values []string `json:"values" validate:"required"`
}

// Constants associated with the InstanceProfileGpuManufacturer.Type property.
// The type for this profile field.
const (
	InstanceProfileGpuManufacturerTypeEnumConst = "enum"
)

// UnmarshalInstanceProfileGpuManufacturer unmarshals an instance of InstanceProfileGpuManufacturer from the specified map of raw messages.
func UnmarshalInstanceProfileGpuManufacturer(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileGpuManufacturer)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "values", &obj.Values)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileGpuMemory : InstanceProfileGpuMemory struct
// Models which "extend" this model:
// - InstanceProfileGpuMemoryFixed
// - InstanceProfileGpuMemoryRange
// - InstanceProfileGpuMemoryEnum
// - InstanceProfileGpuMemoryDependent
type InstanceProfileGpuMemory struct {
	// The type for this profile field.
	Type *string `json:"type,omitempty"`

	// The value for this profile field.
	Value *int64 `json:"value,omitempty"`

	// The default value for this profile field.
	Default *int64 `json:"default,omitempty"`

	// The maximum value for this profile field.
	Max *int64 `json:"max,omitempty"`

	// The minimum value for this profile field.
	Min *int64 `json:"min,omitempty"`

	// The increment step value for this profile field.
	Step *int64 `json:"step,omitempty"`

	// The permitted values for this profile field.
	Values []int64 `json:"values,omitempty"`
}

// Constants associated with the InstanceProfileGpuMemory.Type property.
// The type for this profile field.
const (
	InstanceProfileGpuMemoryTypeFixedConst = "fixed"
)

func (*InstanceProfileGpuMemory) isaInstanceProfileGpuMemory() bool {
	return true
}

type InstanceProfileGpuMemoryIntf interface {
	isaInstanceProfileGpuMemory() bool
}

// UnmarshalInstanceProfileGpuMemory unmarshals an instance of InstanceProfileGpuMemory from the specified map of raw messages.
func UnmarshalInstanceProfileGpuMemory(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileGpuMemory)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "max", &obj.Max)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "min", &obj.Min)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "step", &obj.Step)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "values", &obj.Values)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileGpuModel : InstanceProfileGpuModel struct
type InstanceProfileGpuModel struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The possible GPU model(s) for an instance with this profile.
	Values []string `json:"values" validate:"required"`
}

// Constants associated with the InstanceProfileGpuModel.Type property.
// The type for this profile field.
const (
	InstanceProfileGpuModelTypeEnumConst = "enum"
)

// UnmarshalInstanceProfileGpuModel unmarshals an instance of InstanceProfileGpuModel from the specified map of raw messages.
func UnmarshalInstanceProfileGpuModel(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileGpuModel)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "values", &obj.Values)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileIdentity : Identifies an instance profile by a unique property.
// Models which "extend" this model:
// - InstanceProfileIdentityByName
// - InstanceProfileIdentityByHref
type InstanceProfileIdentity struct {
	// The name for this virtual server instance profile.
	Name *string `json:"name,omitempty"`

	// The URL for this virtual server instance profile.
	Href *string `json:"href,omitempty"`
}

func (*InstanceProfileIdentity) isaInstanceProfileIdentity() bool {
	return true
}

type InstanceProfileIdentityIntf interface {
	isaInstanceProfileIdentity() bool
}

// UnmarshalInstanceProfileIdentity unmarshals an instance of InstanceProfileIdentity from the specified map of raw messages.
func UnmarshalInstanceProfileIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileIdentity)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileMemory : InstanceProfileMemory struct
// Models which "extend" this model:
// - InstanceProfileMemoryFixed
// - InstanceProfileMemoryRange
// - InstanceProfileMemoryEnum
// - InstanceProfileMemoryDependent
type InstanceProfileMemory struct {
	// The type for this profile field.
	Type *string `json:"type,omitempty"`

	// The value for this profile field.
	Value *int64 `json:"value,omitempty"`

	// The default value for this profile field.
	Default *int64 `json:"default,omitempty"`

	// The maximum value for this profile field.
	Max *int64 `json:"max,omitempty"`

	// The minimum value for this profile field.
	Min *int64 `json:"min,omitempty"`

	// The increment step value for this profile field.
	Step *int64 `json:"step,omitempty"`

	// The permitted values for this profile field.
	Values []int64 `json:"values,omitempty"`
}

// Constants associated with the InstanceProfileMemory.Type property.
// The type for this profile field.
const (
	InstanceProfileMemoryTypeFixedConst = "fixed"
)

func (*InstanceProfileMemory) isaInstanceProfileMemory() bool {
	return true
}

type InstanceProfileMemoryIntf interface {
	isaInstanceProfileMemory() bool
}

// UnmarshalInstanceProfileMemory unmarshals an instance of InstanceProfileMemory from the specified map of raw messages.
func UnmarshalInstanceProfileMemory(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileMemory)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "max", &obj.Max)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "min", &obj.Min)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "step", &obj.Step)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "values", &obj.Values)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileOsArchitecture : InstanceProfileOsArchitecture struct
type InstanceProfileOsArchitecture struct {
	// The default OS architecture for an instance with this profile.
	Default *string `json:"default" validate:"required"`

	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The supported OS architecture(s) for an instance with this profile.
	Values []string `json:"values" validate:"required"`
}

// Constants associated with the InstanceProfileOsArchitecture.Type property.
// The type for this profile field.
const (
	InstanceProfileOsArchitectureTypeEnumConst = "enum"
)

// UnmarshalInstanceProfileOsArchitecture unmarshals an instance of InstanceProfileOsArchitecture from the specified map of raw messages.
func UnmarshalInstanceProfileOsArchitecture(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileOsArchitecture)
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "values", &obj.Values)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfilePortSpeed : InstanceProfilePortSpeed struct
// Models which "extend" this model:
// - InstanceProfilePortSpeedFixed
// - InstanceProfilePortSpeedDependent
type InstanceProfilePortSpeed struct {
	// The type for this profile field.
	Type *string `json:"type,omitempty"`

	// The value for this profile field.
	Value *int64 `json:"value,omitempty"`
}

// Constants associated with the InstanceProfilePortSpeed.Type property.
// The type for this profile field.
const (
	InstanceProfilePortSpeedTypeFixedConst = "fixed"
)

func (*InstanceProfilePortSpeed) isaInstanceProfilePortSpeed() bool {
	return true
}

type InstanceProfilePortSpeedIntf interface {
	isaInstanceProfilePortSpeed() bool
}

// UnmarshalInstanceProfilePortSpeed unmarshals an instance of InstanceProfilePortSpeed from the specified map of raw messages.
func UnmarshalInstanceProfilePortSpeed(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfilePortSpeed)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileReference : InstanceProfileReference struct
type InstanceProfileReference struct {
	// The URL for this virtual server instance profile.
	Href *string `json:"href" validate:"required"`

	// The name for this virtual server instance profile.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalInstanceProfileReference unmarshals an instance of InstanceProfileReference from the specified map of raw messages.
func UnmarshalInstanceProfileReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileReference)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileVcpu : InstanceProfileVcpu struct
// Models which "extend" this model:
// - InstanceProfileVcpuFixed
// - InstanceProfileVcpuRange
// - InstanceProfileVcpuEnum
// - InstanceProfileVcpuDependent
type InstanceProfileVcpu struct {
	// The type for this profile field.
	Type *string `json:"type,omitempty"`

	// The value for this profile field.
	Value *int64 `json:"value,omitempty"`

	// The default value for this profile field.
	Default *int64 `json:"default,omitempty"`

	// The maximum value for this profile field.
	Max *int64 `json:"max,omitempty"`

	// The minimum value for this profile field.
	Min *int64 `json:"min,omitempty"`

	// The increment step value for this profile field.
	Step *int64 `json:"step,omitempty"`

	// The permitted values for this profile field.
	Values []int64 `json:"values,omitempty"`
}

// Constants associated with the InstanceProfileVcpu.Type property.
// The type for this profile field.
const (
	InstanceProfileVcpuTypeFixedConst = "fixed"
)

func (*InstanceProfileVcpu) isaInstanceProfileVcpu() bool {
	return true
}

type InstanceProfileVcpuIntf interface {
	isaInstanceProfileVcpu() bool
}

// UnmarshalInstanceProfileVcpu unmarshals an instance of InstanceProfileVcpu from the specified map of raw messages.
func UnmarshalInstanceProfileVcpu(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileVcpu)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "max", &obj.Max)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "min", &obj.Min)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "step", &obj.Step)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "values", &obj.Values)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileVcpuArchitecture : InstanceProfileVcpuArchitecture struct
type InstanceProfileVcpuArchitecture struct {
	// The default VCPU architecture for an instance with this profile.
	Default *string `json:"default,omitempty"`

	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The VCPU architecture for an instance with this profile.
	Value *string `json:"value" validate:"required"`
}

// Constants associated with the InstanceProfileVcpuArchitecture.Type property.
// The type for this profile field.
const (
	InstanceProfileVcpuArchitectureTypeFixedConst = "fixed"
)

// UnmarshalInstanceProfileVcpuArchitecture unmarshals an instance of InstanceProfileVcpuArchitecture from the specified map of raw messages.
func UnmarshalInstanceProfileVcpuArchitecture(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileVcpuArchitecture)
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstancePrototype : InstancePrototype struct
// Models which "extend" this model:
// - InstancePrototypeInstanceByImage
// - InstancePrototypeInstanceBySourceTemplate
type InstancePrototype struct {
	// The public SSH keys to install on the virtual server instance. Up to 10 keys may be provided; if no keys are
	// provided the instance will be inaccessible unless the image used provides a means of access. For Windows instances,
	// one of the keys will be used to encrypt the administrator password.
	Keys []KeyIdentityIntf `json:"keys,omitempty"`

	// The unique user-defined name for this virtual server instance (and default system hostname). If unspecified, the
	// name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// Collection of additional network interfaces to create for the virtual server instance.
	NetworkInterfaces []NetworkInterfacePrototype `json:"network_interfaces,omitempty"`

	// The placement for the virtual server instance.
	PlacementTarget InstancePlacementPrototypeIntf `json:"placement_target,omitempty"`

	// The profile to use for this virtual server instance.
	Profile InstanceProfileIdentityIntf `json:"profile,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// User data to be made available when setting up the virtual server instance.
	UserData *string `json:"user_data,omitempty"`

	// Collection of volume attachments.
	VolumeAttachments []VolumeAttachmentPrototypeInstanceContext `json:"volume_attachments,omitempty"`

	// The VPC the virtual server instance is to be a part of. If provided, must match the
	// VPC tied to the subnets of the instance's network interfaces.
	VPC VPCIdentityIntf `json:"vpc,omitempty"`

	// The boot volume attachment for the virtual server instance.
	BootVolumeAttachment *VolumeAttachmentPrototypeInstanceByImageContext `json:"boot_volume_attachment,omitempty"`

	// The identity of the image to be used when provisioning the virtual server instance.
	Image ImageIdentityIntf `json:"image,omitempty"`

	// Primary network interface.
	PrimaryNetworkInterface *NetworkInterfacePrototype `json:"primary_network_interface,omitempty"`

	// The identity of the zone to provision the virtual server instance in.
	Zone ZoneIdentityIntf `json:"zone,omitempty"`

	// Identifies an instance template by a unique property.
	SourceTemplate InstanceTemplateIdentityIntf `json:"source_template,omitempty"`
}

func (*InstancePrototype) isaInstancePrototype() bool {
	return true
}

type InstancePrototypeIntf interface {
	isaInstancePrototype() bool
}

// UnmarshalInstancePrototype unmarshals an instance of InstancePrototype from the specified map of raw messages.
func UnmarshalInstancePrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstancePrototype)
	err = core.UnmarshalModel(m, "keys", &obj.Keys, UnmarshalKeyIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "network_interfaces", &obj.NetworkInterfaces, UnmarshalNetworkInterfacePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "placement_target", &obj.PlacementTarget, UnmarshalInstancePlacementPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "profile", &obj.Profile, UnmarshalInstanceProfileIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "user_data", &obj.UserData)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "volume_attachments", &obj.VolumeAttachments, UnmarshalVolumeAttachmentPrototypeInstanceContext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vpc", &obj.VPC, UnmarshalVPCIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "boot_volume_attachment", &obj.BootVolumeAttachment, UnmarshalVolumeAttachmentPrototypeInstanceByImageContext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "image", &obj.Image, UnmarshalImageIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "primary_network_interface", &obj.PrimaryNetworkInterface, UnmarshalNetworkInterfacePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "source_template", &obj.SourceTemplate, UnmarshalInstanceTemplateIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceReference : InstanceReference struct
type InstanceReference struct {
	// The CRN for this virtual server instance.
	CRN *string `json:"crn" validate:"required"`

	// The URL for this virtual server instance.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this virtual server instance.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this virtual server instance (and default system hostname).
	Name *string `json:"name" validate:"required"`

	// The type of resource referenced.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the InstanceReference.ResourceType property.
// The type of resource referenced.
const (
	InstanceReferenceResourceTypeInstanceConst = "instance"
)

// UnmarshalInstanceReference unmarshals an instance of InstanceReference from the specified map of raw messages.
func UnmarshalInstanceReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceTemplate : InstanceTemplate struct
// Models which "extend" this model:
// - InstanceTemplateInstanceByImage
// - InstanceTemplateInstanceBySourceTemplate
type InstanceTemplate struct {
	// The date and time that the instance template was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The CRN for this instance template.
	CRN *string `json:"crn" validate:"required"`

	// The URL for this instance template.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this instance template.
	ID *string `json:"id" validate:"required"`

	// The public SSH keys to install on the virtual server instance. Up to 10 keys may be provided; if no keys are
	// provided the instance will be inaccessible unless the image used provides a means of access. For Windows instances,
	// one of the keys will be used to encrypt the administrator password.
	Keys []KeyIdentityIntf `json:"keys,omitempty"`

	// The unique user-defined name for this instance template.
	Name *string `json:"name" validate:"required"`

	// Collection of additional network interfaces to create for the virtual server instance.
	NetworkInterfaces []NetworkInterfacePrototype `json:"network_interfaces,omitempty"`

	// The placement for the virtual server instance.
	PlacementTarget InstancePlacementPrototypeIntf `json:"placement_target,omitempty"`

	// The profile to use for this virtual server instance.
	Profile InstanceProfileIdentityIntf `json:"profile,omitempty"`

	// The resource group of the instance template.
	ResourceGroup *ResourceGroupReference `json:"resource_group" validate:"required"`

	// User data to be made available when setting up the virtual server instance.
	UserData *string `json:"user_data,omitempty"`

	// Collection of volume attachments.
	VolumeAttachments []VolumeAttachmentPrototypeInstanceContext `json:"volume_attachments,omitempty"`

	// The VPC the virtual server instance is to be a part of. If provided, must match the
	// VPC tied to the subnets of the instance's network interfaces.
	VPC VPCIdentityIntf `json:"vpc,omitempty"`

	// The boot volume attachment for the virtual server instance.
	BootVolumeAttachment *VolumeAttachmentPrototypeInstanceByImageContext `json:"boot_volume_attachment,omitempty"`

	// The identity of the image to be used when provisioning the virtual server instance.
	Image ImageIdentityIntf `json:"image,omitempty"`

	// Primary network interface.
	PrimaryNetworkInterface *NetworkInterfacePrototype `json:"primary_network_interface,omitempty"`

	// The identity of the zone to provision the virtual server instance in.
	Zone ZoneIdentityIntf `json:"zone,omitempty"`

	// Identifies an instance template by a unique property.
	SourceTemplate InstanceTemplateIdentityIntf `json:"source_template,omitempty"`
}

func (*InstanceTemplate) isaInstanceTemplate() bool {
	return true
}

type InstanceTemplateIntf interface {
	isaInstanceTemplate() bool
}

// UnmarshalInstanceTemplate unmarshals an instance of InstanceTemplate from the specified map of raw messages.
func UnmarshalInstanceTemplate(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceTemplate)
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "keys", &obj.Keys, UnmarshalKeyIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "network_interfaces", &obj.NetworkInterfaces, UnmarshalNetworkInterfacePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "placement_target", &obj.PlacementTarget, UnmarshalInstancePlacementPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "profile", &obj.Profile, UnmarshalInstanceProfileIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "user_data", &obj.UserData)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "volume_attachments", &obj.VolumeAttachments, UnmarshalVolumeAttachmentPrototypeInstanceContext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vpc", &obj.VPC, UnmarshalVPCIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "boot_volume_attachment", &obj.BootVolumeAttachment, UnmarshalVolumeAttachmentPrototypeInstanceByImageContext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "image", &obj.Image, UnmarshalImageIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "primary_network_interface", &obj.PrimaryNetworkInterface, UnmarshalNetworkInterfacePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "source_template", &obj.SourceTemplate, UnmarshalInstanceTemplateIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceTemplateCollection : InstanceTemplateCollection struct
type InstanceTemplateCollection struct {
	// A reference to the first page of resources.
	First *InstanceTemplateCollectionFirst `json:"first" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A reference to the next page of resources; this reference is included for all pages
	// except the last page.
	Next *InstanceTemplateCollectionNext `json:"next,omitempty"`

	// Collection of instance templates.
	Templates []InstanceTemplateIntf `json:"templates" validate:"required"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalInstanceTemplateCollection unmarshals an instance of InstanceTemplateCollection from the specified map of raw messages.
func UnmarshalInstanceTemplateCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceTemplateCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalInstanceTemplateCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalInstanceTemplateCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "templates", &obj.Templates, UnmarshalInstanceTemplate)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceTemplateCollectionFirst : A reference to the first page of resources.
type InstanceTemplateCollectionFirst struct {
	// The URL for the first page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalInstanceTemplateCollectionFirst unmarshals an instance of InstanceTemplateCollectionFirst from the specified map of raw messages.
func UnmarshalInstanceTemplateCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceTemplateCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceTemplateCollectionNext : A reference to the next page of resources; this reference is included for all pages except the last page.
type InstanceTemplateCollectionNext struct {
	// The URL for the next page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalInstanceTemplateCollectionNext unmarshals an instance of InstanceTemplateCollectionNext from the specified map of raw messages.
func UnmarshalInstanceTemplateCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceTemplateCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceTemplateIdentity : Identifies an instance template by a unique property.
// Models which "extend" this model:
// - InstanceTemplateIdentityByID
// - InstanceTemplateIdentityByHref
// - InstanceTemplateIdentityByCRN
type InstanceTemplateIdentity struct {
	// The unique identifier for this instance template.
	ID *string `json:"id,omitempty"`

	// The URL for this instance template.
	Href *string `json:"href,omitempty"`

	// The CRN for this instance template.
	CRN *string `json:"crn,omitempty"`
}

func (*InstanceTemplateIdentity) isaInstanceTemplateIdentity() bool {
	return true
}

type InstanceTemplateIdentityIntf interface {
	isaInstanceTemplateIdentity() bool
}

// UnmarshalInstanceTemplateIdentity unmarshals an instance of InstanceTemplateIdentity from the specified map of raw messages.
func UnmarshalInstanceTemplateIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceTemplateIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceTemplatePrototype : InstanceTemplatePrototype struct
// Models which "extend" this model:
// - InstanceTemplatePrototypeInstanceByImage
// - InstanceTemplatePrototypeInstanceBySourceTemplate
type InstanceTemplatePrototype struct {
	// The public SSH keys to install on the virtual server instance. Up to 10 keys may be provided; if no keys are
	// provided the instance will be inaccessible unless the image used provides a means of access. For Windows instances,
	// one of the keys will be used to encrypt the administrator password.
	Keys []KeyIdentityIntf `json:"keys,omitempty"`

	// The unique user-defined name for this virtual server instance (and default system hostname). If unspecified, the
	// name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// Collection of additional network interfaces to create for the virtual server instance.
	NetworkInterfaces []NetworkInterfacePrototype `json:"network_interfaces,omitempty"`

	// The placement for the virtual server instance.
	PlacementTarget InstancePlacementPrototypeIntf `json:"placement_target,omitempty"`

	// The profile to use for this virtual server instance.
	Profile InstanceProfileIdentityIntf `json:"profile,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// User data to be made available when setting up the virtual server instance.
	UserData *string `json:"user_data,omitempty"`

	// Collection of volume attachments.
	VolumeAttachments []VolumeAttachmentPrototypeInstanceContext `json:"volume_attachments,omitempty"`

	// The VPC the virtual server instance is to be a part of. If provided, must match the
	// VPC tied to the subnets of the instance's network interfaces.
	VPC VPCIdentityIntf `json:"vpc,omitempty"`

	// The boot volume attachment for the virtual server instance.
	BootVolumeAttachment *VolumeAttachmentPrototypeInstanceByImageContext `json:"boot_volume_attachment,omitempty"`

	// The identity of the image to be used when provisioning the virtual server instance.
	Image ImageIdentityIntf `json:"image,omitempty"`

	// Primary network interface.
	PrimaryNetworkInterface *NetworkInterfacePrototype `json:"primary_network_interface,omitempty"`

	// The identity of the zone to provision the virtual server instance in.
	Zone ZoneIdentityIntf `json:"zone,omitempty"`

	// Identifies an instance template by a unique property.
	SourceTemplate InstanceTemplateIdentityIntf `json:"source_template,omitempty"`
}

func (*InstanceTemplatePrototype) isaInstanceTemplatePrototype() bool {
	return true
}

type InstanceTemplatePrototypeIntf interface {
	isaInstanceTemplatePrototype() bool
}

// UnmarshalInstanceTemplatePrototype unmarshals an instance of InstanceTemplatePrototype from the specified map of raw messages.
func UnmarshalInstanceTemplatePrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceTemplatePrototype)
	err = core.UnmarshalModel(m, "keys", &obj.Keys, UnmarshalKeyIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "network_interfaces", &obj.NetworkInterfaces, UnmarshalNetworkInterfacePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "placement_target", &obj.PlacementTarget, UnmarshalInstancePlacementPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "profile", &obj.Profile, UnmarshalInstanceProfileIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "user_data", &obj.UserData)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "volume_attachments", &obj.VolumeAttachments, UnmarshalVolumeAttachmentPrototypeInstanceContext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vpc", &obj.VPC, UnmarshalVPCIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "boot_volume_attachment", &obj.BootVolumeAttachment, UnmarshalVolumeAttachmentPrototypeInstanceByImageContext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "image", &obj.Image, UnmarshalImageIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "primary_network_interface", &obj.PrimaryNetworkInterface, UnmarshalNetworkInterfacePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "source_template", &obj.SourceTemplate, UnmarshalInstanceTemplateIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceTemplateReference : InstanceTemplateReference struct
type InstanceTemplateReference struct {
	// The CRN for this instance template.
	CRN *string `json:"crn" validate:"required"`

	// The URL for this instance template.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this instance template.
	ID *string `json:"id" validate:"required"`
}

// UnmarshalInstanceTemplateReference unmarshals an instance of InstanceTemplateReference from the specified map of raw messages.
func UnmarshalInstanceTemplateReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceTemplateReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceVcpu : The virtual server instance VCPU configuration.
type InstanceVcpu struct {
	// The VCPU architecture.
	Architecture *string `json:"architecture" validate:"required"`

	// The number of VCPUs assigned.
	Count *int64 `json:"count" validate:"required"`
}

// UnmarshalInstanceVcpu unmarshals an instance of InstanceVcpu from the specified map of raw messages.
func UnmarshalInstanceVcpu(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceVcpu)
	err = core.UnmarshalPrimitive(m, "architecture", &obj.Architecture)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "count", &obj.Count)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Key : Key struct
type Key struct {
	// The date and time that the key was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The CRN for this key.
	CRN *string `json:"crn" validate:"required"`

	// The fingerprint for this key.  The value is returned base64-encoded and prefixed with the hash algorithm (always
	// `SHA256`).
	Fingerprint *string `json:"fingerprint" validate:"required"`

	// The URL for this key.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this key.
	ID *string `json:"id" validate:"required"`

	// The length of this key (in bits).
	Length *int64 `json:"length" validate:"required"`

	// The unique user-defined name for this key. If unspecified, the name will be a hyphenated list of randomly-selected
	// words.
	Name *string `json:"name" validate:"required"`

	// The public SSH key.
	PublicKey *string `json:"public_key" validate:"required"`

	// The resource group for this key.
	ResourceGroup *ResourceGroupReference `json:"resource_group" validate:"required"`

	// The cryptosystem used by this key.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the Key.Type property.
// The cryptosystem used by this key.
const (
	KeyTypeRsaConst = "rsa"
)

// UnmarshalKey unmarshals an instance of Key from the specified map of raw messages.
func UnmarshalKey(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Key)
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "fingerprint", &obj.Fingerprint)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "length", &obj.Length)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "public_key", &obj.PublicKey)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// KeyCollection : KeyCollection struct
type KeyCollection struct {
	// A reference to the first page of resources.
	First *KeyCollectionFirst `json:"first" validate:"required"`

	// Collection of keys.
	Keys []Key `json:"keys" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A reference to the next page of resources; this reference is included for all pages
	// except the last page.
	Next *KeyCollectionNext `json:"next,omitempty"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalKeyCollection unmarshals an instance of KeyCollection from the specified map of raw messages.
func UnmarshalKeyCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(KeyCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalKeyCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "keys", &obj.Keys, UnmarshalKey)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalKeyCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// KeyCollectionFirst : A reference to the first page of resources.
type KeyCollectionFirst struct {
	// The URL for the first page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalKeyCollectionFirst unmarshals an instance of KeyCollectionFirst from the specified map of raw messages.
func UnmarshalKeyCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(KeyCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// KeyCollectionNext : A reference to the next page of resources; this reference is included for all pages except the last page.
type KeyCollectionNext struct {
	// The URL for the next page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalKeyCollectionNext unmarshals an instance of KeyCollectionNext from the specified map of raw messages.
func UnmarshalKeyCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(KeyCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// KeyIdentity : Identifies a key by a unique property.
// Models which "extend" this model:
// - KeyIdentityByID
// - KeyIdentityByCRN
// - KeyIdentityByHref
// - KeyIdentityByFingerprint
type KeyIdentity struct {
	// The unique identifier for this key.
	ID *string `json:"id,omitempty"`

	// The CRN for this key.
	CRN *string `json:"crn,omitempty"`

	// The URL for this key.
	Href *string `json:"href,omitempty"`

	// The fingerprint for this key.  The value is returned base64-encoded and prefixed with the hash algorithm (always
	// `SHA256`).
	Fingerprint *string `json:"fingerprint,omitempty"`
}

func (*KeyIdentity) isaKeyIdentity() bool {
	return true
}

type KeyIdentityIntf interface {
	isaKeyIdentity() bool
}

// UnmarshalKeyIdentity unmarshals an instance of KeyIdentity from the specified map of raw messages.
func UnmarshalKeyIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(KeyIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "fingerprint", &obj.Fingerprint)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// KeyReferenceInstanceInitializationContext : KeyReferenceInstanceInitializationContext struct
// Models which "extend" this model:
// - KeyReferenceInstanceInitializationContextKeyReference
// - KeyReferenceInstanceInitializationContextKeyIdentityByFingerprint
type KeyReferenceInstanceInitializationContext struct {
	// The CRN for this key.
	CRN *string `json:"crn,omitempty"`

	// The fingerprint for this key.  The value is returned base64-encoded and prefixed with the hash algorithm (always
	// `SHA256`).
	Fingerprint *string `json:"fingerprint,omitempty"`

	// The URL for this key.
	Href *string `json:"href,omitempty"`

	// The unique identifier for this key.
	ID *string `json:"id,omitempty"`

	// The user-defined name for this key.
	Name *string `json:"name,omitempty"`
}

func (*KeyReferenceInstanceInitializationContext) isaKeyReferenceInstanceInitializationContext() bool {
	return true
}

type KeyReferenceInstanceInitializationContextIntf interface {
	isaKeyReferenceInstanceInitializationContext() bool
}

// UnmarshalKeyReferenceInstanceInitializationContext unmarshals an instance of KeyReferenceInstanceInitializationContext from the specified map of raw messages.
func UnmarshalKeyReferenceInstanceInitializationContext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(KeyReferenceInstanceInitializationContext)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "fingerprint", &obj.Fingerprint)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ListDedicatedHostGroupsOptions : The ListDedicatedHostGroups options.
type ListDedicatedHostGroupsOptions struct {
	// A server-supplied token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Filters the collection to resources within one of the resource groups identified in a comma-separated list of
	// resource group identifiers.
	ResourceGroupID *string `json:"resource_group.id,omitempty"`

	// Filters the collection to resources in the zone with the exact specified name.
	ZoneName *string `json:"zone.name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListDedicatedHostGroupsOptions : Instantiate ListDedicatedHostGroupsOptions
func (*VpcV1) NewListDedicatedHostGroupsOptions() *ListDedicatedHostGroupsOptions {
	return &ListDedicatedHostGroupsOptions{}
}

// SetStart : Allow user to set Start
func (options *ListDedicatedHostGroupsOptions) SetStart(start string) *ListDedicatedHostGroupsOptions {
	options.Start = core.StringPtr(start)
	return options
}

// SetLimit : Allow user to set Limit
func (options *ListDedicatedHostGroupsOptions) SetLimit(limit int64) *ListDedicatedHostGroupsOptions {
	options.Limit = core.Int64Ptr(limit)
	return options
}

// SetResourceGroupID : Allow user to set ResourceGroupID
func (options *ListDedicatedHostGroupsOptions) SetResourceGroupID(resourceGroupID string) *ListDedicatedHostGroupsOptions {
	options.ResourceGroupID = core.StringPtr(resourceGroupID)
	return options
}

// SetZoneName : Allow user to set ZoneName
func (options *ListDedicatedHostGroupsOptions) SetZoneName(zoneName string) *ListDedicatedHostGroupsOptions {
	options.ZoneName = core.StringPtr(zoneName)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListDedicatedHostGroupsOptions) SetHeaders(param map[string]string) *ListDedicatedHostGroupsOptions {
	options.Headers = param
	return options
}

// ListDedicatedHostProfilesOptions : The ListDedicatedHostProfiles options.
type ListDedicatedHostProfilesOptions struct {
	// A server-supplied token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListDedicatedHostProfilesOptions : Instantiate ListDedicatedHostProfilesOptions
func (*VpcV1) NewListDedicatedHostProfilesOptions() *ListDedicatedHostProfilesOptions {
	return &ListDedicatedHostProfilesOptions{}
}

// SetStart : Allow user to set Start
func (options *ListDedicatedHostProfilesOptions) SetStart(start string) *ListDedicatedHostProfilesOptions {
	options.Start = core.StringPtr(start)
	return options
}

// SetLimit : Allow user to set Limit
func (options *ListDedicatedHostProfilesOptions) SetLimit(limit int64) *ListDedicatedHostProfilesOptions {
	options.Limit = core.Int64Ptr(limit)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListDedicatedHostProfilesOptions) SetHeaders(param map[string]string) *ListDedicatedHostProfilesOptions {
	options.Headers = param
	return options
}

// ListDedicatedHostsOptions : The ListDedicatedHosts options.
type ListDedicatedHostsOptions struct {
	// Filters the collection to dedicated host groups with specified identifier.
	DedicatedHostGroupID *string `json:"dedicated_host_group.id,omitempty"`

	// A server-supplied token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Filters the collection to resources within one of the resource groups identified in a comma-separated list of
	// resource group identifiers.
	ResourceGroupID *string `json:"resource_group.id,omitempty"`

	// Filters the collection to resources in the zone with the exact specified name.
	ZoneName *string `json:"zone.name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListDedicatedHostsOptions : Instantiate ListDedicatedHostsOptions
func (*VpcV1) NewListDedicatedHostsOptions() *ListDedicatedHostsOptions {
	return &ListDedicatedHostsOptions{}
}

// SetDedicatedHostGroupID : Allow user to set DedicatedHostGroupID
func (options *ListDedicatedHostsOptions) SetDedicatedHostGroupID(dedicatedHostGroupID string) *ListDedicatedHostsOptions {
	options.DedicatedHostGroupID = core.StringPtr(dedicatedHostGroupID)
	return options
}

// SetStart : Allow user to set Start
func (options *ListDedicatedHostsOptions) SetStart(start string) *ListDedicatedHostsOptions {
	options.Start = core.StringPtr(start)
	return options
}

// SetLimit : Allow user to set Limit
func (options *ListDedicatedHostsOptions) SetLimit(limit int64) *ListDedicatedHostsOptions {
	options.Limit = core.Int64Ptr(limit)
	return options
}

// SetResourceGroupID : Allow user to set ResourceGroupID
func (options *ListDedicatedHostsOptions) SetResourceGroupID(resourceGroupID string) *ListDedicatedHostsOptions {
	options.ResourceGroupID = core.StringPtr(resourceGroupID)
	return options
}

// SetZoneName : Allow user to set ZoneName
func (options *ListDedicatedHostsOptions) SetZoneName(zoneName string) *ListDedicatedHostsOptions {
	options.ZoneName = core.StringPtr(zoneName)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListDedicatedHostsOptions) SetHeaders(param map[string]string) *ListDedicatedHostsOptions {
	options.Headers = param
	return options
}

// ListFloatingIpsOptions : The ListFloatingIps options.
type ListFloatingIpsOptions struct {
	// A server-supplied token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Filters the collection to resources within one of the resource groups identified in a comma-separated list of
	// resource group identifiers.
	ResourceGroupID *string `json:"resource_group.id,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListFloatingIpsOptions : Instantiate ListFloatingIpsOptions
func (*VpcV1) NewListFloatingIpsOptions() *ListFloatingIpsOptions {
	return &ListFloatingIpsOptions{}
}

// SetStart : Allow user to set Start
func (options *ListFloatingIpsOptions) SetStart(start string) *ListFloatingIpsOptions {
	options.Start = core.StringPtr(start)
	return options
}

// SetLimit : Allow user to set Limit
func (options *ListFloatingIpsOptions) SetLimit(limit int64) *ListFloatingIpsOptions {
	options.Limit = core.Int64Ptr(limit)
	return options
}

// SetResourceGroupID : Allow user to set ResourceGroupID
func (options *ListFloatingIpsOptions) SetResourceGroupID(resourceGroupID string) *ListFloatingIpsOptions {
	options.ResourceGroupID = core.StringPtr(resourceGroupID)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListFloatingIpsOptions) SetHeaders(param map[string]string) *ListFloatingIpsOptions {
	options.Headers = param
	return options
}

// ListFlowLogCollectorsOptions : The ListFlowLogCollectors options.
type ListFlowLogCollectorsOptions struct {
	// A server-supplied token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Filters the collection to resources within one of the resource groups identified in a comma-separated list of
	// resource group identifiers.
	ResourceGroupID *string `json:"resource_group.id,omitempty"`

	// Filters the collection to resources with the exact specified name.
	Name *string `json:"name,omitempty"`

	// Filters the collection to resources in the VPC with the specified identifier.
	VPCID *string `json:"vpc.id,omitempty"`

	// Filters the collection to resources in the VPC with the specified CRN.
	VPCCRN *string `json:"vpc.crn,omitempty"`

	// Filters the collection to resources in the VPC with the exact specified name.
	VPCName *string `json:"vpc.name,omitempty"`

	// Filters the collection to flow log collectors that target the specified resource.
	TargetID *string `json:"target.id,omitempty"`

	// Filters the collection to flow log collectors that target the specified resource type.
	TargetResourceType *string `json:"target.resource_type,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the ListFlowLogCollectorsOptions.TargetResourceType property.
// Filters the collection to flow log collectors that target the specified resource type.
const (
	ListFlowLogCollectorsOptionsTargetResourceTypeInstanceConst         = "instance"
	ListFlowLogCollectorsOptionsTargetResourceTypeNetworkInterfaceConst = "network_interface"
	ListFlowLogCollectorsOptionsTargetResourceTypeSubnetConst           = "subnet"
	ListFlowLogCollectorsOptionsTargetResourceTypeVPCConst              = "vpc"
)

// NewListFlowLogCollectorsOptions : Instantiate ListFlowLogCollectorsOptions
func (*VpcV1) NewListFlowLogCollectorsOptions() *ListFlowLogCollectorsOptions {
	return &ListFlowLogCollectorsOptions{}
}

// SetStart : Allow user to set Start
func (options *ListFlowLogCollectorsOptions) SetStart(start string) *ListFlowLogCollectorsOptions {
	options.Start = core.StringPtr(start)
	return options
}

// SetLimit : Allow user to set Limit
func (options *ListFlowLogCollectorsOptions) SetLimit(limit int64) *ListFlowLogCollectorsOptions {
	options.Limit = core.Int64Ptr(limit)
	return options
}

// SetResourceGroupID : Allow user to set ResourceGroupID
func (options *ListFlowLogCollectorsOptions) SetResourceGroupID(resourceGroupID string) *ListFlowLogCollectorsOptions {
	options.ResourceGroupID = core.StringPtr(resourceGroupID)
	return options
}

// SetName : Allow user to set Name
func (options *ListFlowLogCollectorsOptions) SetName(name string) *ListFlowLogCollectorsOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetVPCID : Allow user to set VPCID
func (options *ListFlowLogCollectorsOptions) SetVPCID(vpcID string) *ListFlowLogCollectorsOptions {
	options.VPCID = core.StringPtr(vpcID)
	return options
}

// SetVPCCRN : Allow user to set VPCCRN
func (options *ListFlowLogCollectorsOptions) SetVPCCRN(vpcCRN string) *ListFlowLogCollectorsOptions {
	options.VPCCRN = core.StringPtr(vpcCRN)
	return options
}

// SetVPCName : Allow user to set VPCName
func (options *ListFlowLogCollectorsOptions) SetVPCName(vpcName string) *ListFlowLogCollectorsOptions {
	options.VPCName = core.StringPtr(vpcName)
	return options
}

// SetTargetID : Allow user to set TargetID
func (options *ListFlowLogCollectorsOptions) SetTargetID(targetID string) *ListFlowLogCollectorsOptions {
	options.TargetID = core.StringPtr(targetID)
	return options
}

// SetTargetResourceType : Allow user to set TargetResourceType
func (options *ListFlowLogCollectorsOptions) SetTargetResourceType(targetResourceType string) *ListFlowLogCollectorsOptions {
	options.TargetResourceType = core.StringPtr(targetResourceType)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListFlowLogCollectorsOptions) SetHeaders(param map[string]string) *ListFlowLogCollectorsOptions {
	options.Headers = param
	return options
}

// ListIkePoliciesOptions : The ListIkePolicies options.
type ListIkePoliciesOptions struct {
	// A server-supplied token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListIkePoliciesOptions : Instantiate ListIkePoliciesOptions
func (*VpcV1) NewListIkePoliciesOptions() *ListIkePoliciesOptions {
	return &ListIkePoliciesOptions{}
}

// SetStart : Allow user to set Start
func (options *ListIkePoliciesOptions) SetStart(start string) *ListIkePoliciesOptions {
	options.Start = core.StringPtr(start)
	return options
}

// SetLimit : Allow user to set Limit
func (options *ListIkePoliciesOptions) SetLimit(limit int64) *ListIkePoliciesOptions {
	options.Limit = core.Int64Ptr(limit)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListIkePoliciesOptions) SetHeaders(param map[string]string) *ListIkePoliciesOptions {
	options.Headers = param
	return options
}

// ListIkePolicyConnectionsOptions : The ListIkePolicyConnections options.
type ListIkePolicyConnectionsOptions struct {
	// The IKE policy identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListIkePolicyConnectionsOptions : Instantiate ListIkePolicyConnectionsOptions
func (*VpcV1) NewListIkePolicyConnectionsOptions(id string) *ListIkePolicyConnectionsOptions {
	return &ListIkePolicyConnectionsOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *ListIkePolicyConnectionsOptions) SetID(id string) *ListIkePolicyConnectionsOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListIkePolicyConnectionsOptions) SetHeaders(param map[string]string) *ListIkePolicyConnectionsOptions {
	options.Headers = param
	return options
}

// ListImagesOptions : The ListImages options.
type ListImagesOptions struct {
	// A server-supplied token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Filters the collection to resources within one of the resource groups identified in a comma-separated list of
	// resource group identifiers.
	ResourceGroupID *string `json:"resource_group.id,omitempty"`

	// Filters the collection to resources with the exact specified name.
	Name *string `json:"name,omitempty"`

	// Filters the collection to images with the specified visibility.
	Visibility *string `json:"visibility,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the ListImagesOptions.Visibility property.
// Filters the collection to images with the specified visibility.
const (
	ListImagesOptionsVisibilityPrivateConst = "private"
	ListImagesOptionsVisibilityPublicConst  = "public"
)

// NewListImagesOptions : Instantiate ListImagesOptions
func (*VpcV1) NewListImagesOptions() *ListImagesOptions {
	return &ListImagesOptions{}
}

// SetStart : Allow user to set Start
func (options *ListImagesOptions) SetStart(start string) *ListImagesOptions {
	options.Start = core.StringPtr(start)
	return options
}

// SetLimit : Allow user to set Limit
func (options *ListImagesOptions) SetLimit(limit int64) *ListImagesOptions {
	options.Limit = core.Int64Ptr(limit)
	return options
}

// SetResourceGroupID : Allow user to set ResourceGroupID
func (options *ListImagesOptions) SetResourceGroupID(resourceGroupID string) *ListImagesOptions {
	options.ResourceGroupID = core.StringPtr(resourceGroupID)
	return options
}

// SetName : Allow user to set Name
func (options *ListImagesOptions) SetName(name string) *ListImagesOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetVisibility : Allow user to set Visibility
func (options *ListImagesOptions) SetVisibility(visibility string) *ListImagesOptions {
	options.Visibility = core.StringPtr(visibility)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListImagesOptions) SetHeaders(param map[string]string) *ListImagesOptions {
	options.Headers = param
	return options
}

// ListInstanceGroupManagerPoliciesOptions : The ListInstanceGroupManagerPolicies options.
type ListInstanceGroupManagerPoliciesOptions struct {
	// The instance group identifier.
	InstanceGroupID *string `json:"instance_group_id" validate:"required"`

	// The instance group manager identifier.
	InstanceGroupManagerID *string `json:"instance_group_manager_id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListInstanceGroupManagerPoliciesOptions : Instantiate ListInstanceGroupManagerPoliciesOptions
func (*VpcV1) NewListInstanceGroupManagerPoliciesOptions(instanceGroupID string, instanceGroupManagerID string) *ListInstanceGroupManagerPoliciesOptions {
	return &ListInstanceGroupManagerPoliciesOptions{
		InstanceGroupID:        core.StringPtr(instanceGroupID),
		InstanceGroupManagerID: core.StringPtr(instanceGroupManagerID),
	}
}

// SetInstanceGroupID : Allow user to set InstanceGroupID
func (options *ListInstanceGroupManagerPoliciesOptions) SetInstanceGroupID(instanceGroupID string) *ListInstanceGroupManagerPoliciesOptions {
	options.InstanceGroupID = core.StringPtr(instanceGroupID)
	return options
}

// SetInstanceGroupManagerID : Allow user to set InstanceGroupManagerID
func (options *ListInstanceGroupManagerPoliciesOptions) SetInstanceGroupManagerID(instanceGroupManagerID string) *ListInstanceGroupManagerPoliciesOptions {
	options.InstanceGroupManagerID = core.StringPtr(instanceGroupManagerID)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListInstanceGroupManagerPoliciesOptions) SetHeaders(param map[string]string) *ListInstanceGroupManagerPoliciesOptions {
	options.Headers = param
	return options
}

// ListInstanceGroupManagersOptions : The ListInstanceGroupManagers options.
type ListInstanceGroupManagersOptions struct {
	// The instance group identifier.
	InstanceGroupID *string `json:"instance_group_id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListInstanceGroupManagersOptions : Instantiate ListInstanceGroupManagersOptions
func (*VpcV1) NewListInstanceGroupManagersOptions(instanceGroupID string) *ListInstanceGroupManagersOptions {
	return &ListInstanceGroupManagersOptions{
		InstanceGroupID: core.StringPtr(instanceGroupID),
	}
}

// SetInstanceGroupID : Allow user to set InstanceGroupID
func (options *ListInstanceGroupManagersOptions) SetInstanceGroupID(instanceGroupID string) *ListInstanceGroupManagersOptions {
	options.InstanceGroupID = core.StringPtr(instanceGroupID)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListInstanceGroupManagersOptions) SetHeaders(param map[string]string) *ListInstanceGroupManagersOptions {
	options.Headers = param
	return options
}

// ListInstanceGroupMembershipsOptions : The ListInstanceGroupMemberships options.
type ListInstanceGroupMembershipsOptions struct {
	// The instance group identifier.
	InstanceGroupID *string `json:"instance_group_id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListInstanceGroupMembershipsOptions : Instantiate ListInstanceGroupMembershipsOptions
func (*VpcV1) NewListInstanceGroupMembershipsOptions(instanceGroupID string) *ListInstanceGroupMembershipsOptions {
	return &ListInstanceGroupMembershipsOptions{
		InstanceGroupID: core.StringPtr(instanceGroupID),
	}
}

// SetInstanceGroupID : Allow user to set InstanceGroupID
func (options *ListInstanceGroupMembershipsOptions) SetInstanceGroupID(instanceGroupID string) *ListInstanceGroupMembershipsOptions {
	options.InstanceGroupID = core.StringPtr(instanceGroupID)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListInstanceGroupMembershipsOptions) SetHeaders(param map[string]string) *ListInstanceGroupMembershipsOptions {
	options.Headers = param
	return options
}

// ListInstanceGroupsOptions : The ListInstanceGroups options.
type ListInstanceGroupsOptions struct {
	// A server-supplied token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListInstanceGroupsOptions : Instantiate ListInstanceGroupsOptions
func (*VpcV1) NewListInstanceGroupsOptions() *ListInstanceGroupsOptions {
	return &ListInstanceGroupsOptions{}
}

// SetStart : Allow user to set Start
func (options *ListInstanceGroupsOptions) SetStart(start string) *ListInstanceGroupsOptions {
	options.Start = core.StringPtr(start)
	return options
}

// SetLimit : Allow user to set Limit
func (options *ListInstanceGroupsOptions) SetLimit(limit int64) *ListInstanceGroupsOptions {
	options.Limit = core.Int64Ptr(limit)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListInstanceGroupsOptions) SetHeaders(param map[string]string) *ListInstanceGroupsOptions {
	options.Headers = param
	return options
}

// ListInstanceNetworkInterfaceFloatingIpsOptions : The ListInstanceNetworkInterfaceFloatingIps options.
type ListInstanceNetworkInterfaceFloatingIpsOptions struct {
	// The instance identifier.
	InstanceID *string `json:"instance_id" validate:"required"`

	// The network interface identifier.
	NetworkInterfaceID *string `json:"network_interface_id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListInstanceNetworkInterfaceFloatingIpsOptions : Instantiate ListInstanceNetworkInterfaceFloatingIpsOptions
func (*VpcV1) NewListInstanceNetworkInterfaceFloatingIpsOptions(instanceID string, networkInterfaceID string) *ListInstanceNetworkInterfaceFloatingIpsOptions {
	return &ListInstanceNetworkInterfaceFloatingIpsOptions{
		InstanceID:         core.StringPtr(instanceID),
		NetworkInterfaceID: core.StringPtr(networkInterfaceID),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (options *ListInstanceNetworkInterfaceFloatingIpsOptions) SetInstanceID(instanceID string) *ListInstanceNetworkInterfaceFloatingIpsOptions {
	options.InstanceID = core.StringPtr(instanceID)
	return options
}

// SetNetworkInterfaceID : Allow user to set NetworkInterfaceID
func (options *ListInstanceNetworkInterfaceFloatingIpsOptions) SetNetworkInterfaceID(networkInterfaceID string) *ListInstanceNetworkInterfaceFloatingIpsOptions {
	options.NetworkInterfaceID = core.StringPtr(networkInterfaceID)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListInstanceNetworkInterfaceFloatingIpsOptions) SetHeaders(param map[string]string) *ListInstanceNetworkInterfaceFloatingIpsOptions {
	options.Headers = param
	return options
}

// ListInstanceNetworkInterfacesOptions : The ListInstanceNetworkInterfaces options.
type ListInstanceNetworkInterfacesOptions struct {
	// The instance identifier.
	InstanceID *string `json:"instance_id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListInstanceNetworkInterfacesOptions : Instantiate ListInstanceNetworkInterfacesOptions
func (*VpcV1) NewListInstanceNetworkInterfacesOptions(instanceID string) *ListInstanceNetworkInterfacesOptions {
	return &ListInstanceNetworkInterfacesOptions{
		InstanceID: core.StringPtr(instanceID),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (options *ListInstanceNetworkInterfacesOptions) SetInstanceID(instanceID string) *ListInstanceNetworkInterfacesOptions {
	options.InstanceID = core.StringPtr(instanceID)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListInstanceNetworkInterfacesOptions) SetHeaders(param map[string]string) *ListInstanceNetworkInterfacesOptions {
	options.Headers = param
	return options
}

// ListInstanceProfilesOptions : The ListInstanceProfiles options.
type ListInstanceProfilesOptions struct {
	// A server-supplied token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListInstanceProfilesOptions : Instantiate ListInstanceProfilesOptions
func (*VpcV1) NewListInstanceProfilesOptions() *ListInstanceProfilesOptions {
	return &ListInstanceProfilesOptions{}
}

// SetStart : Allow user to set Start
func (options *ListInstanceProfilesOptions) SetStart(start string) *ListInstanceProfilesOptions {
	options.Start = core.StringPtr(start)
	return options
}

// SetLimit : Allow user to set Limit
func (options *ListInstanceProfilesOptions) SetLimit(limit int64) *ListInstanceProfilesOptions {
	options.Limit = core.Int64Ptr(limit)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListInstanceProfilesOptions) SetHeaders(param map[string]string) *ListInstanceProfilesOptions {
	options.Headers = param
	return options
}

// ListInstanceTemplatesOptions : The ListInstanceTemplates options.
type ListInstanceTemplatesOptions struct {

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListInstanceTemplatesOptions : Instantiate ListInstanceTemplatesOptions
func (*VpcV1) NewListInstanceTemplatesOptions() *ListInstanceTemplatesOptions {
	return &ListInstanceTemplatesOptions{}
}

// SetHeaders : Allow user to set Headers
func (options *ListInstanceTemplatesOptions) SetHeaders(param map[string]string) *ListInstanceTemplatesOptions {
	options.Headers = param
	return options
}

// ListInstanceVolumeAttachmentsOptions : The ListInstanceVolumeAttachments options.
type ListInstanceVolumeAttachmentsOptions struct {
	// The instance identifier.
	InstanceID *string `json:"instance_id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListInstanceVolumeAttachmentsOptions : Instantiate ListInstanceVolumeAttachmentsOptions
func (*VpcV1) NewListInstanceVolumeAttachmentsOptions(instanceID string) *ListInstanceVolumeAttachmentsOptions {
	return &ListInstanceVolumeAttachmentsOptions{
		InstanceID: core.StringPtr(instanceID),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (options *ListInstanceVolumeAttachmentsOptions) SetInstanceID(instanceID string) *ListInstanceVolumeAttachmentsOptions {
	options.InstanceID = core.StringPtr(instanceID)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListInstanceVolumeAttachmentsOptions) SetHeaders(param map[string]string) *ListInstanceVolumeAttachmentsOptions {
	options.Headers = param
	return options
}

// ListInstancesOptions : The ListInstances options.
type ListInstancesOptions struct {
	// A server-supplied token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Filters the collection to resources within one of the resource groups identified in a comma-separated list of
	// resource group identifiers.
	ResourceGroupID *string `json:"resource_group.id,omitempty"`

	// Filters the collection to resources with the exact specified name.
	Name *string `json:"name,omitempty"`

	// Filters the collection to resources in the VPC with the specified identifier.
	VPCID *string `json:"vpc.id,omitempty"`

	// Filters the collection to resources in the VPC with the specified CRN.
	VPCCRN *string `json:"vpc.crn,omitempty"`

	// Filters the collection to resources in the VPC with the exact specified name.
	VPCName *string `json:"vpc.name,omitempty"`

	// Filters the collection to instances on the subnet of the specified identifier.
	NetworkInterfacesSubnetID *string `json:"network_interfaces.subnet.id,omitempty"`

	// Filters the collection to instances on the subnet of the specified CRN.
	NetworkInterfacesSubnetCRN *string `json:"network_interfaces.subnet.crn,omitempty"`

	// Filters the collection to instances on the subnet of the specified name.
	NetworkInterfacesSubnetName *string `json:"network_interfaces.subnet.name,omitempty"`

	// Filters the collection to instances that reside on the dedicated host with specified id.
	DedicatedHostID *string `json:"dedicated_host.id,omitempty"`

	// Filters the collection to instances that reside on the dedicated host with specified crn.
	DedicatedHostCRN *string `json:"dedicated_host.crn,omitempty"`

	// Filters the collection to instances that reside on the dedicated host with specified name.
	DedicatedHostName *string `json:"dedicated_host.name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListInstancesOptions : Instantiate ListInstancesOptions
func (*VpcV1) NewListInstancesOptions() *ListInstancesOptions {
	return &ListInstancesOptions{}
}

// SetStart : Allow user to set Start
func (options *ListInstancesOptions) SetStart(start string) *ListInstancesOptions {
	options.Start = core.StringPtr(start)
	return options
}

// SetLimit : Allow user to set Limit
func (options *ListInstancesOptions) SetLimit(limit int64) *ListInstancesOptions {
	options.Limit = core.Int64Ptr(limit)
	return options
}

// SetResourceGroupID : Allow user to set ResourceGroupID
func (options *ListInstancesOptions) SetResourceGroupID(resourceGroupID string) *ListInstancesOptions {
	options.ResourceGroupID = core.StringPtr(resourceGroupID)
	return options
}

// SetName : Allow user to set Name
func (options *ListInstancesOptions) SetName(name string) *ListInstancesOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetVPCID : Allow user to set VPCID
func (options *ListInstancesOptions) SetVPCID(vpcID string) *ListInstancesOptions {
	options.VPCID = core.StringPtr(vpcID)
	return options
}

// SetVPCCRN : Allow user to set VPCCRN
func (options *ListInstancesOptions) SetVPCCRN(vpcCRN string) *ListInstancesOptions {
	options.VPCCRN = core.StringPtr(vpcCRN)
	return options
}

// SetVPCName : Allow user to set VPCName
func (options *ListInstancesOptions) SetVPCName(vpcName string) *ListInstancesOptions {
	options.VPCName = core.StringPtr(vpcName)
	return options
}

// SetNetworkInterfacesSubnetID : Allow user to set NetworkInterfacesSubnetID
func (options *ListInstancesOptions) SetNetworkInterfacesSubnetID(networkInterfacesSubnetID string) *ListInstancesOptions {
	options.NetworkInterfacesSubnetID = core.StringPtr(networkInterfacesSubnetID)
	return options
}

// SetNetworkInterfacesSubnetCRN : Allow user to set NetworkInterfacesSubnetCRN
func (options *ListInstancesOptions) SetNetworkInterfacesSubnetCRN(networkInterfacesSubnetCRN string) *ListInstancesOptions {
	options.NetworkInterfacesSubnetCRN = core.StringPtr(networkInterfacesSubnetCRN)
	return options
}

// SetNetworkInterfacesSubnetName : Allow user to set NetworkInterfacesSubnetName
func (options *ListInstancesOptions) SetNetworkInterfacesSubnetName(networkInterfacesSubnetName string) *ListInstancesOptions {
	options.NetworkInterfacesSubnetName = core.StringPtr(networkInterfacesSubnetName)
	return options
}

// SetDedicatedHostID : Allow user to set DedicatedHostID
func (options *ListInstancesOptions) SetDedicatedHostID(dedicatedHostID string) *ListInstancesOptions {
	options.DedicatedHostID = core.StringPtr(dedicatedHostID)
	return options
}

// SetDedicatedHostCRN : Allow user to set DedicatedHostCRN
func (options *ListInstancesOptions) SetDedicatedHostCRN(dedicatedHostCRN string) *ListInstancesOptions {
	options.DedicatedHostCRN = core.StringPtr(dedicatedHostCRN)
	return options
}

// SetDedicatedHostName : Allow user to set DedicatedHostName
func (options *ListInstancesOptions) SetDedicatedHostName(dedicatedHostName string) *ListInstancesOptions {
	options.DedicatedHostName = core.StringPtr(dedicatedHostName)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListInstancesOptions) SetHeaders(param map[string]string) *ListInstancesOptions {
	options.Headers = param
	return options
}

// ListIpsecPoliciesOptions : The ListIpsecPolicies options.
type ListIpsecPoliciesOptions struct {
	// A server-supplied token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListIpsecPoliciesOptions : Instantiate ListIpsecPoliciesOptions
func (*VpcV1) NewListIpsecPoliciesOptions() *ListIpsecPoliciesOptions {
	return &ListIpsecPoliciesOptions{}
}

// SetStart : Allow user to set Start
func (options *ListIpsecPoliciesOptions) SetStart(start string) *ListIpsecPoliciesOptions {
	options.Start = core.StringPtr(start)
	return options
}

// SetLimit : Allow user to set Limit
func (options *ListIpsecPoliciesOptions) SetLimit(limit int64) *ListIpsecPoliciesOptions {
	options.Limit = core.Int64Ptr(limit)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListIpsecPoliciesOptions) SetHeaders(param map[string]string) *ListIpsecPoliciesOptions {
	options.Headers = param
	return options
}

// ListIpsecPolicyConnectionsOptions : The ListIpsecPolicyConnections options.
type ListIpsecPolicyConnectionsOptions struct {
	// The IPsec policy identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListIpsecPolicyConnectionsOptions : Instantiate ListIpsecPolicyConnectionsOptions
func (*VpcV1) NewListIpsecPolicyConnectionsOptions(id string) *ListIpsecPolicyConnectionsOptions {
	return &ListIpsecPolicyConnectionsOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *ListIpsecPolicyConnectionsOptions) SetID(id string) *ListIpsecPolicyConnectionsOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListIpsecPolicyConnectionsOptions) SetHeaders(param map[string]string) *ListIpsecPolicyConnectionsOptions {
	options.Headers = param
	return options
}

// ListKeysOptions : The ListKeys options.
type ListKeysOptions struct {
	// A server-supplied token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Filters the collection to resources within one of the resource groups identified in a comma-separated list of
	// resource group identifiers.
	ResourceGroupID *string `json:"resource_group.id,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListKeysOptions : Instantiate ListKeysOptions
func (*VpcV1) NewListKeysOptions() *ListKeysOptions {
	return &ListKeysOptions{}
}

// SetStart : Allow user to set Start
func (options *ListKeysOptions) SetStart(start string) *ListKeysOptions {
	options.Start = core.StringPtr(start)
	return options
}

// SetLimit : Allow user to set Limit
func (options *ListKeysOptions) SetLimit(limit int64) *ListKeysOptions {
	options.Limit = core.Int64Ptr(limit)
	return options
}

// SetResourceGroupID : Allow user to set ResourceGroupID
func (options *ListKeysOptions) SetResourceGroupID(resourceGroupID string) *ListKeysOptions {
	options.ResourceGroupID = core.StringPtr(resourceGroupID)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListKeysOptions) SetHeaders(param map[string]string) *ListKeysOptions {
	options.Headers = param
	return options
}

// ListLoadBalancerListenerPoliciesOptions : The ListLoadBalancerListenerPolicies options.
type ListLoadBalancerListenerPoliciesOptions struct {
	// The load balancer identifier.
	LoadBalancerID *string `json:"load_balancer_id" validate:"required"`

	// The listener identifier.
	ListenerID *string `json:"listener_id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListLoadBalancerListenerPoliciesOptions : Instantiate ListLoadBalancerListenerPoliciesOptions
func (*VpcV1) NewListLoadBalancerListenerPoliciesOptions(loadBalancerID string, listenerID string) *ListLoadBalancerListenerPoliciesOptions {
	return &ListLoadBalancerListenerPoliciesOptions{
		LoadBalancerID: core.StringPtr(loadBalancerID),
		ListenerID:     core.StringPtr(listenerID),
	}
}

// SetLoadBalancerID : Allow user to set LoadBalancerID
func (options *ListLoadBalancerListenerPoliciesOptions) SetLoadBalancerID(loadBalancerID string) *ListLoadBalancerListenerPoliciesOptions {
	options.LoadBalancerID = core.StringPtr(loadBalancerID)
	return options
}

// SetListenerID : Allow user to set ListenerID
func (options *ListLoadBalancerListenerPoliciesOptions) SetListenerID(listenerID string) *ListLoadBalancerListenerPoliciesOptions {
	options.ListenerID = core.StringPtr(listenerID)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListLoadBalancerListenerPoliciesOptions) SetHeaders(param map[string]string) *ListLoadBalancerListenerPoliciesOptions {
	options.Headers = param
	return options
}

// ListLoadBalancerListenerPolicyRulesOptions : The ListLoadBalancerListenerPolicyRules options.
type ListLoadBalancerListenerPolicyRulesOptions struct {
	// The load balancer identifier.
	LoadBalancerID *string `json:"load_balancer_id" validate:"required"`

	// The listener identifier.
	ListenerID *string `json:"listener_id" validate:"required"`

	// The policy identifier.
	PolicyID *string `json:"policy_id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListLoadBalancerListenerPolicyRulesOptions : Instantiate ListLoadBalancerListenerPolicyRulesOptions
func (*VpcV1) NewListLoadBalancerListenerPolicyRulesOptions(loadBalancerID string, listenerID string, policyID string) *ListLoadBalancerListenerPolicyRulesOptions {
	return &ListLoadBalancerListenerPolicyRulesOptions{
		LoadBalancerID: core.StringPtr(loadBalancerID),
		ListenerID:     core.StringPtr(listenerID),
		PolicyID:       core.StringPtr(policyID),
	}
}

// SetLoadBalancerID : Allow user to set LoadBalancerID
func (options *ListLoadBalancerListenerPolicyRulesOptions) SetLoadBalancerID(loadBalancerID string) *ListLoadBalancerListenerPolicyRulesOptions {
	options.LoadBalancerID = core.StringPtr(loadBalancerID)
	return options
}

// SetListenerID : Allow user to set ListenerID
func (options *ListLoadBalancerListenerPolicyRulesOptions) SetListenerID(listenerID string) *ListLoadBalancerListenerPolicyRulesOptions {
	options.ListenerID = core.StringPtr(listenerID)
	return options
}

// SetPolicyID : Allow user to set PolicyID
func (options *ListLoadBalancerListenerPolicyRulesOptions) SetPolicyID(policyID string) *ListLoadBalancerListenerPolicyRulesOptions {
	options.PolicyID = core.StringPtr(policyID)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListLoadBalancerListenerPolicyRulesOptions) SetHeaders(param map[string]string) *ListLoadBalancerListenerPolicyRulesOptions {
	options.Headers = param
	return options
}

// ListLoadBalancerListenersOptions : The ListLoadBalancerListeners options.
type ListLoadBalancerListenersOptions struct {
	// The load balancer identifier.
	LoadBalancerID *string `json:"load_balancer_id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListLoadBalancerListenersOptions : Instantiate ListLoadBalancerListenersOptions
func (*VpcV1) NewListLoadBalancerListenersOptions(loadBalancerID string) *ListLoadBalancerListenersOptions {
	return &ListLoadBalancerListenersOptions{
		LoadBalancerID: core.StringPtr(loadBalancerID),
	}
}

// SetLoadBalancerID : Allow user to set LoadBalancerID
func (options *ListLoadBalancerListenersOptions) SetLoadBalancerID(loadBalancerID string) *ListLoadBalancerListenersOptions {
	options.LoadBalancerID = core.StringPtr(loadBalancerID)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListLoadBalancerListenersOptions) SetHeaders(param map[string]string) *ListLoadBalancerListenersOptions {
	options.Headers = param
	return options
}

// ListLoadBalancerPoolMembersOptions : The ListLoadBalancerPoolMembers options.
type ListLoadBalancerPoolMembersOptions struct {
	// The load balancer identifier.
	LoadBalancerID *string `json:"load_balancer_id" validate:"required"`

	// The pool identifier.
	PoolID *string `json:"pool_id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListLoadBalancerPoolMembersOptions : Instantiate ListLoadBalancerPoolMembersOptions
func (*VpcV1) NewListLoadBalancerPoolMembersOptions(loadBalancerID string, poolID string) *ListLoadBalancerPoolMembersOptions {
	return &ListLoadBalancerPoolMembersOptions{
		LoadBalancerID: core.StringPtr(loadBalancerID),
		PoolID:         core.StringPtr(poolID),
	}
}

// SetLoadBalancerID : Allow user to set LoadBalancerID
func (options *ListLoadBalancerPoolMembersOptions) SetLoadBalancerID(loadBalancerID string) *ListLoadBalancerPoolMembersOptions {
	options.LoadBalancerID = core.StringPtr(loadBalancerID)
	return options
}

// SetPoolID : Allow user to set PoolID
func (options *ListLoadBalancerPoolMembersOptions) SetPoolID(poolID string) *ListLoadBalancerPoolMembersOptions {
	options.PoolID = core.StringPtr(poolID)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListLoadBalancerPoolMembersOptions) SetHeaders(param map[string]string) *ListLoadBalancerPoolMembersOptions {
	options.Headers = param
	return options
}

// ListLoadBalancerPoolsOptions : The ListLoadBalancerPools options.
type ListLoadBalancerPoolsOptions struct {
	// The load balancer identifier.
	LoadBalancerID *string `json:"load_balancer_id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListLoadBalancerPoolsOptions : Instantiate ListLoadBalancerPoolsOptions
func (*VpcV1) NewListLoadBalancerPoolsOptions(loadBalancerID string) *ListLoadBalancerPoolsOptions {
	return &ListLoadBalancerPoolsOptions{
		LoadBalancerID: core.StringPtr(loadBalancerID),
	}
}

// SetLoadBalancerID : Allow user to set LoadBalancerID
func (options *ListLoadBalancerPoolsOptions) SetLoadBalancerID(loadBalancerID string) *ListLoadBalancerPoolsOptions {
	options.LoadBalancerID = core.StringPtr(loadBalancerID)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListLoadBalancerPoolsOptions) SetHeaders(param map[string]string) *ListLoadBalancerPoolsOptions {
	options.Headers = param
	return options
}

// ListLoadBalancerProfilesOptions : The ListLoadBalancerProfiles options.
type ListLoadBalancerProfilesOptions struct {
	// A server-supplied token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListLoadBalancerProfilesOptions : Instantiate ListLoadBalancerProfilesOptions
func (*VpcV1) NewListLoadBalancerProfilesOptions() *ListLoadBalancerProfilesOptions {
	return &ListLoadBalancerProfilesOptions{}
}

// SetStart : Allow user to set Start
func (options *ListLoadBalancerProfilesOptions) SetStart(start string) *ListLoadBalancerProfilesOptions {
	options.Start = core.StringPtr(start)
	return options
}

// SetLimit : Allow user to set Limit
func (options *ListLoadBalancerProfilesOptions) SetLimit(limit int64) *ListLoadBalancerProfilesOptions {
	options.Limit = core.Int64Ptr(limit)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListLoadBalancerProfilesOptions) SetHeaders(param map[string]string) *ListLoadBalancerProfilesOptions {
	options.Headers = param
	return options
}

// ListLoadBalancersOptions : The ListLoadBalancers options.
type ListLoadBalancersOptions struct {
	// Filters the collection to resources within one of the resource groups identified in a comma-separated list of
	// resource group identifiers.
	ResourceGroupID *string `json:"resource_group.id,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListLoadBalancersOptions : Instantiate ListLoadBalancersOptions
func (*VpcV1) NewListLoadBalancersOptions() *ListLoadBalancersOptions {
	return &ListLoadBalancersOptions{}
}

// SetResourceGroupID : Allow user to set ResourceGroupID
func (options *ListLoadBalancersOptions) SetResourceGroupID(resourceGroupID string) *ListLoadBalancersOptions {
	options.ResourceGroupID = core.StringPtr(resourceGroupID)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListLoadBalancersOptions) SetHeaders(param map[string]string) *ListLoadBalancersOptions {
	options.Headers = param
	return options
}

// ListNetworkACLRulesOptions : The ListNetworkACLRules options.
type ListNetworkACLRulesOptions struct {
	// The network ACL identifier.
	NetworkACLID *string `json:"network_acl_id" validate:"required"`

	// A server-supplied token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Filters the collection to rules with the specified direction.
	Direction *string `json:"direction,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the ListNetworkACLRulesOptions.Direction property.
// Filters the collection to rules with the specified direction.
const (
	ListNetworkACLRulesOptionsDirectionInboundConst  = "inbound"
	ListNetworkACLRulesOptionsDirectionOutboundConst = "outbound"
)

// NewListNetworkACLRulesOptions : Instantiate ListNetworkACLRulesOptions
func (*VpcV1) NewListNetworkACLRulesOptions(networkACLID string) *ListNetworkACLRulesOptions {
	return &ListNetworkACLRulesOptions{
		NetworkACLID: core.StringPtr(networkACLID),
	}
}

// SetNetworkACLID : Allow user to set NetworkACLID
func (options *ListNetworkACLRulesOptions) SetNetworkACLID(networkACLID string) *ListNetworkACLRulesOptions {
	options.NetworkACLID = core.StringPtr(networkACLID)
	return options
}

// SetStart : Allow user to set Start
func (options *ListNetworkACLRulesOptions) SetStart(start string) *ListNetworkACLRulesOptions {
	options.Start = core.StringPtr(start)
	return options
}

// SetLimit : Allow user to set Limit
func (options *ListNetworkACLRulesOptions) SetLimit(limit int64) *ListNetworkACLRulesOptions {
	options.Limit = core.Int64Ptr(limit)
	return options
}

// SetDirection : Allow user to set Direction
func (options *ListNetworkACLRulesOptions) SetDirection(direction string) *ListNetworkACLRulesOptions {
	options.Direction = core.StringPtr(direction)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListNetworkACLRulesOptions) SetHeaders(param map[string]string) *ListNetworkACLRulesOptions {
	options.Headers = param
	return options
}

// ListNetworkAclsOptions : The ListNetworkAcls options.
type ListNetworkAclsOptions struct {
	// A server-supplied token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Filters the collection to resources within one of the resource groups identified in a comma-separated list of
	// resource group identifiers.
	ResourceGroupID *string `json:"resource_group.id,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListNetworkAclsOptions : Instantiate ListNetworkAclsOptions
func (*VpcV1) NewListNetworkAclsOptions() *ListNetworkAclsOptions {
	return &ListNetworkAclsOptions{}
}

// SetStart : Allow user to set Start
func (options *ListNetworkAclsOptions) SetStart(start string) *ListNetworkAclsOptions {
	options.Start = core.StringPtr(start)
	return options
}

// SetLimit : Allow user to set Limit
func (options *ListNetworkAclsOptions) SetLimit(limit int64) *ListNetworkAclsOptions {
	options.Limit = core.Int64Ptr(limit)
	return options
}

// SetResourceGroupID : Allow user to set ResourceGroupID
func (options *ListNetworkAclsOptions) SetResourceGroupID(resourceGroupID string) *ListNetworkAclsOptions {
	options.ResourceGroupID = core.StringPtr(resourceGroupID)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListNetworkAclsOptions) SetHeaders(param map[string]string) *ListNetworkAclsOptions {
	options.Headers = param
	return options
}

// ListOperatingSystemsOptions : The ListOperatingSystems options.
type ListOperatingSystemsOptions struct {
	// A server-supplied token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListOperatingSystemsOptions : Instantiate ListOperatingSystemsOptions
func (*VpcV1) NewListOperatingSystemsOptions() *ListOperatingSystemsOptions {
	return &ListOperatingSystemsOptions{}
}

// SetStart : Allow user to set Start
func (options *ListOperatingSystemsOptions) SetStart(start string) *ListOperatingSystemsOptions {
	options.Start = core.StringPtr(start)
	return options
}

// SetLimit : Allow user to set Limit
func (options *ListOperatingSystemsOptions) SetLimit(limit int64) *ListOperatingSystemsOptions {
	options.Limit = core.Int64Ptr(limit)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListOperatingSystemsOptions) SetHeaders(param map[string]string) *ListOperatingSystemsOptions {
	options.Headers = param
	return options
}

// ListPublicGatewaysOptions : The ListPublicGateways options.
type ListPublicGatewaysOptions struct {
	// A server-supplied token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Filters the collection to resources within one of the resource groups identified in a comma-separated list of
	// resource group identifiers.
	ResourceGroupID *string `json:"resource_group.id,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListPublicGatewaysOptions : Instantiate ListPublicGatewaysOptions
func (*VpcV1) NewListPublicGatewaysOptions() *ListPublicGatewaysOptions {
	return &ListPublicGatewaysOptions{}
}

// SetStart : Allow user to set Start
func (options *ListPublicGatewaysOptions) SetStart(start string) *ListPublicGatewaysOptions {
	options.Start = core.StringPtr(start)
	return options
}

// SetLimit : Allow user to set Limit
func (options *ListPublicGatewaysOptions) SetLimit(limit int64) *ListPublicGatewaysOptions {
	options.Limit = core.Int64Ptr(limit)
	return options
}

// SetResourceGroupID : Allow user to set ResourceGroupID
func (options *ListPublicGatewaysOptions) SetResourceGroupID(resourceGroupID string) *ListPublicGatewaysOptions {
	options.ResourceGroupID = core.StringPtr(resourceGroupID)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListPublicGatewaysOptions) SetHeaders(param map[string]string) *ListPublicGatewaysOptions {
	options.Headers = param
	return options
}

// ListRegionZonesOptions : The ListRegionZones options.
type ListRegionZonesOptions struct {
	// The region name.
	RegionName *string `json:"region_name" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListRegionZonesOptions : Instantiate ListRegionZonesOptions
func (*VpcV1) NewListRegionZonesOptions(regionName string) *ListRegionZonesOptions {
	return &ListRegionZonesOptions{
		RegionName: core.StringPtr(regionName),
	}
}

// SetRegionName : Allow user to set RegionName
func (options *ListRegionZonesOptions) SetRegionName(regionName string) *ListRegionZonesOptions {
	options.RegionName = core.StringPtr(regionName)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListRegionZonesOptions) SetHeaders(param map[string]string) *ListRegionZonesOptions {
	options.Headers = param
	return options
}

// ListRegionsOptions : The ListRegions options.
type ListRegionsOptions struct {

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListRegionsOptions : Instantiate ListRegionsOptions
func (*VpcV1) NewListRegionsOptions() *ListRegionsOptions {
	return &ListRegionsOptions{}
}

// SetHeaders : Allow user to set Headers
func (options *ListRegionsOptions) SetHeaders(param map[string]string) *ListRegionsOptions {
	options.Headers = param
	return options
}

// ListSecurityGroupNetworkInterfacesOptions : The ListSecurityGroupNetworkInterfaces options.
type ListSecurityGroupNetworkInterfacesOptions struct {
	// The security group identifier.
	SecurityGroupID *string `json:"security_group_id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListSecurityGroupNetworkInterfacesOptions : Instantiate ListSecurityGroupNetworkInterfacesOptions
func (*VpcV1) NewListSecurityGroupNetworkInterfacesOptions(securityGroupID string) *ListSecurityGroupNetworkInterfacesOptions {
	return &ListSecurityGroupNetworkInterfacesOptions{
		SecurityGroupID: core.StringPtr(securityGroupID),
	}
}

// SetSecurityGroupID : Allow user to set SecurityGroupID
func (options *ListSecurityGroupNetworkInterfacesOptions) SetSecurityGroupID(securityGroupID string) *ListSecurityGroupNetworkInterfacesOptions {
	options.SecurityGroupID = core.StringPtr(securityGroupID)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListSecurityGroupNetworkInterfacesOptions) SetHeaders(param map[string]string) *ListSecurityGroupNetworkInterfacesOptions {
	options.Headers = param
	return options
}

// ListSecurityGroupRulesOptions : The ListSecurityGroupRules options.
type ListSecurityGroupRulesOptions struct {
	// The security group identifier.
	SecurityGroupID *string `json:"security_group_id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListSecurityGroupRulesOptions : Instantiate ListSecurityGroupRulesOptions
func (*VpcV1) NewListSecurityGroupRulesOptions(securityGroupID string) *ListSecurityGroupRulesOptions {
	return &ListSecurityGroupRulesOptions{
		SecurityGroupID: core.StringPtr(securityGroupID),
	}
}

// SetSecurityGroupID : Allow user to set SecurityGroupID
func (options *ListSecurityGroupRulesOptions) SetSecurityGroupID(securityGroupID string) *ListSecurityGroupRulesOptions {
	options.SecurityGroupID = core.StringPtr(securityGroupID)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListSecurityGroupRulesOptions) SetHeaders(param map[string]string) *ListSecurityGroupRulesOptions {
	options.Headers = param
	return options
}

// ListSecurityGroupsOptions : The ListSecurityGroups options.
type ListSecurityGroupsOptions struct {
	// A server-supplied token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Filters the collection to resources within one of the resource groups identified in a comma-separated list of
	// resource group identifiers.
	ResourceGroupID *string `json:"resource_group.id,omitempty"`

	// Filters the collection to resources in the VPC with the specified identifier.
	VPCID *string `json:"vpc.id,omitempty"`

	// Filters the collection to resources in the VPC with the specified CRN.
	VPCCRN *string `json:"vpc.crn,omitempty"`

	// Filters the collection to resources in the VPC with the exact specified name.
	VPCName *string `json:"vpc.name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListSecurityGroupsOptions : Instantiate ListSecurityGroupsOptions
func (*VpcV1) NewListSecurityGroupsOptions() *ListSecurityGroupsOptions {
	return &ListSecurityGroupsOptions{}
}

// SetStart : Allow user to set Start
func (options *ListSecurityGroupsOptions) SetStart(start string) *ListSecurityGroupsOptions {
	options.Start = core.StringPtr(start)
	return options
}

// SetLimit : Allow user to set Limit
func (options *ListSecurityGroupsOptions) SetLimit(limit int64) *ListSecurityGroupsOptions {
	options.Limit = core.Int64Ptr(limit)
	return options
}

// SetResourceGroupID : Allow user to set ResourceGroupID
func (options *ListSecurityGroupsOptions) SetResourceGroupID(resourceGroupID string) *ListSecurityGroupsOptions {
	options.ResourceGroupID = core.StringPtr(resourceGroupID)
	return options
}

// SetVPCID : Allow user to set VPCID
func (options *ListSecurityGroupsOptions) SetVPCID(vpcID string) *ListSecurityGroupsOptions {
	options.VPCID = core.StringPtr(vpcID)
	return options
}

// SetVPCCRN : Allow user to set VPCCRN
func (options *ListSecurityGroupsOptions) SetVPCCRN(vpcCRN string) *ListSecurityGroupsOptions {
	options.VPCCRN = core.StringPtr(vpcCRN)
	return options
}

// SetVPCName : Allow user to set VPCName
func (options *ListSecurityGroupsOptions) SetVPCName(vpcName string) *ListSecurityGroupsOptions {
	options.VPCName = core.StringPtr(vpcName)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListSecurityGroupsOptions) SetHeaders(param map[string]string) *ListSecurityGroupsOptions {
	options.Headers = param
	return options
}

// ListSubnetsOptions : The ListSubnets options.
type ListSubnetsOptions struct {
	// A server-supplied token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Filters the collection to resources within one of the resource groups identified in a comma-separated list of
	// resource group identifiers.
	ResourceGroupID *string `json:"resource_group.id,omitempty"`

	// Filters the collection to subnets with the routing table of the specified identifier.
	RoutingTableID *string `json:"routing_table.id,omitempty"`

	// Filters the collection to subnets with the routing table of the specified name.
	RoutingTableName *string `json:"routing_table.name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListSubnetsOptions : Instantiate ListSubnetsOptions
func (*VpcV1) NewListSubnetsOptions() *ListSubnetsOptions {
	return &ListSubnetsOptions{}
}

// SetStart : Allow user to set Start
func (options *ListSubnetsOptions) SetStart(start string) *ListSubnetsOptions {
	options.Start = core.StringPtr(start)
	return options
}

// SetLimit : Allow user to set Limit
func (options *ListSubnetsOptions) SetLimit(limit int64) *ListSubnetsOptions {
	options.Limit = core.Int64Ptr(limit)
	return options
}

// SetResourceGroupID : Allow user to set ResourceGroupID
func (options *ListSubnetsOptions) SetResourceGroupID(resourceGroupID string) *ListSubnetsOptions {
	options.ResourceGroupID = core.StringPtr(resourceGroupID)
	return options
}

// SetRoutingTableID : Allow user to set RoutingTableID
func (options *ListSubnetsOptions) SetRoutingTableID(routingTableID string) *ListSubnetsOptions {
	options.RoutingTableID = core.StringPtr(routingTableID)
	return options
}

// SetRoutingTableName : Allow user to set RoutingTableName
func (options *ListSubnetsOptions) SetRoutingTableName(routingTableName string) *ListSubnetsOptions {
	options.RoutingTableName = core.StringPtr(routingTableName)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListSubnetsOptions) SetHeaders(param map[string]string) *ListSubnetsOptions {
	options.Headers = param
	return options
}

// ListVolumeProfilesOptions : The ListVolumeProfiles options.
type ListVolumeProfilesOptions struct {
	// A server-supplied token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListVolumeProfilesOptions : Instantiate ListVolumeProfilesOptions
func (*VpcV1) NewListVolumeProfilesOptions() *ListVolumeProfilesOptions {
	return &ListVolumeProfilesOptions{}
}

// SetStart : Allow user to set Start
func (options *ListVolumeProfilesOptions) SetStart(start string) *ListVolumeProfilesOptions {
	options.Start = core.StringPtr(start)
	return options
}

// SetLimit : Allow user to set Limit
func (options *ListVolumeProfilesOptions) SetLimit(limit int64) *ListVolumeProfilesOptions {
	options.Limit = core.Int64Ptr(limit)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListVolumeProfilesOptions) SetHeaders(param map[string]string) *ListVolumeProfilesOptions {
	options.Headers = param
	return options
}

// ListVolumesOptions : The ListVolumes options.
type ListVolumesOptions struct {
	// A server-supplied token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Filters the collection to resources with the exact specified name.
	Name *string `json:"name,omitempty"`

	// Filters the collection to resources in the zone with the exact specified name.
	ZoneName *string `json:"zone.name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListVolumesOptions : Instantiate ListVolumesOptions
func (*VpcV1) NewListVolumesOptions() *ListVolumesOptions {
	return &ListVolumesOptions{}
}

// SetStart : Allow user to set Start
func (options *ListVolumesOptions) SetStart(start string) *ListVolumesOptions {
	options.Start = core.StringPtr(start)
	return options
}

// SetLimit : Allow user to set Limit
func (options *ListVolumesOptions) SetLimit(limit int64) *ListVolumesOptions {
	options.Limit = core.Int64Ptr(limit)
	return options
}

// SetName : Allow user to set Name
func (options *ListVolumesOptions) SetName(name string) *ListVolumesOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetZoneName : Allow user to set ZoneName
func (options *ListVolumesOptions) SetZoneName(zoneName string) *ListVolumesOptions {
	options.ZoneName = core.StringPtr(zoneName)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListVolumesOptions) SetHeaders(param map[string]string) *ListVolumesOptions {
	options.Headers = param
	return options
}

// ListVPCAddressPrefixesOptions : The ListVPCAddressPrefixes options.
type ListVPCAddressPrefixesOptions struct {
	// The VPC identifier.
	VPCID *string `json:"vpc_id" validate:"required"`

	// A server-supplied token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListVPCAddressPrefixesOptions : Instantiate ListVPCAddressPrefixesOptions
func (*VpcV1) NewListVPCAddressPrefixesOptions(vpcID string) *ListVPCAddressPrefixesOptions {
	return &ListVPCAddressPrefixesOptions{
		VPCID: core.StringPtr(vpcID),
	}
}

// SetVPCID : Allow user to set VPCID
func (options *ListVPCAddressPrefixesOptions) SetVPCID(vpcID string) *ListVPCAddressPrefixesOptions {
	options.VPCID = core.StringPtr(vpcID)
	return options
}

// SetStart : Allow user to set Start
func (options *ListVPCAddressPrefixesOptions) SetStart(start string) *ListVPCAddressPrefixesOptions {
	options.Start = core.StringPtr(start)
	return options
}

// SetLimit : Allow user to set Limit
func (options *ListVPCAddressPrefixesOptions) SetLimit(limit int64) *ListVPCAddressPrefixesOptions {
	options.Limit = core.Int64Ptr(limit)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListVPCAddressPrefixesOptions) SetHeaders(param map[string]string) *ListVPCAddressPrefixesOptions {
	options.Headers = param
	return options
}

// ListVPCRoutesOptions : The ListVPCRoutes options.
type ListVPCRoutesOptions struct {
	// The VPC identifier.
	VPCID *string `json:"vpc_id" validate:"required"`

	// Filters the collection to resources in the zone with the exact specified name.
	ZoneName *string `json:"zone.name,omitempty"`

	// A server-supplied token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListVPCRoutesOptions : Instantiate ListVPCRoutesOptions
func (*VpcV1) NewListVPCRoutesOptions(vpcID string) *ListVPCRoutesOptions {
	return &ListVPCRoutesOptions{
		VPCID: core.StringPtr(vpcID),
	}
}

// SetVPCID : Allow user to set VPCID
func (options *ListVPCRoutesOptions) SetVPCID(vpcID string) *ListVPCRoutesOptions {
	options.VPCID = core.StringPtr(vpcID)
	return options
}

// SetZoneName : Allow user to set ZoneName
func (options *ListVPCRoutesOptions) SetZoneName(zoneName string) *ListVPCRoutesOptions {
	options.ZoneName = core.StringPtr(zoneName)
	return options
}

// SetStart : Allow user to set Start
func (options *ListVPCRoutesOptions) SetStart(start string) *ListVPCRoutesOptions {
	options.Start = core.StringPtr(start)
	return options
}

// SetLimit : Allow user to set Limit
func (options *ListVPCRoutesOptions) SetLimit(limit int64) *ListVPCRoutesOptions {
	options.Limit = core.Int64Ptr(limit)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListVPCRoutesOptions) SetHeaders(param map[string]string) *ListVPCRoutesOptions {
	options.Headers = param
	return options
}

// ListVPCRoutingTableRoutesOptions : The ListVPCRoutingTableRoutes options.
type ListVPCRoutingTableRoutesOptions struct {
	// The VPC identifier.
	VPCID *string `json:"vpc_id" validate:"required"`

	// The routing table identifier.
	RoutingTableID *string `json:"routing_table_id" validate:"required"`

	// A server-supplied token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListVPCRoutingTableRoutesOptions : Instantiate ListVPCRoutingTableRoutesOptions
func (*VpcV1) NewListVPCRoutingTableRoutesOptions(vpcID string, routingTableID string) *ListVPCRoutingTableRoutesOptions {
	return &ListVPCRoutingTableRoutesOptions{
		VPCID:          core.StringPtr(vpcID),
		RoutingTableID: core.StringPtr(routingTableID),
	}
}

// SetVPCID : Allow user to set VPCID
func (options *ListVPCRoutingTableRoutesOptions) SetVPCID(vpcID string) *ListVPCRoutingTableRoutesOptions {
	options.VPCID = core.StringPtr(vpcID)
	return options
}

// SetRoutingTableID : Allow user to set RoutingTableID
func (options *ListVPCRoutingTableRoutesOptions) SetRoutingTableID(routingTableID string) *ListVPCRoutingTableRoutesOptions {
	options.RoutingTableID = core.StringPtr(routingTableID)
	return options
}

// SetStart : Allow user to set Start
func (options *ListVPCRoutingTableRoutesOptions) SetStart(start string) *ListVPCRoutingTableRoutesOptions {
	options.Start = core.StringPtr(start)
	return options
}

// SetLimit : Allow user to set Limit
func (options *ListVPCRoutingTableRoutesOptions) SetLimit(limit int64) *ListVPCRoutingTableRoutesOptions {
	options.Limit = core.Int64Ptr(limit)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListVPCRoutingTableRoutesOptions) SetHeaders(param map[string]string) *ListVPCRoutingTableRoutesOptions {
	options.Headers = param
	return options
}

// ListVPCRoutingTablesOptions : The ListVPCRoutingTables options.
type ListVPCRoutingTablesOptions struct {
	// The VPC identifier.
	VPCID *string `json:"vpc_id" validate:"required"`

	// A server-supplied token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListVPCRoutingTablesOptions : Instantiate ListVPCRoutingTablesOptions
func (*VpcV1) NewListVPCRoutingTablesOptions(vpcID string) *ListVPCRoutingTablesOptions {
	return &ListVPCRoutingTablesOptions{
		VPCID: core.StringPtr(vpcID),
	}
}

// SetVPCID : Allow user to set VPCID
func (options *ListVPCRoutingTablesOptions) SetVPCID(vpcID string) *ListVPCRoutingTablesOptions {
	options.VPCID = core.StringPtr(vpcID)
	return options
}

// SetStart : Allow user to set Start
func (options *ListVPCRoutingTablesOptions) SetStart(start string) *ListVPCRoutingTablesOptions {
	options.Start = core.StringPtr(start)
	return options
}

// SetLimit : Allow user to set Limit
func (options *ListVPCRoutingTablesOptions) SetLimit(limit int64) *ListVPCRoutingTablesOptions {
	options.Limit = core.Int64Ptr(limit)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListVPCRoutingTablesOptions) SetHeaders(param map[string]string) *ListVPCRoutingTablesOptions {
	options.Headers = param
	return options
}

// ListVpcsOptions : The ListVpcs options.
type ListVpcsOptions struct {
	// A server-supplied token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Filters the collection to resources within one of the resource groups identified in a comma-separated list of
	// resource group identifiers.
	ResourceGroupID *string `json:"resource_group.id,omitempty"`

	// The `classic_access` parameter filters the returned collection by the supplied field. If the supplied field is
	// `true`, only Classic Access VPCs will be returned. If the supplied field is `false`, only VPCs without Classic
	// Access will be returned.
	ClassicAccess *bool `json:"classic_access,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListVpcsOptions : Instantiate ListVpcsOptions
func (*VpcV1) NewListVpcsOptions() *ListVpcsOptions {
	return &ListVpcsOptions{}
}

// SetStart : Allow user to set Start
func (options *ListVpcsOptions) SetStart(start string) *ListVpcsOptions {
	options.Start = core.StringPtr(start)
	return options
}

// SetLimit : Allow user to set Limit
func (options *ListVpcsOptions) SetLimit(limit int64) *ListVpcsOptions {
	options.Limit = core.Int64Ptr(limit)
	return options
}

// SetResourceGroupID : Allow user to set ResourceGroupID
func (options *ListVpcsOptions) SetResourceGroupID(resourceGroupID string) *ListVpcsOptions {
	options.ResourceGroupID = core.StringPtr(resourceGroupID)
	return options
}

// SetClassicAccess : Allow user to set ClassicAccess
func (options *ListVpcsOptions) SetClassicAccess(classicAccess bool) *ListVpcsOptions {
	options.ClassicAccess = core.BoolPtr(classicAccess)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListVpcsOptions) SetHeaders(param map[string]string) *ListVpcsOptions {
	options.Headers = param
	return options
}

// ListVPNGatewayConnectionLocalCidrsOptions : The ListVPNGatewayConnectionLocalCidrs options.
type ListVPNGatewayConnectionLocalCidrsOptions struct {
	// The VPN gateway identifier.
	VPNGatewayID *string `json:"vpn_gateway_id" validate:"required"`

	// The VPN connection identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListVPNGatewayConnectionLocalCidrsOptions : Instantiate ListVPNGatewayConnectionLocalCidrsOptions
func (*VpcV1) NewListVPNGatewayConnectionLocalCidrsOptions(vpnGatewayID string, id string) *ListVPNGatewayConnectionLocalCidrsOptions {
	return &ListVPNGatewayConnectionLocalCidrsOptions{
		VPNGatewayID: core.StringPtr(vpnGatewayID),
		ID:           core.StringPtr(id),
	}
}

// SetVPNGatewayID : Allow user to set VPNGatewayID
func (options *ListVPNGatewayConnectionLocalCidrsOptions) SetVPNGatewayID(vpnGatewayID string) *ListVPNGatewayConnectionLocalCidrsOptions {
	options.VPNGatewayID = core.StringPtr(vpnGatewayID)
	return options
}

// SetID : Allow user to set ID
func (options *ListVPNGatewayConnectionLocalCidrsOptions) SetID(id string) *ListVPNGatewayConnectionLocalCidrsOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListVPNGatewayConnectionLocalCidrsOptions) SetHeaders(param map[string]string) *ListVPNGatewayConnectionLocalCidrsOptions {
	options.Headers = param
	return options
}

// ListVPNGatewayConnectionPeerCidrsOptions : The ListVPNGatewayConnectionPeerCidrs options.
type ListVPNGatewayConnectionPeerCidrsOptions struct {
	// The VPN gateway identifier.
	VPNGatewayID *string `json:"vpn_gateway_id" validate:"required"`

	// The VPN connection identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListVPNGatewayConnectionPeerCidrsOptions : Instantiate ListVPNGatewayConnectionPeerCidrsOptions
func (*VpcV1) NewListVPNGatewayConnectionPeerCidrsOptions(vpnGatewayID string, id string) *ListVPNGatewayConnectionPeerCidrsOptions {
	return &ListVPNGatewayConnectionPeerCidrsOptions{
		VPNGatewayID: core.StringPtr(vpnGatewayID),
		ID:           core.StringPtr(id),
	}
}

// SetVPNGatewayID : Allow user to set VPNGatewayID
func (options *ListVPNGatewayConnectionPeerCidrsOptions) SetVPNGatewayID(vpnGatewayID string) *ListVPNGatewayConnectionPeerCidrsOptions {
	options.VPNGatewayID = core.StringPtr(vpnGatewayID)
	return options
}

// SetID : Allow user to set ID
func (options *ListVPNGatewayConnectionPeerCidrsOptions) SetID(id string) *ListVPNGatewayConnectionPeerCidrsOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListVPNGatewayConnectionPeerCidrsOptions) SetHeaders(param map[string]string) *ListVPNGatewayConnectionPeerCidrsOptions {
	options.Headers = param
	return options
}

// ListVPNGatewayConnectionsOptions : The ListVPNGatewayConnections options.
type ListVPNGatewayConnectionsOptions struct {
	// The VPN gateway identifier.
	VPNGatewayID *string `json:"vpn_gateway_id" validate:"required"`

	// Filters the collection to VPN connections with the specified status.
	Status *string `json:"status,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListVPNGatewayConnectionsOptions : Instantiate ListVPNGatewayConnectionsOptions
func (*VpcV1) NewListVPNGatewayConnectionsOptions(vpnGatewayID string) *ListVPNGatewayConnectionsOptions {
	return &ListVPNGatewayConnectionsOptions{
		VPNGatewayID: core.StringPtr(vpnGatewayID),
	}
}

// SetVPNGatewayID : Allow user to set VPNGatewayID
func (options *ListVPNGatewayConnectionsOptions) SetVPNGatewayID(vpnGatewayID string) *ListVPNGatewayConnectionsOptions {
	options.VPNGatewayID = core.StringPtr(vpnGatewayID)
	return options
}

// SetStatus : Allow user to set Status
func (options *ListVPNGatewayConnectionsOptions) SetStatus(status string) *ListVPNGatewayConnectionsOptions {
	options.Status = core.StringPtr(status)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListVPNGatewayConnectionsOptions) SetHeaders(param map[string]string) *ListVPNGatewayConnectionsOptions {
	options.Headers = param
	return options
}

// ListVPNGatewaysOptions : The ListVPNGateways options.
type ListVPNGatewaysOptions struct {
	// A server-supplied token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Filters the collection to resources within one of the resource groups identified in a comma-separated list of
	// resource group identifiers.
	ResourceGroupID *string `json:"resource_group.id,omitempty"`

	// Sorts the returned collection by the specified field name in ascending order. A `-` may be prepended to the field
	// name to sort in descending order. For example, the value
	// `-created_at` sorts the collection by the `created_at` field in descending order, and the value `name` sorts it by
	// the `name` field in ascending order.
	Sort *string `json:"sort,omitempty"`

	// Filters the collection to VPN gateways with the specified mode.
	Mode *string `json:"mode,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the ListVPNGatewaysOptions.Sort property.
// Sorts the returned collection by the specified field name in ascending order. A `-` may be prepended to the field
// name to sort in descending order. For example, the value
// `-created_at` sorts the collection by the `created_at` field in descending order, and the value `name` sorts it by
// the `name` field in ascending order.
const (
	ListVPNGatewaysOptionsSortCreatedAtConst = "created_at"
	ListVPNGatewaysOptionsSortNameConst      = "name"
)

// Constants associated with the ListVPNGatewaysOptions.Mode property.
// Filters the collection to VPN gateways with the specified mode.
const (
	ListVPNGatewaysOptionsModePolicyConst = "policy"
	ListVPNGatewaysOptionsModeRouteConst  = "route"
)

// NewListVPNGatewaysOptions : Instantiate ListVPNGatewaysOptions
func (*VpcV1) NewListVPNGatewaysOptions() *ListVPNGatewaysOptions {
	return &ListVPNGatewaysOptions{}
}

// SetStart : Allow user to set Start
func (options *ListVPNGatewaysOptions) SetStart(start string) *ListVPNGatewaysOptions {
	options.Start = core.StringPtr(start)
	return options
}

// SetLimit : Allow user to set Limit
func (options *ListVPNGatewaysOptions) SetLimit(limit int64) *ListVPNGatewaysOptions {
	options.Limit = core.Int64Ptr(limit)
	return options
}

// SetResourceGroupID : Allow user to set ResourceGroupID
func (options *ListVPNGatewaysOptions) SetResourceGroupID(resourceGroupID string) *ListVPNGatewaysOptions {
	options.ResourceGroupID = core.StringPtr(resourceGroupID)
	return options
}

// SetSort : Allow user to set Sort
func (options *ListVPNGatewaysOptions) SetSort(sort string) *ListVPNGatewaysOptions {
	options.Sort = core.StringPtr(sort)
	return options
}

// SetMode : Allow user to set Mode
func (options *ListVPNGatewaysOptions) SetMode(mode string) *ListVPNGatewaysOptions {
	options.Mode = core.StringPtr(mode)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListVPNGatewaysOptions) SetHeaders(param map[string]string) *ListVPNGatewaysOptions {
	options.Headers = param
	return options
}

// LoadBalancer : LoadBalancer struct
type LoadBalancer struct {
	// The date and time that this load balancer was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The load balancer's CRN.
	CRN *string `json:"crn" validate:"required"`

	// Fully qualified domain name assigned to this load balancer.
	Hostname *string `json:"hostname" validate:"required"`

	// The load balancer's canonical URL.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this load balancer.
	ID *string `json:"id" validate:"required"`

	// The type of this load balancer, public or private.
	IsPublic *bool `json:"is_public" validate:"required"`

	// The listeners of this load balancer.
	Listeners []LoadBalancerListenerReference `json:"listeners" validate:"required"`

	// The unique user-defined name for this load balancer.
	Name *string `json:"name" validate:"required"`

	// The operating status of this load balancer.
	OperatingStatus *string `json:"operating_status" validate:"required"`

	// The pools of this load balancer.
	Pools []LoadBalancerPoolReference `json:"pools" validate:"required"`

	// The private IP addresses assigned to this load balancer.
	PrivateIps []IP `json:"private_ips" validate:"required"`

	// The profile to use for this load balancer.
	Profile *LoadBalancerProfileReference `json:"profile" validate:"required"`

	// The provisioning status of this load balancer.
	ProvisioningStatus *string `json:"provisioning_status" validate:"required"`

	// The public IP addresses assigned to this load balancer. These are applicable only for public load balancers.
	PublicIps []IP `json:"public_ips" validate:"required"`

	// The resource group for this load balancer.
	ResourceGroup *ResourceGroupReference `json:"resource_group" validate:"required"`

	// The subnets this load balancer is part of.
	Subnets []SubnetReference `json:"subnets" validate:"required"`
}

// Constants associated with the LoadBalancer.OperatingStatus property.
// The operating status of this load balancer.
const (
	LoadBalancerOperatingStatusOfflineConst = "offline"
	LoadBalancerOperatingStatusOnlineConst  = "online"
)

// Constants associated with the LoadBalancer.ProvisioningStatus property.
// The provisioning status of this load balancer.
const (
	LoadBalancerProvisioningStatusActiveConst             = "active"
	LoadBalancerProvisioningStatusCreatePendingConst      = "create_pending"
	LoadBalancerProvisioningStatusDeletePendingConst      = "delete_pending"
	LoadBalancerProvisioningStatusFailedConst             = "failed"
	LoadBalancerProvisioningStatusMaintenancePendingConst = "maintenance_pending"
	LoadBalancerProvisioningStatusUpdatePendingConst      = "update_pending"
)

// UnmarshalLoadBalancer unmarshals an instance of LoadBalancer from the specified map of raw messages.
func UnmarshalLoadBalancer(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancer)
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "hostname", &obj.Hostname)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "is_public", &obj.IsPublic)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "listeners", &obj.Listeners, UnmarshalLoadBalancerListenerReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "operating_status", &obj.OperatingStatus)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "pools", &obj.Pools, UnmarshalLoadBalancerPoolReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "private_ips", &obj.PrivateIps, UnmarshalIP)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "profile", &obj.Profile, UnmarshalLoadBalancerProfileReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "provisioning_status", &obj.ProvisioningStatus)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "public_ips", &obj.PublicIps, UnmarshalIP)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "subnets", &obj.Subnets, UnmarshalSubnetReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerCollection : LoadBalancerCollection struct
type LoadBalancerCollection struct {
	// Collection of load balancers.
	LoadBalancers []LoadBalancer `json:"load_balancers" validate:"required"`
}

// UnmarshalLoadBalancerCollection unmarshals an instance of LoadBalancerCollection from the specified map of raw messages.
func UnmarshalLoadBalancerCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerCollection)
	err = core.UnmarshalModel(m, "load_balancers", &obj.LoadBalancers, UnmarshalLoadBalancer)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerIdentity : Identifies a load balancer by a unique property.
// Models which "extend" this model:
// - LoadBalancerIdentityByID
// - LoadBalancerIdentityByCRN
// - LoadBalancerIdentityByHref
type LoadBalancerIdentity struct {
	// The unique identifier for this load balancer.
	ID *string `json:"id,omitempty"`

	// The load balancer's CRN.
	CRN *string `json:"crn,omitempty"`

	// The load balancer's canonical URL.
	Href *string `json:"href,omitempty"`
}

func (*LoadBalancerIdentity) isaLoadBalancerIdentity() bool {
	return true
}

type LoadBalancerIdentityIntf interface {
	isaLoadBalancerIdentity() bool
}

// UnmarshalLoadBalancerIdentity unmarshals an instance of LoadBalancerIdentity from the specified map of raw messages.
func UnmarshalLoadBalancerIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerListener : LoadBalancerListener struct
type LoadBalancerListener struct {
	// The certificate instance used for SSL termination. It is applicable only to `https`
	// protocol.
	CertificateInstance *CertificateInstanceReference `json:"certificate_instance,omitempty"`

	// The connection limit of the listener.
	ConnectionLimit *int64 `json:"connection_limit,omitempty"`

	// The date and time that this listener was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The default pool associated with the listener.
	DefaultPool *LoadBalancerPoolReference `json:"default_pool,omitempty"`

	// The listener's canonical URL.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this load balancer listener.
	ID *string `json:"id" validate:"required"`

	// The list of policies of this listener.
	Policies []LoadBalancerListenerPolicyReference `json:"policies,omitempty"`

	// The listener port number.
	Port *int64 `json:"port" validate:"required"`

	// The listener protocol. Load balancers in the `network` family support `tcp`. Load balancers in the `application`
	// family support `tcp`, `http`, and `https`.
	Protocol *string `json:"protocol" validate:"required"`

	// The provisioning status of this listener.
	ProvisioningStatus *string `json:"provisioning_status" validate:"required"`
}

// Constants associated with the LoadBalancerListener.Protocol property.
// The listener protocol. Load balancers in the `network` family support `tcp`. Load balancers in the `application`
// family support `tcp`, `http`, and `https`.
const (
	LoadBalancerListenerProtocolHTTPConst  = "http"
	LoadBalancerListenerProtocolHTTPSConst = "https"
	LoadBalancerListenerProtocolTCPConst   = "tcp"
)

// Constants associated with the LoadBalancerListener.ProvisioningStatus property.
// The provisioning status of this listener.
const (
	LoadBalancerListenerProvisioningStatusActiveConst             = "active"
	LoadBalancerListenerProvisioningStatusCreatePendingConst      = "create_pending"
	LoadBalancerListenerProvisioningStatusDeletePendingConst      = "delete_pending"
	LoadBalancerListenerProvisioningStatusFailedConst             = "failed"
	LoadBalancerListenerProvisioningStatusMaintenancePendingConst = "maintenance_pending"
	LoadBalancerListenerProvisioningStatusUpdatePendingConst      = "update_pending"
)

// UnmarshalLoadBalancerListener unmarshals an instance of LoadBalancerListener from the specified map of raw messages.
func UnmarshalLoadBalancerListener(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerListener)
	err = core.UnmarshalModel(m, "certificate_instance", &obj.CertificateInstance, UnmarshalCertificateInstanceReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "connection_limit", &obj.ConnectionLimit)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "default_pool", &obj.DefaultPool, UnmarshalLoadBalancerPoolReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "policies", &obj.Policies, UnmarshalLoadBalancerListenerPolicyReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "port", &obj.Port)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "protocol", &obj.Protocol)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "provisioning_status", &obj.ProvisioningStatus)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerListenerCollection : LoadBalancerListenerCollection struct
type LoadBalancerListenerCollection struct {
	// Collection of listeners.
	Listeners []LoadBalancerListener `json:"listeners" validate:"required"`
}

// UnmarshalLoadBalancerListenerCollection unmarshals an instance of LoadBalancerListenerCollection from the specified map of raw messages.
func UnmarshalLoadBalancerListenerCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerListenerCollection)
	err = core.UnmarshalModel(m, "listeners", &obj.Listeners, UnmarshalLoadBalancerListener)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerListenerPolicy : LoadBalancerListenerPolicy struct
type LoadBalancerListenerPolicy struct {
	// The policy action.
	Action *string `json:"action" validate:"required"`

	// The date and time that this policy was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The listener policy's canonical URL.
	Href *string `json:"href" validate:"required"`

	// The policy's unique identifier.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this policy.
	Name *string `json:"name" validate:"required"`

	// Priority of the policy. Lower value indicates higher priority.
	Priority *int64 `json:"priority" validate:"required"`

	// The provisioning status of this policy.
	ProvisioningStatus *string `json:"provisioning_status" validate:"required"`

	// The rules of this policy.
	Rules []LoadBalancerListenerPolicyRuleReference `json:"rules" validate:"required"`

	// `LoadBalancerPoolReference` is in the response if `action` is `forward`.
	// `LoadBalancerListenerPolicyRedirectURL` is in the response if `action` is `redirect`.
	Target LoadBalancerListenerPolicyTargetReferenceIntf `json:"target,omitempty"`
}

// Constants associated with the LoadBalancerListenerPolicy.Action property.
// The policy action.
const (
	LoadBalancerListenerPolicyActionForwardConst  = "forward"
	LoadBalancerListenerPolicyActionRedirectConst = "redirect"
	LoadBalancerListenerPolicyActionRejectConst   = "reject"
)

// Constants associated with the LoadBalancerListenerPolicy.ProvisioningStatus property.
// The provisioning status of this policy.
const (
	LoadBalancerListenerPolicyProvisioningStatusActiveConst             = "active"
	LoadBalancerListenerPolicyProvisioningStatusCreatePendingConst      = "create_pending"
	LoadBalancerListenerPolicyProvisioningStatusDeletePendingConst      = "delete_pending"
	LoadBalancerListenerPolicyProvisioningStatusFailedConst             = "failed"
	LoadBalancerListenerPolicyProvisioningStatusMaintenancePendingConst = "maintenance_pending"
	LoadBalancerListenerPolicyProvisioningStatusUpdatePendingConst      = "update_pending"
)

// UnmarshalLoadBalancerListenerPolicy unmarshals an instance of LoadBalancerListenerPolicy from the specified map of raw messages.
func UnmarshalLoadBalancerListenerPolicy(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerListenerPolicy)
	err = core.UnmarshalPrimitive(m, "action", &obj.Action)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "priority", &obj.Priority)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "provisioning_status", &obj.ProvisioningStatus)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "rules", &obj.Rules, UnmarshalLoadBalancerListenerPolicyRuleReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "target", &obj.Target, UnmarshalLoadBalancerListenerPolicyTargetReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerListenerPolicyCollection : LoadBalancerListenerPolicyCollection struct
type LoadBalancerListenerPolicyCollection struct {
	// Collection of policies.
	Policies []LoadBalancerListenerPolicy `json:"policies" validate:"required"`
}

// UnmarshalLoadBalancerListenerPolicyCollection unmarshals an instance of LoadBalancerListenerPolicyCollection from the specified map of raw messages.
func UnmarshalLoadBalancerListenerPolicyCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerListenerPolicyCollection)
	err = core.UnmarshalModel(m, "policies", &obj.Policies, UnmarshalLoadBalancerListenerPolicy)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerListenerPolicyPatchTarget : When `action` is `forward`, `LoadBalancerPoolIdentity` specifies which pool the load balancer forwards the traffic
// to. When `action` is `redirect`,
// `LoadBalancerListenerPolicyRedirectURLPatch` specifies the url and http status code used in the redirect response.
// Models which "extend" this model:
// - LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentity
// - LoadBalancerListenerPolicyPatchTargetLoadBalancerListenerPolicyRedirectURLPatch
type LoadBalancerListenerPolicyPatchTarget struct {
	// The unique identifier for this load balancer pool.
	ID *string `json:"id,omitempty"`

	// The pool's canonical URL.
	Href *string `json:"href,omitempty"`

	// The http status code in the redirect response.
	HTTPStatusCode *int64 `json:"http_status_code,omitempty"`

	// The redirect target URL.
	URL *string `json:"url,omitempty"`
}

func (*LoadBalancerListenerPolicyPatchTarget) isaLoadBalancerListenerPolicyPatchTarget() bool {
	return true
}

type LoadBalancerListenerPolicyPatchTargetIntf interface {
	isaLoadBalancerListenerPolicyPatchTarget() bool
}

// UnmarshalLoadBalancerListenerPolicyPatchTarget unmarshals an instance of LoadBalancerListenerPolicyPatchTarget from the specified map of raw messages.
func UnmarshalLoadBalancerListenerPolicyPatchTarget(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerListenerPolicyPatchTarget)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "http_status_code", &obj.HTTPStatusCode)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "url", &obj.URL)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerListenerPolicyPrototype : LoadBalancerListenerPolicyPrototype struct
type LoadBalancerListenerPolicyPrototype struct {
	// The policy action.
	Action *string `json:"action" validate:"required"`

	// The user-defined name for this policy. Names must be unique within the load balancer listener the policy resides in.
	Name *string `json:"name,omitempty"`

	// Priority of the policy. Lower value indicates higher priority.
	Priority *int64 `json:"priority" validate:"required"`

	// The list of rules of this policy.
	Rules []LoadBalancerListenerPolicyRulePrototype `json:"rules,omitempty"`

	// When `action` is `forward`, `LoadBalancerPoolIdentity` is required to specify which
	// pool the load balancer forwards the traffic to. When `action` is `redirect`,
	// `LoadBalancerListenerPolicyRedirectURLPrototype` is required to specify the url and
	// http status code used in the redirect response.
	Target LoadBalancerListenerPolicyPrototypeTargetIntf `json:"target,omitempty"`
}

// Constants associated with the LoadBalancerListenerPolicyPrototype.Action property.
// The policy action.
const (
	LoadBalancerListenerPolicyPrototypeActionForwardConst  = "forward"
	LoadBalancerListenerPolicyPrototypeActionRedirectConst = "redirect"
	LoadBalancerListenerPolicyPrototypeActionRejectConst   = "reject"
)

// NewLoadBalancerListenerPolicyPrototype : Instantiate LoadBalancerListenerPolicyPrototype (Generic Model Constructor)
func (*VpcV1) NewLoadBalancerListenerPolicyPrototype(action string, priority int64) (model *LoadBalancerListenerPolicyPrototype, err error) {
	model = &LoadBalancerListenerPolicyPrototype{
		Action:   core.StringPtr(action),
		Priority: core.Int64Ptr(priority),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

// UnmarshalLoadBalancerListenerPolicyPrototype unmarshals an instance of LoadBalancerListenerPolicyPrototype from the specified map of raw messages.
func UnmarshalLoadBalancerListenerPolicyPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerListenerPolicyPrototype)
	err = core.UnmarshalPrimitive(m, "action", &obj.Action)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "priority", &obj.Priority)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "rules", &obj.Rules, UnmarshalLoadBalancerListenerPolicyRulePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "target", &obj.Target, UnmarshalLoadBalancerListenerPolicyPrototypeTarget)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerListenerPolicyPrototypeTarget : When `action` is `forward`, `LoadBalancerPoolIdentity` is required to specify which pool the load balancer forwards
// the traffic to. When `action` is `redirect`,
// `LoadBalancerListenerPolicyRedirectURLPrototype` is required to specify the url and http status code used in the
// redirect response.
// Models which "extend" this model:
// - LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentity
// - LoadBalancerListenerPolicyPrototypeTargetLoadBalancerListenerPolicyRedirectURLPrototype
type LoadBalancerListenerPolicyPrototypeTarget struct {
	// The unique identifier for this load balancer pool.
	ID *string `json:"id,omitempty"`

	// The pool's canonical URL.
	Href *string `json:"href,omitempty"`

	// The http status code in the redirect response.
	HTTPStatusCode *int64 `json:"http_status_code,omitempty"`

	// The redirect target URL.
	URL *string `json:"url,omitempty"`
}

func (*LoadBalancerListenerPolicyPrototypeTarget) isaLoadBalancerListenerPolicyPrototypeTarget() bool {
	return true
}

type LoadBalancerListenerPolicyPrototypeTargetIntf interface {
	isaLoadBalancerListenerPolicyPrototypeTarget() bool
}

// UnmarshalLoadBalancerListenerPolicyPrototypeTarget unmarshals an instance of LoadBalancerListenerPolicyPrototypeTarget from the specified map of raw messages.
func UnmarshalLoadBalancerListenerPolicyPrototypeTarget(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerListenerPolicyPrototypeTarget)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "http_status_code", &obj.HTTPStatusCode)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "url", &obj.URL)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerListenerPolicyReference : LoadBalancerListenerPolicyReference struct
type LoadBalancerListenerPolicyReference struct {
	// The listener policy's canonical URL.
	Href *string `json:"href" validate:"required"`

	// The policy's unique identifier.
	ID *string `json:"id" validate:"required"`
}

// UnmarshalLoadBalancerListenerPolicyReference unmarshals an instance of LoadBalancerListenerPolicyReference from the specified map of raw messages.
func UnmarshalLoadBalancerListenerPolicyReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerListenerPolicyReference)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerListenerPolicyRule : LoadBalancerListenerPolicyRule struct
type LoadBalancerListenerPolicyRule struct {
	// The condition of the rule.
	Condition *string `json:"condition" validate:"required"`

	// The date and time that this rule was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// HTTP header field. This is only applicable to "header" rule type.
	Field *string `json:"field,omitempty"`

	// The rule's canonical URL.
	Href *string `json:"href" validate:"required"`

	// The rule's unique identifier.
	ID *string `json:"id" validate:"required"`

	// The provisioning status of this rule.
	ProvisioningStatus *string `json:"provisioning_status" validate:"required"`

	// The type of the rule.
	Type *string `json:"type" validate:"required"`

	// Value to be matched for rule condition.
	Value *string `json:"value" validate:"required"`
}

// Constants associated with the LoadBalancerListenerPolicyRule.Condition property.
// The condition of the rule.
const (
	LoadBalancerListenerPolicyRuleConditionContainsConst     = "contains"
	LoadBalancerListenerPolicyRuleConditionEqualsConst       = "equals"
	LoadBalancerListenerPolicyRuleConditionMatchesRegexConst = "matches_regex"
)

// Constants associated with the LoadBalancerListenerPolicyRule.ProvisioningStatus property.
// The provisioning status of this rule.
const (
	LoadBalancerListenerPolicyRuleProvisioningStatusActiveConst             = "active"
	LoadBalancerListenerPolicyRuleProvisioningStatusCreatePendingConst      = "create_pending"
	LoadBalancerListenerPolicyRuleProvisioningStatusDeletePendingConst      = "delete_pending"
	LoadBalancerListenerPolicyRuleProvisioningStatusFailedConst             = "failed"
	LoadBalancerListenerPolicyRuleProvisioningStatusMaintenancePendingConst = "maintenance_pending"
	LoadBalancerListenerPolicyRuleProvisioningStatusUpdatePendingConst      = "update_pending"
)

// Constants associated with the LoadBalancerListenerPolicyRule.Type property.
// The type of the rule.
const (
	LoadBalancerListenerPolicyRuleTypeHeaderConst   = "header"
	LoadBalancerListenerPolicyRuleTypeHostnameConst = "hostname"
	LoadBalancerListenerPolicyRuleTypePathConst     = "path"
)

// UnmarshalLoadBalancerListenerPolicyRule unmarshals an instance of LoadBalancerListenerPolicyRule from the specified map of raw messages.
func UnmarshalLoadBalancerListenerPolicyRule(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerListenerPolicyRule)
	err = core.UnmarshalPrimitive(m, "condition", &obj.Condition)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "field", &obj.Field)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "provisioning_status", &obj.ProvisioningStatus)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerListenerPolicyRuleCollection : LoadBalancerListenerPolicyRuleCollection struct
type LoadBalancerListenerPolicyRuleCollection struct {
	// Collection of rules.
	Rules []LoadBalancerListenerPolicyRule `json:"rules" validate:"required"`
}

// UnmarshalLoadBalancerListenerPolicyRuleCollection unmarshals an instance of LoadBalancerListenerPolicyRuleCollection from the specified map of raw messages.
func UnmarshalLoadBalancerListenerPolicyRuleCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerListenerPolicyRuleCollection)
	err = core.UnmarshalModel(m, "rules", &obj.Rules, UnmarshalLoadBalancerListenerPolicyRule)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerListenerPolicyRulePrototype : LoadBalancerListenerPolicyRulePrototype struct
type LoadBalancerListenerPolicyRulePrototype struct {
	// The condition of the rule.
	Condition *string `json:"condition" validate:"required"`

	// HTTP header field. This is only applicable to "header" rule type.
	Field *string `json:"field,omitempty"`

	// The type of the rule.
	Type *string `json:"type" validate:"required"`

	// Value to be matched for rule condition.
	Value *string `json:"value" validate:"required"`
}

// Constants associated with the LoadBalancerListenerPolicyRulePrototype.Condition property.
// The condition of the rule.
const (
	LoadBalancerListenerPolicyRulePrototypeConditionContainsConst     = "contains"
	LoadBalancerListenerPolicyRulePrototypeConditionEqualsConst       = "equals"
	LoadBalancerListenerPolicyRulePrototypeConditionMatchesRegexConst = "matches_regex"
)

// Constants associated with the LoadBalancerListenerPolicyRulePrototype.Type property.
// The type of the rule.
const (
	LoadBalancerListenerPolicyRulePrototypeTypeHeaderConst   = "header"
	LoadBalancerListenerPolicyRulePrototypeTypeHostnameConst = "hostname"
	LoadBalancerListenerPolicyRulePrototypeTypePathConst     = "path"
)

// NewLoadBalancerListenerPolicyRulePrototype : Instantiate LoadBalancerListenerPolicyRulePrototype (Generic Model Constructor)
func (*VpcV1) NewLoadBalancerListenerPolicyRulePrototype(condition string, typeVar string, value string) (model *LoadBalancerListenerPolicyRulePrototype, err error) {
	model = &LoadBalancerListenerPolicyRulePrototype{
		Condition: core.StringPtr(condition),
		Type:      core.StringPtr(typeVar),
		Value:     core.StringPtr(value),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

// UnmarshalLoadBalancerListenerPolicyRulePrototype unmarshals an instance of LoadBalancerListenerPolicyRulePrototype from the specified map of raw messages.
func UnmarshalLoadBalancerListenerPolicyRulePrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerListenerPolicyRulePrototype)
	err = core.UnmarshalPrimitive(m, "condition", &obj.Condition)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "field", &obj.Field)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerListenerPolicyRuleReference : LoadBalancerListenerPolicyRuleReference struct
type LoadBalancerListenerPolicyRuleReference struct {
	// The rule's canonical URL.
	Href *string `json:"href" validate:"required"`

	// The rule's unique identifier.
	ID *string `json:"id" validate:"required"`
}

// UnmarshalLoadBalancerListenerPolicyRuleReference unmarshals an instance of LoadBalancerListenerPolicyRuleReference from the specified map of raw messages.
func UnmarshalLoadBalancerListenerPolicyRuleReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerListenerPolicyRuleReference)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerListenerPolicyTargetReference : `LoadBalancerPoolReference` is in the response if `action` is `forward`.
// `LoadBalancerListenerPolicyRedirectURL` is in the response if `action` is `redirect`.
// Models which "extend" this model:
// - LoadBalancerListenerPolicyTargetReferenceLoadBalancerPoolReference
// - LoadBalancerListenerPolicyTargetReferenceLoadBalancerListenerPolicyRedirectURL
type LoadBalancerListenerPolicyTargetReference struct {
	// The pool's canonical URL.
	Href *string `json:"href,omitempty"`

	// The unique identifier for this load balancer pool.
	ID *string `json:"id,omitempty"`

	// The user-defined name for this load balancer pool.
	Name *string `json:"name,omitempty"`

	// The http status code in the redirect response.
	HTTPStatusCode *int64 `json:"http_status_code,omitempty"`

	// The redirect target URL.
	URL *string `json:"url,omitempty"`
}

func (*LoadBalancerListenerPolicyTargetReference) isaLoadBalancerListenerPolicyTargetReference() bool {
	return true
}

type LoadBalancerListenerPolicyTargetReferenceIntf interface {
	isaLoadBalancerListenerPolicyTargetReference() bool
}

// UnmarshalLoadBalancerListenerPolicyTargetReference unmarshals an instance of LoadBalancerListenerPolicyTargetReference from the specified map of raw messages.
func UnmarshalLoadBalancerListenerPolicyTargetReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerListenerPolicyTargetReference)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "http_status_code", &obj.HTTPStatusCode)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "url", &obj.URL)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerListenerPrototypeLoadBalancerContext : LoadBalancerListenerPrototypeLoadBalancerContext struct
type LoadBalancerListenerPrototypeLoadBalancerContext struct {
	// The connection limit of the listener.
	ConnectionLimit *int64 `json:"connection_limit,omitempty"`

	// The default pool associated with the listener.
	DefaultPool *LoadBalancerPoolIdentityByName `json:"default_pool,omitempty"`

	// The listener port number.
	Port *int64 `json:"port" validate:"required"`

	// The listener protocol. Load balancers in the `network` family support `tcp`. Load balancers in the `application`
	// family support `tcp`, `http`, and `https`.
	Protocol *string `json:"protocol" validate:"required"`
}

// Constants associated with the LoadBalancerListenerPrototypeLoadBalancerContext.Protocol property.
// The listener protocol. Load balancers in the `network` family support `tcp`. Load balancers in the `application`
// family support `tcp`, `http`, and `https`.
const (
	LoadBalancerListenerPrototypeLoadBalancerContextProtocolHTTPConst  = "http"
	LoadBalancerListenerPrototypeLoadBalancerContextProtocolHTTPSConst = "https"
	LoadBalancerListenerPrototypeLoadBalancerContextProtocolTCPConst   = "tcp"
)

// NewLoadBalancerListenerPrototypeLoadBalancerContext : Instantiate LoadBalancerListenerPrototypeLoadBalancerContext (Generic Model Constructor)
func (*VpcV1) NewLoadBalancerListenerPrototypeLoadBalancerContext(port int64, protocol string) (model *LoadBalancerListenerPrototypeLoadBalancerContext, err error) {
	model = &LoadBalancerListenerPrototypeLoadBalancerContext{
		Port:     core.Int64Ptr(port),
		Protocol: core.StringPtr(protocol),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

// UnmarshalLoadBalancerListenerPrototypeLoadBalancerContext unmarshals an instance of LoadBalancerListenerPrototypeLoadBalancerContext from the specified map of raw messages.
func UnmarshalLoadBalancerListenerPrototypeLoadBalancerContext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerListenerPrototypeLoadBalancerContext)
	err = core.UnmarshalPrimitive(m, "connection_limit", &obj.ConnectionLimit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "default_pool", &obj.DefaultPool, UnmarshalLoadBalancerPoolIdentityByName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "port", &obj.Port)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "protocol", &obj.Protocol)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerListenerReference : LoadBalancerListenerReference struct
type LoadBalancerListenerReference struct {
	// The listener's canonical URL.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this load balancer listener.
	ID *string `json:"id" validate:"required"`
}

// UnmarshalLoadBalancerListenerReference unmarshals an instance of LoadBalancerListenerReference from the specified map of raw messages.
func UnmarshalLoadBalancerListenerReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerListenerReference)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerPool : LoadBalancerPool struct
type LoadBalancerPool struct {
	// The load balancing algorithm.
	Algorithm *string `json:"algorithm" validate:"required"`

	// The date and time that this pool was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The health monitor of this pool.
	HealthMonitor *LoadBalancerPoolHealthMonitor `json:"health_monitor" validate:"required"`

	// The pool's canonical URL.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this load balancer pool.
	ID *string `json:"id" validate:"required"`

	// The instance group that is managing this pool.
	InstanceGroup *InstanceGroupReference `json:"instance_group,omitempty"`

	// The backend server members of the pool.
	Members []LoadBalancerPoolMemberReference `json:"members,omitempty"`

	// The user-defined name for this load balancer pool.
	Name *string `json:"name" validate:"required"`

	// The protocol used for this load balancer pool.
	//
	// The enumerated values for this property are expected to expand in the future. When processing this property, check
	// for and log unknown values. Optionally halt processing and surface the error, or bypass the pool on which the
	// unexpected property value was encountered.
	Protocol *string `json:"protocol" validate:"required"`

	// The provisioning status of this pool.
	ProvisioningStatus *string `json:"provisioning_status" validate:"required"`

	// The session persistence of this pool.
	SessionPersistence *LoadBalancerPoolSessionPersistence `json:"session_persistence,omitempty"`
}

// Constants associated with the LoadBalancerPool.Algorithm property.
// The load balancing algorithm.
const (
	LoadBalancerPoolAlgorithmLeastConnectionsConst   = "least_connections"
	LoadBalancerPoolAlgorithmRoundRobinConst         = "round_robin"
	LoadBalancerPoolAlgorithmWeightedRoundRobinConst = "weighted_round_robin"
)

// Constants associated with the LoadBalancerPool.Protocol property.
// The protocol used for this load balancer pool.
//
// The enumerated values for this property are expected to expand in the future. When processing this property, check
// for and log unknown values. Optionally halt processing and surface the error, or bypass the pool on which the
// unexpected property value was encountered.
const (
	LoadBalancerPoolProtocolHTTPConst  = "http"
	LoadBalancerPoolProtocolHTTPSConst = "https"
	LoadBalancerPoolProtocolTCPConst   = "tcp"
)

// Constants associated with the LoadBalancerPool.ProvisioningStatus property.
// The provisioning status of this pool.
const (
	LoadBalancerPoolProvisioningStatusActiveConst             = "active"
	LoadBalancerPoolProvisioningStatusCreatePendingConst      = "create_pending"
	LoadBalancerPoolProvisioningStatusDeletePendingConst      = "delete_pending"
	LoadBalancerPoolProvisioningStatusFailedConst             = "failed"
	LoadBalancerPoolProvisioningStatusMaintenancePendingConst = "maintenance_pending"
	LoadBalancerPoolProvisioningStatusUpdatePendingConst      = "update_pending"
)

// UnmarshalLoadBalancerPool unmarshals an instance of LoadBalancerPool from the specified map of raw messages.
func UnmarshalLoadBalancerPool(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerPool)
	err = core.UnmarshalPrimitive(m, "algorithm", &obj.Algorithm)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "health_monitor", &obj.HealthMonitor, UnmarshalLoadBalancerPoolHealthMonitor)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "instance_group", &obj.InstanceGroup, UnmarshalInstanceGroupReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "members", &obj.Members, UnmarshalLoadBalancerPoolMemberReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "protocol", &obj.Protocol)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "provisioning_status", &obj.ProvisioningStatus)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "session_persistence", &obj.SessionPersistence, UnmarshalLoadBalancerPoolSessionPersistence)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerPoolCollection : LoadBalancerPoolCollection struct
type LoadBalancerPoolCollection struct {
	// Collection of pools.
	Pools []LoadBalancerPool `json:"pools" validate:"required"`
}

// UnmarshalLoadBalancerPoolCollection unmarshals an instance of LoadBalancerPoolCollection from the specified map of raw messages.
func UnmarshalLoadBalancerPoolCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerPoolCollection)
	err = core.UnmarshalModel(m, "pools", &obj.Pools, UnmarshalLoadBalancerPool)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerPoolHealthMonitor : LoadBalancerPoolHealthMonitor struct
type LoadBalancerPoolHealthMonitor struct {
	// The health check interval in seconds. Interval must be greater than timeout value.
	Delay *int64 `json:"delay" validate:"required"`

	// The health check max retries.
	MaxRetries *int64 `json:"max_retries" validate:"required"`

	// The health check port number. If specified, this overrides the ports specified in the server member resources.
	Port *int64 `json:"port,omitempty"`

	// The health check timeout in seconds.
	Timeout *int64 `json:"timeout" validate:"required"`

	// The protocol type of this load balancer pool health monitor.
	//
	// The enumerated values for this property are expected to expand in the future. When processing this property, check
	// for and log unknown values. Optionally halt processing and surface the error, or bypass the health monitor on which
	// the unexpected property value was encountered.
	Type *string `json:"type" validate:"required"`

	// The health check URL. This is applicable only to `http` type of health monitor.
	URLPath *string `json:"url_path,omitempty"`
}

// Constants associated with the LoadBalancerPoolHealthMonitor.Type property.
// The protocol type of this load balancer pool health monitor.
//
// The enumerated values for this property are expected to expand in the future. When processing this property, check
// for and log unknown values. Optionally halt processing and surface the error, or bypass the health monitor on which
// the unexpected property value was encountered.
const (
	LoadBalancerPoolHealthMonitorTypeHTTPConst  = "http"
	LoadBalancerPoolHealthMonitorTypeHTTPSConst = "https"
	LoadBalancerPoolHealthMonitorTypeTCPConst   = "tcp"
)

// UnmarshalLoadBalancerPoolHealthMonitor unmarshals an instance of LoadBalancerPoolHealthMonitor from the specified map of raw messages.
func UnmarshalLoadBalancerPoolHealthMonitor(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerPoolHealthMonitor)
	err = core.UnmarshalPrimitive(m, "delay", &obj.Delay)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "max_retries", &obj.MaxRetries)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "port", &obj.Port)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "timeout", &obj.Timeout)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "url_path", &obj.URLPath)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerPoolHealthMonitorPatch : LoadBalancerPoolHealthMonitorPatch struct
type LoadBalancerPoolHealthMonitorPatch struct {
	// The health check interval in seconds. Interval must be greater than timeout value.
	Delay *int64 `json:"delay" validate:"required"`

	// The health check max retries.
	MaxRetries *int64 `json:"max_retries" validate:"required"`

	// The health check port number. If specified, this overrides the ports specified in the server member resources.
	// Specify `null` to remove an existing port value.
	Port *int64 `json:"port,omitempty"`

	// The health check timeout in seconds.
	Timeout *int64 `json:"timeout" validate:"required"`

	// The protocol type of this load balancer pool health monitor.
	//
	// The enumerated values for this property are expected to expand in the future. When processing this property, check
	// for and log unknown values. Optionally halt processing and surface the error, or bypass the health monitor on which
	// the unexpected property value was encountered.
	Type *string `json:"type" validate:"required"`

	// The health check URL. This is applicable only to `http` type of health monitor.
	URLPath *string `json:"url_path,omitempty"`
}

// Constants associated with the LoadBalancerPoolHealthMonitorPatch.Type property.
// The protocol type of this load balancer pool health monitor.
//
// The enumerated values for this property are expected to expand in the future. When processing this property, check
// for and log unknown values. Optionally halt processing and surface the error, or bypass the health monitor on which
// the unexpected property value was encountered.
const (
	LoadBalancerPoolHealthMonitorPatchTypeHTTPConst  = "http"
	LoadBalancerPoolHealthMonitorPatchTypeHTTPSConst = "https"
	LoadBalancerPoolHealthMonitorPatchTypeTCPConst   = "tcp"
)

// NewLoadBalancerPoolHealthMonitorPatch : Instantiate LoadBalancerPoolHealthMonitorPatch (Generic Model Constructor)
func (*VpcV1) NewLoadBalancerPoolHealthMonitorPatch(delay int64, maxRetries int64, timeout int64, typeVar string) (model *LoadBalancerPoolHealthMonitorPatch, err error) {
	model = &LoadBalancerPoolHealthMonitorPatch{
		Delay:      core.Int64Ptr(delay),
		MaxRetries: core.Int64Ptr(maxRetries),
		Timeout:    core.Int64Ptr(timeout),
		Type:       core.StringPtr(typeVar),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

// UnmarshalLoadBalancerPoolHealthMonitorPatch unmarshals an instance of LoadBalancerPoolHealthMonitorPatch from the specified map of raw messages.
func UnmarshalLoadBalancerPoolHealthMonitorPatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerPoolHealthMonitorPatch)
	err = core.UnmarshalPrimitive(m, "delay", &obj.Delay)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "max_retries", &obj.MaxRetries)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "port", &obj.Port)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "timeout", &obj.Timeout)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "url_path", &obj.URLPath)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerPoolHealthMonitorPrototype : LoadBalancerPoolHealthMonitorPrototype struct
type LoadBalancerPoolHealthMonitorPrototype struct {
	// The health check interval in seconds. Interval must be greater than timeout value.
	Delay *int64 `json:"delay" validate:"required"`

	// The health check max retries.
	MaxRetries *int64 `json:"max_retries" validate:"required"`

	// The health check port number. If specified, this overrides the ports specified in the server member resources.
	Port *int64 `json:"port,omitempty"`

	// The health check timeout in seconds.
	Timeout *int64 `json:"timeout" validate:"required"`

	// The protocol type of this load balancer pool health monitor.
	//
	// The enumerated values for this property are expected to expand in the future. When processing this property, check
	// for and log unknown values. Optionally halt processing and surface the error, or bypass the health monitor on which
	// the unexpected property value was encountered.
	Type *string `json:"type" validate:"required"`

	// The health check URL. This is applicable only to `http` type of health monitor.
	URLPath *string `json:"url_path,omitempty"`
}

// Constants associated with the LoadBalancerPoolHealthMonitorPrototype.Type property.
// The protocol type of this load balancer pool health monitor.
//
// The enumerated values for this property are expected to expand in the future. When processing this property, check
// for and log unknown values. Optionally halt processing and surface the error, or bypass the health monitor on which
// the unexpected property value was encountered.
const (
	LoadBalancerPoolHealthMonitorPrototypeTypeHTTPConst  = "http"
	LoadBalancerPoolHealthMonitorPrototypeTypeHTTPSConst = "https"
	LoadBalancerPoolHealthMonitorPrototypeTypeTCPConst   = "tcp"
)

// NewLoadBalancerPoolHealthMonitorPrototype : Instantiate LoadBalancerPoolHealthMonitorPrototype (Generic Model Constructor)
func (*VpcV1) NewLoadBalancerPoolHealthMonitorPrototype(delay int64, maxRetries int64, timeout int64, typeVar string) (model *LoadBalancerPoolHealthMonitorPrototype, err error) {
	model = &LoadBalancerPoolHealthMonitorPrototype{
		Delay:      core.Int64Ptr(delay),
		MaxRetries: core.Int64Ptr(maxRetries),
		Timeout:    core.Int64Ptr(timeout),
		Type:       core.StringPtr(typeVar),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

// UnmarshalLoadBalancerPoolHealthMonitorPrototype unmarshals an instance of LoadBalancerPoolHealthMonitorPrototype from the specified map of raw messages.
func UnmarshalLoadBalancerPoolHealthMonitorPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerPoolHealthMonitorPrototype)
	err = core.UnmarshalPrimitive(m, "delay", &obj.Delay)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "max_retries", &obj.MaxRetries)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "port", &obj.Port)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "timeout", &obj.Timeout)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "url_path", &obj.URLPath)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerPoolIdentity : Identifies a load balancer pool by a unique property.
// Models which "extend" this model:
// - LoadBalancerPoolIdentityByID
// - LoadBalancerPoolIdentityByHref
type LoadBalancerPoolIdentity struct {
	// The unique identifier for this load balancer pool.
	ID *string `json:"id,omitempty"`

	// The pool's canonical URL.
	Href *string `json:"href,omitempty"`
}

func (*LoadBalancerPoolIdentity) isaLoadBalancerPoolIdentity() bool {
	return true
}

type LoadBalancerPoolIdentityIntf interface {
	isaLoadBalancerPoolIdentity() bool
}

// UnmarshalLoadBalancerPoolIdentity unmarshals an instance of LoadBalancerPoolIdentity from the specified map of raw messages.
func UnmarshalLoadBalancerPoolIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerPoolIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerPoolIdentityByName : LoadBalancerPoolIdentityByName struct
type LoadBalancerPoolIdentityByName struct {
	// The user-defined name for this load balancer pool.
	Name *string `json:"name" validate:"required"`
}

// NewLoadBalancerPoolIdentityByName : Instantiate LoadBalancerPoolIdentityByName (Generic Model Constructor)
func (*VpcV1) NewLoadBalancerPoolIdentityByName(name string) (model *LoadBalancerPoolIdentityByName, err error) {
	model = &LoadBalancerPoolIdentityByName{
		Name: core.StringPtr(name),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

// UnmarshalLoadBalancerPoolIdentityByName unmarshals an instance of LoadBalancerPoolIdentityByName from the specified map of raw messages.
func UnmarshalLoadBalancerPoolIdentityByName(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerPoolIdentityByName)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerPoolMember : LoadBalancerPoolMember struct
type LoadBalancerPoolMember struct {
	// The date and time that this member was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// Health of the server member in the pool.
	Health *string `json:"health" validate:"required"`

	// The member's canonical URL.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this load balancer pool member.
	ID *string `json:"id" validate:"required"`

	// The port number of the application running in the server member.
	Port *int64 `json:"port" validate:"required"`

	// The provisioning status of this member.
	ProvisioningStatus *string `json:"provisioning_status" validate:"required"`

	// The pool member target. Load balancers in the `network` family
	// support instances. Load balancers in the `application` family support
	// IP addresses.
	Target LoadBalancerPoolMemberTargetIntf `json:"target" validate:"required"`

	// Weight of the server member. This takes effect only when the load balancing algorithm of its belonging pool is
	// `weighted_round_robin`.
	Weight *int64 `json:"weight,omitempty"`
}

// Constants associated with the LoadBalancerPoolMember.Health property.
// Health of the server member in the pool.
const (
	LoadBalancerPoolMemberHealthFaultedConst = "faulted"
	LoadBalancerPoolMemberHealthOkConst      = "ok"
	LoadBalancerPoolMemberHealthUnknownConst = "unknown"
)

// Constants associated with the LoadBalancerPoolMember.ProvisioningStatus property.
// The provisioning status of this member.
const (
	LoadBalancerPoolMemberProvisioningStatusActiveConst             = "active"
	LoadBalancerPoolMemberProvisioningStatusCreatePendingConst      = "create_pending"
	LoadBalancerPoolMemberProvisioningStatusDeletePendingConst      = "delete_pending"
	LoadBalancerPoolMemberProvisioningStatusFailedConst             = "failed"
	LoadBalancerPoolMemberProvisioningStatusMaintenancePendingConst = "maintenance_pending"
	LoadBalancerPoolMemberProvisioningStatusUpdatePendingConst      = "update_pending"
)

// UnmarshalLoadBalancerPoolMember unmarshals an instance of LoadBalancerPoolMember from the specified map of raw messages.
func UnmarshalLoadBalancerPoolMember(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerPoolMember)
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "health", &obj.Health)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "port", &obj.Port)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "provisioning_status", &obj.ProvisioningStatus)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "target", &obj.Target, UnmarshalLoadBalancerPoolMemberTarget)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "weight", &obj.Weight)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerPoolMemberCollection : LoadBalancerPoolMemberCollection struct
type LoadBalancerPoolMemberCollection struct {
	// Collection of members.
	Members []LoadBalancerPoolMember `json:"members" validate:"required"`
}

// UnmarshalLoadBalancerPoolMemberCollection unmarshals an instance of LoadBalancerPoolMemberCollection from the specified map of raw messages.
func UnmarshalLoadBalancerPoolMemberCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerPoolMemberCollection)
	err = core.UnmarshalModel(m, "members", &obj.Members, UnmarshalLoadBalancerPoolMember)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerPoolMemberPrototype : LoadBalancerPoolMemberPrototype struct
type LoadBalancerPoolMemberPrototype struct {
	// The port number of the application running in the server member.
	Port *int64 `json:"port" validate:"required"`

	// The pool member target. Load balancers in the `network` family
	// support instances. Load balancers in the `application` family support
	// IP addresses.
	Target LoadBalancerPoolMemberTargetPrototypeIntf `json:"target" validate:"required"`

	// Weight of the server member. This takes effect only when the load balancing algorithm of its belonging pool is
	// `weighted_round_robin`.
	Weight *int64 `json:"weight,omitempty"`
}

// NewLoadBalancerPoolMemberPrototype : Instantiate LoadBalancerPoolMemberPrototype (Generic Model Constructor)
func (*VpcV1) NewLoadBalancerPoolMemberPrototype(port int64, target LoadBalancerPoolMemberTargetPrototypeIntf) (model *LoadBalancerPoolMemberPrototype, err error) {
	model = &LoadBalancerPoolMemberPrototype{
		Port:   core.Int64Ptr(port),
		Target: target,
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

// UnmarshalLoadBalancerPoolMemberPrototype unmarshals an instance of LoadBalancerPoolMemberPrototype from the specified map of raw messages.
func UnmarshalLoadBalancerPoolMemberPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerPoolMemberPrototype)
	err = core.UnmarshalPrimitive(m, "port", &obj.Port)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "target", &obj.Target, UnmarshalLoadBalancerPoolMemberTargetPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "weight", &obj.Weight)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerPoolMemberReference : LoadBalancerPoolMemberReference struct
type LoadBalancerPoolMemberReference struct {
	// The member's canonical URL.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this load balancer pool member.
	ID *string `json:"id" validate:"required"`
}

// UnmarshalLoadBalancerPoolMemberReference unmarshals an instance of LoadBalancerPoolMemberReference from the specified map of raw messages.
func UnmarshalLoadBalancerPoolMemberReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerPoolMemberReference)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerPoolMemberTarget : The pool member target. Load balancers in the `network` family support instances. Load balancers in the `application`
// family support IP addresses.
// Models which "extend" this model:
// - LoadBalancerPoolMemberTargetInstanceReference
// - LoadBalancerPoolMemberTargetIP
type LoadBalancerPoolMemberTarget struct {
	// The CRN for this virtual server instance.
	CRN *string `json:"crn,omitempty"`

	// The URL for this virtual server instance.
	Href *string `json:"href,omitempty"`

	// The unique identifier for this virtual server instance.
	ID *string `json:"id,omitempty"`

	// The user-defined name for this virtual server instance (and default system hostname).
	Name *string `json:"name,omitempty"`

	// The type of resource referenced.
	ResourceType *string `json:"resource_type,omitempty"`

	// The IP address. This property may add support for IPv6 addresses in the future. When processing a value in this
	// property, verify that the address is in an expected format. If it is not, log an error. Optionally halt processing
	// and surface the error, or bypass the resource on which the unexpected IP address format was encountered.
	Address *string `json:"address,omitempty"`
}

// Constants associated with the LoadBalancerPoolMemberTarget.ResourceType property.
// The type of resource referenced.
const (
	LoadBalancerPoolMemberTargetResourceTypeInstanceConst = "instance"
)

func (*LoadBalancerPoolMemberTarget) isaLoadBalancerPoolMemberTarget() bool {
	return true
}

type LoadBalancerPoolMemberTargetIntf interface {
	isaLoadBalancerPoolMemberTarget() bool
}

// UnmarshalLoadBalancerPoolMemberTarget unmarshals an instance of LoadBalancerPoolMemberTarget from the specified map of raw messages.
func UnmarshalLoadBalancerPoolMemberTarget(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerPoolMemberTarget)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "address", &obj.Address)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerPoolMemberTargetPrototype : The pool member target. Load balancers in the `network` family support instances. Load balancers in the `application`
// family support IP addresses.
// Models which "extend" this model:
// - LoadBalancerPoolMemberTargetPrototypeInstanceIdentity
// - LoadBalancerPoolMemberTargetPrototypeIP
type LoadBalancerPoolMemberTargetPrototype struct {
	// The unique identifier for this virtual server instance.
	ID *string `json:"id,omitempty"`

	// The CRN for this virtual server instance.
	CRN *string `json:"crn,omitempty"`

	// The URL for this virtual server instance.
	Href *string `json:"href,omitempty"`

	// The IP address. This property may add support for IPv6 addresses in the future. When processing a value in this
	// property, verify that the address is in an expected format. If it is not, log an error. Optionally halt processing
	// and surface the error, or bypass the resource on which the unexpected IP address format was encountered.
	Address *string `json:"address,omitempty"`
}

func (*LoadBalancerPoolMemberTargetPrototype) isaLoadBalancerPoolMemberTargetPrototype() bool {
	return true
}

type LoadBalancerPoolMemberTargetPrototypeIntf interface {
	isaLoadBalancerPoolMemberTargetPrototype() bool
}

// UnmarshalLoadBalancerPoolMemberTargetPrototype unmarshals an instance of LoadBalancerPoolMemberTargetPrototype from the specified map of raw messages.
func UnmarshalLoadBalancerPoolMemberTargetPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerPoolMemberTargetPrototype)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "address", &obj.Address)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerPoolPrototype : LoadBalancerPoolPrototype struct
type LoadBalancerPoolPrototype struct {
	// The load balancing algorithm.
	Algorithm *string `json:"algorithm" validate:"required"`

	// The health monitor of this pool.
	HealthMonitor *LoadBalancerPoolHealthMonitorPrototype `json:"health_monitor" validate:"required"`

	// The members for this load balancer pool. For load balancers in the `network` family, the same `port` and `target`
	// tuple cannot be shared by a member of any other load balancer.
	Members []LoadBalancerPoolMemberPrototype `json:"members,omitempty"`

	// The user-defined name for this load balancer pool. If unspecified, the name will be a hyphenated list of
	// randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The protocol used for this load balancer pool.
	//
	// The enumerated values for this property are expected to expand in the future. When processing this property, check
	// for and log unknown values. Optionally halt processing and surface the error, or bypass the pool on which the
	// unexpected property value was encountered.
	Protocol *string `json:"protocol" validate:"required"`

	// The session persistence of this pool.
	SessionPersistence *LoadBalancerPoolSessionPersistencePrototype `json:"session_persistence,omitempty"`
}

// Constants associated with the LoadBalancerPoolPrototype.Algorithm property.
// The load balancing algorithm.
const (
	LoadBalancerPoolPrototypeAlgorithmLeastConnectionsConst   = "least_connections"
	LoadBalancerPoolPrototypeAlgorithmRoundRobinConst         = "round_robin"
	LoadBalancerPoolPrototypeAlgorithmWeightedRoundRobinConst = "weighted_round_robin"
)

// Constants associated with the LoadBalancerPoolPrototype.Protocol property.
// The protocol used for this load balancer pool.
//
// The enumerated values for this property are expected to expand in the future. When processing this property, check
// for and log unknown values. Optionally halt processing and surface the error, or bypass the pool on which the
// unexpected property value was encountered.
const (
	LoadBalancerPoolPrototypeProtocolHTTPConst  = "http"
	LoadBalancerPoolPrototypeProtocolHTTPSConst = "https"
	LoadBalancerPoolPrototypeProtocolTCPConst   = "tcp"
)

// NewLoadBalancerPoolPrototype : Instantiate LoadBalancerPoolPrototype (Generic Model Constructor)
func (*VpcV1) NewLoadBalancerPoolPrototype(algorithm string, healthMonitor *LoadBalancerPoolHealthMonitorPrototype, protocol string) (model *LoadBalancerPoolPrototype, err error) {
	model = &LoadBalancerPoolPrototype{
		Algorithm:     core.StringPtr(algorithm),
		HealthMonitor: healthMonitor,
		Protocol:      core.StringPtr(protocol),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

// UnmarshalLoadBalancerPoolPrototype unmarshals an instance of LoadBalancerPoolPrototype from the specified map of raw messages.
func UnmarshalLoadBalancerPoolPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerPoolPrototype)
	err = core.UnmarshalPrimitive(m, "algorithm", &obj.Algorithm)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "health_monitor", &obj.HealthMonitor, UnmarshalLoadBalancerPoolHealthMonitorPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "members", &obj.Members, UnmarshalLoadBalancerPoolMemberPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "protocol", &obj.Protocol)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "session_persistence", &obj.SessionPersistence, UnmarshalLoadBalancerPoolSessionPersistencePrototype)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerPoolReference : LoadBalancerPoolReference struct
type LoadBalancerPoolReference struct {
	// The pool's canonical URL.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this load balancer pool.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this load balancer pool.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalLoadBalancerPoolReference unmarshals an instance of LoadBalancerPoolReference from the specified map of raw messages.
func UnmarshalLoadBalancerPoolReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerPoolReference)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerPoolSessionPersistence : LoadBalancerPoolSessionPersistence struct
type LoadBalancerPoolSessionPersistence struct {
	// The session persistence type.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the LoadBalancerPoolSessionPersistence.Type property.
// The session persistence type.
const (
	LoadBalancerPoolSessionPersistenceTypeSourceIPConst = "source_ip"
)

// UnmarshalLoadBalancerPoolSessionPersistence unmarshals an instance of LoadBalancerPoolSessionPersistence from the specified map of raw messages.
func UnmarshalLoadBalancerPoolSessionPersistence(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerPoolSessionPersistence)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerPoolSessionPersistencePatch : LoadBalancerPoolSessionPersistencePatch struct
type LoadBalancerPoolSessionPersistencePatch struct {
	// The session persistence type.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the LoadBalancerPoolSessionPersistencePatch.Type property.
// The session persistence type.
const (
	LoadBalancerPoolSessionPersistencePatchTypeSourceIPConst = "source_ip"
)

// NewLoadBalancerPoolSessionPersistencePatch : Instantiate LoadBalancerPoolSessionPersistencePatch (Generic Model Constructor)
func (*VpcV1) NewLoadBalancerPoolSessionPersistencePatch(typeVar string) (model *LoadBalancerPoolSessionPersistencePatch, err error) {
	model = &LoadBalancerPoolSessionPersistencePatch{
		Type: core.StringPtr(typeVar),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

// UnmarshalLoadBalancerPoolSessionPersistencePatch unmarshals an instance of LoadBalancerPoolSessionPersistencePatch from the specified map of raw messages.
func UnmarshalLoadBalancerPoolSessionPersistencePatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerPoolSessionPersistencePatch)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerPoolSessionPersistencePrototype : LoadBalancerPoolSessionPersistencePrototype struct
type LoadBalancerPoolSessionPersistencePrototype struct {
	// The session persistence type.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the LoadBalancerPoolSessionPersistencePrototype.Type property.
// The session persistence type.
const (
	LoadBalancerPoolSessionPersistencePrototypeTypeSourceIPConst = "source_ip"
)

// NewLoadBalancerPoolSessionPersistencePrototype : Instantiate LoadBalancerPoolSessionPersistencePrototype (Generic Model Constructor)
func (*VpcV1) NewLoadBalancerPoolSessionPersistencePrototype(typeVar string) (model *LoadBalancerPoolSessionPersistencePrototype, err error) {
	model = &LoadBalancerPoolSessionPersistencePrototype{
		Type: core.StringPtr(typeVar),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

// UnmarshalLoadBalancerPoolSessionPersistencePrototype unmarshals an instance of LoadBalancerPoolSessionPersistencePrototype from the specified map of raw messages.
func UnmarshalLoadBalancerPoolSessionPersistencePrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerPoolSessionPersistencePrototype)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerProfile : LoadBalancerProfile struct
type LoadBalancerProfile struct {
	// The product family this load balancer profile belongs to.
	Family *string `json:"family" validate:"required"`

	// The URL for this load balancer profile.
	Href *string `json:"href" validate:"required"`

	// The name for this load balancer profile.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalLoadBalancerProfile unmarshals an instance of LoadBalancerProfile from the specified map of raw messages.
func UnmarshalLoadBalancerProfile(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerProfile)
	err = core.UnmarshalPrimitive(m, "family", &obj.Family)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerProfileCollection : LoadBalancerProfileCollection struct
type LoadBalancerProfileCollection struct {
	// A reference to the first page of resources.
	First *LoadBalancerProfileCollectionFirst `json:"first" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A reference to the next page of resources; this reference is included for all pages
	// except the last page.
	Next *LoadBalancerProfileCollectionNext `json:"next,omitempty"`

	// Collection of load balancer profiles.
	Profiles []LoadBalancerProfile `json:"profiles" validate:"required"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalLoadBalancerProfileCollection unmarshals an instance of LoadBalancerProfileCollection from the specified map of raw messages.
func UnmarshalLoadBalancerProfileCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerProfileCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalLoadBalancerProfileCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalLoadBalancerProfileCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "profiles", &obj.Profiles, UnmarshalLoadBalancerProfile)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerProfileCollectionFirst : A reference to the first page of resources.
type LoadBalancerProfileCollectionFirst struct {
	// The URL for the first page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalLoadBalancerProfileCollectionFirst unmarshals an instance of LoadBalancerProfileCollectionFirst from the specified map of raw messages.
func UnmarshalLoadBalancerProfileCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerProfileCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerProfileCollectionNext : A reference to the next page of resources; this reference is included for all pages except the last page.
type LoadBalancerProfileCollectionNext struct {
	// The URL for the next page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalLoadBalancerProfileCollectionNext unmarshals an instance of LoadBalancerProfileCollectionNext from the specified map of raw messages.
func UnmarshalLoadBalancerProfileCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerProfileCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerProfileIdentity : Identifies a load balancer profile by a unique property.
// Models which "extend" this model:
// - LoadBalancerProfileIdentityByName
// - LoadBalancerProfileIdentityByHref
type LoadBalancerProfileIdentity struct {
	// The name for this load balancer profile.
	Name *string `json:"name,omitempty"`

	// The URL for this load balancer profile.
	Href *string `json:"href,omitempty"`
}

func (*LoadBalancerProfileIdentity) isaLoadBalancerProfileIdentity() bool {
	return true
}

type LoadBalancerProfileIdentityIntf interface {
	isaLoadBalancerProfileIdentity() bool
}

// UnmarshalLoadBalancerProfileIdentity unmarshals an instance of LoadBalancerProfileIdentity from the specified map of raw messages.
func UnmarshalLoadBalancerProfileIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerProfileIdentity)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerProfileReference : LoadBalancerProfileReference struct
type LoadBalancerProfileReference struct {
	// The product family this load balancer profile belongs to.
	Family *string `json:"family" validate:"required"`

	// The URL for this load balancer profile.
	Href *string `json:"href" validate:"required"`

	// The name for this load balancer profile.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalLoadBalancerProfileReference unmarshals an instance of LoadBalancerProfileReference from the specified map of raw messages.
func UnmarshalLoadBalancerProfileReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerProfileReference)
	err = core.UnmarshalPrimitive(m, "family", &obj.Family)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerStatistics : LoadBalancerStatistics struct
type LoadBalancerStatistics struct {
	// Number of active connections of this load balancer.
	ActiveConnections *int64 `json:"active_connections" validate:"required"`

	// Current connection rate (connections per second) of this load balancer.
	ConnectionRate *float32 `json:"connection_rate" validate:"required"`

	// Total number of data processed (bytes) of this load balancer within current calendar month.
	DataProcessedThisMonth *int64 `json:"data_processed_this_month" validate:"required"`

	// Current throughput (Mbps) of this load balancer.
	Throughput *float32 `json:"throughput" validate:"required"`
}

// UnmarshalLoadBalancerStatistics unmarshals an instance of LoadBalancerStatistics from the specified map of raw messages.
func UnmarshalLoadBalancerStatistics(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerStatistics)
	err = core.UnmarshalPrimitive(m, "active_connections", &obj.ActiveConnections)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "connection_rate", &obj.ConnectionRate)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "data_processed_this_month", &obj.DataProcessedThisMonth)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "throughput", &obj.Throughput)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkACL : NetworkACL struct
type NetworkACL struct {
	// The date and time that the network ACL was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The CRN for this network ACL.
	CRN *string `json:"crn" validate:"required"`

	// The URL for this network ACL.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this network ACL.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this network ACL.
	Name *string `json:"name" validate:"required"`

	// The resource group for this Network ACL.
	ResourceGroup *ResourceGroupReference `json:"resource_group" validate:"required"`

	// The ordered rules for this network ACL. If no rules exist, all traffic will be denied.
	Rules []NetworkACLRuleItemIntf `json:"rules" validate:"required"`

	// The subnets to which this network ACL is attached.
	Subnets []SubnetReference `json:"subnets" validate:"required"`

	// The VPC this network ACL is a part of.
	VPC *VPCReference `json:"vpc" validate:"required"`
}

// UnmarshalNetworkACL unmarshals an instance of NetworkACL from the specified map of raw messages.
func UnmarshalNetworkACL(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkACL)
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "rules", &obj.Rules, UnmarshalNetworkACLRuleItem)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "subnets", &obj.Subnets, UnmarshalSubnetReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vpc", &obj.VPC, UnmarshalVPCReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkACLCollection : NetworkACLCollection struct
type NetworkACLCollection struct {
	// A reference to the first page of resources.
	First *NetworkACLCollectionFirst `json:"first" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// Collection of network ACLs.
	NetworkAcls []NetworkACL `json:"network_acls" validate:"required"`

	// A reference to the next page of resources; this reference is included for all pages
	// except the last page.
	Next *NetworkACLCollectionNext `json:"next,omitempty"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalNetworkACLCollection unmarshals an instance of NetworkACLCollection from the specified map of raw messages.
func UnmarshalNetworkACLCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkACLCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalNetworkACLCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "network_acls", &obj.NetworkAcls, UnmarshalNetworkACL)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalNetworkACLCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkACLCollectionFirst : A reference to the first page of resources.
type NetworkACLCollectionFirst struct {
	// The URL for the first page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalNetworkACLCollectionFirst unmarshals an instance of NetworkACLCollectionFirst from the specified map of raw messages.
func UnmarshalNetworkACLCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkACLCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkACLCollectionNext : A reference to the next page of resources; this reference is included for all pages except the last page.
type NetworkACLCollectionNext struct {
	// The URL for the next page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalNetworkACLCollectionNext unmarshals an instance of NetworkACLCollectionNext from the specified map of raw messages.
func UnmarshalNetworkACLCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkACLCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkACLIdentity : Identifies a network ACL by a unique property.
// Models which "extend" this model:
// - NetworkACLIdentityByID
// - NetworkACLIdentityByCRN
// - NetworkACLIdentityByHref
type NetworkACLIdentity struct {
	// The unique identifier for this network ACL.
	ID *string `json:"id,omitempty"`

	// The CRN for this network ACL.
	CRN *string `json:"crn,omitempty"`

	// The URL for this network ACL.
	Href *string `json:"href,omitempty"`
}

func (*NetworkACLIdentity) isaNetworkACLIdentity() bool {
	return true
}

type NetworkACLIdentityIntf interface {
	isaNetworkACLIdentity() bool
}

// UnmarshalNetworkACLIdentity unmarshals an instance of NetworkACLIdentity from the specified map of raw messages.
func UnmarshalNetworkACLIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkACLIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkACLPrototype : NetworkACLPrototype struct
// Models which "extend" this model:
// - NetworkACLPrototypeNetworkACLByRules
// - NetworkACLPrototypeNetworkACLBySourceNetworkACL
type NetworkACLPrototype struct {
	// The user-defined name for this network ACL. Names must be unique within the VPC the Network ACL resides in. If
	// unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// The VPC this network ACL is to be a part of.
	VPC VPCIdentityIntf `json:"vpc" validate:"required"`

	// Array of prototype objects for rules to create along with this network ACL. If unspecified, no rules will be
	// created, resulting in all traffic being denied.
	Rules []NetworkACLRulePrototypeNetworkACLContextIntf `json:"rules,omitempty"`

	// Network ACL to copy rules from.
	SourceNetworkACL NetworkACLIdentityIntf `json:"source_network_acl,omitempty"`
}

func (*NetworkACLPrototype) isaNetworkACLPrototype() bool {
	return true
}

type NetworkACLPrototypeIntf interface {
	isaNetworkACLPrototype() bool
}

// UnmarshalNetworkACLPrototype unmarshals an instance of NetworkACLPrototype from the specified map of raw messages.
func UnmarshalNetworkACLPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkACLPrototype)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vpc", &obj.VPC, UnmarshalVPCIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "rules", &obj.Rules, UnmarshalNetworkACLRulePrototypeNetworkACLContext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "source_network_acl", &obj.SourceNetworkACL, UnmarshalNetworkACLIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkACLReference : NetworkACLReference struct
type NetworkACLReference struct {
	// The CRN for this network ACL.
	CRN *string `json:"crn" validate:"required"`

	// The URL for this network ACL.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this network ACL.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this network ACL.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalNetworkACLReference unmarshals an instance of NetworkACLReference from the specified map of raw messages.
func UnmarshalNetworkACLReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkACLReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkACLRule : NetworkACLRule struct
// Models which "extend" this model:
// - NetworkACLRuleProtocolTcpudp
// - NetworkACLRuleProtocolIcmp
// - NetworkACLRuleProtocolAll
type NetworkACLRule struct {
	// Whether to allow or deny matching traffic.
	Action *string `json:"action" validate:"required"`

	// The rule that this rule is immediately before. If absent, this is the last rule.
	Before *NetworkACLRuleReference `json:"before,omitempty"`

	// The date and time that the rule was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The destination CIDR block. The CIDR block `0.0.0.0/0` applies to all addresses.
	Destination *string `json:"destination" validate:"required"`

	// Whether the traffic to be matched is `inbound` or `outbound`.
	Direction *string `json:"direction" validate:"required"`

	// The URL for this Network ACL rule.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this Network ACL rule.
	ID *string `json:"id" validate:"required"`

	// The IP version for this rule.
	IPVersion *string `json:"ip_version" validate:"required"`

	// The user-defined name for this rule. Names must be unique within the network ACL the rule resides in. If
	// unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name" validate:"required"`

	// The protocol to enforce.
	Protocol *string `json:"protocol,omitempty"`

	// The source CIDR block. The CIDR block `0.0.0.0/0` applies to all addresses.
	Source *string `json:"source" validate:"required"`

	// The inclusive upper bound of TCP/UDP destination port range.
	DestinationPortMax *int64 `json:"destination_port_max,omitempty"`

	// The inclusive lower bound of TCP/UDP destination port range.
	DestinationPortMin *int64 `json:"destination_port_min,omitempty"`

	// The inclusive upper bound of TCP/UDP source port range.
	SourcePortMax *int64 `json:"source_port_max,omitempty"`

	// The inclusive lower bound of TCP/UDP source port range.
	SourcePortMin *int64 `json:"source_port_min,omitempty"`

	// The ICMP traffic code to allow. If unspecified, all codes are allowed. This can only be specified if type is also
	// specified.
	Code *int64 `json:"code,omitempty"`

	// The ICMP traffic type to allow. If unspecified, all types are allowed by this rule.
	Type *int64 `json:"type,omitempty"`
}

// Constants associated with the NetworkACLRule.Action property.
// Whether to allow or deny matching traffic.
const (
	NetworkACLRuleActionAllowConst = "allow"
	NetworkACLRuleActionDenyConst  = "deny"
)

// Constants associated with the NetworkACLRule.Direction property.
// Whether the traffic to be matched is `inbound` or `outbound`.
const (
	NetworkACLRuleDirectionInboundConst  = "inbound"
	NetworkACLRuleDirectionOutboundConst = "outbound"
)

// Constants associated with the NetworkACLRule.IPVersion property.
// The IP version for this rule.
const (
	NetworkACLRuleIPVersionIpv4Const = "ipv4"
	NetworkACLRuleIPVersionIpv6Const = "ipv6"
)

// Constants associated with the NetworkACLRule.Protocol property.
// The protocol to enforce.
const (
	NetworkACLRuleProtocolAllConst  = "all"
	NetworkACLRuleProtocolIcmpConst = "icmp"
	NetworkACLRuleProtocolTCPConst  = "tcp"
	NetworkACLRuleProtocolUDPConst  = "udp"
)

func (*NetworkACLRule) isaNetworkACLRule() bool {
	return true
}

type NetworkACLRuleIntf interface {
	isaNetworkACLRule() bool
}

// UnmarshalNetworkACLRule unmarshals an instance of NetworkACLRule from the specified map of raw messages.
func UnmarshalNetworkACLRule(m map[string]json.RawMessage, result interface{}) (err error) {
	// Retrieve discriminator value to determine correct "subclass".
	var discValue string
	err = core.UnmarshalPrimitive(m, "protocol", &discValue)
	if err != nil {
		err = fmt.Errorf("error unmarshalling discriminator property 'protocol': %s", err.Error())
		return
	}
	if discValue == "" {
		err = fmt.Errorf("required discriminator property 'protocol' not found in JSON object")
		return
	}
	if discValue == "all" {
		err = core.UnmarshalModel(m, "", result, UnmarshalNetworkACLRuleProtocolAll)
	} else if discValue == "icmp" {
		err = core.UnmarshalModel(m, "", result, UnmarshalNetworkACLRuleProtocolIcmp)
	} else if discValue == "tcp" {
		err = core.UnmarshalModel(m, "", result, UnmarshalNetworkACLRuleProtocolTcpudp)
	} else if discValue == "udp" {
		err = core.UnmarshalModel(m, "", result, UnmarshalNetworkACLRuleProtocolTcpudp)
	} else {
		err = fmt.Errorf("unrecognized value for discriminator property 'protocol': %s", discValue)
	}
	return
}

// NetworkACLRuleCollection : NetworkACLRuleCollection struct
type NetworkACLRuleCollection struct {
	// A reference to the first page of resources.
	First *NetworkACLRuleCollectionFirst `json:"first" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A reference to the next page of resources; this reference is included for all pages
	// except the last page.
	Next *NetworkACLRuleCollectionNext `json:"next,omitempty"`

	// Ordered collection of Network ACL rules.
	Rules []NetworkACLRuleItemIntf `json:"rules" validate:"required"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalNetworkACLRuleCollection unmarshals an instance of NetworkACLRuleCollection from the specified map of raw messages.
func UnmarshalNetworkACLRuleCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkACLRuleCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalNetworkACLRuleCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalNetworkACLRuleCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "rules", &obj.Rules, UnmarshalNetworkACLRuleItem)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkACLRuleCollectionFirst : A reference to the first page of resources.
type NetworkACLRuleCollectionFirst struct {
	// The URL for the first page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalNetworkACLRuleCollectionFirst unmarshals an instance of NetworkACLRuleCollectionFirst from the specified map of raw messages.
func UnmarshalNetworkACLRuleCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkACLRuleCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkACLRuleCollectionNext : A reference to the next page of resources; this reference is included for all pages except the last page.
type NetworkACLRuleCollectionNext struct {
	// The URL for the next page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalNetworkACLRuleCollectionNext unmarshals an instance of NetworkACLRuleCollectionNext from the specified map of raw messages.
func UnmarshalNetworkACLRuleCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkACLRuleCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkACLRuleItem : NetworkACLRuleItem struct
// Models which "extend" this model:
// - NetworkACLRuleItemNetworkACLRuleProtocolTcpudp
// - NetworkACLRuleItemNetworkACLRuleProtocolIcmp
// - NetworkACLRuleItemNetworkACLRuleProtocolAll
type NetworkACLRuleItem struct {
	// Whether to allow or deny matching traffic.
	Action *string `json:"action" validate:"required"`

	// The rule that this rule is immediately before. In a rule collection, this always
	// refers to the next item in the collection. If absent, this is the last rule.
	Before *NetworkACLRuleReference `json:"before,omitempty"`

	// The date and time that the rule was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The destination CIDR block. The CIDR block `0.0.0.0/0` applies to all addresses.
	Destination *string `json:"destination" validate:"required"`

	// Whether the traffic to be matched is `inbound` or `outbound`.
	Direction *string `json:"direction" validate:"required"`

	// The URL for this Network ACL rule.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this Network ACL rule.
	ID *string `json:"id" validate:"required"`

	// The IP version for this rule.
	IPVersion *string `json:"ip_version" validate:"required"`

	// The user-defined name for this rule. Names must be unique within the network ACL the rule resides in. If
	// unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name" validate:"required"`

	// The protocol to enforce.
	Protocol *string `json:"protocol,omitempty"`

	// The source CIDR block. The CIDR block `0.0.0.0/0` applies to all addresses.
	Source *string `json:"source" validate:"required"`

	// The inclusive upper bound of TCP/UDP destination port range.
	DestinationPortMax *int64 `json:"destination_port_max,omitempty"`

	// The inclusive lower bound of TCP/UDP destination port range.
	DestinationPortMin *int64 `json:"destination_port_min,omitempty"`

	// The inclusive upper bound of TCP/UDP source port range.
	SourcePortMax *int64 `json:"source_port_max,omitempty"`

	// The inclusive lower bound of TCP/UDP source port range.
	SourcePortMin *int64 `json:"source_port_min,omitempty"`

	// The ICMP traffic code to allow. If unspecified, all codes are allowed. This can only be specified if type is also
	// specified.
	Code *int64 `json:"code,omitempty"`

	// The ICMP traffic type to allow. If unspecified, all types are allowed by this rule.
	Type *int64 `json:"type,omitempty"`
}

// Constants associated with the NetworkACLRuleItem.Action property.
// Whether to allow or deny matching traffic.
const (
	NetworkACLRuleItemActionAllowConst = "allow"
	NetworkACLRuleItemActionDenyConst  = "deny"
)

// Constants associated with the NetworkACLRuleItem.Direction property.
// Whether the traffic to be matched is `inbound` or `outbound`.
const (
	NetworkACLRuleItemDirectionInboundConst  = "inbound"
	NetworkACLRuleItemDirectionOutboundConst = "outbound"
)

// Constants associated with the NetworkACLRuleItem.IPVersion property.
// The IP version for this rule.
const (
	NetworkACLRuleItemIPVersionIpv4Const = "ipv4"
	NetworkACLRuleItemIPVersionIpv6Const = "ipv6"
)

// Constants associated with the NetworkACLRuleItem.Protocol property.
// The protocol to enforce.
const (
	NetworkACLRuleItemProtocolAllConst  = "all"
	NetworkACLRuleItemProtocolIcmpConst = "icmp"
	NetworkACLRuleItemProtocolTCPConst  = "tcp"
	NetworkACLRuleItemProtocolUDPConst  = "udp"
)

func (*NetworkACLRuleItem) isaNetworkACLRuleItem() bool {
	return true
}

type NetworkACLRuleItemIntf interface {
	isaNetworkACLRuleItem() bool
}

// UnmarshalNetworkACLRuleItem unmarshals an instance of NetworkACLRuleItem from the specified map of raw messages.
func UnmarshalNetworkACLRuleItem(m map[string]json.RawMessage, result interface{}) (err error) {
	// Retrieve discriminator value to determine correct "subclass".
	var discValue string
	err = core.UnmarshalPrimitive(m, "protocol", &discValue)
	if err != nil {
		err = fmt.Errorf("error unmarshalling discriminator property 'protocol': %s", err.Error())
		return
	}
	if discValue == "" {
		err = fmt.Errorf("required discriminator property 'protocol' not found in JSON object")
		return
	}
	if discValue == "all" {
		err = core.UnmarshalModel(m, "", result, UnmarshalNetworkACLRuleItemNetworkACLRuleProtocolAll)
	} else if discValue == "icmp" {
		err = core.UnmarshalModel(m, "", result, UnmarshalNetworkACLRuleItemNetworkACLRuleProtocolIcmp)
	} else if discValue == "tcp" {
		err = core.UnmarshalModel(m, "", result, UnmarshalNetworkACLRuleItemNetworkACLRuleProtocolTcpudp)
	} else if discValue == "udp" {
		err = core.UnmarshalModel(m, "", result, UnmarshalNetworkACLRuleItemNetworkACLRuleProtocolTcpudp)
	} else {
		err = fmt.Errorf("unrecognized value for discriminator property 'protocol': %s", discValue)
	}
	return
}

// NetworkACLRulePatchBefore : The rule to move this rule immediately before. Specify `null` to move this rule after all existing rules.
// Models which "extend" this model:
// - NetworkACLRulePatchBeforeNetworkACLRuleIdentityByID
// - NetworkACLRulePatchBeforeNetworkACLRuleIdentityByHref
type NetworkACLRulePatchBefore struct {
	// The unique identifier for this Network ACL rule.
	ID *string `json:"id,omitempty"`

	// The URL for this Network ACL rule.
	Href *string `json:"href,omitempty"`
}

func (*NetworkACLRulePatchBefore) isaNetworkACLRulePatchBefore() bool {
	return true
}

type NetworkACLRulePatchBeforeIntf interface {
	isaNetworkACLRulePatchBefore() bool
}

// UnmarshalNetworkACLRulePatchBefore unmarshals an instance of NetworkACLRulePatchBefore from the specified map of raw messages.
func UnmarshalNetworkACLRulePatchBefore(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkACLRulePatchBefore)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkACLRulePrototype : NetworkACLRulePrototype struct
// Models which "extend" this model:
// - NetworkACLRulePrototypeNetworkACLRuleProtocolTcpudp
// - NetworkACLRulePrototypeNetworkACLRuleProtocolIcmp
// - NetworkACLRulePrototypeNetworkACLRuleProtocolAll
type NetworkACLRulePrototype struct {
	// Whether to allow or deny matching traffic.
	Action *string `json:"action" validate:"required"`

	// The rule to insert this rule immediately before. If omitted, this rule will be
	// inserted after all existing rules.
	Before NetworkACLRulePrototypeBeforeIntf `json:"before,omitempty"`

	// The destination IP address or CIDR block. The CIDR block `0.0.0.0/0` applies to all addresses.
	Destination *string `json:"destination" validate:"required"`

	// Whether the traffic to be matched is `inbound` or `outbound`.
	Direction *string `json:"direction" validate:"required"`

	// The user-defined name for this rule. Names must be unique within the network ACL the rule resides in. If
	// unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The protocol to enforce.
	Protocol *string `json:"protocol,omitempty"`

	// The source IP address or CIDR block.  The CIDR block `0.0.0.0/0` applies to all addresses.
	Source *string `json:"source" validate:"required"`

	// The date and time that the rule was created.
	CreatedAt *strfmt.DateTime `json:"created_at,omitempty"`

	// The URL for this Network ACL rule.
	Href *string `json:"href,omitempty"`

	// The unique identifier for this Network ACL rule.
	ID *string `json:"id,omitempty"`

	// The IP version for this rule.
	IPVersion *string `json:"ip_version,omitempty"`

	// The inclusive upper bound of TCP/UDP destination port range.
	DestinationPortMax *int64 `json:"destination_port_max,omitempty"`

	// The inclusive lower bound of TCP/UDP destination port range.
	DestinationPortMin *int64 `json:"destination_port_min,omitempty"`

	// The inclusive upper bound of TCP/UDP source port range.
	SourcePortMax *int64 `json:"source_port_max,omitempty"`

	// The inclusive lower bound of TCP/UDP source port range.
	SourcePortMin *int64 `json:"source_port_min,omitempty"`

	// The ICMP traffic code to allow. If unspecified, all codes are allowed. This can only be specified if type is also
	// specified.
	Code *int64 `json:"code,omitempty"`

	// The ICMP traffic type to allow. If unspecified, all types are allowed by this rule.
	Type *int64 `json:"type,omitempty"`
}

// Constants associated with the NetworkACLRulePrototype.Action property.
// Whether to allow or deny matching traffic.
const (
	NetworkACLRulePrototypeActionAllowConst = "allow"
	NetworkACLRulePrototypeActionDenyConst  = "deny"
)

// Constants associated with the NetworkACLRulePrototype.Direction property.
// Whether the traffic to be matched is `inbound` or `outbound`.
const (
	NetworkACLRulePrototypeDirectionInboundConst  = "inbound"
	NetworkACLRulePrototypeDirectionOutboundConst = "outbound"
)

// Constants associated with the NetworkACLRulePrototype.Protocol property.
// The protocol to enforce.
const (
	NetworkACLRulePrototypeProtocolAllConst  = "all"
	NetworkACLRulePrototypeProtocolIcmpConst = "icmp"
	NetworkACLRulePrototypeProtocolTCPConst  = "tcp"
	NetworkACLRulePrototypeProtocolUDPConst  = "udp"
)

// Constants associated with the NetworkACLRulePrototype.IPVersion property.
// The IP version for this rule.
const (
	NetworkACLRulePrototypeIPVersionIpv4Const = "ipv4"
	NetworkACLRulePrototypeIPVersionIpv6Const = "ipv6"
)

func (*NetworkACLRulePrototype) isaNetworkACLRulePrototype() bool {
	return true
}

type NetworkACLRulePrototypeIntf interface {
	isaNetworkACLRulePrototype() bool
}

// UnmarshalNetworkACLRulePrototype unmarshals an instance of NetworkACLRulePrototype from the specified map of raw messages.
func UnmarshalNetworkACLRulePrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	// Retrieve discriminator value to determine correct "subclass".
	var discValue string
	err = core.UnmarshalPrimitive(m, "protocol", &discValue)
	if err != nil {
		err = fmt.Errorf("error unmarshalling discriminator property 'protocol': %s", err.Error())
		return
	}
	if discValue == "" {
		err = fmt.Errorf("required discriminator property 'protocol' not found in JSON object")
		return
	}
	if discValue == "all" {
		err = core.UnmarshalModel(m, "", result, UnmarshalNetworkACLRulePrototypeNetworkACLRuleProtocolAll)
	} else if discValue == "icmp" {
		err = core.UnmarshalModel(m, "", result, UnmarshalNetworkACLRulePrototypeNetworkACLRuleProtocolIcmp)
	} else if discValue == "tcp" {
		err = core.UnmarshalModel(m, "", result, UnmarshalNetworkACLRulePrototypeNetworkACLRuleProtocolTcpudp)
	} else if discValue == "udp" {
		err = core.UnmarshalModel(m, "", result, UnmarshalNetworkACLRulePrototypeNetworkACLRuleProtocolTcpudp)
	} else {
		err = fmt.Errorf("unrecognized value for discriminator property 'protocol': %s", discValue)
	}
	return
}

// NetworkACLRulePrototypeBefore : The rule to insert this rule immediately before. If omitted, this rule will be inserted after all existing rules.
// Models which "extend" this model:
// - NetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByID
// - NetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByHref
type NetworkACLRulePrototypeBefore struct {
	// The unique identifier for this Network ACL rule.
	ID *string `json:"id,omitempty"`

	// The URL for this Network ACL rule.
	Href *string `json:"href,omitempty"`
}

func (*NetworkACLRulePrototypeBefore) isaNetworkACLRulePrototypeBefore() bool {
	return true
}

type NetworkACLRulePrototypeBeforeIntf interface {
	isaNetworkACLRulePrototypeBefore() bool
}

// UnmarshalNetworkACLRulePrototypeBefore unmarshals an instance of NetworkACLRulePrototypeBefore from the specified map of raw messages.
func UnmarshalNetworkACLRulePrototypeBefore(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkACLRulePrototypeBefore)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkACLRulePrototypeNetworkACLContext : NetworkACLRulePrototypeNetworkACLContext struct
// Models which "extend" this model:
// - NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTcpudp
// - NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolIcmp
// - NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAll
type NetworkACLRulePrototypeNetworkACLContext struct {
	// Whether to allow or deny matching traffic.
	Action *string `json:"action" validate:"required"`

	// The destination IP address or CIDR block. The CIDR block `0.0.0.0/0` applies to all addresses.
	Destination *string `json:"destination" validate:"required"`

	// Whether the traffic to be matched is `inbound` or `outbound`.
	Direction *string `json:"direction" validate:"required"`

	// The user-defined name for this rule. Names must be unique within the network ACL the rule resides in. If
	// unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The protocol to enforce.
	Protocol *string `json:"protocol,omitempty"`

	// The source IP address or CIDR block.  The CIDR block `0.0.0.0/0` applies to all addresses.
	Source *string `json:"source" validate:"required"`

	// The rule that this rule is immediately before. If absent, this is the last rule.
	Before *NetworkACLRuleReference `json:"before,omitempty"`

	// The date and time that the rule was created.
	CreatedAt *strfmt.DateTime `json:"created_at,omitempty"`

	// The URL for this Network ACL rule.
	Href *string `json:"href,omitempty"`

	// The unique identifier for this Network ACL rule.
	ID *string `json:"id,omitempty"`

	// The IP version for this rule.
	IPVersion *string `json:"ip_version,omitempty"`

	// The inclusive upper bound of TCP/UDP destination port range.
	DestinationPortMax *int64 `json:"destination_port_max,omitempty"`

	// The inclusive lower bound of TCP/UDP destination port range.
	DestinationPortMin *int64 `json:"destination_port_min,omitempty"`

	// The inclusive upper bound of TCP/UDP source port range.
	SourcePortMax *int64 `json:"source_port_max,omitempty"`

	// The inclusive lower bound of TCP/UDP source port range.
	SourcePortMin *int64 `json:"source_port_min,omitempty"`

	// The ICMP traffic code to allow. If unspecified, all codes are allowed. This can only be specified if type is also
	// specified.
	Code *int64 `json:"code,omitempty"`

	// The ICMP traffic type to allow. If unspecified, all types are allowed by this rule.
	Type *int64 `json:"type,omitempty"`
}

// Constants associated with the NetworkACLRulePrototypeNetworkACLContext.Action property.
// Whether to allow or deny matching traffic.
const (
	NetworkACLRulePrototypeNetworkACLContextActionAllowConst = "allow"
	NetworkACLRulePrototypeNetworkACLContextActionDenyConst  = "deny"
)

// Constants associated with the NetworkACLRulePrototypeNetworkACLContext.Direction property.
// Whether the traffic to be matched is `inbound` or `outbound`.
const (
	NetworkACLRulePrototypeNetworkACLContextDirectionInboundConst  = "inbound"
	NetworkACLRulePrototypeNetworkACLContextDirectionOutboundConst = "outbound"
)

// Constants associated with the NetworkACLRulePrototypeNetworkACLContext.Protocol property.
// The protocol to enforce.
const (
	NetworkACLRulePrototypeNetworkACLContextProtocolAllConst  = "all"
	NetworkACLRulePrototypeNetworkACLContextProtocolIcmpConst = "icmp"
	NetworkACLRulePrototypeNetworkACLContextProtocolTCPConst  = "tcp"
	NetworkACLRulePrototypeNetworkACLContextProtocolUDPConst  = "udp"
)

// Constants associated with the NetworkACLRulePrototypeNetworkACLContext.IPVersion property.
// The IP version for this rule.
const (
	NetworkACLRulePrototypeNetworkACLContextIPVersionIpv4Const = "ipv4"
	NetworkACLRulePrototypeNetworkACLContextIPVersionIpv6Const = "ipv6"
)

func (*NetworkACLRulePrototypeNetworkACLContext) isaNetworkACLRulePrototypeNetworkACLContext() bool {
	return true
}

type NetworkACLRulePrototypeNetworkACLContextIntf interface {
	isaNetworkACLRulePrototypeNetworkACLContext() bool
}

// UnmarshalNetworkACLRulePrototypeNetworkACLContext unmarshals an instance of NetworkACLRulePrototypeNetworkACLContext from the specified map of raw messages.
func UnmarshalNetworkACLRulePrototypeNetworkACLContext(m map[string]json.RawMessage, result interface{}) (err error) {
	// Retrieve discriminator value to determine correct "subclass".
	var discValue string
	err = core.UnmarshalPrimitive(m, "protocol", &discValue)
	if err != nil {
		err = fmt.Errorf("error unmarshalling discriminator property 'protocol': %s", err.Error())
		return
	}
	if discValue == "" {
		err = fmt.Errorf("required discriminator property 'protocol' not found in JSON object")
		return
	}
	if discValue == "all" {
		err = core.UnmarshalModel(m, "", result, UnmarshalNetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAll)
	} else if discValue == "icmp" {
		err = core.UnmarshalModel(m, "", result, UnmarshalNetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolIcmp)
	} else if discValue == "tcp" {
		err = core.UnmarshalModel(m, "", result, UnmarshalNetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTcpudp)
	} else if discValue == "udp" {
		err = core.UnmarshalModel(m, "", result, UnmarshalNetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTcpudp)
	} else {
		err = fmt.Errorf("unrecognized value for discriminator property 'protocol': %s", discValue)
	}
	return
}

// NetworkACLRuleReference : NetworkACLRuleReference struct
type NetworkACLRuleReference struct {
	// The URL for this Network ACL rule.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this Network ACL rule.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this Network ACL rule.
	Name *string `json:"name" validate:"required"`
}

// NewNetworkACLRuleReference : Instantiate NetworkACLRuleReference (Generic Model Constructor)
func (*VpcV1) NewNetworkACLRuleReference(href string, id string, name string) (model *NetworkACLRuleReference, err error) {
	model = &NetworkACLRuleReference{
		Href: core.StringPtr(href),
		ID:   core.StringPtr(id),
		Name: core.StringPtr(name),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

// UnmarshalNetworkACLRuleReference unmarshals an instance of NetworkACLRuleReference from the specified map of raw messages.
func UnmarshalNetworkACLRuleReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkACLRuleReference)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkInterface : NetworkInterface struct
type NetworkInterface struct {
	// Indicates whether source IP spoofing is allowed on this interface. If false, source IP spoofing is prevented on this
	// interface. If true, source IP spoofing is allowed on this interface.
	AllowIPSpoofing *bool `json:"allow_ip_spoofing" validate:"required"`

	// The date and time that the network interface was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// Array of references to floating IPs associated with this network interface.
	FloatingIps []FloatingIPReference `json:"floating_ips,omitempty"`

	// The URL for this network interface.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this network interface.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this network interface.
	Name *string `json:"name" validate:"required"`

	// The network interface port speed in Mbps.
	PortSpeed *int64 `json:"port_speed" validate:"required"`

	// The primary IPv4 address.
	PrimaryIpv4Address *string `json:"primary_ipv4_address" validate:"required"`

	// The type of resource referenced.
	ResourceType *string `json:"resource_type" validate:"required"`

	// Collection of security groups.
	SecurityGroups []SecurityGroupReference `json:"security_groups" validate:"required"`

	// The status of the network interface.
	Status *string `json:"status" validate:"required"`

	// The associated subnet.
	Subnet *SubnetReference `json:"subnet" validate:"required"`

	// The type of this network interface as it relates to an instance.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the NetworkInterface.ResourceType property.
// The type of resource referenced.
const (
	NetworkInterfaceResourceTypeNetworkInterfaceConst = "network_interface"
)

// Constants associated with the NetworkInterface.Status property.
// The status of the network interface.
const (
	NetworkInterfaceStatusAvailableConst = "available"
	NetworkInterfaceStatusFailedConst    = "failed"
	NetworkInterfaceStatusPendingConst   = "pending"
)

// Constants associated with the NetworkInterface.Type property.
// The type of this network interface as it relates to an instance.
const (
	NetworkInterfaceTypePrimaryConst   = "primary"
	NetworkInterfaceTypeSecondaryConst = "secondary"
)

// UnmarshalNetworkInterface unmarshals an instance of NetworkInterface from the specified map of raw messages.
func UnmarshalNetworkInterface(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkInterface)
	err = core.UnmarshalPrimitive(m, "allow_ip_spoofing", &obj.AllowIPSpoofing)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "floating_ips", &obj.FloatingIps, UnmarshalFloatingIPReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "port_speed", &obj.PortSpeed)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "primary_ipv4_address", &obj.PrimaryIpv4Address)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "security_groups", &obj.SecurityGroups, UnmarshalSecurityGroupReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "subnet", &obj.Subnet, UnmarshalSubnetReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkInterfaceCollection : NetworkInterfaceCollection struct
type NetworkInterfaceCollection struct {
	// Collection of network interfaces.
	NetworkInterfaces []NetworkInterface `json:"network_interfaces" validate:"required"`
}

// UnmarshalNetworkInterfaceCollection unmarshals an instance of NetworkInterfaceCollection from the specified map of raw messages.
func UnmarshalNetworkInterfaceCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkInterfaceCollection)
	err = core.UnmarshalModel(m, "network_interfaces", &obj.NetworkInterfaces, UnmarshalNetworkInterface)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkInterfaceIdentity : Identifies a network interface by a unique property.
// Models which "extend" this model:
// - NetworkInterfaceIdentityByID
// - NetworkInterfaceIdentityByHref
type NetworkInterfaceIdentity struct {
	// The unique identifier for this network interface.
	ID *string `json:"id,omitempty"`

	// The URL for this network interface.
	Href *string `json:"href,omitempty"`
}

func (*NetworkInterfaceIdentity) isaNetworkInterfaceIdentity() bool {
	return true
}

type NetworkInterfaceIdentityIntf interface {
	isaNetworkInterfaceIdentity() bool
}

// UnmarshalNetworkInterfaceIdentity unmarshals an instance of NetworkInterfaceIdentity from the specified map of raw messages.
func UnmarshalNetworkInterfaceIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkInterfaceIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkInterfaceInstanceContextReference : NetworkInterfaceInstanceContextReference struct
type NetworkInterfaceInstanceContextReference struct {
	// The URL for this network interface.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this network interface.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this network interface.
	Name *string `json:"name" validate:"required"`

	// The primary IPv4 address.
	PrimaryIpv4Address *string `json:"primary_ipv4_address" validate:"required"`

	// The type of resource referenced.
	ResourceType *string `json:"resource_type" validate:"required"`

	// The associated subnet.
	Subnet *SubnetReference `json:"subnet" validate:"required"`
}

// Constants associated with the NetworkInterfaceInstanceContextReference.ResourceType property.
// The type of resource referenced.
const (
	NetworkInterfaceInstanceContextReferenceResourceTypeNetworkInterfaceConst = "network_interface"
)

// UnmarshalNetworkInterfaceInstanceContextReference unmarshals an instance of NetworkInterfaceInstanceContextReference from the specified map of raw messages.
func UnmarshalNetworkInterfaceInstanceContextReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkInterfaceInstanceContextReference)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "primary_ipv4_address", &obj.PrimaryIpv4Address)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "subnet", &obj.Subnet, UnmarshalSubnetReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkInterfacePrototype : NetworkInterfacePrototype struct
type NetworkInterfacePrototype struct {
	// Indicates whether source IP spoofing is allowed on this interface. If false, source IP spoofing is prevented on this
	// interface. If true, source IP spoofing is allowed on this interface.
	AllowIPSpoofing *bool `json:"allow_ip_spoofing,omitempty"`

	// The user-defined name for this network interface. If unspecified, the name will be a hyphenated list of
	// randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The primary IPv4 address.
	PrimaryIpv4Address *string `json:"primary_ipv4_address,omitempty"`

	// Collection of security groups.
	SecurityGroups []SecurityGroupIdentityIntf `json:"security_groups,omitempty"`

	// The associated subnet.
	Subnet SubnetIdentityIntf `json:"subnet" validate:"required"`
}

// NewNetworkInterfacePrototype : Instantiate NetworkInterfacePrototype (Generic Model Constructor)
func (*VpcV1) NewNetworkInterfacePrototype(subnet SubnetIdentityIntf) (model *NetworkInterfacePrototype, err error) {
	model = &NetworkInterfacePrototype{
		Subnet: subnet,
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

// UnmarshalNetworkInterfacePrototype unmarshals an instance of NetworkInterfacePrototype from the specified map of raw messages.
func UnmarshalNetworkInterfacePrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkInterfacePrototype)
	err = core.UnmarshalPrimitive(m, "allow_ip_spoofing", &obj.AllowIPSpoofing)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "primary_ipv4_address", &obj.PrimaryIpv4Address)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "security_groups", &obj.SecurityGroups, UnmarshalSecurityGroupIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "subnet", &obj.Subnet, UnmarshalSubnetIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkInterfaceReference : NetworkInterfaceReference struct
type NetworkInterfaceReference struct {
	// The URL for this network interface.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this network interface.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this network interface.
	Name *string `json:"name" validate:"required"`

	// The primary IPv4 address.
	PrimaryIpv4Address *string `json:"primary_ipv4_address" validate:"required"`

	// The type of resource referenced.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the NetworkInterfaceReference.ResourceType property.
// The type of resource referenced.
const (
	NetworkInterfaceReferenceResourceTypeNetworkInterfaceConst = "network_interface"
)

// UnmarshalNetworkInterfaceReference unmarshals an instance of NetworkInterfaceReference from the specified map of raw messages.
func UnmarshalNetworkInterfaceReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkInterfaceReference)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "primary_ipv4_address", &obj.PrimaryIpv4Address)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// OperatingSystem : OperatingSystem struct
type OperatingSystem struct {
	// The operating system architecture.
	Architecture *string `json:"architecture" validate:"required"`

	// A unique, display-friendly name for the operating system.
	DisplayName *string `json:"display_name" validate:"required"`

	// The name of the software family this operating system belongs to.
	Family *string `json:"family" validate:"required"`

	// The supported GPU manufacturer(s) for this operating system.
	GpuSupported []string `json:"gpu_supported,omitempty"`

	// The URL for this operating system.
	Href *string `json:"href" validate:"required"`

	// The unique name of the operating system.
	Name *string `json:"name" validate:"required"`

	// The vendor of the operating system.
	Vendor *string `json:"vendor" validate:"required"`

	// The major release version of this operating system.
	Version *string `json:"version" validate:"required"`
}

// UnmarshalOperatingSystem unmarshals an instance of OperatingSystem from the specified map of raw messages.
func UnmarshalOperatingSystem(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(OperatingSystem)
	err = core.UnmarshalPrimitive(m, "architecture", &obj.Architecture)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "display_name", &obj.DisplayName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "family", &obj.Family)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "gpu_supported", &obj.GpuSupported)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "vendor", &obj.Vendor)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "version", &obj.Version)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// OperatingSystemCollection : OperatingSystemCollection struct
type OperatingSystemCollection struct {
	// A reference to the first page of resources.
	First *OperatingSystemCollectionFirst `json:"first" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A reference to the next page of resources; this reference is included for all pages
	// except the last page.
	Next *OperatingSystemCollectionNext `json:"next,omitempty"`

	// Collection of operating systems.
	OperatingSystems []OperatingSystem `json:"operating_systems" validate:"required"`
}

// UnmarshalOperatingSystemCollection unmarshals an instance of OperatingSystemCollection from the specified map of raw messages.
func UnmarshalOperatingSystemCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(OperatingSystemCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalOperatingSystemCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalOperatingSystemCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "operating_systems", &obj.OperatingSystems, UnmarshalOperatingSystem)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// OperatingSystemCollectionFirst : A reference to the first page of resources.
type OperatingSystemCollectionFirst struct {
	// The URL for the first page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalOperatingSystemCollectionFirst unmarshals an instance of OperatingSystemCollectionFirst from the specified map of raw messages.
func UnmarshalOperatingSystemCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(OperatingSystemCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// OperatingSystemCollectionNext : A reference to the next page of resources; this reference is included for all pages except the last page.
type OperatingSystemCollectionNext struct {
	// The URL for the next page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalOperatingSystemCollectionNext unmarshals an instance of OperatingSystemCollectionNext from the specified map of raw messages.
func UnmarshalOperatingSystemCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(OperatingSystemCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// OperatingSystemIdentity : Identifies an operating system by a unique property.
// Models which "extend" this model:
// - OperatingSystemIdentityByName
// - OperatingSystemIdentityByHref
type OperatingSystemIdentity struct {
	// The unique name of the operating system.
	Name *string `json:"name,omitempty"`

	// The URL for this operating system.
	Href *string `json:"href,omitempty"`
}

func (*OperatingSystemIdentity) isaOperatingSystemIdentity() bool {
	return true
}

type OperatingSystemIdentityIntf interface {
	isaOperatingSystemIdentity() bool
}

// UnmarshalOperatingSystemIdentity unmarshals an instance of OperatingSystemIdentity from the specified map of raw messages.
func UnmarshalOperatingSystemIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(OperatingSystemIdentity)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PublicGateway : PublicGateway struct
type PublicGateway struct {
	// The date and time that the public gateway was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The CRN for this public gateway.
	CRN *string `json:"crn" validate:"required"`

	// Reference to the floating IP which is bound to this public gateway.
	FloatingIP *PublicGatewayFloatingIP `json:"floating_ip" validate:"required"`

	// The URL for this public gateway.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this public gateway.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this public gateway.
	Name *string `json:"name" validate:"required"`

	// The resource group for this public gateway.
	ResourceGroup *ResourceGroupReference `json:"resource_group" validate:"required"`

	// The type of resource referenced.
	ResourceType *string `json:"resource_type" validate:"required"`

	// The status of the volume.
	Status *string `json:"status" validate:"required"`

	// The VPC this public gateway serves.
	VPC *VPCReference `json:"vpc" validate:"required"`

	// The zone where this public gateway lives.
	Zone *ZoneReference `json:"zone" validate:"required"`
}

// Constants associated with the PublicGateway.ResourceType property.
// The type of resource referenced.
const (
	PublicGatewayResourceTypePublicGatewayConst = "public_gateway"
)

// Constants associated with the PublicGateway.Status property.
// The status of the volume.
const (
	PublicGatewayStatusAvailableConst = "available"
	PublicGatewayStatusDeletingConst  = "deleting"
	PublicGatewayStatusFailedConst    = "failed"
	PublicGatewayStatusPendingConst   = "pending"
)

// UnmarshalPublicGateway unmarshals an instance of PublicGateway from the specified map of raw messages.
func UnmarshalPublicGateway(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PublicGateway)
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "floating_ip", &obj.FloatingIP, UnmarshalPublicGatewayFloatingIP)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vpc", &obj.VPC, UnmarshalVPCReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PublicGatewayCollection : PublicGatewayCollection struct
type PublicGatewayCollection struct {
	// A reference to the first page of resources.
	First *PublicGatewayCollectionFirst `json:"first" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A reference to the next page of resources; this reference is included for all pages
	// except the last page.
	Next *PublicGatewayCollectionNext `json:"next,omitempty"`

	// Collection of public gateways.
	PublicGateways []PublicGateway `json:"public_gateways" validate:"required"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalPublicGatewayCollection unmarshals an instance of PublicGatewayCollection from the specified map of raw messages.
func UnmarshalPublicGatewayCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PublicGatewayCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalPublicGatewayCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalPublicGatewayCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "public_gateways", &obj.PublicGateways, UnmarshalPublicGateway)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PublicGatewayCollectionFirst : A reference to the first page of resources.
type PublicGatewayCollectionFirst struct {
	// The URL for the first page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalPublicGatewayCollectionFirst unmarshals an instance of PublicGatewayCollectionFirst from the specified map of raw messages.
func UnmarshalPublicGatewayCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PublicGatewayCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PublicGatewayCollectionNext : A reference to the next page of resources; this reference is included for all pages except the last page.
type PublicGatewayCollectionNext struct {
	// The URL for the next page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalPublicGatewayCollectionNext unmarshals an instance of PublicGatewayCollectionNext from the specified map of raw messages.
func UnmarshalPublicGatewayCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PublicGatewayCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PublicGatewayFloatingIP : Reference to the floating IP which is bound to this public gateway.
type PublicGatewayFloatingIP struct {
	// The globally unique IP address.
	Address *string `json:"address" validate:"required"`

	// The CRN for this floating IP.
	CRN *string `json:"crn" validate:"required"`

	// The URL for this floating IP.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this floating IP.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this floating IP.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalPublicGatewayFloatingIP unmarshals an instance of PublicGatewayFloatingIP from the specified map of raw messages.
func UnmarshalPublicGatewayFloatingIP(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PublicGatewayFloatingIP)
	err = core.UnmarshalPrimitive(m, "address", &obj.Address)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PublicGatewayIdentity : Identifies a public gateway by a unique property.
// Models which "extend" this model:
// - PublicGatewayIdentityByID
// - PublicGatewayIdentityByCRN
// - PublicGatewayIdentityByHref
type PublicGatewayIdentity struct {
	// The unique identifier for this public gateway.
	ID *string `json:"id,omitempty"`

	// The CRN for this public gateway.
	CRN *string `json:"crn,omitempty"`

	// The URL for this public gateway.
	Href *string `json:"href,omitempty"`
}

func (*PublicGatewayIdentity) isaPublicGatewayIdentity() bool {
	return true
}

type PublicGatewayIdentityIntf interface {
	isaPublicGatewayIdentity() bool
}

// UnmarshalPublicGatewayIdentity unmarshals an instance of PublicGatewayIdentity from the specified map of raw messages.
func UnmarshalPublicGatewayIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PublicGatewayIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PublicGatewayPrototypeFloatingIP : PublicGatewayPrototypeFloatingIP struct
// Models which "extend" this model:
// - PublicGatewayPrototypeFloatingIPFloatingIPIdentity
// - PublicGatewayPrototypeFloatingIPFloatingIPPrototypeTargetContext
type PublicGatewayPrototypeFloatingIP struct {
	// The unique identifier for this floating IP.
	ID *string `json:"id,omitempty"`

	// The CRN for this floating IP.
	CRN *string `json:"crn,omitempty"`

	// The URL for this floating IP.
	Href *string `json:"href,omitempty"`

	// The globally unique IP address.
	Address *string `json:"address,omitempty"`

	// The unique user-defined name for this floating IP. If unspecified, the name will be a hyphenated list of
	// randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`
}

func (*PublicGatewayPrototypeFloatingIP) isaPublicGatewayPrototypeFloatingIP() bool {
	return true
}

type PublicGatewayPrototypeFloatingIPIntf interface {
	isaPublicGatewayPrototypeFloatingIP() bool
}

// UnmarshalPublicGatewayPrototypeFloatingIP unmarshals an instance of PublicGatewayPrototypeFloatingIP from the specified map of raw messages.
func UnmarshalPublicGatewayPrototypeFloatingIP(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PublicGatewayPrototypeFloatingIP)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "address", &obj.Address)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PublicGatewayReference : PublicGatewayReference struct
type PublicGatewayReference struct {
	// The CRN for this public gateway.
	CRN *string `json:"crn" validate:"required"`

	// The URL for this public gateway.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this public gateway.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this public gateway.
	Name *string `json:"name" validate:"required"`

	// The type of resource referenced.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the PublicGatewayReference.ResourceType property.
// The type of resource referenced.
const (
	PublicGatewayReferenceResourceTypePublicGatewayConst = "public_gateway"
)

// UnmarshalPublicGatewayReference unmarshals an instance of PublicGatewayReference from the specified map of raw messages.
func UnmarshalPublicGatewayReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PublicGatewayReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Region : Region struct
type Region struct {
	// The API endpoint for this region.
	Endpoint *string `json:"endpoint" validate:"required"`

	// The URL for this region.
	Href *string `json:"href" validate:"required"`

	// The name for this region.
	Name *string `json:"name" validate:"required"`

	// The availability status of this region.
	Status *string `json:"status" validate:"required"`
}

// Constants associated with the Region.Status property.
// The availability status of this region.
const (
	RegionStatusAvailableConst   = "available"
	RegionStatusUnavailableConst = "unavailable"
)

// UnmarshalRegion unmarshals an instance of Region from the specified map of raw messages.
func UnmarshalRegion(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Region)
	err = core.UnmarshalPrimitive(m, "endpoint", &obj.Endpoint)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RegionCollection : RegionCollection struct
type RegionCollection struct {
	// Array of Region objects.
	Regions []Region `json:"regions" validate:"required"`
}

// UnmarshalRegionCollection unmarshals an instance of RegionCollection from the specified map of raw messages.
func UnmarshalRegionCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RegionCollection)
	err = core.UnmarshalModel(m, "regions", &obj.Regions, UnmarshalRegion)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RegionReference : RegionReference struct
type RegionReference struct {
	// The URL for this region.
	Href *string `json:"href" validate:"required"`

	// The name for this region.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalRegionReference unmarshals an instance of RegionReference from the specified map of raw messages.
func UnmarshalRegionReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RegionReference)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RemoveInstanceNetworkInterfaceFloatingIPOptions : The RemoveInstanceNetworkInterfaceFloatingIP options.
type RemoveInstanceNetworkInterfaceFloatingIPOptions struct {
	// The instance identifier.
	InstanceID *string `json:"instance_id" validate:"required"`

	// The network interface identifier.
	NetworkInterfaceID *string `json:"network_interface_id" validate:"required"`

	// The floating IP identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewRemoveInstanceNetworkInterfaceFloatingIPOptions : Instantiate RemoveInstanceNetworkInterfaceFloatingIPOptions
func (*VpcV1) NewRemoveInstanceNetworkInterfaceFloatingIPOptions(instanceID string, networkInterfaceID string, id string) *RemoveInstanceNetworkInterfaceFloatingIPOptions {
	return &RemoveInstanceNetworkInterfaceFloatingIPOptions{
		InstanceID:         core.StringPtr(instanceID),
		NetworkInterfaceID: core.StringPtr(networkInterfaceID),
		ID:                 core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (options *RemoveInstanceNetworkInterfaceFloatingIPOptions) SetInstanceID(instanceID string) *RemoveInstanceNetworkInterfaceFloatingIPOptions {
	options.InstanceID = core.StringPtr(instanceID)
	return options
}

// SetNetworkInterfaceID : Allow user to set NetworkInterfaceID
func (options *RemoveInstanceNetworkInterfaceFloatingIPOptions) SetNetworkInterfaceID(networkInterfaceID string) *RemoveInstanceNetworkInterfaceFloatingIPOptions {
	options.NetworkInterfaceID = core.StringPtr(networkInterfaceID)
	return options
}

// SetID : Allow user to set ID
func (options *RemoveInstanceNetworkInterfaceFloatingIPOptions) SetID(id string) *RemoveInstanceNetworkInterfaceFloatingIPOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *RemoveInstanceNetworkInterfaceFloatingIPOptions) SetHeaders(param map[string]string) *RemoveInstanceNetworkInterfaceFloatingIPOptions {
	options.Headers = param
	return options
}

// RemoveSecurityGroupNetworkInterfaceOptions : The RemoveSecurityGroupNetworkInterface options.
type RemoveSecurityGroupNetworkInterfaceOptions struct {
	// The security group identifier.
	SecurityGroupID *string `json:"security_group_id" validate:"required"`

	// The network interface identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewRemoveSecurityGroupNetworkInterfaceOptions : Instantiate RemoveSecurityGroupNetworkInterfaceOptions
func (*VpcV1) NewRemoveSecurityGroupNetworkInterfaceOptions(securityGroupID string, id string) *RemoveSecurityGroupNetworkInterfaceOptions {
	return &RemoveSecurityGroupNetworkInterfaceOptions{
		SecurityGroupID: core.StringPtr(securityGroupID),
		ID:              core.StringPtr(id),
	}
}

// SetSecurityGroupID : Allow user to set SecurityGroupID
func (options *RemoveSecurityGroupNetworkInterfaceOptions) SetSecurityGroupID(securityGroupID string) *RemoveSecurityGroupNetworkInterfaceOptions {
	options.SecurityGroupID = core.StringPtr(securityGroupID)
	return options
}

// SetID : Allow user to set ID
func (options *RemoveSecurityGroupNetworkInterfaceOptions) SetID(id string) *RemoveSecurityGroupNetworkInterfaceOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *RemoveSecurityGroupNetworkInterfaceOptions) SetHeaders(param map[string]string) *RemoveSecurityGroupNetworkInterfaceOptions {
	options.Headers = param
	return options
}

// RemoveVPNGatewayConnectionLocalCIDROptions : The RemoveVPNGatewayConnectionLocalCIDR options.
type RemoveVPNGatewayConnectionLocalCIDROptions struct {
	// The VPN gateway identifier.
	VPNGatewayID *string `json:"vpn_gateway_id" validate:"required"`

	// The VPN connection identifier.
	ID *string `json:"id" validate:"required"`

	// The address prefix part of the CIDR.
	CIDRPrefix *string `json:"cidr_prefix" validate:"required"`

	// The prefix length part of the CIDR.
	PrefixLength *string `json:"prefix_length" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewRemoveVPNGatewayConnectionLocalCIDROptions : Instantiate RemoveVPNGatewayConnectionLocalCIDROptions
func (*VpcV1) NewRemoveVPNGatewayConnectionLocalCIDROptions(vpnGatewayID string, id string, cidrPrefix string, prefixLength string) *RemoveVPNGatewayConnectionLocalCIDROptions {
	return &RemoveVPNGatewayConnectionLocalCIDROptions{
		VPNGatewayID: core.StringPtr(vpnGatewayID),
		ID:           core.StringPtr(id),
		CIDRPrefix:   core.StringPtr(cidrPrefix),
		PrefixLength: core.StringPtr(prefixLength),
	}
}

// SetVPNGatewayID : Allow user to set VPNGatewayID
func (options *RemoveVPNGatewayConnectionLocalCIDROptions) SetVPNGatewayID(vpnGatewayID string) *RemoveVPNGatewayConnectionLocalCIDROptions {
	options.VPNGatewayID = core.StringPtr(vpnGatewayID)
	return options
}

// SetID : Allow user to set ID
func (options *RemoveVPNGatewayConnectionLocalCIDROptions) SetID(id string) *RemoveVPNGatewayConnectionLocalCIDROptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetCIDRPrefix : Allow user to set CIDRPrefix
func (options *RemoveVPNGatewayConnectionLocalCIDROptions) SetCIDRPrefix(cidrPrefix string) *RemoveVPNGatewayConnectionLocalCIDROptions {
	options.CIDRPrefix = core.StringPtr(cidrPrefix)
	return options
}

// SetPrefixLength : Allow user to set PrefixLength
func (options *RemoveVPNGatewayConnectionLocalCIDROptions) SetPrefixLength(prefixLength string) *RemoveVPNGatewayConnectionLocalCIDROptions {
	options.PrefixLength = core.StringPtr(prefixLength)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *RemoveVPNGatewayConnectionLocalCIDROptions) SetHeaders(param map[string]string) *RemoveVPNGatewayConnectionLocalCIDROptions {
	options.Headers = param
	return options
}

// RemoveVPNGatewayConnectionPeerCIDROptions : The RemoveVPNGatewayConnectionPeerCIDR options.
type RemoveVPNGatewayConnectionPeerCIDROptions struct {
	// The VPN gateway identifier.
	VPNGatewayID *string `json:"vpn_gateway_id" validate:"required"`

	// The VPN connection identifier.
	ID *string `json:"id" validate:"required"`

	// The address prefix part of the CIDR.
	CIDRPrefix *string `json:"cidr_prefix" validate:"required"`

	// The prefix length part of the CIDR.
	PrefixLength *string `json:"prefix_length" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewRemoveVPNGatewayConnectionPeerCIDROptions : Instantiate RemoveVPNGatewayConnectionPeerCIDROptions
func (*VpcV1) NewRemoveVPNGatewayConnectionPeerCIDROptions(vpnGatewayID string, id string, cidrPrefix string, prefixLength string) *RemoveVPNGatewayConnectionPeerCIDROptions {
	return &RemoveVPNGatewayConnectionPeerCIDROptions{
		VPNGatewayID: core.StringPtr(vpnGatewayID),
		ID:           core.StringPtr(id),
		CIDRPrefix:   core.StringPtr(cidrPrefix),
		PrefixLength: core.StringPtr(prefixLength),
	}
}

// SetVPNGatewayID : Allow user to set VPNGatewayID
func (options *RemoveVPNGatewayConnectionPeerCIDROptions) SetVPNGatewayID(vpnGatewayID string) *RemoveVPNGatewayConnectionPeerCIDROptions {
	options.VPNGatewayID = core.StringPtr(vpnGatewayID)
	return options
}

// SetID : Allow user to set ID
func (options *RemoveVPNGatewayConnectionPeerCIDROptions) SetID(id string) *RemoveVPNGatewayConnectionPeerCIDROptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetCIDRPrefix : Allow user to set CIDRPrefix
func (options *RemoveVPNGatewayConnectionPeerCIDROptions) SetCIDRPrefix(cidrPrefix string) *RemoveVPNGatewayConnectionPeerCIDROptions {
	options.CIDRPrefix = core.StringPtr(cidrPrefix)
	return options
}

// SetPrefixLength : Allow user to set PrefixLength
func (options *RemoveVPNGatewayConnectionPeerCIDROptions) SetPrefixLength(prefixLength string) *RemoveVPNGatewayConnectionPeerCIDROptions {
	options.PrefixLength = core.StringPtr(prefixLength)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *RemoveVPNGatewayConnectionPeerCIDROptions) SetHeaders(param map[string]string) *RemoveVPNGatewayConnectionPeerCIDROptions {
	options.Headers = param
	return options
}

// ReplaceLoadBalancerPoolMembersOptions : The ReplaceLoadBalancerPoolMembers options.
type ReplaceLoadBalancerPoolMembersOptions struct {
	// The load balancer identifier.
	LoadBalancerID *string `json:"load_balancer_id" validate:"required"`

	// The pool identifier.
	PoolID *string `json:"pool_id" validate:"required"`

	// Array of pool member prototype objects.
	Members []LoadBalancerPoolMemberPrototype `json:"members" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewReplaceLoadBalancerPoolMembersOptions : Instantiate ReplaceLoadBalancerPoolMembersOptions
func (*VpcV1) NewReplaceLoadBalancerPoolMembersOptions(loadBalancerID string, poolID string, members []LoadBalancerPoolMemberPrototype) *ReplaceLoadBalancerPoolMembersOptions {
	return &ReplaceLoadBalancerPoolMembersOptions{
		LoadBalancerID: core.StringPtr(loadBalancerID),
		PoolID:         core.StringPtr(poolID),
		Members:        members,
	}
}

// SetLoadBalancerID : Allow user to set LoadBalancerID
func (options *ReplaceLoadBalancerPoolMembersOptions) SetLoadBalancerID(loadBalancerID string) *ReplaceLoadBalancerPoolMembersOptions {
	options.LoadBalancerID = core.StringPtr(loadBalancerID)
	return options
}

// SetPoolID : Allow user to set PoolID
func (options *ReplaceLoadBalancerPoolMembersOptions) SetPoolID(poolID string) *ReplaceLoadBalancerPoolMembersOptions {
	options.PoolID = core.StringPtr(poolID)
	return options
}

// SetMembers : Allow user to set Members
func (options *ReplaceLoadBalancerPoolMembersOptions) SetMembers(members []LoadBalancerPoolMemberPrototype) *ReplaceLoadBalancerPoolMembersOptions {
	options.Members = members
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ReplaceLoadBalancerPoolMembersOptions) SetHeaders(param map[string]string) *ReplaceLoadBalancerPoolMembersOptions {
	options.Headers = param
	return options
}

// ReplaceSubnetNetworkACLOptions : The ReplaceSubnetNetworkACL options.
type ReplaceSubnetNetworkACLOptions struct {
	// The subnet identifier.
	ID *string `json:"id" validate:"required"`

	// The network ACL identity.
	NetworkACLIdentity NetworkACLIdentityIntf `json:"NetworkACLIdentity" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewReplaceSubnetNetworkACLOptions : Instantiate ReplaceSubnetNetworkACLOptions
func (*VpcV1) NewReplaceSubnetNetworkACLOptions(id string, networkACLIdentity NetworkACLIdentityIntf) *ReplaceSubnetNetworkACLOptions {
	return &ReplaceSubnetNetworkACLOptions{
		ID:                 core.StringPtr(id),
		NetworkACLIdentity: networkACLIdentity,
	}
}

// SetID : Allow user to set ID
func (options *ReplaceSubnetNetworkACLOptions) SetID(id string) *ReplaceSubnetNetworkACLOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetNetworkACLIdentity : Allow user to set NetworkACLIdentity
func (options *ReplaceSubnetNetworkACLOptions) SetNetworkACLIdentity(networkACLIdentity NetworkACLIdentityIntf) *ReplaceSubnetNetworkACLOptions {
	options.NetworkACLIdentity = networkACLIdentity
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ReplaceSubnetNetworkACLOptions) SetHeaders(param map[string]string) *ReplaceSubnetNetworkACLOptions {
	options.Headers = param
	return options
}

// ReplaceSubnetRoutingTableOptions : The ReplaceSubnetRoutingTable options.
type ReplaceSubnetRoutingTableOptions struct {
	// The subnet identifier.
	ID *string `json:"id" validate:"required"`

	// The routing table identity.
	RoutingTableIdentity RoutingTableIdentityIntf `json:"RoutingTableIdentity" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewReplaceSubnetRoutingTableOptions : Instantiate ReplaceSubnetRoutingTableOptions
func (*VpcV1) NewReplaceSubnetRoutingTableOptions(id string, routingTableIdentity RoutingTableIdentityIntf) *ReplaceSubnetRoutingTableOptions {
	return &ReplaceSubnetRoutingTableOptions{
		ID:                   core.StringPtr(id),
		RoutingTableIdentity: routingTableIdentity,
	}
}

// SetID : Allow user to set ID
func (options *ReplaceSubnetRoutingTableOptions) SetID(id string) *ReplaceSubnetRoutingTableOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetRoutingTableIdentity : Allow user to set RoutingTableIdentity
func (options *ReplaceSubnetRoutingTableOptions) SetRoutingTableIdentity(routingTableIdentity RoutingTableIdentityIntf) *ReplaceSubnetRoutingTableOptions {
	options.RoutingTableIdentity = routingTableIdentity
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ReplaceSubnetRoutingTableOptions) SetHeaders(param map[string]string) *ReplaceSubnetRoutingTableOptions {
	options.Headers = param
	return options
}

// ResourceGroupIdentity : The resource group to use. If unspecified, the account's [default resource
// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
// Models which "extend" this model:
// - ResourceGroupIdentityByID
type ResourceGroupIdentity struct {
	// The unique identifier for this resource group.
	ID *string `json:"id,omitempty"`
}

func (*ResourceGroupIdentity) isaResourceGroupIdentity() bool {
	return true
}

type ResourceGroupIdentityIntf interface {
	isaResourceGroupIdentity() bool
}

// UnmarshalResourceGroupIdentity unmarshals an instance of ResourceGroupIdentity from the specified map of raw messages.
func UnmarshalResourceGroupIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ResourceGroupIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ResourceGroupReference : ResourceGroupReference struct
type ResourceGroupReference struct {
	// The URL for this resource group.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this resource group.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this resource group.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalResourceGroupReference unmarshals an instance of ResourceGroupReference from the specified map of raw messages.
func UnmarshalResourceGroupReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ResourceGroupReference)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Route : Route struct
type Route struct {
	// The action to perform with a packet matching the route:
	// - `delegate`: delegate to the system's built-in routes
	// - `deliver`: deliver the packet to the specified `next_hop`
	// - `drop`: drop the packet.
	Action *string `json:"action" validate:"required"`

	// The date and time that the route was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The destination of the route.
	Destination *string `json:"destination" validate:"required"`

	// The URL for this route.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this route.
	ID *string `json:"id" validate:"required"`

	// The lifecycle state of the route.
	LifecycleState *string `json:"lifecycle_state" validate:"required"`

	// The user-defined name for this route.
	Name *string `json:"name" validate:"required"`

	// If `action` is `deliver`, the next hop that packets will be delivered to.  For
	// other `action` values, its `address` will be `0.0.0.0`.
	NextHop RouteNextHopIntf `json:"next_hop" validate:"required"`

	// The zone the route applies to. (Traffic from subnets in this zone will be
	// subject to this route.).
	Zone *ZoneReference `json:"zone" validate:"required"`
}

// Constants associated with the Route.Action property.
// The action to perform with a packet matching the route:
// - `delegate`: delegate to the system's built-in routes
// - `deliver`: deliver the packet to the specified `next_hop`
// - `drop`: drop the packet.
const (
	RouteActionDelegateConst = "delegate"
	RouteActionDeliverConst  = "deliver"
	RouteActionDropConst     = "drop"
)

// Constants associated with the Route.LifecycleState property.
// The lifecycle state of the route.
const (
	RouteLifecycleStateDeletedConst  = "deleted"
	RouteLifecycleStateDeletingConst = "deleting"
	RouteLifecycleStateFailedConst   = "failed"
	RouteLifecycleStatePendingConst  = "pending"
	RouteLifecycleStateStableConst   = "stable"
	RouteLifecycleStateUpdatingConst = "updating"
	RouteLifecycleStateWaitingConst  = "waiting"
)

// UnmarshalRoute unmarshals an instance of Route from the specified map of raw messages.
func UnmarshalRoute(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Route)
	err = core.UnmarshalPrimitive(m, "action", &obj.Action)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "destination", &obj.Destination)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "lifecycle_state", &obj.LifecycleState)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next_hop", &obj.NextHop, UnmarshalRouteNextHop)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RouteCollection : RouteCollection struct
type RouteCollection struct {
	// A reference to the first page of resources.
	First *RouteCollectionFirst `json:"first" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A reference to the next page of resources; this reference is included for all pages
	// except the last page.
	Next *RouteCollectionNext `json:"next,omitempty"`

	// Collection of routes.
	Routes []Route `json:"routes" validate:"required"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalRouteCollection unmarshals an instance of RouteCollection from the specified map of raw messages.
func UnmarshalRouteCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RouteCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalRouteCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalRouteCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "routes", &obj.Routes, UnmarshalRoute)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RouteCollectionFirst : A reference to the first page of resources.
type RouteCollectionFirst struct {
	// The URL for the first page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalRouteCollectionFirst unmarshals an instance of RouteCollectionFirst from the specified map of raw messages.
func UnmarshalRouteCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RouteCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RouteCollectionNext : A reference to the next page of resources; this reference is included for all pages except the last page.
type RouteCollectionNext struct {
	// The URL for the next page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalRouteCollectionNext unmarshals an instance of RouteCollectionNext from the specified map of raw messages.
func UnmarshalRouteCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RouteCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RouteNextHop : RouteNextHop struct
// Models which "extend" this model:
// - RouteNextHopIP
// - RouteNextHopVPNGatewayConnectionReference
type RouteNextHop struct {
	// The IP address. This property may add support for IPv6 addresses in the future. When processing a value in this
	// property, verify that the address is in an expected format. If it is not, log an error. Optionally halt processing
	// and surface the error, or bypass the resource on which the unexpected IP address format was encountered.
	Address *string `json:"address,omitempty"`

	// The VPN connection's canonical URL.
	Href *string `json:"href,omitempty"`

	// The unique identifier for this VPN connection.
	ID *string `json:"id,omitempty"`

	// The user-defined name for this VPN connection.
	Name *string `json:"name,omitempty"`
}

func (*RouteNextHop) isaRouteNextHop() bool {
	return true
}

type RouteNextHopIntf interface {
	isaRouteNextHop() bool
}

// UnmarshalRouteNextHop unmarshals an instance of RouteNextHop from the specified map of raw messages.
func UnmarshalRouteNextHop(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RouteNextHop)
	err = core.UnmarshalPrimitive(m, "address", &obj.Address)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RouteNextHopPrototype : RouteNextHopPrototype struct
// Models which "extend" this model:
// - RouteNextHopPrototypeRouteNextHopIP
// - RouteNextHopPrototypeRouteNextHopConnection
type RouteNextHopPrototype struct {
	// The IP address. This property may add support for IPv6 addresses in the future. When processing a value in this
	// property, verify that the address is in an expected format. If it is not, log an error. Optionally halt processing
	// and surface the error, or bypass the resource on which the unexpected IP address format was encountered.
	Address *string `json:"address,omitempty"`

	// The unique identifier for this VPN connection.
	ID *string `json:"id,omitempty"`

	// The VPN connection's canonical URL.
	Href *string `json:"href,omitempty"`
}

func (*RouteNextHopPrototype) isaRouteNextHopPrototype() bool {
	return true
}

type RouteNextHopPrototypeIntf interface {
	isaRouteNextHopPrototype() bool
}

// UnmarshalRouteNextHopPrototype unmarshals an instance of RouteNextHopPrototype from the specified map of raw messages.
func UnmarshalRouteNextHopPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RouteNextHopPrototype)
	err = core.UnmarshalPrimitive(m, "address", &obj.Address)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RoutePrototype : RoutePrototype struct
type RoutePrototype struct {
	// The action to perform with a packet matching the route:
	// - `delegate`: delegate to the system's built-in routes
	// - `deliver`: deliver the packet to the specified `next_hop`
	// - `drop`: drop the packet.
	Action *string `json:"action,omitempty"`

	// The destination of the route. At most two routes per `zone` in a table can have the same destination, and only if
	// both routes have an `action` of `deliver`.
	Destination *string `json:"destination" validate:"required"`

	// The user-defined name for this route. If unspecified, the name will be a hyphenated list of randomly-selected words.
	// Names must be unique within the VPC routing table the route resides in.
	Name *string `json:"name,omitempty"`

	// If `action` is `deliver`, the next hop that packets will be delivered to.  For
	// other `action` values, its `address` will be `0.0.0.0`.
	NextHop RouteNextHopPrototypeIntf `json:"next_hop,omitempty"`

	// The zone to apply the route to. (Traffic from subnets in this zone will be
	// subject to this route.).
	Zone ZoneIdentityIntf `json:"zone" validate:"required"`
}

// Constants associated with the RoutePrototype.Action property.
// The action to perform with a packet matching the route:
// - `delegate`: delegate to the system's built-in routes
// - `deliver`: deliver the packet to the specified `next_hop`
// - `drop`: drop the packet.
const (
	RoutePrototypeActionDelegateConst = "delegate"
	RoutePrototypeActionDeliverConst  = "deliver"
	RoutePrototypeActionDropConst     = "drop"
)

// NewRoutePrototype : Instantiate RoutePrototype (Generic Model Constructor)
func (*VpcV1) NewRoutePrototype(destination string, zone ZoneIdentityIntf) (model *RoutePrototype, err error) {
	model = &RoutePrototype{
		Destination: core.StringPtr(destination),
		Zone:        zone,
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

// UnmarshalRoutePrototype unmarshals an instance of RoutePrototype from the specified map of raw messages.
func UnmarshalRoutePrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RoutePrototype)
	err = core.UnmarshalPrimitive(m, "action", &obj.Action)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "destination", &obj.Destination)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next_hop", &obj.NextHop, UnmarshalRouteNextHopPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RouteReference : RouteReference struct
type RouteReference struct {
	// The URL for this route.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this route.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this route.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalRouteReference unmarshals an instance of RouteReference from the specified map of raw messages.
func UnmarshalRouteReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RouteReference)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RoutingTable : RoutingTable struct
type RoutingTable struct {
	// The date and time that this routing table was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The URL for this routing table.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this routing table.
	ID *string `json:"id" validate:"required"`

	// The lifecycle state of the routing table.
	LifecycleState *string `json:"lifecycle_state" validate:"required"`

	// The user-defined name for this routing table. Names must be unique within the VPC the routing table resides in.
	Name *string `json:"name" validate:"required"`

	// The type of resource referenced.
	ResourceType *string `json:"resource_type" validate:"required"`

	// The routes for this routing table.
	Routes []RouteReference `json:"routes" validate:"required"`

	// The subnets to which this routing table is attached.
	Subnets []SubnetReference `json:"subnets" validate:"required"`
}

// Constants associated with the RoutingTable.LifecycleState property.
// The lifecycle state of the routing table.
const (
	RoutingTableLifecycleStateDeletedConst  = "deleted"
	RoutingTableLifecycleStateDeletingConst = "deleting"
	RoutingTableLifecycleStateFailedConst   = "failed"
	RoutingTableLifecycleStatePendingConst  = "pending"
	RoutingTableLifecycleStateStableConst   = "stable"
	RoutingTableLifecycleStateUpdatingConst = "updating"
	RoutingTableLifecycleStateWaitingConst  = "waiting"
)

// Constants associated with the RoutingTable.ResourceType property.
// The type of resource referenced.
const (
	RoutingTableResourceTypeRoutingTableConst = "routing_table"
)

// UnmarshalRoutingTable unmarshals an instance of RoutingTable from the specified map of raw messages.
func UnmarshalRoutingTable(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RoutingTable)
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "lifecycle_state", &obj.LifecycleState)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "routes", &obj.Routes, UnmarshalRouteReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "subnets", &obj.Subnets, UnmarshalSubnetReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RoutingTableCollection : RoutingTableCollection struct
type RoutingTableCollection struct {
	// A reference to the first page of resources.
	First *RoutingTableCollectionFirst `json:"first" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A reference to the next page of resources; this reference is included for all pages
	// except the last page.
	Next *RoutingTableCollectionNext `json:"next,omitempty"`

	// Collection of routing tables.
	RoutingTables []RoutingTable `json:"routing_tables" validate:"required"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalRoutingTableCollection unmarshals an instance of RoutingTableCollection from the specified map of raw messages.
func UnmarshalRoutingTableCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RoutingTableCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalRoutingTableCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalRoutingTableCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "routing_tables", &obj.RoutingTables, UnmarshalRoutingTable)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RoutingTableCollectionFirst : A reference to the first page of resources.
type RoutingTableCollectionFirst struct {
	// The URL for the first page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalRoutingTableCollectionFirst unmarshals an instance of RoutingTableCollectionFirst from the specified map of raw messages.
func UnmarshalRoutingTableCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RoutingTableCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RoutingTableCollectionNext : A reference to the next page of resources; this reference is included for all pages except the last page.
type RoutingTableCollectionNext struct {
	// The URL for the next page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalRoutingTableCollectionNext unmarshals an instance of RoutingTableCollectionNext from the specified map of raw messages.
func UnmarshalRoutingTableCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RoutingTableCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RoutingTableIdentity : Identifies a routing table by a unique property.
// Models which "extend" this model:
// - RoutingTableIdentityByID
// - RoutingTableIdentityByHref
type RoutingTableIdentity struct {
	// The unique identifier for this routing table.
	ID *string `json:"id,omitempty"`

	// The URL for this routing table.
	Href *string `json:"href,omitempty"`
}

func (*RoutingTableIdentity) isaRoutingTableIdentity() bool {
	return true
}

type RoutingTableIdentityIntf interface {
	isaRoutingTableIdentity() bool
}

// UnmarshalRoutingTableIdentity unmarshals an instance of RoutingTableIdentity from the specified map of raw messages.
func UnmarshalRoutingTableIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RoutingTableIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RoutingTableReference : RoutingTableReference struct
type RoutingTableReference struct {
	// The URL for this routing table.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this routing table.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this routing table.
	Name *string `json:"name" validate:"required"`

	// The type of resource referenced.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the RoutingTableReference.ResourceType property.
// The type of resource referenced.
const (
	RoutingTableReferenceResourceTypeRoutingTableConst = "routing_table"
)

// UnmarshalRoutingTableReference unmarshals an instance of RoutingTableReference from the specified map of raw messages.
func UnmarshalRoutingTableReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RoutingTableReference)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroup : SecurityGroup struct
type SecurityGroup struct {
	// The date and time that this security group was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The security group's CRN.
	CRN *string `json:"crn" validate:"required"`

	// The security group's canonical URL.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this security group.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this security group. Names must be unique within the VPC the security group resides in.
	Name *string `json:"name" validate:"required"`

	// Array of references to network interfaces.
	NetworkInterfaces []NetworkInterfaceReference `json:"network_interfaces" validate:"required"`

	// The resource group for this security group.
	ResourceGroup *ResourceGroupReference `json:"resource_group" validate:"required"`

	// Array of rules for this security group. If no rules exist, all traffic will be denied.
	Rules []SecurityGroupRuleIntf `json:"rules" validate:"required"`

	// The VPC this security group is a part of.
	VPC *VPCReference `json:"vpc" validate:"required"`
}

// UnmarshalSecurityGroup unmarshals an instance of SecurityGroup from the specified map of raw messages.
func UnmarshalSecurityGroup(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroup)
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "network_interfaces", &obj.NetworkInterfaces, UnmarshalNetworkInterfaceReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "rules", &obj.Rules, UnmarshalSecurityGroupRule)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vpc", &obj.VPC, UnmarshalVPCReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupCollection : SecurityGroupCollection struct
type SecurityGroupCollection struct {
	// A reference to the first page of resources.
	First *SecurityGroupCollectionFirst `json:"first" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A reference to the next page of resources; this reference is included for all pages
	// except the last page.
	Next *SecurityGroupCollectionNext `json:"next,omitempty"`

	// Collection of security groups.
	SecurityGroups []SecurityGroup `json:"security_groups" validate:"required"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalSecurityGroupCollection unmarshals an instance of SecurityGroupCollection from the specified map of raw messages.
func UnmarshalSecurityGroupCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalSecurityGroupCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalSecurityGroupCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "security_groups", &obj.SecurityGroups, UnmarshalSecurityGroup)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupCollectionFirst : A reference to the first page of resources.
type SecurityGroupCollectionFirst struct {
	// The URL for the first page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalSecurityGroupCollectionFirst unmarshals an instance of SecurityGroupCollectionFirst from the specified map of raw messages.
func UnmarshalSecurityGroupCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupCollectionNext : A reference to the next page of resources; this reference is included for all pages except the last page.
type SecurityGroupCollectionNext struct {
	// The URL for the next page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalSecurityGroupCollectionNext unmarshals an instance of SecurityGroupCollectionNext from the specified map of raw messages.
func UnmarshalSecurityGroupCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupIdentity : Identifies a security group by a unique property.
// Models which "extend" this model:
// - SecurityGroupIdentityByID
// - SecurityGroupIdentityByCRN
// - SecurityGroupIdentityByHref
type SecurityGroupIdentity struct {
	// The unique identifier for this security group.
	ID *string `json:"id,omitempty"`

	// The security group's CRN.
	CRN *string `json:"crn,omitempty"`

	// The security group's canonical URL.
	Href *string `json:"href,omitempty"`
}

func (*SecurityGroupIdentity) isaSecurityGroupIdentity() bool {
	return true
}

type SecurityGroupIdentityIntf interface {
	isaSecurityGroupIdentity() bool
}

// UnmarshalSecurityGroupIdentity unmarshals an instance of SecurityGroupIdentity from the specified map of raw messages.
func UnmarshalSecurityGroupIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupReference : SecurityGroupReference struct
type SecurityGroupReference struct {
	// The security group's CRN.
	CRN *string `json:"crn" validate:"required"`

	// The security group's canonical URL.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this security group.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this security group. Names must be unique within the VPC the security group resides in.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalSecurityGroupReference unmarshals an instance of SecurityGroupReference from the specified map of raw messages.
func UnmarshalSecurityGroupReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupRule : SecurityGroupRule struct
// Models which "extend" this model:
// - SecurityGroupRuleProtocolAll
// - SecurityGroupRuleProtocolIcmp
// - SecurityGroupRuleProtocolTcpudp
type SecurityGroupRule struct {
	// The direction of traffic to enforce, either `inbound` or `outbound`.
	Direction *string `json:"direction" validate:"required"`

	// The URL for this security group rule.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this security group rule.
	ID *string `json:"id" validate:"required"`

	// The IP version to enforce. The format of `remote.address` or `remote.cidr_block` must match this field, if they are
	// used. Alternatively, if `remote` references a security group, then this rule only applies to IP addresses (network
	// interfaces) in that group matching this IP version.
	IPVersion *string `json:"ip_version,omitempty"`

	// The protocol to enforce.
	Protocol *string `json:"protocol,omitempty"`

	// The IP addresses or security groups from which this rule allows traffic (or to which,
	// for outbound rules). Can be specified as an IP address, a CIDR block, or a security
	// group. A CIDR block of `0.0.0.0/0` allows traffic from any source (or to any source,
	// for outbound rules).
	Remote SecurityGroupRuleRemoteIntf `json:"remote" validate:"required"`

	// The ICMP traffic code to allow.
	Code *int64 `json:"code,omitempty"`

	// The ICMP traffic type to allow.
	Type *int64 `json:"type,omitempty"`

	// The inclusive upper bound of TCP/UDP port range.
	PortMax *int64 `json:"port_max,omitempty"`

	// The inclusive lower bound of TCP/UDP port range.
	PortMin *int64 `json:"port_min,omitempty"`
}

// Constants associated with the SecurityGroupRule.Direction property.
// The direction of traffic to enforce, either `inbound` or `outbound`.
const (
	SecurityGroupRuleDirectionInboundConst  = "inbound"
	SecurityGroupRuleDirectionOutboundConst = "outbound"
)

// Constants associated with the SecurityGroupRule.IPVersion property.
// The IP version to enforce. The format of `remote.address` or `remote.cidr_block` must match this field, if they are
// used. Alternatively, if `remote` references a security group, then this rule only applies to IP addresses (network
// interfaces) in that group matching this IP version.
const (
	SecurityGroupRuleIPVersionIpv4Const = "ipv4"
)

// Constants associated with the SecurityGroupRule.Protocol property.
// The protocol to enforce.
const (
	SecurityGroupRuleProtocolAllConst  = "all"
	SecurityGroupRuleProtocolIcmpConst = "icmp"
	SecurityGroupRuleProtocolTCPConst  = "tcp"
	SecurityGroupRuleProtocolUDPConst  = "udp"
)

func (*SecurityGroupRule) isaSecurityGroupRule() bool {
	return true
}

type SecurityGroupRuleIntf interface {
	isaSecurityGroupRule() bool
}

// UnmarshalSecurityGroupRule unmarshals an instance of SecurityGroupRule from the specified map of raw messages.
func UnmarshalSecurityGroupRule(m map[string]json.RawMessage, result interface{}) (err error) {
	// Retrieve discriminator value to determine correct "subclass".
	var discValue string
	err = core.UnmarshalPrimitive(m, "protocol", &discValue)
	if err != nil {
		err = fmt.Errorf("error unmarshalling discriminator property 'protocol': %s", err.Error())
		return
	}
	if discValue == "" {
		err = fmt.Errorf("required discriminator property 'protocol' not found in JSON object")
		return
	}
	if discValue == "all" {
		err = core.UnmarshalModel(m, "", result, UnmarshalSecurityGroupRuleProtocolAll)
	} else if discValue == "icmp" {
		err = core.UnmarshalModel(m, "", result, UnmarshalSecurityGroupRuleProtocolIcmp)
	} else if discValue == "tcp" {
		err = core.UnmarshalModel(m, "", result, UnmarshalSecurityGroupRuleProtocolTcpudp)
	} else if discValue == "udp" {
		err = core.UnmarshalModel(m, "", result, UnmarshalSecurityGroupRuleProtocolTcpudp)
	} else {
		err = fmt.Errorf("unrecognized value for discriminator property 'protocol': %s", discValue)
	}
	return
}

// SecurityGroupRuleCollection : Collection of rules in a security group.
type SecurityGroupRuleCollection struct {
	// Array of rules.
	Rules []SecurityGroupRuleIntf `json:"rules" validate:"required"`
}

// UnmarshalSecurityGroupRuleCollection unmarshals an instance of SecurityGroupRuleCollection from the specified map of raw messages.
func UnmarshalSecurityGroupRuleCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupRuleCollection)
	err = core.UnmarshalModel(m, "rules", &obj.Rules, UnmarshalSecurityGroupRule)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupRulePatchRemote : The IP addresses or security groups from which this rule will allow traffic (or to which, for outbound rules). Can be
// specified as an IP address, a CIDR block, or a security group. A CIDR block of `0.0.0.0/0` will allow traffic from
// any source (or to any source, for outbound rules).
// Models which "extend" this model:
// - SecurityGroupRulePatchRemoteIP
// - SecurityGroupRulePatchRemoteCIDR
// - SecurityGroupRulePatchRemoteSecurityGroupIdentity
type SecurityGroupRulePatchRemote struct {
	// The IP address. This property may add support for IPv6 addresses in the future. When processing a value in this
	// property, verify that the address is in an expected format. If it is not, log an error. Optionally halt processing
	// and surface the error, or bypass the resource on which the unexpected IP address format was encountered.
	Address *string `json:"address,omitempty"`

	// The CIDR block. This property may add support for IPv6 CIDR blocks in the future. When processing a value in this
	// property, verify that the CIDR block is in an expected format. If it is not, log an error. Optionally halt
	// processing and surface the error, or bypass the resource on which the unexpected CIDR block format was encountered.
	CIDRBlock *string `json:"cidr_block,omitempty"`

	// The unique identifier for this security group.
	ID *string `json:"id,omitempty"`

	// The security group's CRN.
	CRN *string `json:"crn,omitempty"`

	// The security group's canonical URL.
	Href *string `json:"href,omitempty"`
}

func (*SecurityGroupRulePatchRemote) isaSecurityGroupRulePatchRemote() bool {
	return true
}

type SecurityGroupRulePatchRemoteIntf interface {
	isaSecurityGroupRulePatchRemote() bool
}

// UnmarshalSecurityGroupRulePatchRemote unmarshals an instance of SecurityGroupRulePatchRemote from the specified map of raw messages.
func UnmarshalSecurityGroupRulePatchRemote(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupRulePatchRemote)
	err = core.UnmarshalPrimitive(m, "address", &obj.Address)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "cidr_block", &obj.CIDRBlock)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupRuleProtocolAllRemote : The IP addresses or security groups from which this rule allows traffic (or to which, for outbound rules). Can be
// specified as an IP address, a CIDR block, or a security group. A CIDR block of `0.0.0.0/0` allows traffic from any
// source (or to any source, for outbound rules).
// Models which "extend" this model:
// - SecurityGroupRuleProtocolAllRemoteIP
// - SecurityGroupRuleProtocolAllRemoteCIDR
// - SecurityGroupRuleProtocolAllRemoteSecurityGroupReference
type SecurityGroupRuleProtocolAllRemote struct {
	// The IP address. This property may add support for IPv6 addresses in the future. When processing a value in this
	// property, verify that the address is in an expected format. If it is not, log an error. Optionally halt processing
	// and surface the error, or bypass the resource on which the unexpected IP address format was encountered.
	Address *string `json:"address,omitempty"`

	// The CIDR block. This property may add support for IPv6 CIDR blocks in the future. When processing a value in this
	// property, verify that the CIDR block is in an expected format. If it is not, log an error. Optionally halt
	// processing and surface the error, or bypass the resource on which the unexpected CIDR block format was encountered.
	CIDRBlock *string `json:"cidr_block,omitempty"`

	// The security group's CRN.
	CRN *string `json:"crn,omitempty"`

	// The security group's canonical URL.
	Href *string `json:"href,omitempty"`

	// The unique identifier for this security group.
	ID *string `json:"id,omitempty"`

	// The user-defined name for this security group. Names must be unique within the VPC the security group resides in.
	Name *string `json:"name,omitempty"`
}

func (*SecurityGroupRuleProtocolAllRemote) isaSecurityGroupRuleProtocolAllRemote() bool {
	return true
}

type SecurityGroupRuleProtocolAllRemoteIntf interface {
	isaSecurityGroupRuleProtocolAllRemote() bool
}

// UnmarshalSecurityGroupRuleProtocolAllRemote unmarshals an instance of SecurityGroupRuleProtocolAllRemote from the specified map of raw messages.
func UnmarshalSecurityGroupRuleProtocolAllRemote(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupRuleProtocolAllRemote)
	err = core.UnmarshalPrimitive(m, "address", &obj.Address)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "cidr_block", &obj.CIDRBlock)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupRuleProtocolIcmpRemote : The IP addresses or security groups from which this rule allows traffic (or to which, for outbound rules). Can be
// specified as an IP address, a CIDR block, or a security group. A CIDR block of `0.0.0.0/0` allows traffic from any
// source (or to any source, for outbound rules).
// Models which "extend" this model:
// - SecurityGroupRuleProtocolIcmpRemoteIP
// - SecurityGroupRuleProtocolIcmpRemoteCIDR
// - SecurityGroupRuleProtocolIcmpRemoteSecurityGroupReference
type SecurityGroupRuleProtocolIcmpRemote struct {
	// The IP address. This property may add support for IPv6 addresses in the future. When processing a value in this
	// property, verify that the address is in an expected format. If it is not, log an error. Optionally halt processing
	// and surface the error, or bypass the resource on which the unexpected IP address format was encountered.
	Address *string `json:"address,omitempty"`

	// The CIDR block. This property may add support for IPv6 CIDR blocks in the future. When processing a value in this
	// property, verify that the CIDR block is in an expected format. If it is not, log an error. Optionally halt
	// processing and surface the error, or bypass the resource on which the unexpected CIDR block format was encountered.
	CIDRBlock *string `json:"cidr_block,omitempty"`

	// The security group's CRN.
	CRN *string `json:"crn,omitempty"`

	// The security group's canonical URL.
	Href *string `json:"href,omitempty"`

	// The unique identifier for this security group.
	ID *string `json:"id,omitempty"`

	// The user-defined name for this security group. Names must be unique within the VPC the security group resides in.
	Name *string `json:"name,omitempty"`
}

func (*SecurityGroupRuleProtocolIcmpRemote) isaSecurityGroupRuleProtocolIcmpRemote() bool {
	return true
}

type SecurityGroupRuleProtocolIcmpRemoteIntf interface {
	isaSecurityGroupRuleProtocolIcmpRemote() bool
}

// UnmarshalSecurityGroupRuleProtocolIcmpRemote unmarshals an instance of SecurityGroupRuleProtocolIcmpRemote from the specified map of raw messages.
func UnmarshalSecurityGroupRuleProtocolIcmpRemote(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupRuleProtocolIcmpRemote)
	err = core.UnmarshalPrimitive(m, "address", &obj.Address)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "cidr_block", &obj.CIDRBlock)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupRulePrototype : SecurityGroupRulePrototype struct
// Models which "extend" this model:
// - SecurityGroupRulePrototypeSecurityGroupRuleProtocolAll
// - SecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmp
// - SecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudp
type SecurityGroupRulePrototype struct {
	// The direction of traffic to enforce, either `inbound` or `outbound`.
	Direction *string `json:"direction" validate:"required"`

	// The IP version to enforce. The format of `remote.address` or `remote.cidr_block` must match this field, if they are
	// used. Alternatively, if `remote` references a security group, then this rule only applies to IP addresses (network
	// interfaces) in that group matching this IP version.
	IPVersion *string `json:"ip_version,omitempty"`

	// The protocol to enforce.
	Protocol *string `json:"protocol,omitempty"`

	// The IP addresses or security groups from which this rule will allow traffic (or to
	// which, for outbound rules). Can be specified as an IP address, a CIDR block, or a
	// security group. If omitted, a CIDR block of `0.0.0.0/0` will be used to allow traffic
	// from any source (or to any source, for outbound rules).
	Remote SecurityGroupRulePrototypeRemoteIntf `json:"remote,omitempty"`

	// The URL for this security group rule.
	Href *string `json:"href,omitempty"`

	// The unique identifier for this security group rule.
	ID *string `json:"id,omitempty"`

	// The ICMP traffic code to allow.
	Code *int64 `json:"code,omitempty"`

	// The ICMP traffic type to allow.
	Type *int64 `json:"type,omitempty"`

	// The inclusive upper bound of TCP/UDP port range.
	PortMax *int64 `json:"port_max,omitempty"`

	// The inclusive lower bound of TCP/UDP port range.
	PortMin *int64 `json:"port_min,omitempty"`
}

// Constants associated with the SecurityGroupRulePrototype.Direction property.
// The direction of traffic to enforce, either `inbound` or `outbound`.
const (
	SecurityGroupRulePrototypeDirectionInboundConst  = "inbound"
	SecurityGroupRulePrototypeDirectionOutboundConst = "outbound"
)

// Constants associated with the SecurityGroupRulePrototype.IPVersion property.
// The IP version to enforce. The format of `remote.address` or `remote.cidr_block` must match this field, if they are
// used. Alternatively, if `remote` references a security group, then this rule only applies to IP addresses (network
// interfaces) in that group matching this IP version.
const (
	SecurityGroupRulePrototypeIPVersionIpv4Const = "ipv4"
)

// Constants associated with the SecurityGroupRulePrototype.Protocol property.
// The protocol to enforce.
const (
	SecurityGroupRulePrototypeProtocolAllConst  = "all"
	SecurityGroupRulePrototypeProtocolIcmpConst = "icmp"
	SecurityGroupRulePrototypeProtocolTCPConst  = "tcp"
	SecurityGroupRulePrototypeProtocolUDPConst  = "udp"
)

func (*SecurityGroupRulePrototype) isaSecurityGroupRulePrototype() bool {
	return true
}

type SecurityGroupRulePrototypeIntf interface {
	isaSecurityGroupRulePrototype() bool
}

// UnmarshalSecurityGroupRulePrototype unmarshals an instance of SecurityGroupRulePrototype from the specified map of raw messages.
func UnmarshalSecurityGroupRulePrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	// Retrieve discriminator value to determine correct "subclass".
	var discValue string
	err = core.UnmarshalPrimitive(m, "protocol", &discValue)
	if err != nil {
		err = fmt.Errorf("error unmarshalling discriminator property 'protocol': %s", err.Error())
		return
	}
	if discValue == "" {
		err = fmt.Errorf("required discriminator property 'protocol' not found in JSON object")
		return
	}
	if discValue == "all" {
		err = core.UnmarshalModel(m, "", result, UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAll)
	} else if discValue == "icmp" {
		err = core.UnmarshalModel(m, "", result, UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmp)
	} else if discValue == "tcp" {
		err = core.UnmarshalModel(m, "", result, UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudp)
	} else if discValue == "udp" {
		err = core.UnmarshalModel(m, "", result, UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudp)
	} else {
		err = fmt.Errorf("unrecognized value for discriminator property 'protocol': %s", discValue)
	}
	return
}

// SecurityGroupRulePrototypeRemote : The IP addresses or security groups from which this rule will allow traffic (or to which, for outbound rules). Can be
// specified as an IP address, a CIDR block, or a security group. If omitted, a CIDR block of `0.0.0.0/0` will be used
// to allow traffic from any source (or to any source, for outbound rules).
// Models which "extend" this model:
// - SecurityGroupRulePrototypeRemoteIP
// - SecurityGroupRulePrototypeRemoteCIDR
// - SecurityGroupRulePrototypeRemoteSecurityGroupIdentity
type SecurityGroupRulePrototypeRemote struct {
	// The IP address. This property may add support for IPv6 addresses in the future. When processing a value in this
	// property, verify that the address is in an expected format. If it is not, log an error. Optionally halt processing
	// and surface the error, or bypass the resource on which the unexpected IP address format was encountered.
	Address *string `json:"address,omitempty"`

	// The CIDR block. This property may add support for IPv6 CIDR blocks in the future. When processing a value in this
	// property, verify that the CIDR block is in an expected format. If it is not, log an error. Optionally halt
	// processing and surface the error, or bypass the resource on which the unexpected CIDR block format was encountered.
	CIDRBlock *string `json:"cidr_block,omitempty"`

	// The unique identifier for this security group.
	ID *string `json:"id,omitempty"`

	// The security group's CRN.
	CRN *string `json:"crn,omitempty"`

	// The security group's canonical URL.
	Href *string `json:"href,omitempty"`
}

func (*SecurityGroupRulePrototypeRemote) isaSecurityGroupRulePrototypeRemote() bool {
	return true
}

type SecurityGroupRulePrototypeRemoteIntf interface {
	isaSecurityGroupRulePrototypeRemote() bool
}

// UnmarshalSecurityGroupRulePrototypeRemote unmarshals an instance of SecurityGroupRulePrototypeRemote from the specified map of raw messages.
func UnmarshalSecurityGroupRulePrototypeRemote(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupRulePrototypeRemote)
	err = core.UnmarshalPrimitive(m, "address", &obj.Address)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "cidr_block", &obj.CIDRBlock)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemote : The IP addresses or security groups from which this rule allows traffic (or to which, for outbound rules). Can be
// specified as an IP address, a CIDR block, or a security group. A CIDR block of `0.0.0.0/0` allows traffic from any
// source (or to any source, for outbound rules).
// Models which "extend" this model:
// - SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteIP
// - SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteCIDR
// - SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupReference
type SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemote struct {
	// The IP address. This property may add support for IPv6 addresses in the future. When processing a value in this
	// property, verify that the address is in an expected format. If it is not, log an error. Optionally halt processing
	// and surface the error, or bypass the resource on which the unexpected IP address format was encountered.
	Address *string `json:"address,omitempty"`

	// The CIDR block. This property may add support for IPv6 CIDR blocks in the future. When processing a value in this
	// property, verify that the CIDR block is in an expected format. If it is not, log an error. Optionally halt
	// processing and surface the error, or bypass the resource on which the unexpected CIDR block format was encountered.
	CIDRBlock *string `json:"cidr_block,omitempty"`

	// The security group's CRN.
	CRN *string `json:"crn,omitempty"`

	// The security group's canonical URL.
	Href *string `json:"href,omitempty"`

	// The unique identifier for this security group.
	ID *string `json:"id,omitempty"`

	// The user-defined name for this security group. Names must be unique within the VPC the security group resides in.
	Name *string `json:"name,omitempty"`
}

func (*SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemote) isaSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemote() bool {
	return true
}

type SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteIntf interface {
	isaSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemote() bool
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemote unmarshals an instance of SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemote from the specified map of raw messages.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemote(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemote)
	err = core.UnmarshalPrimitive(m, "address", &obj.Address)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "cidr_block", &obj.CIDRBlock)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmpRemote : The IP addresses or security groups from which this rule allows traffic (or to which, for outbound rules). Can be
// specified as an IP address, a CIDR block, or a security group. A CIDR block of `0.0.0.0/0` allows traffic from any
// source (or to any source, for outbound rules).
// Models which "extend" this model:
// - SecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmpRemoteIP
// - SecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmpRemoteCIDR
// - SecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmpRemoteSecurityGroupReference
type SecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmpRemote struct {
	// The IP address. This property may add support for IPv6 addresses in the future. When processing a value in this
	// property, verify that the address is in an expected format. If it is not, log an error. Optionally halt processing
	// and surface the error, or bypass the resource on which the unexpected IP address format was encountered.
	Address *string `json:"address,omitempty"`

	// The CIDR block. This property may add support for IPv6 CIDR blocks in the future. When processing a value in this
	// property, verify that the CIDR block is in an expected format. If it is not, log an error. Optionally halt
	// processing and surface the error, or bypass the resource on which the unexpected CIDR block format was encountered.
	CIDRBlock *string `json:"cidr_block,omitempty"`

	// The security group's CRN.
	CRN *string `json:"crn,omitempty"`

	// The security group's canonical URL.
	Href *string `json:"href,omitempty"`

	// The unique identifier for this security group.
	ID *string `json:"id,omitempty"`

	// The user-defined name for this security group. Names must be unique within the VPC the security group resides in.
	Name *string `json:"name,omitempty"`
}

func (*SecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmpRemote) isaSecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmpRemote() bool {
	return true
}

type SecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmpRemoteIntf interface {
	isaSecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmpRemote() bool
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmpRemote unmarshals an instance of SecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmpRemote from the specified map of raw messages.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmpRemote(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmpRemote)
	err = core.UnmarshalPrimitive(m, "address", &obj.Address)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "cidr_block", &obj.CIDRBlock)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudpRemote : The IP addresses or security groups from which this rule allows traffic (or to which, for outbound rules). Can be
// specified as an IP address, a CIDR block, or a security group. A CIDR block of `0.0.0.0/0` allows traffic from any
// source (or to any source, for outbound rules).
// Models which "extend" this model:
// - SecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudpRemoteIP
// - SecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudpRemoteCIDR
// - SecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudpRemoteSecurityGroupReference
type SecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudpRemote struct {
	// The IP address. This property may add support for IPv6 addresses in the future. When processing a value in this
	// property, verify that the address is in an expected format. If it is not, log an error. Optionally halt processing
	// and surface the error, or bypass the resource on which the unexpected IP address format was encountered.
	Address *string `json:"address,omitempty"`

	// The CIDR block. This property may add support for IPv6 CIDR blocks in the future. When processing a value in this
	// property, verify that the CIDR block is in an expected format. If it is not, log an error. Optionally halt
	// processing and surface the error, or bypass the resource on which the unexpected CIDR block format was encountered.
	CIDRBlock *string `json:"cidr_block,omitempty"`

	// The security group's CRN.
	CRN *string `json:"crn,omitempty"`

	// The security group's canonical URL.
	Href *string `json:"href,omitempty"`

	// The unique identifier for this security group.
	ID *string `json:"id,omitempty"`

	// The user-defined name for this security group. Names must be unique within the VPC the security group resides in.
	Name *string `json:"name,omitempty"`
}

func (*SecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudpRemote) isaSecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudpRemote() bool {
	return true
}

type SecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudpRemoteIntf interface {
	isaSecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudpRemote() bool
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudpRemote unmarshals an instance of SecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudpRemote from the specified map of raw messages.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudpRemote(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudpRemote)
	err = core.UnmarshalPrimitive(m, "address", &obj.Address)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "cidr_block", &obj.CIDRBlock)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupRuleRemote : The IP addresses or security groups from which this rule allows traffic (or to which, for outbound rules). Can be
// specified as an IP address, a CIDR block, or a security group. A CIDR block of `0.0.0.0/0` allows traffic from any
// source (or to any source, for outbound rules).
// Models which "extend" this model:
// - SecurityGroupRuleRemoteIP
// - SecurityGroupRuleRemoteCIDR
// - SecurityGroupRuleRemoteSecurityGroupReference
type SecurityGroupRuleRemote struct {
	// The IP address. This property may add support for IPv6 addresses in the future. When processing a value in this
	// property, verify that the address is in an expected format. If it is not, log an error. Optionally halt processing
	// and surface the error, or bypass the resource on which the unexpected IP address format was encountered.
	Address *string `json:"address,omitempty"`

	// The CIDR block. This property may add support for IPv6 CIDR blocks in the future. When processing a value in this
	// property, verify that the CIDR block is in an expected format. If it is not, log an error. Optionally halt
	// processing and surface the error, or bypass the resource on which the unexpected CIDR block format was encountered.
	CIDRBlock *string `json:"cidr_block,omitempty"`

	// The security group's CRN.
	CRN *string `json:"crn,omitempty"`

	// The security group's canonical URL.
	Href *string `json:"href,omitempty"`

	// The unique identifier for this security group.
	ID *string `json:"id,omitempty"`

	// The user-defined name for this security group. Names must be unique within the VPC the security group resides in.
	Name *string `json:"name,omitempty"`
}

func (*SecurityGroupRuleRemote) isaSecurityGroupRuleRemote() bool {
	return true
}

type SecurityGroupRuleRemoteIntf interface {
	isaSecurityGroupRuleRemote() bool
}

// UnmarshalSecurityGroupRuleRemote unmarshals an instance of SecurityGroupRuleRemote from the specified map of raw messages.
func UnmarshalSecurityGroupRuleRemote(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupRuleRemote)
	err = core.UnmarshalPrimitive(m, "address", &obj.Address)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "cidr_block", &obj.CIDRBlock)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SetSubnetPublicGatewayOptions : The SetSubnetPublicGateway options.
type SetSubnetPublicGatewayOptions struct {
	// The subnet identifier.
	ID *string `json:"id" validate:"required"`

	// The public gateway identity.
	PublicGatewayIdentity PublicGatewayIdentityIntf `json:"PublicGatewayIdentity" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewSetSubnetPublicGatewayOptions : Instantiate SetSubnetPublicGatewayOptions
func (*VpcV1) NewSetSubnetPublicGatewayOptions(id string, publicGatewayIdentity PublicGatewayIdentityIntf) *SetSubnetPublicGatewayOptions {
	return &SetSubnetPublicGatewayOptions{
		ID:                    core.StringPtr(id),
		PublicGatewayIdentity: publicGatewayIdentity,
	}
}

// SetID : Allow user to set ID
func (options *SetSubnetPublicGatewayOptions) SetID(id string) *SetSubnetPublicGatewayOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetPublicGatewayIdentity : Allow user to set PublicGatewayIdentity
func (options *SetSubnetPublicGatewayOptions) SetPublicGatewayIdentity(publicGatewayIdentity PublicGatewayIdentityIntf) *SetSubnetPublicGatewayOptions {
	options.PublicGatewayIdentity = publicGatewayIdentity
	return options
}

// SetHeaders : Allow user to set Headers
func (options *SetSubnetPublicGatewayOptions) SetHeaders(param map[string]string) *SetSubnetPublicGatewayOptions {
	options.Headers = param
	return options
}

// Subnet : Subnet struct
type Subnet struct {
	// The number of IPv4 addresses in this subnet that are not in-use, and have not been reserved by the user or the
	// provider.
	AvailableIpv4AddressCount *int64 `json:"available_ipv4_address_count" validate:"required"`

	// The date and time that the subnet was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The CRN for this subnet.
	CRN *string `json:"crn" validate:"required"`

	// The URL for this subnet.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this subnet.
	ID *string `json:"id" validate:"required"`

	// The IP version(s) supported by this subnet.
	IPVersion *string `json:"ip_version" validate:"required"`

	// The IPv4 range of the subnet, expressed in CIDR format.
	Ipv4CIDRBlock *string `json:"ipv4_cidr_block,omitempty"`

	// The user-defined name for this subnet.
	Name *string `json:"name" validate:"required"`

	// The network ACL for this subnet.
	NetworkACL *NetworkACLReference `json:"network_acl" validate:"required"`

	// The public gateway to handle internet bound traffic for this subnet.
	PublicGateway *PublicGatewayReference `json:"public_gateway,omitempty"`

	// The resource group for this subnet.
	ResourceGroup *ResourceGroupReference `json:"resource_group" validate:"required"`

	// The type of resource referenced.
	ResourceType *string `json:"resource_type" validate:"required"`

	// The routing table for this subnet.
	RoutingTable *RoutingTableReference `json:"routing_table" validate:"required"`

	// The status of the subnet.
	Status *string `json:"status" validate:"required"`

	// The total number of IPv4 addresses in this subnet.
	//
	// Note: This is calculated as 2<sup>(32  prefix length)</sup>. For example, the prefix length `/24` gives:<br>
	// 2<sup>(32  24)</sup> = 2<sup>8</sup> = 256 addresses.
	TotalIpv4AddressCount *int64 `json:"total_ipv4_address_count" validate:"required"`

	// The VPC this subnet is a part of.
	VPC *VPCReference `json:"vpc" validate:"required"`

	// The zone this subnet resides in.
	Zone *ZoneReference `json:"zone" validate:"required"`
}

// Constants associated with the Subnet.IPVersion property.
// The IP version(s) supported by this subnet.
const (
	SubnetIPVersionBothConst = "both"
	SubnetIPVersionIpv4Const = "ipv4"
	SubnetIPVersionIpv6Const = "ipv6"
)

// Constants associated with the Subnet.ResourceType property.
// The type of resource referenced.
const (
	SubnetResourceTypeSubnetConst = "subnet"
)

// Constants associated with the Subnet.Status property.
// The status of the subnet.
const (
	SubnetStatusAvailableConst = "available"
	SubnetStatusDeletingConst  = "deleting"
	SubnetStatusFailedConst    = "failed"
	SubnetStatusPendingConst   = "pending"
)

// UnmarshalSubnet unmarshals an instance of Subnet from the specified map of raw messages.
func UnmarshalSubnet(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Subnet)
	err = core.UnmarshalPrimitive(m, "available_ipv4_address_count", &obj.AvailableIpv4AddressCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ip_version", &obj.IPVersion)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ipv4_cidr_block", &obj.Ipv4CIDRBlock)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "network_acl", &obj.NetworkACL, UnmarshalNetworkACLReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "public_gateway", &obj.PublicGateway, UnmarshalPublicGatewayReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "routing_table", &obj.RoutingTable, UnmarshalRoutingTableReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_ipv4_address_count", &obj.TotalIpv4AddressCount)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vpc", &obj.VPC, UnmarshalVPCReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubnetCollection : SubnetCollection struct
type SubnetCollection struct {
	// A reference to the first page of resources.
	First *SubnetCollectionFirst `json:"first" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A reference to the next page of resources; this reference is included for all pages
	// except the last page.
	Next *SubnetCollectionNext `json:"next,omitempty"`

	// Collection of subnets.
	Subnets []Subnet `json:"subnets" validate:"required"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalSubnetCollection unmarshals an instance of SubnetCollection from the specified map of raw messages.
func UnmarshalSubnetCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubnetCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalSubnetCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalSubnetCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "subnets", &obj.Subnets, UnmarshalSubnet)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubnetCollectionFirst : A reference to the first page of resources.
type SubnetCollectionFirst struct {
	// The URL for the first page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalSubnetCollectionFirst unmarshals an instance of SubnetCollectionFirst from the specified map of raw messages.
func UnmarshalSubnetCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubnetCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubnetCollectionNext : A reference to the next page of resources; this reference is included for all pages except the last page.
type SubnetCollectionNext struct {
	// The URL for the next page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalSubnetCollectionNext unmarshals an instance of SubnetCollectionNext from the specified map of raw messages.
func UnmarshalSubnetCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubnetCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubnetIdentity : Identifies a subnet by a unique property.
// Models which "extend" this model:
// - SubnetIdentityByID
// - SubnetIdentityByCRN
// - SubnetIdentityByHref
type SubnetIdentity struct {
	// The unique identifier for this subnet.
	ID *string `json:"id,omitempty"`

	// The CRN for this subnet.
	CRN *string `json:"crn,omitempty"`

	// The URL for this subnet.
	Href *string `json:"href,omitempty"`
}

func (*SubnetIdentity) isaSubnetIdentity() bool {
	return true
}

type SubnetIdentityIntf interface {
	isaSubnetIdentity() bool
}

// UnmarshalSubnetIdentity unmarshals an instance of SubnetIdentity from the specified map of raw messages.
func UnmarshalSubnetIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubnetIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubnetPrototype : SubnetPrototype struct
// Models which "extend" this model:
// - SubnetPrototypeSubnetByTotalCount
// - SubnetPrototypeSubnetByCIDR
type SubnetPrototype struct {
	// The IP version(s) supported by this subnet; if unspecified, `ipv4` is used.
	IPVersion *string `json:"ip_version,omitempty"`

	// The user-defined name for this subnet. Names must be unique within the VPC the subnet resides in. If unspecified,
	// the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The network ACL to use for this subnet.
	NetworkACL NetworkACLIdentityIntf `json:"network_acl,omitempty"`

	// The public gateway to handle internet bound traffic for this subnet.
	PublicGateway PublicGatewayIdentityIntf `json:"public_gateway,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// The routing table to use for this subnet; if unspecified, the default routing table
	// for the VPC is used.
	RoutingTable RoutingTableIdentityIntf `json:"routing_table,omitempty"`

	// The VPC the subnet is to be a part of.
	VPC VPCIdentityIntf `json:"vpc" validate:"required"`

	// The total number of IPv4 addresses required. Must be a power of 2. The VPC must have a default address prefix in the
	// specified zone, and that prefix must have a free CIDR range with at least this number of addresses.
	TotalIpv4AddressCount *int64 `json:"total_ipv4_address_count,omitempty"`

	// The zone the subnet is to reside in.
	Zone ZoneIdentityIntf `json:"zone,omitempty"`

	// The IPv4 range of the subnet, expressed in CIDR format. The prefix length of the subnet's CIDR must be between `/8`
	// (16,777,216 addresses) and `/29` (8 addresses). The IPv4 range of the subnet's CIDR must fall within an existing
	// address prefix in the VPC. The subnet will be created in the zone of the address prefix that contains the IPv4 CIDR.
	// If zone is specified, it must match the zone of the address prefix that contains the subnet's IPv4 CIDR.
	Ipv4CIDRBlock *string `json:"ipv4_cidr_block,omitempty"`
}

// Constants associated with the SubnetPrototype.IPVersion property.
// The IP version(s) supported by this subnet; if unspecified, `ipv4` is used.
const (
	SubnetPrototypeIPVersionBothConst = "both"
	SubnetPrototypeIPVersionIpv4Const = "ipv4"
	SubnetPrototypeIPVersionIpv6Const = "ipv6"
)

func (*SubnetPrototype) isaSubnetPrototype() bool {
	return true
}

type SubnetPrototypeIntf interface {
	isaSubnetPrototype() bool
}

// UnmarshalSubnetPrototype unmarshals an instance of SubnetPrototype from the specified map of raw messages.
func UnmarshalSubnetPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubnetPrototype)
	err = core.UnmarshalPrimitive(m, "ip_version", &obj.IPVersion)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "network_acl", &obj.NetworkACL, UnmarshalNetworkACLIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "public_gateway", &obj.PublicGateway, UnmarshalPublicGatewayIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "routing_table", &obj.RoutingTable, UnmarshalRoutingTableIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vpc", &obj.VPC, UnmarshalVPCIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_ipv4_address_count", &obj.TotalIpv4AddressCount)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ipv4_cidr_block", &obj.Ipv4CIDRBlock)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubnetReference : SubnetReference struct
type SubnetReference struct {
	// The CRN for this subnet.
	CRN *string `json:"crn" validate:"required"`

	// The URL for this subnet.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this subnet.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this subnet.
	Name *string `json:"name" validate:"required"`

	// The type of resource referenced.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the SubnetReference.ResourceType property.
// The type of resource referenced.
const (
	SubnetReferenceResourceTypeSubnetConst = "subnet"
)

// UnmarshalSubnetReference unmarshals an instance of SubnetReference from the specified map of raw messages.
func UnmarshalSubnetReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubnetReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// UnsetSubnetPublicGatewayOptions : The UnsetSubnetPublicGateway options.
type UnsetSubnetPublicGatewayOptions struct {
	// The subnet identifier.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUnsetSubnetPublicGatewayOptions : Instantiate UnsetSubnetPublicGatewayOptions
func (*VpcV1) NewUnsetSubnetPublicGatewayOptions(id string) *UnsetSubnetPublicGatewayOptions {
	return &UnsetSubnetPublicGatewayOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *UnsetSubnetPublicGatewayOptions) SetID(id string) *UnsetSubnetPublicGatewayOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UnsetSubnetPublicGatewayOptions) SetHeaders(param map[string]string) *UnsetSubnetPublicGatewayOptions {
	options.Headers = param
	return options
}

// UpdateDedicatedHostGroupOptions : The UpdateDedicatedHostGroup options.
type UpdateDedicatedHostGroupOptions struct {
	// The dedicated host group identifier.
	ID *string `json:"id" validate:"required"`

	// The unique user-defined name for this dedicated host group. If unspecified, the name will be a hyphenated list of
	// randomly-selected words.
	Name *string `json:"name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateDedicatedHostGroupOptions : Instantiate UpdateDedicatedHostGroupOptions
func (*VpcV1) NewUpdateDedicatedHostGroupOptions(id string) *UpdateDedicatedHostGroupOptions {
	return &UpdateDedicatedHostGroupOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *UpdateDedicatedHostGroupOptions) SetID(id string) *UpdateDedicatedHostGroupOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetName : Allow user to set Name
func (options *UpdateDedicatedHostGroupOptions) SetName(name string) *UpdateDedicatedHostGroupOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateDedicatedHostGroupOptions) SetHeaders(param map[string]string) *UpdateDedicatedHostGroupOptions {
	options.Headers = param
	return options
}

// UpdateDedicatedHostOptions : The UpdateDedicatedHost options.
type UpdateDedicatedHostOptions struct {
	// The dedicated host identifier.
	ID *string `json:"id" validate:"required"`

	// If set to true, instances can be placed on this dedicated host.
	InstancePlacementEnabled *bool `json:"instance_placement_enabled,omitempty"`

	// The unique user-defined name for this dedicated host. If unspecified, the name will be a hyphenated list of
	// randomly-selected words.
	Name *string `json:"name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateDedicatedHostOptions : Instantiate UpdateDedicatedHostOptions
func (*VpcV1) NewUpdateDedicatedHostOptions(id string) *UpdateDedicatedHostOptions {
	return &UpdateDedicatedHostOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *UpdateDedicatedHostOptions) SetID(id string) *UpdateDedicatedHostOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetInstancePlacementEnabled : Allow user to set InstancePlacementEnabled
func (options *UpdateDedicatedHostOptions) SetInstancePlacementEnabled(instancePlacementEnabled bool) *UpdateDedicatedHostOptions {
	options.InstancePlacementEnabled = core.BoolPtr(instancePlacementEnabled)
	return options
}

// SetName : Allow user to set Name
func (options *UpdateDedicatedHostOptions) SetName(name string) *UpdateDedicatedHostOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateDedicatedHostOptions) SetHeaders(param map[string]string) *UpdateDedicatedHostOptions {
	options.Headers = param
	return options
}

// UpdateFloatingIPOptions : The UpdateFloatingIP options.
type UpdateFloatingIPOptions struct {
	// The floating IP identifier.
	ID *string `json:"id" validate:"required"`

	// The unique user-defined name for this floating IP.
	Name *string `json:"name,omitempty"`

	// A new target to bind this floating IP with, replacing any existing binding.
	// For this request to succeed, the existing floating IP must not be required by another
	// resource, such as a public gateway.
	Target NetworkInterfaceIdentityIntf `json:"target,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateFloatingIPOptions : Instantiate UpdateFloatingIPOptions
func (*VpcV1) NewUpdateFloatingIPOptions(id string) *UpdateFloatingIPOptions {
	return &UpdateFloatingIPOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *UpdateFloatingIPOptions) SetID(id string) *UpdateFloatingIPOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetName : Allow user to set Name
func (options *UpdateFloatingIPOptions) SetName(name string) *UpdateFloatingIPOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetTarget : Allow user to set Target
func (options *UpdateFloatingIPOptions) SetTarget(target NetworkInterfaceIdentityIntf) *UpdateFloatingIPOptions {
	options.Target = target
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateFloatingIPOptions) SetHeaders(param map[string]string) *UpdateFloatingIPOptions {
	options.Headers = param
	return options
}

// UpdateFlowLogCollectorOptions : The UpdateFlowLogCollector options.
type UpdateFlowLogCollectorOptions struct {
	// The flow log collector identifier.
	ID *string `json:"id" validate:"required"`

	// Indicates whether this collector is active. Updating to false deactivates the collector and updating to true
	// activates the collector.
	Active *bool `json:"active,omitempty"`

	// The unique user-defined name for this flow log collector.
	Name *string `json:"name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateFlowLogCollectorOptions : Instantiate UpdateFlowLogCollectorOptions
func (*VpcV1) NewUpdateFlowLogCollectorOptions(id string) *UpdateFlowLogCollectorOptions {
	return &UpdateFlowLogCollectorOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *UpdateFlowLogCollectorOptions) SetID(id string) *UpdateFlowLogCollectorOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetActive : Allow user to set Active
func (options *UpdateFlowLogCollectorOptions) SetActive(active bool) *UpdateFlowLogCollectorOptions {
	options.Active = core.BoolPtr(active)
	return options
}

// SetName : Allow user to set Name
func (options *UpdateFlowLogCollectorOptions) SetName(name string) *UpdateFlowLogCollectorOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateFlowLogCollectorOptions) SetHeaders(param map[string]string) *UpdateFlowLogCollectorOptions {
	options.Headers = param
	return options
}

// UpdateIkePolicyOptions : The UpdateIkePolicy options.
type UpdateIkePolicyOptions struct {
	// The IKE policy identifier.
	ID *string `json:"id" validate:"required"`

	// The authentication algorithm.
	AuthenticationAlgorithm *string `json:"authentication_algorithm,omitempty"`

	// The Diffie-Hellman group.
	DhGroup *int64 `json:"dh_group,omitempty"`

	// The encryption algorithm.
	EncryptionAlgorithm *string `json:"encryption_algorithm,omitempty"`

	// The IKE protocol version.
	IkeVersion *int64 `json:"ike_version,omitempty"`

	// The key lifetime in seconds.
	KeyLifetime *int64 `json:"key_lifetime,omitempty"`

	// The user-defined name for this IKE policy.
	Name *string `json:"name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the UpdateIkePolicyOptions.AuthenticationAlgorithm property.
// The authentication algorithm.
const (
	UpdateIkePolicyOptionsAuthenticationAlgorithmMd5Const    = "md5"
	UpdateIkePolicyOptionsAuthenticationAlgorithmSha1Const   = "sha1"
	UpdateIkePolicyOptionsAuthenticationAlgorithmSha256Const = "sha256"
)

// Constants associated with the UpdateIkePolicyOptions.EncryptionAlgorithm property.
// The encryption algorithm.
const (
	UpdateIkePolicyOptionsEncryptionAlgorithmAes128Const    = "aes128"
	UpdateIkePolicyOptionsEncryptionAlgorithmAes256Const    = "aes256"
	UpdateIkePolicyOptionsEncryptionAlgorithmTripleDesConst = "triple_des"
)

// NewUpdateIkePolicyOptions : Instantiate UpdateIkePolicyOptions
func (*VpcV1) NewUpdateIkePolicyOptions(id string) *UpdateIkePolicyOptions {
	return &UpdateIkePolicyOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *UpdateIkePolicyOptions) SetID(id string) *UpdateIkePolicyOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetAuthenticationAlgorithm : Allow user to set AuthenticationAlgorithm
func (options *UpdateIkePolicyOptions) SetAuthenticationAlgorithm(authenticationAlgorithm string) *UpdateIkePolicyOptions {
	options.AuthenticationAlgorithm = core.StringPtr(authenticationAlgorithm)
	return options
}

// SetDhGroup : Allow user to set DhGroup
func (options *UpdateIkePolicyOptions) SetDhGroup(dhGroup int64) *UpdateIkePolicyOptions {
	options.DhGroup = core.Int64Ptr(dhGroup)
	return options
}

// SetEncryptionAlgorithm : Allow user to set EncryptionAlgorithm
func (options *UpdateIkePolicyOptions) SetEncryptionAlgorithm(encryptionAlgorithm string) *UpdateIkePolicyOptions {
	options.EncryptionAlgorithm = core.StringPtr(encryptionAlgorithm)
	return options
}

// SetIkeVersion : Allow user to set IkeVersion
func (options *UpdateIkePolicyOptions) SetIkeVersion(ikeVersion int64) *UpdateIkePolicyOptions {
	options.IkeVersion = core.Int64Ptr(ikeVersion)
	return options
}

// SetKeyLifetime : Allow user to set KeyLifetime
func (options *UpdateIkePolicyOptions) SetKeyLifetime(keyLifetime int64) *UpdateIkePolicyOptions {
	options.KeyLifetime = core.Int64Ptr(keyLifetime)
	return options
}

// SetName : Allow user to set Name
func (options *UpdateIkePolicyOptions) SetName(name string) *UpdateIkePolicyOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateIkePolicyOptions) SetHeaders(param map[string]string) *UpdateIkePolicyOptions {
	options.Headers = param
	return options
}

// UpdateImageOptions : The UpdateImage options.
type UpdateImageOptions struct {
	// The image identifier.
	ID *string `json:"id" validate:"required"`

	// The unique user-defined name for this image. Names starting with "ibm-" are not allowed.
	Name *string `json:"name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateImageOptions : Instantiate UpdateImageOptions
func (*VpcV1) NewUpdateImageOptions(id string) *UpdateImageOptions {
	return &UpdateImageOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *UpdateImageOptions) SetID(id string) *UpdateImageOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetName : Allow user to set Name
func (options *UpdateImageOptions) SetName(name string) *UpdateImageOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateImageOptions) SetHeaders(param map[string]string) *UpdateImageOptions {
	options.Headers = param
	return options
}

// UpdateInstanceGroupManagerOptions : The UpdateInstanceGroupManager options.
type UpdateInstanceGroupManagerOptions struct {
	// The instance group identifier.
	InstanceGroupID *string `json:"instance_group_id" validate:"required"`

	// The instance group manager identifier.
	ID *string `json:"id" validate:"required"`

	// The time window in seconds to aggregate metrics prior to evaluation.
	AggregationWindow *int64 `json:"aggregation_window,omitempty"`

	// The duration of time in seconds to pause further scale actions after scaling has taken place.
	Cooldown *int64 `json:"cooldown,omitempty"`

	// If set to `true`, this manager will control the instance group.
	ManagementEnabled *bool `json:"management_enabled,omitempty"`

	// The maximum number of members in a managed instance group.
	MaxMembershipCount *int64 `json:"max_membership_count,omitempty"`

	// The minimum number of members in a managed instance group.
	MinMembershipCount *int64 `json:"min_membership_count,omitempty"`

	// The user-defined name for this instance group manager. Names must be unique within the instance group.
	Name *string `json:"name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateInstanceGroupManagerOptions : Instantiate UpdateInstanceGroupManagerOptions
func (*VpcV1) NewUpdateInstanceGroupManagerOptions(instanceGroupID string, id string) *UpdateInstanceGroupManagerOptions {
	return &UpdateInstanceGroupManagerOptions{
		InstanceGroupID: core.StringPtr(instanceGroupID),
		ID:              core.StringPtr(id),
	}
}

// SetInstanceGroupID : Allow user to set InstanceGroupID
func (options *UpdateInstanceGroupManagerOptions) SetInstanceGroupID(instanceGroupID string) *UpdateInstanceGroupManagerOptions {
	options.InstanceGroupID = core.StringPtr(instanceGroupID)
	return options
}

// SetID : Allow user to set ID
func (options *UpdateInstanceGroupManagerOptions) SetID(id string) *UpdateInstanceGroupManagerOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetAggregationWindow : Allow user to set AggregationWindow
func (options *UpdateInstanceGroupManagerOptions) SetAggregationWindow(aggregationWindow int64) *UpdateInstanceGroupManagerOptions {
	options.AggregationWindow = core.Int64Ptr(aggregationWindow)
	return options
}

// SetCooldown : Allow user to set Cooldown
func (options *UpdateInstanceGroupManagerOptions) SetCooldown(cooldown int64) *UpdateInstanceGroupManagerOptions {
	options.Cooldown = core.Int64Ptr(cooldown)
	return options
}

// SetManagementEnabled : Allow user to set ManagementEnabled
func (options *UpdateInstanceGroupManagerOptions) SetManagementEnabled(managementEnabled bool) *UpdateInstanceGroupManagerOptions {
	options.ManagementEnabled = core.BoolPtr(managementEnabled)
	return options
}

// SetMaxMembershipCount : Allow user to set MaxMembershipCount
func (options *UpdateInstanceGroupManagerOptions) SetMaxMembershipCount(maxMembershipCount int64) *UpdateInstanceGroupManagerOptions {
	options.MaxMembershipCount = core.Int64Ptr(maxMembershipCount)
	return options
}

// SetMinMembershipCount : Allow user to set MinMembershipCount
func (options *UpdateInstanceGroupManagerOptions) SetMinMembershipCount(minMembershipCount int64) *UpdateInstanceGroupManagerOptions {
	options.MinMembershipCount = core.Int64Ptr(minMembershipCount)
	return options
}

// SetName : Allow user to set Name
func (options *UpdateInstanceGroupManagerOptions) SetName(name string) *UpdateInstanceGroupManagerOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateInstanceGroupManagerOptions) SetHeaders(param map[string]string) *UpdateInstanceGroupManagerOptions {
	options.Headers = param
	return options
}

// UpdateInstanceGroupManagerPolicyOptions : The UpdateInstanceGroupManagerPolicy options.
type UpdateInstanceGroupManagerPolicyOptions struct {
	// The instance group identifier.
	InstanceGroupID *string `json:"instance_group_id" validate:"required"`

	// The instance group manager identifier.
	InstanceGroupManagerID *string `json:"instance_group_manager_id" validate:"required"`

	// The instance group manager policy identifier.
	ID *string `json:"id" validate:"required"`

	// The type of metric to be evaluated.
	MetricType *string `json:"metric_type,omitempty"`

	// The metric value to be evaluated.
	MetricValue *int64 `json:"metric_value,omitempty"`

	// The user-defined name for this instance group manager policy. Names must be unique within the instance group
	// manager.
	Name *string `json:"name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the UpdateInstanceGroupManagerPolicyOptions.MetricType property.
// The type of metric to be evaluated.
const (
	UpdateInstanceGroupManagerPolicyOptionsMetricTypeCpuConst        = "cpu"
	UpdateInstanceGroupManagerPolicyOptionsMetricTypeMemoryConst     = "memory"
	UpdateInstanceGroupManagerPolicyOptionsMetricTypeNetworkInConst  = "network_in"
	UpdateInstanceGroupManagerPolicyOptionsMetricTypeNetworkOutConst = "network_out"
)

// NewUpdateInstanceGroupManagerPolicyOptions : Instantiate UpdateInstanceGroupManagerPolicyOptions
func (*VpcV1) NewUpdateInstanceGroupManagerPolicyOptions(instanceGroupID string, instanceGroupManagerID string, id string) *UpdateInstanceGroupManagerPolicyOptions {
	return &UpdateInstanceGroupManagerPolicyOptions{
		InstanceGroupID:        core.StringPtr(instanceGroupID),
		InstanceGroupManagerID: core.StringPtr(instanceGroupManagerID),
		ID:                     core.StringPtr(id),
	}
}

// SetInstanceGroupID : Allow user to set InstanceGroupID
func (options *UpdateInstanceGroupManagerPolicyOptions) SetInstanceGroupID(instanceGroupID string) *UpdateInstanceGroupManagerPolicyOptions {
	options.InstanceGroupID = core.StringPtr(instanceGroupID)
	return options
}

// SetInstanceGroupManagerID : Allow user to set InstanceGroupManagerID
func (options *UpdateInstanceGroupManagerPolicyOptions) SetInstanceGroupManagerID(instanceGroupManagerID string) *UpdateInstanceGroupManagerPolicyOptions {
	options.InstanceGroupManagerID = core.StringPtr(instanceGroupManagerID)
	return options
}

// SetID : Allow user to set ID
func (options *UpdateInstanceGroupManagerPolicyOptions) SetID(id string) *UpdateInstanceGroupManagerPolicyOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetMetricType : Allow user to set MetricType
func (options *UpdateInstanceGroupManagerPolicyOptions) SetMetricType(metricType string) *UpdateInstanceGroupManagerPolicyOptions {
	options.MetricType = core.StringPtr(metricType)
	return options
}

// SetMetricValue : Allow user to set MetricValue
func (options *UpdateInstanceGroupManagerPolicyOptions) SetMetricValue(metricValue int64) *UpdateInstanceGroupManagerPolicyOptions {
	options.MetricValue = core.Int64Ptr(metricValue)
	return options
}

// SetName : Allow user to set Name
func (options *UpdateInstanceGroupManagerPolicyOptions) SetName(name string) *UpdateInstanceGroupManagerPolicyOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateInstanceGroupManagerPolicyOptions) SetHeaders(param map[string]string) *UpdateInstanceGroupManagerPolicyOptions {
	options.Headers = param
	return options
}

// UpdateInstanceGroupMembershipOptions : The UpdateInstanceGroupMembership options.
type UpdateInstanceGroupMembershipOptions struct {
	// The instance group identifier.
	InstanceGroupID *string `json:"instance_group_id" validate:"required"`

	// The instance group membership identifier.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this instance group membership. Names must be unique within the instance group.
	Name *string `json:"name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateInstanceGroupMembershipOptions : Instantiate UpdateInstanceGroupMembershipOptions
func (*VpcV1) NewUpdateInstanceGroupMembershipOptions(instanceGroupID string, id string) *UpdateInstanceGroupMembershipOptions {
	return &UpdateInstanceGroupMembershipOptions{
		InstanceGroupID: core.StringPtr(instanceGroupID),
		ID:              core.StringPtr(id),
	}
}

// SetInstanceGroupID : Allow user to set InstanceGroupID
func (options *UpdateInstanceGroupMembershipOptions) SetInstanceGroupID(instanceGroupID string) *UpdateInstanceGroupMembershipOptions {
	options.InstanceGroupID = core.StringPtr(instanceGroupID)
	return options
}

// SetID : Allow user to set ID
func (options *UpdateInstanceGroupMembershipOptions) SetID(id string) *UpdateInstanceGroupMembershipOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetName : Allow user to set Name
func (options *UpdateInstanceGroupMembershipOptions) SetName(name string) *UpdateInstanceGroupMembershipOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateInstanceGroupMembershipOptions) SetHeaders(param map[string]string) *UpdateInstanceGroupMembershipOptions {
	options.Headers = param
	return options
}

// UpdateInstanceGroupOptions : The UpdateInstanceGroup options.
type UpdateInstanceGroupOptions struct {
	// The instance group identifier.
	ID *string `json:"id" validate:"required"`

	// Required if specifying a load balancer pool only. Used by the instance group when scaling up instances to supply the
	// port for the load balancer pool member.
	ApplicationPort *int64 `json:"application_port,omitempty"`

	// Instance template to use when creating new instances.
	InstanceTemplate InstanceTemplateIdentityIntf `json:"instance_template,omitempty"`

	// The load balancer that the load balancer pool used by this group
	// is in. Must be supplied when using a load balancer pool.
	LoadBalancer LoadBalancerIdentityIntf `json:"load_balancer,omitempty"`

	// When specified, the load balancer pool will be managed by this
	// group. Instances created by this group will have a new load
	// balancer pool member in that pool created. Must be used with
	// `application_port`.
	LoadBalancerPool LoadBalancerPoolIdentityIntf `json:"load_balancer_pool,omitempty"`

	// The number of instances in the instance group.
	MembershipCount *int64 `json:"membership_count,omitempty"`

	// The user-defined name for this instance group.
	Name *string `json:"name,omitempty"`

	// Array of identities to subnets to use when creating new instances.
	Subnets []SubnetIdentityIntf `json:"subnets,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateInstanceGroupOptions : Instantiate UpdateInstanceGroupOptions
func (*VpcV1) NewUpdateInstanceGroupOptions(id string) *UpdateInstanceGroupOptions {
	return &UpdateInstanceGroupOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *UpdateInstanceGroupOptions) SetID(id string) *UpdateInstanceGroupOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetApplicationPort : Allow user to set ApplicationPort
func (options *UpdateInstanceGroupOptions) SetApplicationPort(applicationPort int64) *UpdateInstanceGroupOptions {
	options.ApplicationPort = core.Int64Ptr(applicationPort)
	return options
}

// SetInstanceTemplate : Allow user to set InstanceTemplate
func (options *UpdateInstanceGroupOptions) SetInstanceTemplate(instanceTemplate InstanceTemplateIdentityIntf) *UpdateInstanceGroupOptions {
	options.InstanceTemplate = instanceTemplate
	return options
}

// SetLoadBalancer : Allow user to set LoadBalancer
func (options *UpdateInstanceGroupOptions) SetLoadBalancer(loadBalancer LoadBalancerIdentityIntf) *UpdateInstanceGroupOptions {
	options.LoadBalancer = loadBalancer
	return options
}

// SetLoadBalancerPool : Allow user to set LoadBalancerPool
func (options *UpdateInstanceGroupOptions) SetLoadBalancerPool(loadBalancerPool LoadBalancerPoolIdentityIntf) *UpdateInstanceGroupOptions {
	options.LoadBalancerPool = loadBalancerPool
	return options
}

// SetMembershipCount : Allow user to set MembershipCount
func (options *UpdateInstanceGroupOptions) SetMembershipCount(membershipCount int64) *UpdateInstanceGroupOptions {
	options.MembershipCount = core.Int64Ptr(membershipCount)
	return options
}

// SetName : Allow user to set Name
func (options *UpdateInstanceGroupOptions) SetName(name string) *UpdateInstanceGroupOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetSubnets : Allow user to set Subnets
func (options *UpdateInstanceGroupOptions) SetSubnets(subnets []SubnetIdentityIntf) *UpdateInstanceGroupOptions {
	options.Subnets = subnets
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateInstanceGroupOptions) SetHeaders(param map[string]string) *UpdateInstanceGroupOptions {
	options.Headers = param
	return options
}

// UpdateInstanceNetworkInterfaceOptions : The UpdateInstanceNetworkInterface options.
type UpdateInstanceNetworkInterfaceOptions struct {
	// The instance identifier.
	InstanceID *string `json:"instance_id" validate:"required"`

	// The network interface identifier.
	ID *string `json:"id" validate:"required"`

	// Indicates whether source IP spoofing is allowed on this interface. Updating to true allows source IP spoofing on
	// this interface. Updating to false prevents source IP spoofing on this interface.
	AllowIPSpoofing *bool `json:"allow_ip_spoofing,omitempty"`

	// The user-defined name for this network interface.
	Name *string `json:"name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateInstanceNetworkInterfaceOptions : Instantiate UpdateInstanceNetworkInterfaceOptions
func (*VpcV1) NewUpdateInstanceNetworkInterfaceOptions(instanceID string, id string) *UpdateInstanceNetworkInterfaceOptions {
	return &UpdateInstanceNetworkInterfaceOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (options *UpdateInstanceNetworkInterfaceOptions) SetInstanceID(instanceID string) *UpdateInstanceNetworkInterfaceOptions {
	options.InstanceID = core.StringPtr(instanceID)
	return options
}

// SetID : Allow user to set ID
func (options *UpdateInstanceNetworkInterfaceOptions) SetID(id string) *UpdateInstanceNetworkInterfaceOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetAllowIPSpoofing : Allow user to set AllowIPSpoofing
func (options *UpdateInstanceNetworkInterfaceOptions) SetAllowIPSpoofing(allowIPSpoofing bool) *UpdateInstanceNetworkInterfaceOptions {
	options.AllowIPSpoofing = core.BoolPtr(allowIPSpoofing)
	return options
}

// SetName : Allow user to set Name
func (options *UpdateInstanceNetworkInterfaceOptions) SetName(name string) *UpdateInstanceNetworkInterfaceOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateInstanceNetworkInterfaceOptions) SetHeaders(param map[string]string) *UpdateInstanceNetworkInterfaceOptions {
	options.Headers = param
	return options
}

// UpdateInstanceOptions : The UpdateInstance options.
type UpdateInstanceOptions struct {
	// The instance identifier.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this virtual server instance (and default system hostname).
	Name *string `json:"name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateInstanceOptions : Instantiate UpdateInstanceOptions
func (*VpcV1) NewUpdateInstanceOptions(id string) *UpdateInstanceOptions {
	return &UpdateInstanceOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *UpdateInstanceOptions) SetID(id string) *UpdateInstanceOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetName : Allow user to set Name
func (options *UpdateInstanceOptions) SetName(name string) *UpdateInstanceOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateInstanceOptions) SetHeaders(param map[string]string) *UpdateInstanceOptions {
	options.Headers = param
	return options
}

// UpdateInstanceTemplateOptions : The UpdateInstanceTemplate options.
type UpdateInstanceTemplateOptions struct {
	// The instance template identifier.
	ID *string `json:"id" validate:"required"`

	// The unique user-defined name for this instance template.
	Name *string `json:"name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateInstanceTemplateOptions : Instantiate UpdateInstanceTemplateOptions
func (*VpcV1) NewUpdateInstanceTemplateOptions(id string) *UpdateInstanceTemplateOptions {
	return &UpdateInstanceTemplateOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *UpdateInstanceTemplateOptions) SetID(id string) *UpdateInstanceTemplateOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetName : Allow user to set Name
func (options *UpdateInstanceTemplateOptions) SetName(name string) *UpdateInstanceTemplateOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateInstanceTemplateOptions) SetHeaders(param map[string]string) *UpdateInstanceTemplateOptions {
	options.Headers = param
	return options
}

// UpdateInstanceVolumeAttachmentOptions : The UpdateInstanceVolumeAttachment options.
type UpdateInstanceVolumeAttachmentOptions struct {
	// The instance identifier.
	InstanceID *string `json:"instance_id" validate:"required"`

	// The volume attachment identifier.
	ID *string `json:"id" validate:"required"`

	// If set to true, when deleting the instance the volume will also be deleted.
	DeleteVolumeOnInstanceDelete *bool `json:"delete_volume_on_instance_delete,omitempty"`

	// The user-defined name for this volume attachment.
	Name *string `json:"name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateInstanceVolumeAttachmentOptions : Instantiate UpdateInstanceVolumeAttachmentOptions
func (*VpcV1) NewUpdateInstanceVolumeAttachmentOptions(instanceID string, id string) *UpdateInstanceVolumeAttachmentOptions {
	return &UpdateInstanceVolumeAttachmentOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (options *UpdateInstanceVolumeAttachmentOptions) SetInstanceID(instanceID string) *UpdateInstanceVolumeAttachmentOptions {
	options.InstanceID = core.StringPtr(instanceID)
	return options
}

// SetID : Allow user to set ID
func (options *UpdateInstanceVolumeAttachmentOptions) SetID(id string) *UpdateInstanceVolumeAttachmentOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetDeleteVolumeOnInstanceDelete : Allow user to set DeleteVolumeOnInstanceDelete
func (options *UpdateInstanceVolumeAttachmentOptions) SetDeleteVolumeOnInstanceDelete(deleteVolumeOnInstanceDelete bool) *UpdateInstanceVolumeAttachmentOptions {
	options.DeleteVolumeOnInstanceDelete = core.BoolPtr(deleteVolumeOnInstanceDelete)
	return options
}

// SetName : Allow user to set Name
func (options *UpdateInstanceVolumeAttachmentOptions) SetName(name string) *UpdateInstanceVolumeAttachmentOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateInstanceVolumeAttachmentOptions) SetHeaders(param map[string]string) *UpdateInstanceVolumeAttachmentOptions {
	options.Headers = param
	return options
}

// UpdateIpsecPolicyOptions : The UpdateIpsecPolicy options.
type UpdateIpsecPolicyOptions struct {
	// The IPsec policy identifier.
	ID *string `json:"id" validate:"required"`

	// The authentication algorithm.
	AuthenticationAlgorithm *string `json:"authentication_algorithm,omitempty"`

	// The encryption algorithm.
	EncryptionAlgorithm *string `json:"encryption_algorithm,omitempty"`

	// The key lifetime in seconds.
	KeyLifetime *int64 `json:"key_lifetime,omitempty"`

	// The user-defined name for this IPsec policy.
	Name *string `json:"name,omitempty"`

	// Perfect Forward Secrecy.
	Pfs *string `json:"pfs,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the UpdateIpsecPolicyOptions.AuthenticationAlgorithm property.
// The authentication algorithm.
const (
	UpdateIpsecPolicyOptionsAuthenticationAlgorithmMd5Const    = "md5"
	UpdateIpsecPolicyOptionsAuthenticationAlgorithmSha1Const   = "sha1"
	UpdateIpsecPolicyOptionsAuthenticationAlgorithmSha256Const = "sha256"
)

// Constants associated with the UpdateIpsecPolicyOptions.EncryptionAlgorithm property.
// The encryption algorithm.
const (
	UpdateIpsecPolicyOptionsEncryptionAlgorithmAes128Const    = "aes128"
	UpdateIpsecPolicyOptionsEncryptionAlgorithmAes256Const    = "aes256"
	UpdateIpsecPolicyOptionsEncryptionAlgorithmTripleDesConst = "triple_des"
)

// Constants associated with the UpdateIpsecPolicyOptions.Pfs property.
// Perfect Forward Secrecy.
const (
	UpdateIpsecPolicyOptionsPfsDisabledConst = "disabled"
	UpdateIpsecPolicyOptionsPfsGroup14Const  = "group_14"
	UpdateIpsecPolicyOptionsPfsGroup2Const   = "group_2"
	UpdateIpsecPolicyOptionsPfsGroup5Const   = "group_5"
)

// NewUpdateIpsecPolicyOptions : Instantiate UpdateIpsecPolicyOptions
func (*VpcV1) NewUpdateIpsecPolicyOptions(id string) *UpdateIpsecPolicyOptions {
	return &UpdateIpsecPolicyOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *UpdateIpsecPolicyOptions) SetID(id string) *UpdateIpsecPolicyOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetAuthenticationAlgorithm : Allow user to set AuthenticationAlgorithm
func (options *UpdateIpsecPolicyOptions) SetAuthenticationAlgorithm(authenticationAlgorithm string) *UpdateIpsecPolicyOptions {
	options.AuthenticationAlgorithm = core.StringPtr(authenticationAlgorithm)
	return options
}

// SetEncryptionAlgorithm : Allow user to set EncryptionAlgorithm
func (options *UpdateIpsecPolicyOptions) SetEncryptionAlgorithm(encryptionAlgorithm string) *UpdateIpsecPolicyOptions {
	options.EncryptionAlgorithm = core.StringPtr(encryptionAlgorithm)
	return options
}

// SetKeyLifetime : Allow user to set KeyLifetime
func (options *UpdateIpsecPolicyOptions) SetKeyLifetime(keyLifetime int64) *UpdateIpsecPolicyOptions {
	options.KeyLifetime = core.Int64Ptr(keyLifetime)
	return options
}

// SetName : Allow user to set Name
func (options *UpdateIpsecPolicyOptions) SetName(name string) *UpdateIpsecPolicyOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetPfs : Allow user to set Pfs
func (options *UpdateIpsecPolicyOptions) SetPfs(pfs string) *UpdateIpsecPolicyOptions {
	options.Pfs = core.StringPtr(pfs)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateIpsecPolicyOptions) SetHeaders(param map[string]string) *UpdateIpsecPolicyOptions {
	options.Headers = param
	return options
}

// UpdateKeyOptions : The UpdateKey options.
type UpdateKeyOptions struct {
	// The key identifier.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this key.
	Name *string `json:"name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateKeyOptions : Instantiate UpdateKeyOptions
func (*VpcV1) NewUpdateKeyOptions(id string) *UpdateKeyOptions {
	return &UpdateKeyOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *UpdateKeyOptions) SetID(id string) *UpdateKeyOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetName : Allow user to set Name
func (options *UpdateKeyOptions) SetName(name string) *UpdateKeyOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateKeyOptions) SetHeaders(param map[string]string) *UpdateKeyOptions {
	options.Headers = param
	return options
}

// UpdateLoadBalancerListenerOptions : The UpdateLoadBalancerListener options.
type UpdateLoadBalancerListenerOptions struct {
	// The load balancer identifier.
	LoadBalancerID *string `json:"load_balancer_id" validate:"required"`

	// The listener identifier.
	ID *string `json:"id" validate:"required"`

	// The certificate instance used for SSL termination. It is applicable only to `https`
	// protocol.
	CertificateInstance CertificateInstanceIdentityIntf `json:"certificate_instance,omitempty"`

	// The connection limit of the listener.
	ConnectionLimit *int64 `json:"connection_limit,omitempty"`

	// The default pool associated with the listener.
	DefaultPool LoadBalancerPoolIdentityIntf `json:"default_pool,omitempty"`

	// The listener port number.
	Port *int64 `json:"port,omitempty"`

	// The listener protocol. Load balancers in the `network` family support `tcp`. Load balancers in the `application`
	// family support `tcp`, `http`, and `https`.
	Protocol *string `json:"protocol,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the UpdateLoadBalancerListenerOptions.Protocol property.
// The listener protocol. Load balancers in the `network` family support `tcp`. Load balancers in the `application`
// family support `tcp`, `http`, and `https`.
const (
	UpdateLoadBalancerListenerOptionsProtocolHTTPConst  = "http"
	UpdateLoadBalancerListenerOptionsProtocolHTTPSConst = "https"
	UpdateLoadBalancerListenerOptionsProtocolTCPConst   = "tcp"
)

// NewUpdateLoadBalancerListenerOptions : Instantiate UpdateLoadBalancerListenerOptions
func (*VpcV1) NewUpdateLoadBalancerListenerOptions(loadBalancerID string, id string) *UpdateLoadBalancerListenerOptions {
	return &UpdateLoadBalancerListenerOptions{
		LoadBalancerID: core.StringPtr(loadBalancerID),
		ID:             core.StringPtr(id),
	}
}

// SetLoadBalancerID : Allow user to set LoadBalancerID
func (options *UpdateLoadBalancerListenerOptions) SetLoadBalancerID(loadBalancerID string) *UpdateLoadBalancerListenerOptions {
	options.LoadBalancerID = core.StringPtr(loadBalancerID)
	return options
}

// SetID : Allow user to set ID
func (options *UpdateLoadBalancerListenerOptions) SetID(id string) *UpdateLoadBalancerListenerOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetCertificateInstance : Allow user to set CertificateInstance
func (options *UpdateLoadBalancerListenerOptions) SetCertificateInstance(certificateInstance CertificateInstanceIdentityIntf) *UpdateLoadBalancerListenerOptions {
	options.CertificateInstance = certificateInstance
	return options
}

// SetConnectionLimit : Allow user to set ConnectionLimit
func (options *UpdateLoadBalancerListenerOptions) SetConnectionLimit(connectionLimit int64) *UpdateLoadBalancerListenerOptions {
	options.ConnectionLimit = core.Int64Ptr(connectionLimit)
	return options
}

// SetDefaultPool : Allow user to set DefaultPool
func (options *UpdateLoadBalancerListenerOptions) SetDefaultPool(defaultPool LoadBalancerPoolIdentityIntf) *UpdateLoadBalancerListenerOptions {
	options.DefaultPool = defaultPool
	return options
}

// SetPort : Allow user to set Port
func (options *UpdateLoadBalancerListenerOptions) SetPort(port int64) *UpdateLoadBalancerListenerOptions {
	options.Port = core.Int64Ptr(port)
	return options
}

// SetProtocol : Allow user to set Protocol
func (options *UpdateLoadBalancerListenerOptions) SetProtocol(protocol string) *UpdateLoadBalancerListenerOptions {
	options.Protocol = core.StringPtr(protocol)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateLoadBalancerListenerOptions) SetHeaders(param map[string]string) *UpdateLoadBalancerListenerOptions {
	options.Headers = param
	return options
}

// UpdateLoadBalancerListenerPolicyOptions : The UpdateLoadBalancerListenerPolicy options.
type UpdateLoadBalancerListenerPolicyOptions struct {
	// The load balancer identifier.
	LoadBalancerID *string `json:"load_balancer_id" validate:"required"`

	// The listener identifier.
	ListenerID *string `json:"listener_id" validate:"required"`

	// The policy identifier.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this policy. Names must be unique within the load balancer listener the policy resides in.
	Name *string `json:"name,omitempty"`

	// Priority of the policy. Lower value indicates higher priority.
	Priority *int64 `json:"priority,omitempty"`

	// When `action` is `forward`, `LoadBalancerPoolIdentity` specifies which pool the load
	// balancer forwards the traffic to. When `action` is `redirect`,
	// `LoadBalancerListenerPolicyRedirectURLPatch` specifies the url and http
	// status code used in the redirect response.
	Target LoadBalancerListenerPolicyPatchTargetIntf `json:"target,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateLoadBalancerListenerPolicyOptions : Instantiate UpdateLoadBalancerListenerPolicyOptions
func (*VpcV1) NewUpdateLoadBalancerListenerPolicyOptions(loadBalancerID string, listenerID string, id string) *UpdateLoadBalancerListenerPolicyOptions {
	return &UpdateLoadBalancerListenerPolicyOptions{
		LoadBalancerID: core.StringPtr(loadBalancerID),
		ListenerID:     core.StringPtr(listenerID),
		ID:             core.StringPtr(id),
	}
}

// SetLoadBalancerID : Allow user to set LoadBalancerID
func (options *UpdateLoadBalancerListenerPolicyOptions) SetLoadBalancerID(loadBalancerID string) *UpdateLoadBalancerListenerPolicyOptions {
	options.LoadBalancerID = core.StringPtr(loadBalancerID)
	return options
}

// SetListenerID : Allow user to set ListenerID
func (options *UpdateLoadBalancerListenerPolicyOptions) SetListenerID(listenerID string) *UpdateLoadBalancerListenerPolicyOptions {
	options.ListenerID = core.StringPtr(listenerID)
	return options
}

// SetID : Allow user to set ID
func (options *UpdateLoadBalancerListenerPolicyOptions) SetID(id string) *UpdateLoadBalancerListenerPolicyOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetName : Allow user to set Name
func (options *UpdateLoadBalancerListenerPolicyOptions) SetName(name string) *UpdateLoadBalancerListenerPolicyOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetPriority : Allow user to set Priority
func (options *UpdateLoadBalancerListenerPolicyOptions) SetPriority(priority int64) *UpdateLoadBalancerListenerPolicyOptions {
	options.Priority = core.Int64Ptr(priority)
	return options
}

// SetTarget : Allow user to set Target
func (options *UpdateLoadBalancerListenerPolicyOptions) SetTarget(target LoadBalancerListenerPolicyPatchTargetIntf) *UpdateLoadBalancerListenerPolicyOptions {
	options.Target = target
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateLoadBalancerListenerPolicyOptions) SetHeaders(param map[string]string) *UpdateLoadBalancerListenerPolicyOptions {
	options.Headers = param
	return options
}

// UpdateLoadBalancerListenerPolicyRuleOptions : The UpdateLoadBalancerListenerPolicyRule options.
type UpdateLoadBalancerListenerPolicyRuleOptions struct {
	// The load balancer identifier.
	LoadBalancerID *string `json:"load_balancer_id" validate:"required"`

	// The listener identifier.
	ListenerID *string `json:"listener_id" validate:"required"`

	// The policy identifier.
	PolicyID *string `json:"policy_id" validate:"required"`

	// The rule identifier.
	ID *string `json:"id" validate:"required"`

	// The condition of the rule.
	Condition *string `json:"condition,omitempty"`

	// HTTP header field. This is only applicable to "header" rule type.
	Field *string `json:"field,omitempty"`

	// The type of the rule.
	Type *string `json:"type,omitempty"`

	// Value to be matched for rule condition.
	Value *string `json:"value,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the UpdateLoadBalancerListenerPolicyRuleOptions.Condition property.
// The condition of the rule.
const (
	UpdateLoadBalancerListenerPolicyRuleOptionsConditionContainsConst     = "contains"
	UpdateLoadBalancerListenerPolicyRuleOptionsConditionEqualsConst       = "equals"
	UpdateLoadBalancerListenerPolicyRuleOptionsConditionMatchesRegexConst = "matches_regex"
)

// Constants associated with the UpdateLoadBalancerListenerPolicyRuleOptions.Type property.
// The type of the rule.
const (
	UpdateLoadBalancerListenerPolicyRuleOptionsTypeHeaderConst   = "header"
	UpdateLoadBalancerListenerPolicyRuleOptionsTypeHostnameConst = "hostname"
	UpdateLoadBalancerListenerPolicyRuleOptionsTypePathConst     = "path"
)

// NewUpdateLoadBalancerListenerPolicyRuleOptions : Instantiate UpdateLoadBalancerListenerPolicyRuleOptions
func (*VpcV1) NewUpdateLoadBalancerListenerPolicyRuleOptions(loadBalancerID string, listenerID string, policyID string, id string) *UpdateLoadBalancerListenerPolicyRuleOptions {
	return &UpdateLoadBalancerListenerPolicyRuleOptions{
		LoadBalancerID: core.StringPtr(loadBalancerID),
		ListenerID:     core.StringPtr(listenerID),
		PolicyID:       core.StringPtr(policyID),
		ID:             core.StringPtr(id),
	}
}

// SetLoadBalancerID : Allow user to set LoadBalancerID
func (options *UpdateLoadBalancerListenerPolicyRuleOptions) SetLoadBalancerID(loadBalancerID string) *UpdateLoadBalancerListenerPolicyRuleOptions {
	options.LoadBalancerID = core.StringPtr(loadBalancerID)
	return options
}

// SetListenerID : Allow user to set ListenerID
func (options *UpdateLoadBalancerListenerPolicyRuleOptions) SetListenerID(listenerID string) *UpdateLoadBalancerListenerPolicyRuleOptions {
	options.ListenerID = core.StringPtr(listenerID)
	return options
}

// SetPolicyID : Allow user to set PolicyID
func (options *UpdateLoadBalancerListenerPolicyRuleOptions) SetPolicyID(policyID string) *UpdateLoadBalancerListenerPolicyRuleOptions {
	options.PolicyID = core.StringPtr(policyID)
	return options
}

// SetID : Allow user to set ID
func (options *UpdateLoadBalancerListenerPolicyRuleOptions) SetID(id string) *UpdateLoadBalancerListenerPolicyRuleOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetCondition : Allow user to set Condition
func (options *UpdateLoadBalancerListenerPolicyRuleOptions) SetCondition(condition string) *UpdateLoadBalancerListenerPolicyRuleOptions {
	options.Condition = core.StringPtr(condition)
	return options
}

// SetField : Allow user to set Field
func (options *UpdateLoadBalancerListenerPolicyRuleOptions) SetField(field string) *UpdateLoadBalancerListenerPolicyRuleOptions {
	options.Field = core.StringPtr(field)
	return options
}

// SetType : Allow user to set Type
func (options *UpdateLoadBalancerListenerPolicyRuleOptions) SetType(typeVar string) *UpdateLoadBalancerListenerPolicyRuleOptions {
	options.Type = core.StringPtr(typeVar)
	return options
}

// SetValue : Allow user to set Value
func (options *UpdateLoadBalancerListenerPolicyRuleOptions) SetValue(value string) *UpdateLoadBalancerListenerPolicyRuleOptions {
	options.Value = core.StringPtr(value)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateLoadBalancerListenerPolicyRuleOptions) SetHeaders(param map[string]string) *UpdateLoadBalancerListenerPolicyRuleOptions {
	options.Headers = param
	return options
}

// UpdateLoadBalancerOptions : The UpdateLoadBalancer options.
type UpdateLoadBalancerOptions struct {
	// The load balancer identifier.
	ID *string `json:"id" validate:"required"`

	// The unique user-defined name for this load balancer.
	Name *string `json:"name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateLoadBalancerOptions : Instantiate UpdateLoadBalancerOptions
func (*VpcV1) NewUpdateLoadBalancerOptions(id string) *UpdateLoadBalancerOptions {
	return &UpdateLoadBalancerOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *UpdateLoadBalancerOptions) SetID(id string) *UpdateLoadBalancerOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetName : Allow user to set Name
func (options *UpdateLoadBalancerOptions) SetName(name string) *UpdateLoadBalancerOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateLoadBalancerOptions) SetHeaders(param map[string]string) *UpdateLoadBalancerOptions {
	options.Headers = param
	return options
}

// UpdateLoadBalancerPoolMemberOptions : The UpdateLoadBalancerPoolMember options.
type UpdateLoadBalancerPoolMemberOptions struct {
	// The load balancer identifier.
	LoadBalancerID *string `json:"load_balancer_id" validate:"required"`

	// The pool identifier.
	PoolID *string `json:"pool_id" validate:"required"`

	// The member identifier.
	ID *string `json:"id" validate:"required"`

	// The port number of the application running in the server member.
	Port *int64 `json:"port,omitempty"`

	// The pool member target. Load balancers in the `network` family
	// support instances. Load balancers in the `application` family support
	// IP addresses.
	Target LoadBalancerPoolMemberTargetPrototypeIntf `json:"target,omitempty"`

	// Weight of the server member. This takes effect only when the load balancing algorithm of its belonging pool is
	// `weighted_round_robin`.
	Weight *int64 `json:"weight,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateLoadBalancerPoolMemberOptions : Instantiate UpdateLoadBalancerPoolMemberOptions
func (*VpcV1) NewUpdateLoadBalancerPoolMemberOptions(loadBalancerID string, poolID string, id string) *UpdateLoadBalancerPoolMemberOptions {
	return &UpdateLoadBalancerPoolMemberOptions{
		LoadBalancerID: core.StringPtr(loadBalancerID),
		PoolID:         core.StringPtr(poolID),
		ID:             core.StringPtr(id),
	}
}

// SetLoadBalancerID : Allow user to set LoadBalancerID
func (options *UpdateLoadBalancerPoolMemberOptions) SetLoadBalancerID(loadBalancerID string) *UpdateLoadBalancerPoolMemberOptions {
	options.LoadBalancerID = core.StringPtr(loadBalancerID)
	return options
}

// SetPoolID : Allow user to set PoolID
func (options *UpdateLoadBalancerPoolMemberOptions) SetPoolID(poolID string) *UpdateLoadBalancerPoolMemberOptions {
	options.PoolID = core.StringPtr(poolID)
	return options
}

// SetID : Allow user to set ID
func (options *UpdateLoadBalancerPoolMemberOptions) SetID(id string) *UpdateLoadBalancerPoolMemberOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetPort : Allow user to set Port
func (options *UpdateLoadBalancerPoolMemberOptions) SetPort(port int64) *UpdateLoadBalancerPoolMemberOptions {
	options.Port = core.Int64Ptr(port)
	return options
}

// SetTarget : Allow user to set Target
func (options *UpdateLoadBalancerPoolMemberOptions) SetTarget(target LoadBalancerPoolMemberTargetPrototypeIntf) *UpdateLoadBalancerPoolMemberOptions {
	options.Target = target
	return options
}

// SetWeight : Allow user to set Weight
func (options *UpdateLoadBalancerPoolMemberOptions) SetWeight(weight int64) *UpdateLoadBalancerPoolMemberOptions {
	options.Weight = core.Int64Ptr(weight)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateLoadBalancerPoolMemberOptions) SetHeaders(param map[string]string) *UpdateLoadBalancerPoolMemberOptions {
	options.Headers = param
	return options
}

// UpdateLoadBalancerPoolOptions : The UpdateLoadBalancerPool options.
type UpdateLoadBalancerPoolOptions struct {
	// The load balancer identifier.
	LoadBalancerID *string `json:"load_balancer_id" validate:"required"`

	// The pool identifier.
	ID *string `json:"id" validate:"required"`

	// The load balancing algorithm.
	Algorithm *string `json:"algorithm,omitempty"`

	// The health monitor of this pool.
	HealthMonitor *LoadBalancerPoolHealthMonitorPatch `json:"health_monitor,omitempty"`

	// The user-defined name for this load balancer pool.
	Name *string `json:"name,omitempty"`

	// The protocol used for this load balancer pool.
	//
	// The enumerated values for this property are expected to expand in the future. When processing this property, check
	// for and log unknown values. Optionally halt processing and surface the error, or bypass the pool on which the
	// unexpected property value was encountered.
	Protocol *string `json:"protocol,omitempty"`

	// The session persistence of this pool.
	SessionPersistence *LoadBalancerPoolSessionPersistencePatch `json:"session_persistence,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the UpdateLoadBalancerPoolOptions.Algorithm property.
// The load balancing algorithm.
const (
	UpdateLoadBalancerPoolOptionsAlgorithmLeastConnectionsConst   = "least_connections"
	UpdateLoadBalancerPoolOptionsAlgorithmRoundRobinConst         = "round_robin"
	UpdateLoadBalancerPoolOptionsAlgorithmWeightedRoundRobinConst = "weighted_round_robin"
)

// Constants associated with the UpdateLoadBalancerPoolOptions.Protocol property.
// The protocol used for this load balancer pool.
//
// The enumerated values for this property are expected to expand in the future. When processing this property, check
// for and log unknown values. Optionally halt processing and surface the error, or bypass the pool on which the
// unexpected property value was encountered.
const (
	UpdateLoadBalancerPoolOptionsProtocolHTTPConst  = "http"
	UpdateLoadBalancerPoolOptionsProtocolHTTPSConst = "https"
	UpdateLoadBalancerPoolOptionsProtocolTCPConst   = "tcp"
)

// NewUpdateLoadBalancerPoolOptions : Instantiate UpdateLoadBalancerPoolOptions
func (*VpcV1) NewUpdateLoadBalancerPoolOptions(loadBalancerID string, id string) *UpdateLoadBalancerPoolOptions {
	return &UpdateLoadBalancerPoolOptions{
		LoadBalancerID: core.StringPtr(loadBalancerID),
		ID:             core.StringPtr(id),
	}
}

// SetLoadBalancerID : Allow user to set LoadBalancerID
func (options *UpdateLoadBalancerPoolOptions) SetLoadBalancerID(loadBalancerID string) *UpdateLoadBalancerPoolOptions {
	options.LoadBalancerID = core.StringPtr(loadBalancerID)
	return options
}

// SetID : Allow user to set ID
func (options *UpdateLoadBalancerPoolOptions) SetID(id string) *UpdateLoadBalancerPoolOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetAlgorithm : Allow user to set Algorithm
func (options *UpdateLoadBalancerPoolOptions) SetAlgorithm(algorithm string) *UpdateLoadBalancerPoolOptions {
	options.Algorithm = core.StringPtr(algorithm)
	return options
}

// SetHealthMonitor : Allow user to set HealthMonitor
func (options *UpdateLoadBalancerPoolOptions) SetHealthMonitor(healthMonitor *LoadBalancerPoolHealthMonitorPatch) *UpdateLoadBalancerPoolOptions {
	options.HealthMonitor = healthMonitor
	return options
}

// SetName : Allow user to set Name
func (options *UpdateLoadBalancerPoolOptions) SetName(name string) *UpdateLoadBalancerPoolOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetProtocol : Allow user to set Protocol
func (options *UpdateLoadBalancerPoolOptions) SetProtocol(protocol string) *UpdateLoadBalancerPoolOptions {
	options.Protocol = core.StringPtr(protocol)
	return options
}

// SetSessionPersistence : Allow user to set SessionPersistence
func (options *UpdateLoadBalancerPoolOptions) SetSessionPersistence(sessionPersistence *LoadBalancerPoolSessionPersistencePatch) *UpdateLoadBalancerPoolOptions {
	options.SessionPersistence = sessionPersistence
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateLoadBalancerPoolOptions) SetHeaders(param map[string]string) *UpdateLoadBalancerPoolOptions {
	options.Headers = param
	return options
}

// UpdateNetworkACLOptions : The UpdateNetworkACL options.
type UpdateNetworkACLOptions struct {
	// The network ACL identifier.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this network ACL. Names must be unique within the VPC the Network ACL resides in.
	Name *string `json:"name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateNetworkACLOptions : Instantiate UpdateNetworkACLOptions
func (*VpcV1) NewUpdateNetworkACLOptions(id string) *UpdateNetworkACLOptions {
	return &UpdateNetworkACLOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *UpdateNetworkACLOptions) SetID(id string) *UpdateNetworkACLOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetName : Allow user to set Name
func (options *UpdateNetworkACLOptions) SetName(name string) *UpdateNetworkACLOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateNetworkACLOptions) SetHeaders(param map[string]string) *UpdateNetworkACLOptions {
	options.Headers = param
	return options
}

// UpdateNetworkACLRuleOptions : The UpdateNetworkACLRule options.
type UpdateNetworkACLRuleOptions struct {
	// The network ACL identifier.
	NetworkACLID *string `json:"network_acl_id" validate:"required"`

	// The rule identifier.
	ID *string `json:"id" validate:"required"`

	// Whether to allow or deny matching traffic.
	Action *string `json:"action,omitempty"`

	// The rule to move this rule immediately before. Specify `null` to move this rule after
	// all existing rules.
	Before NetworkACLRulePatchBeforeIntf `json:"before,omitempty"`

	// The ICMP traffic code to allow.
	Code *int64 `json:"code,omitempty"`

	// The destination IP address or CIDR block. The CIDR block `0.0.0.0/0` applies to all addresses.
	Destination *string `json:"destination,omitempty"`

	// The inclusive upper bound of TCP/UDP destination port range.
	DestinationPortMax *int64 `json:"destination_port_max,omitempty"`

	// The inclusive lower bound of TCP/UDP destination port range.
	DestinationPortMin *int64 `json:"destination_port_min,omitempty"`

	// Whether the traffic to be matched is `inbound` or `outbound`.
	Direction *string `json:"direction,omitempty"`

	// The user-defined name for this rule. Names must be unique within the network ACL the rule resides in.
	Name *string `json:"name,omitempty"`

	// The source IP address or CIDR block.  The CIDR block `0.0.0.0/0` applies to all addresses.
	Source *string `json:"source,omitempty"`

	// The inclusive upper bound of TCP/UDP source port range.
	SourcePortMax *int64 `json:"source_port_max,omitempty"`

	// The inclusive lower bound of TCP/UDP source port range.
	SourcePortMin *int64 `json:"source_port_min,omitempty"`

	// The ICMP traffic type to allow.
	Type *int64 `json:"type,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the UpdateNetworkACLRuleOptions.Action property.
// Whether to allow or deny matching traffic.
const (
	UpdateNetworkACLRuleOptionsActionAllowConst = "allow"
	UpdateNetworkACLRuleOptionsActionDenyConst  = "deny"
)

// Constants associated with the UpdateNetworkACLRuleOptions.Direction property.
// Whether the traffic to be matched is `inbound` or `outbound`.
const (
	UpdateNetworkACLRuleOptionsDirectionInboundConst  = "inbound"
	UpdateNetworkACLRuleOptionsDirectionOutboundConst = "outbound"
)

// NewUpdateNetworkACLRuleOptions : Instantiate UpdateNetworkACLRuleOptions
func (*VpcV1) NewUpdateNetworkACLRuleOptions(networkACLID string, id string) *UpdateNetworkACLRuleOptions {
	return &UpdateNetworkACLRuleOptions{
		NetworkACLID: core.StringPtr(networkACLID),
		ID:           core.StringPtr(id),
	}
}

// SetNetworkACLID : Allow user to set NetworkACLID
func (options *UpdateNetworkACLRuleOptions) SetNetworkACLID(networkACLID string) *UpdateNetworkACLRuleOptions {
	options.NetworkACLID = core.StringPtr(networkACLID)
	return options
}

// SetID : Allow user to set ID
func (options *UpdateNetworkACLRuleOptions) SetID(id string) *UpdateNetworkACLRuleOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetAction : Allow user to set Action
func (options *UpdateNetworkACLRuleOptions) SetAction(action string) *UpdateNetworkACLRuleOptions {
	options.Action = core.StringPtr(action)
	return options
}

// SetBefore : Allow user to set Before
func (options *UpdateNetworkACLRuleOptions) SetBefore(before NetworkACLRulePatchBeforeIntf) *UpdateNetworkACLRuleOptions {
	options.Before = before
	return options
}

// SetCode : Allow user to set Code
func (options *UpdateNetworkACLRuleOptions) SetCode(code int64) *UpdateNetworkACLRuleOptions {
	options.Code = core.Int64Ptr(code)
	return options
}

// SetDestination : Allow user to set Destination
func (options *UpdateNetworkACLRuleOptions) SetDestination(destination string) *UpdateNetworkACLRuleOptions {
	options.Destination = core.StringPtr(destination)
	return options
}

// SetDestinationPortMax : Allow user to set DestinationPortMax
func (options *UpdateNetworkACLRuleOptions) SetDestinationPortMax(destinationPortMax int64) *UpdateNetworkACLRuleOptions {
	options.DestinationPortMax = core.Int64Ptr(destinationPortMax)
	return options
}

// SetDestinationPortMin : Allow user to set DestinationPortMin
func (options *UpdateNetworkACLRuleOptions) SetDestinationPortMin(destinationPortMin int64) *UpdateNetworkACLRuleOptions {
	options.DestinationPortMin = core.Int64Ptr(destinationPortMin)
	return options
}

// SetDirection : Allow user to set Direction
func (options *UpdateNetworkACLRuleOptions) SetDirection(direction string) *UpdateNetworkACLRuleOptions {
	options.Direction = core.StringPtr(direction)
	return options
}

// SetName : Allow user to set Name
func (options *UpdateNetworkACLRuleOptions) SetName(name string) *UpdateNetworkACLRuleOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetSource : Allow user to set Source
func (options *UpdateNetworkACLRuleOptions) SetSource(source string) *UpdateNetworkACLRuleOptions {
	options.Source = core.StringPtr(source)
	return options
}

// SetSourcePortMax : Allow user to set SourcePortMax
func (options *UpdateNetworkACLRuleOptions) SetSourcePortMax(sourcePortMax int64) *UpdateNetworkACLRuleOptions {
	options.SourcePortMax = core.Int64Ptr(sourcePortMax)
	return options
}

// SetSourcePortMin : Allow user to set SourcePortMin
func (options *UpdateNetworkACLRuleOptions) SetSourcePortMin(sourcePortMin int64) *UpdateNetworkACLRuleOptions {
	options.SourcePortMin = core.Int64Ptr(sourcePortMin)
	return options
}

// SetType : Allow user to set Type
func (options *UpdateNetworkACLRuleOptions) SetType(typeVar int64) *UpdateNetworkACLRuleOptions {
	options.Type = core.Int64Ptr(typeVar)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateNetworkACLRuleOptions) SetHeaders(param map[string]string) *UpdateNetworkACLRuleOptions {
	options.Headers = param
	return options
}

// UpdatePublicGatewayOptions : The UpdatePublicGateway options.
type UpdatePublicGatewayOptions struct {
	// The public gateway identifier.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this public gateway. Names must be unique within the VPC the public gateway resides in.
	Name *string `json:"name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdatePublicGatewayOptions : Instantiate UpdatePublicGatewayOptions
func (*VpcV1) NewUpdatePublicGatewayOptions(id string) *UpdatePublicGatewayOptions {
	return &UpdatePublicGatewayOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *UpdatePublicGatewayOptions) SetID(id string) *UpdatePublicGatewayOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetName : Allow user to set Name
func (options *UpdatePublicGatewayOptions) SetName(name string) *UpdatePublicGatewayOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UpdatePublicGatewayOptions) SetHeaders(param map[string]string) *UpdatePublicGatewayOptions {
	options.Headers = param
	return options
}

// UpdateSecurityGroupOptions : The UpdateSecurityGroup options.
type UpdateSecurityGroupOptions struct {
	// The security group identifier.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this security group. Names must be unique within the VPC the security group resides in.
	Name *string `json:"name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateSecurityGroupOptions : Instantiate UpdateSecurityGroupOptions
func (*VpcV1) NewUpdateSecurityGroupOptions(id string) *UpdateSecurityGroupOptions {
	return &UpdateSecurityGroupOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *UpdateSecurityGroupOptions) SetID(id string) *UpdateSecurityGroupOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetName : Allow user to set Name
func (options *UpdateSecurityGroupOptions) SetName(name string) *UpdateSecurityGroupOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateSecurityGroupOptions) SetHeaders(param map[string]string) *UpdateSecurityGroupOptions {
	options.Headers = param
	return options
}

// UpdateSecurityGroupRuleOptions : The UpdateSecurityGroupRule options.
type UpdateSecurityGroupRuleOptions struct {
	// The security group identifier.
	SecurityGroupID *string `json:"security_group_id" validate:"required"`

	// The rule identifier.
	ID *string `json:"id" validate:"required"`

	// The ICMP traffic code to allow.
	Code *int64 `json:"code,omitempty"`

	// The direction of traffic to enforce, either `inbound` or `outbound`.
	Direction *string `json:"direction,omitempty"`

	// The IP version to enforce. The format of `remote.address` or `remote.cidr_block` must match this field, if they are
	// used. Alternatively, if `remote` references a security group, then this rule only applies to IP addresses (network
	// interfaces) in that group matching this IP version.
	IPVersion *string `json:"ip_version,omitempty"`

	// The inclusive upper bound of TCP/UDP port range.
	PortMax *int64 `json:"port_max,omitempty"`

	// The inclusive lower bound of TCP/UDP port range.
	PortMin *int64 `json:"port_min,omitempty"`

	// The IP addresses or security groups from which this rule will allow traffic (or to
	// which, for outbound rules). Can be specified as an IP address, a CIDR block, or a
	// security group. A CIDR block of `0.0.0.0/0` will allow traffic from any source (or to
	// any source, for outbound rules).
	Remote SecurityGroupRulePatchRemoteIntf `json:"remote,omitempty"`

	// The ICMP traffic type to allow.
	Type *int64 `json:"type,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the UpdateSecurityGroupRuleOptions.Direction property.
// The direction of traffic to enforce, either `inbound` or `outbound`.
const (
	UpdateSecurityGroupRuleOptionsDirectionInboundConst  = "inbound"
	UpdateSecurityGroupRuleOptionsDirectionOutboundConst = "outbound"
)

// Constants associated with the UpdateSecurityGroupRuleOptions.IPVersion property.
// The IP version to enforce. The format of `remote.address` or `remote.cidr_block` must match this field, if they are
// used. Alternatively, if `remote` references a security group, then this rule only applies to IP addresses (network
// interfaces) in that group matching this IP version.
const (
	UpdateSecurityGroupRuleOptionsIPVersionIpv4Const = "ipv4"
)

// NewUpdateSecurityGroupRuleOptions : Instantiate UpdateSecurityGroupRuleOptions
func (*VpcV1) NewUpdateSecurityGroupRuleOptions(securityGroupID string, id string) *UpdateSecurityGroupRuleOptions {
	return &UpdateSecurityGroupRuleOptions{
		SecurityGroupID: core.StringPtr(securityGroupID),
		ID:              core.StringPtr(id),
	}
}

// SetSecurityGroupID : Allow user to set SecurityGroupID
func (options *UpdateSecurityGroupRuleOptions) SetSecurityGroupID(securityGroupID string) *UpdateSecurityGroupRuleOptions {
	options.SecurityGroupID = core.StringPtr(securityGroupID)
	return options
}

// SetID : Allow user to set ID
func (options *UpdateSecurityGroupRuleOptions) SetID(id string) *UpdateSecurityGroupRuleOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetCode : Allow user to set Code
func (options *UpdateSecurityGroupRuleOptions) SetCode(code int64) *UpdateSecurityGroupRuleOptions {
	options.Code = core.Int64Ptr(code)
	return options
}

// SetDirection : Allow user to set Direction
func (options *UpdateSecurityGroupRuleOptions) SetDirection(direction string) *UpdateSecurityGroupRuleOptions {
	options.Direction = core.StringPtr(direction)
	return options
}

// SetIPVersion : Allow user to set IPVersion
func (options *UpdateSecurityGroupRuleOptions) SetIPVersion(ipVersion string) *UpdateSecurityGroupRuleOptions {
	options.IPVersion = core.StringPtr(ipVersion)
	return options
}

// SetPortMax : Allow user to set PortMax
func (options *UpdateSecurityGroupRuleOptions) SetPortMax(portMax int64) *UpdateSecurityGroupRuleOptions {
	options.PortMax = core.Int64Ptr(portMax)
	return options
}

// SetPortMin : Allow user to set PortMin
func (options *UpdateSecurityGroupRuleOptions) SetPortMin(portMin int64) *UpdateSecurityGroupRuleOptions {
	options.PortMin = core.Int64Ptr(portMin)
	return options
}

// SetRemote : Allow user to set Remote
func (options *UpdateSecurityGroupRuleOptions) SetRemote(remote SecurityGroupRulePatchRemoteIntf) *UpdateSecurityGroupRuleOptions {
	options.Remote = remote
	return options
}

// SetType : Allow user to set Type
func (options *UpdateSecurityGroupRuleOptions) SetType(typeVar int64) *UpdateSecurityGroupRuleOptions {
	options.Type = core.Int64Ptr(typeVar)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateSecurityGroupRuleOptions) SetHeaders(param map[string]string) *UpdateSecurityGroupRuleOptions {
	options.Headers = param
	return options
}

// UpdateSubnetOptions : The UpdateSubnet options.
type UpdateSubnetOptions struct {
	// The subnet identifier.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this subnet. Names must be unique within the VPC the subnet resides in.
	Name *string `json:"name,omitempty"`

	// The network ACL to use for this subnet.
	NetworkACL NetworkACLIdentityIntf `json:"network_acl,omitempty"`

	// The public gateway to handle internet bound traffic for this subnet.
	PublicGateway PublicGatewayIdentityIntf `json:"public_gateway,omitempty"`

	// The routing table to use for this subnet.
	RoutingTable RoutingTableIdentityIntf `json:"routing_table,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateSubnetOptions : Instantiate UpdateSubnetOptions
func (*VpcV1) NewUpdateSubnetOptions(id string) *UpdateSubnetOptions {
	return &UpdateSubnetOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *UpdateSubnetOptions) SetID(id string) *UpdateSubnetOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetName : Allow user to set Name
func (options *UpdateSubnetOptions) SetName(name string) *UpdateSubnetOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetNetworkACL : Allow user to set NetworkACL
func (options *UpdateSubnetOptions) SetNetworkACL(networkACL NetworkACLIdentityIntf) *UpdateSubnetOptions {
	options.NetworkACL = networkACL
	return options
}

// SetPublicGateway : Allow user to set PublicGateway
func (options *UpdateSubnetOptions) SetPublicGateway(publicGateway PublicGatewayIdentityIntf) *UpdateSubnetOptions {
	options.PublicGateway = publicGateway
	return options
}

// SetRoutingTable : Allow user to set RoutingTable
func (options *UpdateSubnetOptions) SetRoutingTable(routingTable RoutingTableIdentityIntf) *UpdateSubnetOptions {
	options.RoutingTable = routingTable
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateSubnetOptions) SetHeaders(param map[string]string) *UpdateSubnetOptions {
	options.Headers = param
	return options
}

// UpdateVolumeOptions : The UpdateVolume options.
type UpdateVolumeOptions struct {
	// The volume identifier.
	ID *string `json:"id" validate:"required"`

	// The unique user-defined name for this volume.
	Name *string `json:"name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateVolumeOptions : Instantiate UpdateVolumeOptions
func (*VpcV1) NewUpdateVolumeOptions(id string) *UpdateVolumeOptions {
	return &UpdateVolumeOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *UpdateVolumeOptions) SetID(id string) *UpdateVolumeOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetName : Allow user to set Name
func (options *UpdateVolumeOptions) SetName(name string) *UpdateVolumeOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateVolumeOptions) SetHeaders(param map[string]string) *UpdateVolumeOptions {
	options.Headers = param
	return options
}

// UpdateVPCAddressPrefixOptions : The UpdateVPCAddressPrefix options.
type UpdateVPCAddressPrefixOptions struct {
	// The VPC identifier.
	VPCID *string `json:"vpc_id" validate:"required"`

	// The prefix identifier.
	ID *string `json:"id" validate:"required"`

	// Indicates whether this is the default prefix for this zone in this VPC. Updating to true makes this prefix the
	// default prefix for this zone in this VPC, provided the VPC currently has no default address prefix for this zone.
	// Updating to false removes the default prefix for this zone in this VPC.
	IsDefault *bool `json:"is_default,omitempty"`

	// The user-defined name for this address prefix. Names must be unique within the VPC the address prefix resides in.
	Name *string `json:"name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateVPCAddressPrefixOptions : Instantiate UpdateVPCAddressPrefixOptions
func (*VpcV1) NewUpdateVPCAddressPrefixOptions(vpcID string, id string) *UpdateVPCAddressPrefixOptions {
	return &UpdateVPCAddressPrefixOptions{
		VPCID: core.StringPtr(vpcID),
		ID:    core.StringPtr(id),
	}
}

// SetVPCID : Allow user to set VPCID
func (options *UpdateVPCAddressPrefixOptions) SetVPCID(vpcID string) *UpdateVPCAddressPrefixOptions {
	options.VPCID = core.StringPtr(vpcID)
	return options
}

// SetID : Allow user to set ID
func (options *UpdateVPCAddressPrefixOptions) SetID(id string) *UpdateVPCAddressPrefixOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetIsDefault : Allow user to set IsDefault
func (options *UpdateVPCAddressPrefixOptions) SetIsDefault(isDefault bool) *UpdateVPCAddressPrefixOptions {
	options.IsDefault = core.BoolPtr(isDefault)
	return options
}

// SetName : Allow user to set Name
func (options *UpdateVPCAddressPrefixOptions) SetName(name string) *UpdateVPCAddressPrefixOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateVPCAddressPrefixOptions) SetHeaders(param map[string]string) *UpdateVPCAddressPrefixOptions {
	options.Headers = param
	return options
}

// UpdateVPCOptions : The UpdateVPC options.
type UpdateVPCOptions struct {
	// The VPC identifier.
	ID *string `json:"id" validate:"required"`

	// The unique user-defined name for this VPC.
	Name *string `json:"name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateVPCOptions : Instantiate UpdateVPCOptions
func (*VpcV1) NewUpdateVPCOptions(id string) *UpdateVPCOptions {
	return &UpdateVPCOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *UpdateVPCOptions) SetID(id string) *UpdateVPCOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetName : Allow user to set Name
func (options *UpdateVPCOptions) SetName(name string) *UpdateVPCOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateVPCOptions) SetHeaders(param map[string]string) *UpdateVPCOptions {
	options.Headers = param
	return options
}

// UpdateVPCRouteOptions : The UpdateVPCRoute options.
type UpdateVPCRouteOptions struct {
	// The VPC identifier.
	VPCID *string `json:"vpc_id" validate:"required"`

	// The route identifier.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this route. Names must be unique within the VPC routing table the route resides in.
	Name *string `json:"name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateVPCRouteOptions : Instantiate UpdateVPCRouteOptions
func (*VpcV1) NewUpdateVPCRouteOptions(vpcID string, id string) *UpdateVPCRouteOptions {
	return &UpdateVPCRouteOptions{
		VPCID: core.StringPtr(vpcID),
		ID:    core.StringPtr(id),
	}
}

// SetVPCID : Allow user to set VPCID
func (options *UpdateVPCRouteOptions) SetVPCID(vpcID string) *UpdateVPCRouteOptions {
	options.VPCID = core.StringPtr(vpcID)
	return options
}

// SetID : Allow user to set ID
func (options *UpdateVPCRouteOptions) SetID(id string) *UpdateVPCRouteOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetName : Allow user to set Name
func (options *UpdateVPCRouteOptions) SetName(name string) *UpdateVPCRouteOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateVPCRouteOptions) SetHeaders(param map[string]string) *UpdateVPCRouteOptions {
	options.Headers = param
	return options
}

// UpdateVPCRoutingTableOptions : The UpdateVPCRoutingTable options.
type UpdateVPCRoutingTableOptions struct {
	// The VPC identifier.
	VPCID *string `json:"vpc_id" validate:"required"`

	// The routing table identifier.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this routing table. Names must be unique within the VPC the routing table resides in.
	Name *string `json:"name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateVPCRoutingTableOptions : Instantiate UpdateVPCRoutingTableOptions
func (*VpcV1) NewUpdateVPCRoutingTableOptions(vpcID string, id string) *UpdateVPCRoutingTableOptions {
	return &UpdateVPCRoutingTableOptions{
		VPCID: core.StringPtr(vpcID),
		ID:    core.StringPtr(id),
	}
}

// SetVPCID : Allow user to set VPCID
func (options *UpdateVPCRoutingTableOptions) SetVPCID(vpcID string) *UpdateVPCRoutingTableOptions {
	options.VPCID = core.StringPtr(vpcID)
	return options
}

// SetID : Allow user to set ID
func (options *UpdateVPCRoutingTableOptions) SetID(id string) *UpdateVPCRoutingTableOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetName : Allow user to set Name
func (options *UpdateVPCRoutingTableOptions) SetName(name string) *UpdateVPCRoutingTableOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateVPCRoutingTableOptions) SetHeaders(param map[string]string) *UpdateVPCRoutingTableOptions {
	options.Headers = param
	return options
}

// UpdateVPCRoutingTableRouteOptions : The UpdateVPCRoutingTableRoute options.
type UpdateVPCRoutingTableRouteOptions struct {
	// The VPC identifier.
	VPCID *string `json:"vpc_id" validate:"required"`

	// The routing table identifier.
	RoutingTableID *string `json:"routing_table_id" validate:"required"`

	// The VPC routing table route identifier.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this route. Names must be unique within the VPC routing table the route resides in.
	Name *string `json:"name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateVPCRoutingTableRouteOptions : Instantiate UpdateVPCRoutingTableRouteOptions
func (*VpcV1) NewUpdateVPCRoutingTableRouteOptions(vpcID string, routingTableID string, id string) *UpdateVPCRoutingTableRouteOptions {
	return &UpdateVPCRoutingTableRouteOptions{
		VPCID:          core.StringPtr(vpcID),
		RoutingTableID: core.StringPtr(routingTableID),
		ID:             core.StringPtr(id),
	}
}

// SetVPCID : Allow user to set VPCID
func (options *UpdateVPCRoutingTableRouteOptions) SetVPCID(vpcID string) *UpdateVPCRoutingTableRouteOptions {
	options.VPCID = core.StringPtr(vpcID)
	return options
}

// SetRoutingTableID : Allow user to set RoutingTableID
func (options *UpdateVPCRoutingTableRouteOptions) SetRoutingTableID(routingTableID string) *UpdateVPCRoutingTableRouteOptions {
	options.RoutingTableID = core.StringPtr(routingTableID)
	return options
}

// SetID : Allow user to set ID
func (options *UpdateVPCRoutingTableRouteOptions) SetID(id string) *UpdateVPCRoutingTableRouteOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetName : Allow user to set Name
func (options *UpdateVPCRoutingTableRouteOptions) SetName(name string) *UpdateVPCRoutingTableRouteOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateVPCRoutingTableRouteOptions) SetHeaders(param map[string]string) *UpdateVPCRoutingTableRouteOptions {
	options.Headers = param
	return options
}

// UpdateVPNGatewayConnectionOptions : The UpdateVPNGatewayConnection options.
type UpdateVPNGatewayConnectionOptions struct {
	// The VPN gateway identifier.
	VPNGatewayID *string `json:"vpn_gateway_id" validate:"required"`

	// The VPN connection identifier.
	ID *string `json:"id" validate:"required"`

	// If set to false, the VPN connection is shut down.
	AdminStateUp *bool `json:"admin_state_up,omitempty"`

	// The Dead Peer Detection settings.
	DeadPeerDetection *VPNGatewayConnectionDpdPrototype `json:"dead_peer_detection,omitempty"`

	// Optional IKE policy configuration. The absence of a policy indicates autonegotiation.
	IkePolicy IkePolicyIdentityIntf `json:"ike_policy,omitempty"`

	// Optional IPsec policy configuration. The absence of a policy indicates
	// autonegotiation.
	IpsecPolicy IPsecPolicyIdentityIntf `json:"ipsec_policy,omitempty"`

	// The user-defined name for this VPN connection.
	Name *string `json:"name,omitempty"`

	// The IP address of the peer VPN gateway.
	PeerAddress *string `json:"peer_address,omitempty"`

	// The preshared key.
	Psk *string `json:"psk,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateVPNGatewayConnectionOptions : Instantiate UpdateVPNGatewayConnectionOptions
func (*VpcV1) NewUpdateVPNGatewayConnectionOptions(vpnGatewayID string, id string) *UpdateVPNGatewayConnectionOptions {
	return &UpdateVPNGatewayConnectionOptions{
		VPNGatewayID: core.StringPtr(vpnGatewayID),
		ID:           core.StringPtr(id),
	}
}

// SetVPNGatewayID : Allow user to set VPNGatewayID
func (options *UpdateVPNGatewayConnectionOptions) SetVPNGatewayID(vpnGatewayID string) *UpdateVPNGatewayConnectionOptions {
	options.VPNGatewayID = core.StringPtr(vpnGatewayID)
	return options
}

// SetID : Allow user to set ID
func (options *UpdateVPNGatewayConnectionOptions) SetID(id string) *UpdateVPNGatewayConnectionOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetAdminStateUp : Allow user to set AdminStateUp
func (options *UpdateVPNGatewayConnectionOptions) SetAdminStateUp(adminStateUp bool) *UpdateVPNGatewayConnectionOptions {
	options.AdminStateUp = core.BoolPtr(adminStateUp)
	return options
}

// SetDeadPeerDetection : Allow user to set DeadPeerDetection
func (options *UpdateVPNGatewayConnectionOptions) SetDeadPeerDetection(deadPeerDetection *VPNGatewayConnectionDpdPrototype) *UpdateVPNGatewayConnectionOptions {
	options.DeadPeerDetection = deadPeerDetection
	return options
}

// SetIkePolicy : Allow user to set IkePolicy
func (options *UpdateVPNGatewayConnectionOptions) SetIkePolicy(ikePolicy IkePolicyIdentityIntf) *UpdateVPNGatewayConnectionOptions {
	options.IkePolicy = ikePolicy
	return options
}

// SetIpsecPolicy : Allow user to set IpsecPolicy
func (options *UpdateVPNGatewayConnectionOptions) SetIpsecPolicy(ipsecPolicy IPsecPolicyIdentityIntf) *UpdateVPNGatewayConnectionOptions {
	options.IpsecPolicy = ipsecPolicy
	return options
}

// SetName : Allow user to set Name
func (options *UpdateVPNGatewayConnectionOptions) SetName(name string) *UpdateVPNGatewayConnectionOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetPeerAddress : Allow user to set PeerAddress
func (options *UpdateVPNGatewayConnectionOptions) SetPeerAddress(peerAddress string) *UpdateVPNGatewayConnectionOptions {
	options.PeerAddress = core.StringPtr(peerAddress)
	return options
}

// SetPsk : Allow user to set Psk
func (options *UpdateVPNGatewayConnectionOptions) SetPsk(psk string) *UpdateVPNGatewayConnectionOptions {
	options.Psk = core.StringPtr(psk)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateVPNGatewayConnectionOptions) SetHeaders(param map[string]string) *UpdateVPNGatewayConnectionOptions {
	options.Headers = param
	return options
}

// UpdateVPNGatewayOptions : The UpdateVPNGateway options.
type UpdateVPNGatewayOptions struct {
	// The VPN gateway identifier.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this VPN gateway.
	Name *string `json:"name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateVPNGatewayOptions : Instantiate UpdateVPNGatewayOptions
func (*VpcV1) NewUpdateVPNGatewayOptions(id string) *UpdateVPNGatewayOptions {
	return &UpdateVPNGatewayOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (options *UpdateVPNGatewayOptions) SetID(id string) *UpdateVPNGatewayOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetName : Allow user to set Name
func (options *UpdateVPNGatewayOptions) SetName(name string) *UpdateVPNGatewayOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateVPNGatewayOptions) SetHeaders(param map[string]string) *UpdateVPNGatewayOptions {
	options.Headers = param
	return options
}

// VPC : VPC struct
type VPC struct {
	// Indicates whether this VPC is connected to Classic Infrastructure. If true, this VPC's resources have private
	// network connectivity to the account's Classic Infrastructure resources. Only one VPC, per region, may be connected
	// in this way. This value is set at creation and subsequently immutable.
	ClassicAccess *bool `json:"classic_access" validate:"required"`

	// The date and time that the VPC was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The CRN for this VPC.
	CRN *string `json:"crn" validate:"required"`

	// Array of CSE ([Cloud Service Endpoint](https://cloud.ibm.com/docs/resources?topic=resources-service-endpoints))
	// source IP addresses for the VPC. The VPC will have one CSE source IP address per zone.
	CseSourceIps []VpccseSourceIP `json:"cse_source_ips,omitempty"`

	// The default network ACL to use for subnets created in this VPC.
	DefaultNetworkACL *NetworkACLReference `json:"default_network_acl" validate:"required"`

	// The default routing table to use for subnets created in this VPC.
	DefaultRoutingTable *RoutingTableReference `json:"default_routing_table" validate:"required"`

	// The default security group to use for network interfaces created in this VPC.
	DefaultSecurityGroup *SecurityGroupReference `json:"default_security_group" validate:"required"`

	// The URL for this VPC.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this VPC.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this VPC.
	Name *string `json:"name" validate:"required"`

	// The resource group for this VPC.
	ResourceGroup *ResourceGroupReference `json:"resource_group" validate:"required"`

	// The type of resource referenced.
	ResourceType *string `json:"resource_type" validate:"required"`

	// The status of this VPC.
	Status *string `json:"status" validate:"required"`
}

// Constants associated with the VPC.ResourceType property.
// The type of resource referenced.
const (
	VPCResourceTypeVPCConst = "vpc"
)

// Constants associated with the VPC.Status property.
// The status of this VPC.
const (
	VPCStatusAvailableConst = "available"
	VPCStatusDeletingConst  = "deleting"
	VPCStatusFailedConst    = "failed"
	VPCStatusPendingConst   = "pending"
)

// UnmarshalVPC unmarshals an instance of VPC from the specified map of raw messages.
func UnmarshalVPC(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPC)
	err = core.UnmarshalPrimitive(m, "classic_access", &obj.ClassicAccess)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "cse_source_ips", &obj.CseSourceIps, UnmarshalVpccseSourceIP)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "default_network_acl", &obj.DefaultNetworkACL, UnmarshalNetworkACLReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "default_routing_table", &obj.DefaultRoutingTable, UnmarshalRoutingTableReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "default_security_group", &obj.DefaultSecurityGroup, UnmarshalSecurityGroupReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VpccseSourceIP : VpccseSourceIP struct
type VpccseSourceIP struct {
	// The Cloud Service Endpoint source IP address for this zone.
	IP *IP `json:"ip" validate:"required"`

	// The zone this Cloud Service Endpoint source IP belongs to.
	Zone *ZoneReference `json:"zone" validate:"required"`
}

// UnmarshalVpccseSourceIP unmarshals an instance of VpccseSourceIP from the specified map of raw messages.
func UnmarshalVpccseSourceIP(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VpccseSourceIP)
	err = core.UnmarshalModel(m, "ip", &obj.IP, UnmarshalIP)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPCCollection : VPCCollection struct
type VPCCollection struct {
	// A reference to the first page of resources.
	First *VPCCollectionFirst `json:"first" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A reference to the next page of resources; this reference is included for all pages
	// except the last page.
	Next *VPCCollectionNext `json:"next,omitempty"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`

	// Collection of VPCs.
	Vpcs []VPC `json:"vpcs" validate:"required"`
}

// UnmarshalVPCCollection unmarshals an instance of VPCCollection from the specified map of raw messages.
func UnmarshalVPCCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPCCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalVPCCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalVPCCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vpcs", &obj.Vpcs, UnmarshalVPC)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPCCollectionFirst : A reference to the first page of resources.
type VPCCollectionFirst struct {
	// The URL for the first page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalVPCCollectionFirst unmarshals an instance of VPCCollectionFirst from the specified map of raw messages.
func UnmarshalVPCCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPCCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPCCollectionNext : A reference to the next page of resources; this reference is included for all pages except the last page.
type VPCCollectionNext struct {
	// The URL for the next page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalVPCCollectionNext unmarshals an instance of VPCCollectionNext from the specified map of raw messages.
func UnmarshalVPCCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPCCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPCIdentity : Identifies a VPC by a unique property.
// Models which "extend" this model:
// - VPCIdentityByID
// - VPCIdentityByCRN
// - VPCIdentityByHref
type VPCIdentity struct {
	// The unique identifier for this VPC.
	ID *string `json:"id,omitempty"`

	// The CRN for this VPC.
	CRN *string `json:"crn,omitempty"`

	// The URL for this VPC.
	Href *string `json:"href,omitempty"`
}

func (*VPCIdentity) isaVPCIdentity() bool {
	return true
}

type VPCIdentityIntf interface {
	isaVPCIdentity() bool
}

// UnmarshalVPCIdentity unmarshals an instance of VPCIdentity from the specified map of raw messages.
func UnmarshalVPCIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPCIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPCReference : VPCReference struct
type VPCReference struct {
	// The CRN for this VPC.
	CRN *string `json:"crn" validate:"required"`

	// The URL for this VPC.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this VPC.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this VPC.
	Name *string `json:"name" validate:"required"`

	// The type of resource referenced.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the VPCReference.ResourceType property.
// The type of resource referenced.
const (
	VPCReferenceResourceTypeVPCConst = "vpc"
)

// UnmarshalVPCReference unmarshals an instance of VPCReference from the specified map of raw messages.
func UnmarshalVPCReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPCReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNGateway : VPNGateway struct
type VPNGateway struct {
	// Collection of references to VPN connections.
	Connections []VPNGatewayConnectionReference `json:"connections" validate:"required"`

	// The date and time that this VPN gateway was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The VPN gateway's CRN.
	CRN *string `json:"crn" validate:"required"`

	// The VPN gateway's canonical URL.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this VPN gateway.
	ID *string `json:"id" validate:"required"`

	// Collection of VPN gateway members.
	Members []VPNGatewayMember `json:"members" validate:"required"`

	// The mode of the VPN gateway.
	Mode *string `json:"mode" validate:"required"`

	// The user-defined name for this VPN gateway.
	Name *string `json:"name" validate:"required"`

	// The resource group for this VPN gateway.
	ResourceGroup *ResourceGroupReference `json:"resource_group" validate:"required"`

	// The status of the VPN gateway.
	Status *string `json:"status" validate:"required"`

	Subnet *SubnetReference `json:"subnet" validate:"required"`
}

// Constants associated with the VPNGateway.Mode property.
// The mode of the VPN gateway.
const (
	VPNGatewayModePolicyConst = "policy"
	VPNGatewayModeRouteConst  = "route"
)

// Constants associated with the VPNGateway.Status property.
// The status of the VPN gateway.
const (
	VPNGatewayStatusAvailableConst = "available"
	VPNGatewayStatusDeletingConst  = "deleting"
	VPNGatewayStatusFailedConst    = "failed"
	VPNGatewayStatusPendingConst   = "pending"
)

// UnmarshalVPNGateway unmarshals an instance of VPNGateway from the specified map of raw messages.
func UnmarshalVPNGateway(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNGateway)
	err = core.UnmarshalModel(m, "connections", &obj.Connections, UnmarshalVPNGatewayConnectionReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "members", &obj.Members, UnmarshalVPNGatewayMember)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "mode", &obj.Mode)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "subnet", &obj.Subnet, UnmarshalSubnetReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNGatewayCollection : VPNGatewayCollection struct
type VPNGatewayCollection struct {
	// A reference to the first page of resources.
	First *VPNGatewayCollectionFirst `json:"first" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A reference to the next page of resources; this reference is included for all pages
	// except the last page.
	Next *VPNGatewayCollectionNext `json:"next,omitempty"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`

	// Collection of VPN gateways.
	VPNGateways []VPNGateway `json:"vpn_gateways" validate:"required"`
}

// UnmarshalVPNGatewayCollection unmarshals an instance of VPNGatewayCollection from the specified map of raw messages.
func UnmarshalVPNGatewayCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNGatewayCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalVPNGatewayCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalVPNGatewayCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vpn_gateways", &obj.VPNGateways, UnmarshalVPNGateway)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNGatewayCollectionFirst : A reference to the first page of resources.
type VPNGatewayCollectionFirst struct {
	// The URL for the first page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalVPNGatewayCollectionFirst unmarshals an instance of VPNGatewayCollectionFirst from the specified map of raw messages.
func UnmarshalVPNGatewayCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNGatewayCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNGatewayCollectionNext : A reference to the next page of resources; this reference is included for all pages except the last page.
type VPNGatewayCollectionNext struct {
	// The URL for the next page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalVPNGatewayCollectionNext unmarshals an instance of VPNGatewayCollectionNext from the specified map of raw messages.
func UnmarshalVPNGatewayCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNGatewayCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNGatewayConnection : VPNGatewayConnection struct
type VPNGatewayConnection struct {
	// If set to false, the VPN connection is shut down.
	AdminStateUp *bool `json:"admin_state_up" validate:"required"`

	// The authentication mode. Only `psk` is currently supported.
	AuthenticationMode *string `json:"authentication_mode" validate:"required"`

	// The date and time that this VPN connection was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The Dead Peer Detection settings.
	DeadPeerDetection *VPNGatewayConnectionDpd `json:"dead_peer_detection" validate:"required"`

	// The VPN connection's canonical URL.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this VPN connection.
	ID *string `json:"id" validate:"required"`

	// Optional IKE policy configuration. The absence of a policy indicates autonegotiation.
	IkePolicy IkePolicyIdentityIntf `json:"ike_policy,omitempty"`

	// Optional IPsec policy configuration. The absence of a policy indicates
	// autonegotiation.
	IpsecPolicy IPsecPolicyIdentityIntf `json:"ipsec_policy,omitempty"`

	// A collection of local CIDRs for this resource.
	LocalCidrs []string `json:"local_cidrs" validate:"required"`

	// The user-defined name for this VPN connection.
	Name *string `json:"name" validate:"required"`

	// The IP address of the peer VPN gateway.
	PeerAddress *string `json:"peer_address" validate:"required"`

	// A collection of peer CIDRs for this resource.
	PeerCidrs []string `json:"peer_cidrs" validate:"required"`

	// The preshared key.
	Psk *string `json:"psk" validate:"required"`

	// The status of a VPN connection.
	Status *string `json:"status" validate:"required"`

	// Collection of VPN tunnels in a VPN connection.
	Tunnels []VPNGatewayTunnel `json:"tunnels" validate:"required"`
}

// Constants associated with the VPNGatewayConnection.AuthenticationMode property.
// The authentication mode. Only `psk` is currently supported.
const (
	VPNGatewayConnectionAuthenticationModePskConst = "psk"
)

// Constants associated with the VPNGatewayConnection.Status property.
// The status of a VPN connection.
const (
	VPNGatewayConnectionStatusDownConst = "down"
	VPNGatewayConnectionStatusUpConst   = "up"
)

// UnmarshalVPNGatewayConnection unmarshals an instance of VPNGatewayConnection from the specified map of raw messages.
func UnmarshalVPNGatewayConnection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNGatewayConnection)
	err = core.UnmarshalPrimitive(m, "admin_state_up", &obj.AdminStateUp)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "authentication_mode", &obj.AuthenticationMode)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "dead_peer_detection", &obj.DeadPeerDetection, UnmarshalVPNGatewayConnectionDpd)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "ike_policy", &obj.IkePolicy, UnmarshalIkePolicyIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "ipsec_policy", &obj.IpsecPolicy, UnmarshalIPsecPolicyIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "local_cidrs", &obj.LocalCidrs)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "peer_address", &obj.PeerAddress)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "peer_cidrs", &obj.PeerCidrs)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "psk", &obj.Psk)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "tunnels", &obj.Tunnels, UnmarshalVPNGatewayTunnel)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNGatewayConnectionCollection : Collection of VPN connections in a VPN gateway.
type VPNGatewayConnectionCollection struct {
	// Array of VPN connections.
	Connections []VPNGatewayConnection `json:"connections" validate:"required"`
}

// UnmarshalVPNGatewayConnectionCollection unmarshals an instance of VPNGatewayConnectionCollection from the specified map of raw messages.
func UnmarshalVPNGatewayConnectionCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNGatewayConnectionCollection)
	err = core.UnmarshalModel(m, "connections", &obj.Connections, UnmarshalVPNGatewayConnection)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNGatewayConnectionDpd : The Dead Peer Detection settings.
type VPNGatewayConnectionDpd struct {
	// Dead Peer Detection actions.
	Action *string `json:"action" validate:"required"`

	// Dead Peer Detection interval in seconds.
	Interval *int64 `json:"interval" validate:"required"`

	// Dead Peer Detection timeout in seconds. Must be at least the interval.
	Timeout *int64 `json:"timeout" validate:"required"`
}

// Constants associated with the VPNGatewayConnectionDpd.Action property.
// Dead Peer Detection actions.
const (
	VPNGatewayConnectionDpdActionClearConst   = "clear"
	VPNGatewayConnectionDpdActionHoldConst    = "hold"
	VPNGatewayConnectionDpdActionNoneConst    = "none"
	VPNGatewayConnectionDpdActionRestartConst = "restart"
)

// UnmarshalVPNGatewayConnectionDpd unmarshals an instance of VPNGatewayConnectionDpd from the specified map of raw messages.
func UnmarshalVPNGatewayConnectionDpd(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNGatewayConnectionDpd)
	err = core.UnmarshalPrimitive(m, "action", &obj.Action)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "interval", &obj.Interval)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "timeout", &obj.Timeout)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNGatewayConnectionDpdPrototype : The Dead Peer Detection settings.
type VPNGatewayConnectionDpdPrototype struct {
	// Dead Peer Detection actions.
	Action *string `json:"action,omitempty"`

	// Dead Peer Detection interval in seconds.
	Interval *int64 `json:"interval,omitempty"`

	// Dead Peer Detection timeout in seconds. Must be at least the interval.
	Timeout *int64 `json:"timeout,omitempty"`
}

// Constants associated with the VPNGatewayConnectionDpdPrototype.Action property.
// Dead Peer Detection actions.
const (
	VPNGatewayConnectionDpdPrototypeActionClearConst   = "clear"
	VPNGatewayConnectionDpdPrototypeActionHoldConst    = "hold"
	VPNGatewayConnectionDpdPrototypeActionNoneConst    = "none"
	VPNGatewayConnectionDpdPrototypeActionRestartConst = "restart"
)

// UnmarshalVPNGatewayConnectionDpdPrototype unmarshals an instance of VPNGatewayConnectionDpdPrototype from the specified map of raw messages.
func UnmarshalVPNGatewayConnectionDpdPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNGatewayConnectionDpdPrototype)
	err = core.UnmarshalPrimitive(m, "action", &obj.Action)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "interval", &obj.Interval)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "timeout", &obj.Timeout)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNGatewayConnectionLocalCidRs : VPNGatewayConnectionLocalCidRs struct
type VPNGatewayConnectionLocalCidRs struct {
	// A collection of local CIDRs for this resource.
	LocalCidrs []string `json:"local_cidrs,omitempty"`
}

// UnmarshalVPNGatewayConnectionLocalCidRs unmarshals an instance of VPNGatewayConnectionLocalCidRs from the specified map of raw messages.
func UnmarshalVPNGatewayConnectionLocalCidRs(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNGatewayConnectionLocalCidRs)
	err = core.UnmarshalPrimitive(m, "local_cidrs", &obj.LocalCidrs)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNGatewayConnectionPeerCidRs : VPNGatewayConnectionPeerCidRs struct
type VPNGatewayConnectionPeerCidRs struct {
	// A collection of peer CIDRs for this resource.
	PeerCidrs []string `json:"peer_cidrs,omitempty"`
}

// UnmarshalVPNGatewayConnectionPeerCidRs unmarshals an instance of VPNGatewayConnectionPeerCidRs from the specified map of raw messages.
func UnmarshalVPNGatewayConnectionPeerCidRs(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNGatewayConnectionPeerCidRs)
	err = core.UnmarshalPrimitive(m, "peer_cidrs", &obj.PeerCidrs)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNGatewayConnectionReference : VPNGatewayConnectionReference struct
type VPNGatewayConnectionReference struct {
	// The VPN connection's canonical URL.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this VPN connection.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this VPN connection.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalVPNGatewayConnectionReference unmarshals an instance of VPNGatewayConnectionReference from the specified map of raw messages.
func UnmarshalVPNGatewayConnectionReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNGatewayConnectionReference)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNGatewayMember : VPNGatewayMember struct
type VPNGatewayMember struct {
	// The public IP address assigned to the VPN gateway member.
	PublicIP *VPNGatewayMemberPublicIP `json:"public_ip" validate:"required"`

	// The high availability role assigned to the VPN gateway member.
	Role *string `json:"role" validate:"required"`

	// The status of the VPN gateway member.
	Status *string `json:"status" validate:"required"`
}

// Constants associated with the VPNGatewayMember.Role property.
// The high availability role assigned to the VPN gateway member.
const (
	VPNGatewayMemberRoleActiveConst  = "active"
	VPNGatewayMemberRoleStandbyConst = "standby"
)

// Constants associated with the VPNGatewayMember.Status property.
// The status of the VPN gateway member.
const (
	VPNGatewayMemberStatusAvailableConst = "available"
	VPNGatewayMemberStatusDeletingConst  = "deleting"
	VPNGatewayMemberStatusFailedConst    = "failed"
	VPNGatewayMemberStatusPendingConst   = "pending"
)

// UnmarshalVPNGatewayMember unmarshals an instance of VPNGatewayMember from the specified map of raw messages.
func UnmarshalVPNGatewayMember(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNGatewayMember)
	err = core.UnmarshalModel(m, "public_ip", &obj.PublicIP, UnmarshalVPNGatewayMemberPublicIP)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "role", &obj.Role)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNGatewayMemberPublicIP : The public IP address assigned to the VPN gateway member.
type VPNGatewayMemberPublicIP struct {
	// The IP address. This property may add support for IPv6 addresses in the future. When processing a value in this
	// property, verify that the address is in an expected format. If it is not, log an error. Optionally halt processing
	// and surface the error, or bypass the resource on which the unexpected IP address format was encountered.
	Address *string `json:"address" validate:"required"`
}

// UnmarshalVPNGatewayMemberPublicIP unmarshals an instance of VPNGatewayMemberPublicIP from the specified map of raw messages.
func UnmarshalVPNGatewayMemberPublicIP(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNGatewayMemberPublicIP)
	err = core.UnmarshalPrimitive(m, "address", &obj.Address)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNGatewayTunnel : VPNGatewayTunnel struct
type VPNGatewayTunnel struct {
	// The IP address of the VPN gateway member in which the tunnel resides.
	PublicIP *IP `json:"public_ip" validate:"required"`

	// The status of the VPN Tunnel.
	Status *string `json:"status" validate:"required"`
}

// Constants associated with the VPNGatewayTunnel.Status property.
// The status of the VPN Tunnel.
const (
	VPNGatewayTunnelStatusDownConst = "down"
	VPNGatewayTunnelStatusUpConst   = "up"
)

// UnmarshalVPNGatewayTunnel unmarshals an instance of VPNGatewayTunnel from the specified map of raw messages.
func UnmarshalVPNGatewayTunnel(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNGatewayTunnel)
	err = core.UnmarshalModel(m, "public_ip", &obj.PublicIP, UnmarshalIP)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Volume : Volume struct
type Volume struct {
	// The capacity of the volume in gigabytes. Note that the specified minimum and maximum capacity values for creating or
	// updating volumes may expand in the future.
	Capacity *int64 `json:"capacity" validate:"required"`

	// The date and time that the volume was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The CRN for this volume.
	CRN *string `json:"crn" validate:"required"`

	// The type of encryption used on the volume.
	Encryption *string `json:"encryption" validate:"required"`

	// A reference to the root key used to wrap the data encryption key for the volume.
	//
	// This property will be present for volumes with an `encryption` type of
	// `user_managed`.
	EncryptionKey *EncryptionKeyReference `json:"encryption_key,omitempty"`

	// The URL for this volume.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this volume.
	ID *string `json:"id" validate:"required"`

	// The bandwidth for the volume.
	Iops *int64 `json:"iops" validate:"required"`

	// The unique user-defined name for this volume.
	Name *string `json:"name" validate:"required"`

	// The profile this volume uses.
	Profile *VolumeProfileReference `json:"profile" validate:"required"`

	// The resource group for this volume.
	ResourceGroup *ResourceGroupReference `json:"resource_group" validate:"required"`

	// The status of the volume.
	Status *string `json:"status" validate:"required"`

	// The collection of volume attachments attaching instances to the volume.
	VolumeAttachments []VolumeAttachmentReferenceVolumeContext `json:"volume_attachments" validate:"required"`

	// The zone this volume resides in.
	Zone *ZoneReference `json:"zone" validate:"required"`
}

// Constants associated with the Volume.Encryption property.
// The type of encryption used on the volume.
const (
	VolumeEncryptionProviderManagedConst = "provider_managed"
	VolumeEncryptionUserManagedConst     = "user_managed"
)

// Constants associated with the Volume.Status property.
// The status of the volume.
const (
	VolumeStatusAvailableConst       = "available"
	VolumeStatusFailedConst          = "failed"
	VolumeStatusPendingConst         = "pending"
	VolumeStatusPendingDeletionConst = "pending_deletion"
)

// UnmarshalVolume unmarshals an instance of Volume from the specified map of raw messages.
func UnmarshalVolume(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Volume)
	err = core.UnmarshalPrimitive(m, "capacity", &obj.Capacity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "encryption", &obj.Encryption)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "encryption_key", &obj.EncryptionKey, UnmarshalEncryptionKeyReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "iops", &obj.Iops)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "profile", &obj.Profile, UnmarshalVolumeProfileReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "volume_attachments", &obj.VolumeAttachments, UnmarshalVolumeAttachmentReferenceVolumeContext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeAttachment : VolumeAttachment struct
type VolumeAttachment struct {
	// The date and time that the volume was attached.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// If set to true, when deleting the instance the volume will also be deleted.
	DeleteVolumeOnInstanceDelete *bool `json:"delete_volume_on_instance_delete,omitempty"`

	// Information about how the volume is exposed to the instance operating system.
	//
	// This property may be absent if the volume attachment's `status` is not `attached`.
	Device *VolumeAttachmentDevice `json:"device,omitempty"`

	// The URL for this volume attachment.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this volume attachment.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this volume attachment.
	Name *string `json:"name" validate:"required"`

	// The status of this volume attachment.
	Status *string `json:"status" validate:"required"`

	// The type of volume attachment.
	Type *string `json:"type" validate:"required"`

	// The attached volume.
	Volume *VolumeReference `json:"volume" validate:"required"`
}

// Constants associated with the VolumeAttachment.Status property.
// The status of this volume attachment.
const (
	VolumeAttachmentStatusAttachedConst  = "attached"
	VolumeAttachmentStatusAttachingConst = "attaching"
	VolumeAttachmentStatusDetachingConst = "detaching"
)

// Constants associated with the VolumeAttachment.Type property.
// The type of volume attachment.
const (
	VolumeAttachmentTypeBootConst = "boot"
	VolumeAttachmentTypeDataConst = "data"
)

// UnmarshalVolumeAttachment unmarshals an instance of VolumeAttachment from the specified map of raw messages.
func UnmarshalVolumeAttachment(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeAttachment)
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "delete_volume_on_instance_delete", &obj.DeleteVolumeOnInstanceDelete)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "device", &obj.Device, UnmarshalVolumeAttachmentDevice)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "volume", &obj.Volume, UnmarshalVolumeReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeAttachmentCollection : VolumeAttachmentCollection struct
type VolumeAttachmentCollection struct {
	// Collection of volume attachments.
	VolumeAttachments []VolumeAttachment `json:"volume_attachments" validate:"required"`
}

// UnmarshalVolumeAttachmentCollection unmarshals an instance of VolumeAttachmentCollection from the specified map of raw messages.
func UnmarshalVolumeAttachmentCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeAttachmentCollection)
	err = core.UnmarshalModel(m, "volume_attachments", &obj.VolumeAttachments, UnmarshalVolumeAttachment)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeAttachmentDevice : VolumeAttachmentDevice struct
type VolumeAttachmentDevice struct {
	// A unique identifier for the device which is exposed to the instance operating system.
	ID *string `json:"id,omitempty"`
}

// UnmarshalVolumeAttachmentDevice unmarshals an instance of VolumeAttachmentDevice from the specified map of raw messages.
func UnmarshalVolumeAttachmentDevice(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeAttachmentDevice)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeAttachmentPrototypeInstanceByImageContext : VolumeAttachmentPrototypeInstanceByImageContext struct
type VolumeAttachmentPrototypeInstanceByImageContext struct {
	// If set to true, when deleting the instance the volume will also be deleted.
	DeleteVolumeOnInstanceDelete *bool `json:"delete_volume_on_instance_delete,omitempty"`

	// The user-defined name for this volume attachment.
	Name *string `json:"name,omitempty"`

	// The identity of the volume to attach to the instance, or a prototype object for a
	// new volume.
	Volume *VolumePrototypeInstanceByImageContext `json:"volume" validate:"required"`
}

// NewVolumeAttachmentPrototypeInstanceByImageContext : Instantiate VolumeAttachmentPrototypeInstanceByImageContext (Generic Model Constructor)
func (*VpcV1) NewVolumeAttachmentPrototypeInstanceByImageContext(volume *VolumePrototypeInstanceByImageContext) (model *VolumeAttachmentPrototypeInstanceByImageContext, err error) {
	model = &VolumeAttachmentPrototypeInstanceByImageContext{
		Volume: volume,
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

// UnmarshalVolumeAttachmentPrototypeInstanceByImageContext unmarshals an instance of VolumeAttachmentPrototypeInstanceByImageContext from the specified map of raw messages.
func UnmarshalVolumeAttachmentPrototypeInstanceByImageContext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeAttachmentPrototypeInstanceByImageContext)
	err = core.UnmarshalPrimitive(m, "delete_volume_on_instance_delete", &obj.DeleteVolumeOnInstanceDelete)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "volume", &obj.Volume, UnmarshalVolumePrototypeInstanceByImageContext)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeAttachmentPrototypeInstanceContext : VolumeAttachmentPrototypeInstanceContext struct
type VolumeAttachmentPrototypeInstanceContext struct {
	// If set to true, when deleting the instance the volume will also be deleted.
	DeleteVolumeOnInstanceDelete *bool `json:"delete_volume_on_instance_delete,omitempty"`

	// The user-defined name for this volume attachment.
	Name *string `json:"name,omitempty"`

	// The identity of the volume to attach to the instance, or a prototype object for a new
	// volume.
	Volume VolumeAttachmentPrototypeInstanceContextVolumeIntf `json:"volume" validate:"required"`
}

// NewVolumeAttachmentPrototypeInstanceContext : Instantiate VolumeAttachmentPrototypeInstanceContext (Generic Model Constructor)
func (*VpcV1) NewVolumeAttachmentPrototypeInstanceContext(volume VolumeAttachmentPrototypeInstanceContextVolumeIntf) (model *VolumeAttachmentPrototypeInstanceContext, err error) {
	model = &VolumeAttachmentPrototypeInstanceContext{
		Volume: volume,
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

// UnmarshalVolumeAttachmentPrototypeInstanceContext unmarshals an instance of VolumeAttachmentPrototypeInstanceContext from the specified map of raw messages.
func UnmarshalVolumeAttachmentPrototypeInstanceContext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeAttachmentPrototypeInstanceContext)
	err = core.UnmarshalPrimitive(m, "delete_volume_on_instance_delete", &obj.DeleteVolumeOnInstanceDelete)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "volume", &obj.Volume, UnmarshalVolumeAttachmentPrototypeInstanceContextVolume)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeAttachmentPrototypeInstanceContextVolume : The identity of the volume to attach to the instance, or a prototype object for a new volume.
// Models which "extend" this model:
// - VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentity
// - VolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContext
type VolumeAttachmentPrototypeInstanceContextVolume struct {
	// The unique identifier for this volume.
	ID *string `json:"id,omitempty"`

	// The CRN for this volume.
	CRN *string `json:"crn,omitempty"`

	// The URL for this volume.
	Href *string `json:"href,omitempty"`

	// A reference to the root key to use to wrap the data encryption key for the volume.
	//
	// If this property is not provided, the `encryption` type for the volume will be
	// `provider_managed`.
	EncryptionKey EncryptionKeyIdentityIntf `json:"encryption_key,omitempty"`

	// The bandwidth for the volume.
	Iops *int64 `json:"iops,omitempty"`

	// The unique user-defined name for this volume.
	Name *string `json:"name,omitempty"`

	// The profile to use for this volume.
	Profile VolumeProfileIdentityIntf `json:"profile,omitempty"`

	// The capacity of the volume in gigabytes. Note that the specified minimum and maximum capacity values for creating or
	// updating volumes may expand in the future.
	Capacity *int64 `json:"capacity,omitempty"`
}

func (*VolumeAttachmentPrototypeInstanceContextVolume) isaVolumeAttachmentPrototypeInstanceContextVolume() bool {
	return true
}

type VolumeAttachmentPrototypeInstanceContextVolumeIntf interface {
	isaVolumeAttachmentPrototypeInstanceContextVolume() bool
}

// UnmarshalVolumeAttachmentPrototypeInstanceContextVolume unmarshals an instance of VolumeAttachmentPrototypeInstanceContextVolume from the specified map of raw messages.
func UnmarshalVolumeAttachmentPrototypeInstanceContextVolume(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeAttachmentPrototypeInstanceContextVolume)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "encryption_key", &obj.EncryptionKey, UnmarshalEncryptionKeyIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "iops", &obj.Iops)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "profile", &obj.Profile, UnmarshalVolumeProfileIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "capacity", &obj.Capacity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeAttachmentReferenceInstanceContext : VolumeAttachmentReferenceInstanceContext struct
type VolumeAttachmentReferenceInstanceContext struct {
	// Information about how the volume is exposed to the instance operating system.
	//
	// This property may be absent if the volume attachment's `status` is not `attached`.
	Device *VolumeAttachmentDevice `json:"device,omitempty"`

	// The URL for this volume attachment.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this volume attachment.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this volume attachment.
	Name *string `json:"name" validate:"required"`

	// The attached volume.
	Volume *VolumeReference `json:"volume" validate:"required"`
}

// UnmarshalVolumeAttachmentReferenceInstanceContext unmarshals an instance of VolumeAttachmentReferenceInstanceContext from the specified map of raw messages.
func UnmarshalVolumeAttachmentReferenceInstanceContext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeAttachmentReferenceInstanceContext)
	err = core.UnmarshalModel(m, "device", &obj.Device, UnmarshalVolumeAttachmentDevice)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "volume", &obj.Volume, UnmarshalVolumeReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeAttachmentReferenceVolumeContext : VolumeAttachmentReferenceVolumeContext struct
type VolumeAttachmentReferenceVolumeContext struct {
	// If set to true, when deleting the instance the volume will also be deleted.
	DeleteVolumeOnInstanceDelete *bool `json:"delete_volume_on_instance_delete" validate:"required"`

	// Information about how the volume is exposed to the instance operating system.
	//
	// This property may be absent if the volume attachment's `status` is not `attached`.
	Device *VolumeAttachmentDevice `json:"device,omitempty"`

	// The URL for this volume attachment.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this volume attachment.
	ID *string `json:"id" validate:"required"`

	// The attached instance.
	Instance *InstanceReference `json:"instance" validate:"required"`

	// The user-defined name for this volume attachment.
	Name *string `json:"name" validate:"required"`

	// The type of volume attachment.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the VolumeAttachmentReferenceVolumeContext.Type property.
// The type of volume attachment.
const (
	VolumeAttachmentReferenceVolumeContextTypeBootConst = "boot"
	VolumeAttachmentReferenceVolumeContextTypeDataConst = "data"
)

// UnmarshalVolumeAttachmentReferenceVolumeContext unmarshals an instance of VolumeAttachmentReferenceVolumeContext from the specified map of raw messages.
func UnmarshalVolumeAttachmentReferenceVolumeContext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeAttachmentReferenceVolumeContext)
	err = core.UnmarshalPrimitive(m, "delete_volume_on_instance_delete", &obj.DeleteVolumeOnInstanceDelete)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "device", &obj.Device, UnmarshalVolumeAttachmentDevice)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "instance", &obj.Instance, UnmarshalInstanceReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeCollection : VolumeCollection struct
type VolumeCollection struct {
	// A reference to the first page of resources.
	First *VolumeCollectionFirst `json:"first" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A reference to the next page of resources; this reference is included for all pages
	// except the last page.
	Next *VolumeCollectionNext `json:"next,omitempty"`

	// Collection of volumes.
	Volumes []Volume `json:"volumes" validate:"required"`
}

// UnmarshalVolumeCollection unmarshals an instance of VolumeCollection from the specified map of raw messages.
func UnmarshalVolumeCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalVolumeCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalVolumeCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "volumes", &obj.Volumes, UnmarshalVolume)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeCollectionFirst : A reference to the first page of resources.
type VolumeCollectionFirst struct {
	// The URL for the first page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalVolumeCollectionFirst unmarshals an instance of VolumeCollectionFirst from the specified map of raw messages.
func UnmarshalVolumeCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeCollectionNext : A reference to the next page of resources; this reference is included for all pages except the last page.
type VolumeCollectionNext struct {
	// The URL for the next page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalVolumeCollectionNext unmarshals an instance of VolumeCollectionNext from the specified map of raw messages.
func UnmarshalVolumeCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeIdentity : Identifies a volume by a unique property.
// Models which "extend" this model:
// - VolumeIdentityByID
// - VolumeIdentityByCRN
// - VolumeIdentityByHref
type VolumeIdentity struct {
	// The unique identifier for this volume.
	ID *string `json:"id,omitempty"`

	// The CRN for this volume.
	CRN *string `json:"crn,omitempty"`

	// The URL for this volume.
	Href *string `json:"href,omitempty"`
}

func (*VolumeIdentity) isaVolumeIdentity() bool {
	return true
}

type VolumeIdentityIntf interface {
	isaVolumeIdentity() bool
}

// UnmarshalVolumeIdentity unmarshals an instance of VolumeIdentity from the specified map of raw messages.
func UnmarshalVolumeIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeProfile : VolumeProfile struct
type VolumeProfile struct {
	// The product family this volume profile belongs to.
	Family *string `json:"family,omitempty"`

	// The URL for this volume profile.
	Href *string `json:"href" validate:"required"`

	// The name for this volume profile.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalVolumeProfile unmarshals an instance of VolumeProfile from the specified map of raw messages.
func UnmarshalVolumeProfile(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeProfile)
	err = core.UnmarshalPrimitive(m, "family", &obj.Family)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeProfileCollection : VolumeProfileCollection struct
type VolumeProfileCollection struct {
	// A reference to the first page of resources.
	First *VolumeProfileCollectionFirst `json:"first" validate:"required"`

	// The maximum number of resources that can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A reference to the next page of resources; this reference is included for all pages
	// except the last page.
	Next *VolumeProfileCollectionNext `json:"next,omitempty"`

	// Collection of volume profiles.
	Profiles []VolumeProfile `json:"profiles" validate:"required"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalVolumeProfileCollection unmarshals an instance of VolumeProfileCollection from the specified map of raw messages.
func UnmarshalVolumeProfileCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeProfileCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalVolumeProfileCollectionFirst)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalVolumeProfileCollectionNext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "profiles", &obj.Profiles, UnmarshalVolumeProfile)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeProfileCollectionFirst : A reference to the first page of resources.
type VolumeProfileCollectionFirst struct {
	// The URL for the first page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalVolumeProfileCollectionFirst unmarshals an instance of VolumeProfileCollectionFirst from the specified map of raw messages.
func UnmarshalVolumeProfileCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeProfileCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeProfileCollectionNext : A reference to the next page of resources; this reference is included for all pages except the last page.
type VolumeProfileCollectionNext struct {
	// The URL for the next page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalVolumeProfileCollectionNext unmarshals an instance of VolumeProfileCollectionNext from the specified map of raw messages.
func UnmarshalVolumeProfileCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeProfileCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeProfileIdentity : Identifies a volume profile by a unique property.
// Models which "extend" this model:
// - VolumeProfileIdentityByName
// - VolumeProfileIdentityByHref
type VolumeProfileIdentity struct {
	// The name for this volume profile.
	Name *string `json:"name,omitempty"`

	// The URL for this volume profile.
	Href *string `json:"href,omitempty"`
}

func (*VolumeProfileIdentity) isaVolumeProfileIdentity() bool {
	return true
}

type VolumeProfileIdentityIntf interface {
	isaVolumeProfileIdentity() bool
}

// UnmarshalVolumeProfileIdentity unmarshals an instance of VolumeProfileIdentity from the specified map of raw messages.
func UnmarshalVolumeProfileIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeProfileIdentity)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeProfileReference : VolumeProfileReference struct
type VolumeProfileReference struct {
	// The URL for this volume profile.
	Href *string `json:"href" validate:"required"`

	// The name for this volume profile.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalVolumeProfileReference unmarshals an instance of VolumeProfileReference from the specified map of raw messages.
func UnmarshalVolumeProfileReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeProfileReference)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumePrototype : VolumePrototype struct
// Models which "extend" this model:
// - VolumePrototypeVolumeByCapacity
type VolumePrototype struct {
	// A reference to the root key to use to wrap the data encryption key for the volume.
	//
	// If this property is not provided, the `encryption` type for the volume will be
	// `provider_managed`.
	EncryptionKey EncryptionKeyIdentityIntf `json:"encryption_key,omitempty"`

	// The bandwidth for the volume.
	Iops *int64 `json:"iops,omitempty"`

	// The unique user-defined name for this volume.
	Name *string `json:"name,omitempty"`

	// The profile to use for this volume.
	Profile VolumeProfileIdentityIntf `json:"profile" validate:"required"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// The location of the volume.
	Zone ZoneIdentityIntf `json:"zone" validate:"required"`

	// The capacity of the volume in gigabytes. Note that the specified minimum and maximum capacity values for creating or
	// updating volumes may expand in the future.
	Capacity *int64 `json:"capacity,omitempty"`
}

func (*VolumePrototype) isaVolumePrototype() bool {
	return true
}

type VolumePrototypeIntf interface {
	isaVolumePrototype() bool
}

// UnmarshalVolumePrototype unmarshals an instance of VolumePrototype from the specified map of raw messages.
func UnmarshalVolumePrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumePrototype)
	err = core.UnmarshalModel(m, "encryption_key", &obj.EncryptionKey, UnmarshalEncryptionKeyIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "iops", &obj.Iops)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "profile", &obj.Profile, UnmarshalVolumeProfileIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "capacity", &obj.Capacity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumePrototypeInstanceByImageContext : VolumePrototypeInstanceByImageContext struct
type VolumePrototypeInstanceByImageContext struct {
	// The capacity of the volume in gigabytes. Note that the specified minimum and maximum capacity values for creating or
	// updating volumes may expand in the future.
	Capacity *int64 `json:"capacity,omitempty"`

	// A reference to the root key to use to wrap the data encryption key for the volume.
	//
	// If this property is not provided, the `encryption` type for the volume will be
	// `provider_managed`.
	EncryptionKey EncryptionKeyIdentityIntf `json:"encryption_key,omitempty"`

	// The bandwidth for the volume.
	Iops *int64 `json:"iops,omitempty"`

	// The unique user-defined name for this volume.
	Name *string `json:"name,omitempty"`

	// The profile to use for this volume.
	Profile VolumeProfileIdentityIntf `json:"profile" validate:"required"`
}

// NewVolumePrototypeInstanceByImageContext : Instantiate VolumePrototypeInstanceByImageContext (Generic Model Constructor)
func (*VpcV1) NewVolumePrototypeInstanceByImageContext(profile VolumeProfileIdentityIntf) (model *VolumePrototypeInstanceByImageContext, err error) {
	model = &VolumePrototypeInstanceByImageContext{
		Profile: profile,
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

// UnmarshalVolumePrototypeInstanceByImageContext unmarshals an instance of VolumePrototypeInstanceByImageContext from the specified map of raw messages.
func UnmarshalVolumePrototypeInstanceByImageContext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumePrototypeInstanceByImageContext)
	err = core.UnmarshalPrimitive(m, "capacity", &obj.Capacity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "encryption_key", &obj.EncryptionKey, UnmarshalEncryptionKeyIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "iops", &obj.Iops)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "profile", &obj.Profile, UnmarshalVolumeProfileIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeReference : VolumeReference struct
type VolumeReference struct {
	// The CRN for this volume.
	CRN *string `json:"crn" validate:"required"`

	// The URL for this volume.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this volume.
	ID *string `json:"id" validate:"required"`

	// The unique user-defined name for this volume.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalVolumeReference unmarshals an instance of VolumeReference from the specified map of raw messages.
func UnmarshalVolumeReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Zone : Zone struct
type Zone struct {
	// The URL for this zone.
	Href *string `json:"href" validate:"required"`

	// The name for this zone.
	Name *string `json:"name" validate:"required"`

	// The region this zone belongs to.
	Region *RegionReference `json:"region" validate:"required"`

	// The availability status of this zone.
	Status *string `json:"status" validate:"required"`
}

// Constants associated with the Zone.Status property.
// The availability status of this zone.
const (
	ZoneStatusAvailableConst   = "available"
	ZoneStatusImpairedConst    = "impaired"
	ZoneStatusUnavailableConst = "unavailable"
)

// UnmarshalZone unmarshals an instance of Zone from the specified map of raw messages.
func UnmarshalZone(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Zone)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "region", &obj.Region, UnmarshalRegionReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ZoneCollection : ZoneCollection struct
type ZoneCollection struct {
	// Collection of zones.
	Zones []Zone `json:"zones" validate:"required"`
}

// UnmarshalZoneCollection unmarshals an instance of ZoneCollection from the specified map of raw messages.
func UnmarshalZoneCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ZoneCollection)
	err = core.UnmarshalModel(m, "zones", &obj.Zones, UnmarshalZone)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ZoneIdentity : Identifies a zone by a unique property.
// Models which "extend" this model:
// - ZoneIdentityByName
// - ZoneIdentityByHref
type ZoneIdentity struct {
	// The name for this zone.
	Name *string `json:"name,omitempty"`

	// The URL for this zone.
	Href *string `json:"href,omitempty"`
}

func (*ZoneIdentity) isaZoneIdentity() bool {
	return true
}

type ZoneIdentityIntf interface {
	isaZoneIdentity() bool
}

// UnmarshalZoneIdentity unmarshals an instance of ZoneIdentity from the specified map of raw messages.
func UnmarshalZoneIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ZoneIdentity)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ZoneReference : ZoneReference struct
type ZoneReference struct {
	// The URL for this zone.
	Href *string `json:"href" validate:"required"`

	// The name for this zone.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalZoneReference unmarshals an instance of ZoneReference from the specified map of raw messages.
func UnmarshalZoneReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ZoneReference)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CertificateInstanceIdentityByCRN : CertificateInstanceIdentityByCRN struct
// This model "extends" CertificateInstanceIdentity
type CertificateInstanceIdentityByCRN struct {
	// The CRN for this certificate instance.
	CRN *string `json:"crn" validate:"required"`
}

// NewCertificateInstanceIdentityByCRN : Instantiate CertificateInstanceIdentityByCRN (Generic Model Constructor)
func (*VpcV1) NewCertificateInstanceIdentityByCRN(crn string) (model *CertificateInstanceIdentityByCRN, err error) {
	model = &CertificateInstanceIdentityByCRN{
		CRN: core.StringPtr(crn),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*CertificateInstanceIdentityByCRN) isaCertificateInstanceIdentity() bool {
	return true
}

// UnmarshalCertificateInstanceIdentityByCRN unmarshals an instance of CertificateInstanceIdentityByCRN from the specified map of raw messages.
func UnmarshalCertificateInstanceIdentityByCRN(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CertificateInstanceIdentityByCRN)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CloudObjectStorageBucketIdentityByName : CloudObjectStorageBucketIdentityByName struct
// This model "extends" CloudObjectStorageBucketIdentity
type CloudObjectStorageBucketIdentityByName struct {
	// The globally unique name of this COS bucket.
	Name *string `json:"name" validate:"required"`
}

// NewCloudObjectStorageBucketIdentityByName : Instantiate CloudObjectStorageBucketIdentityByName (Generic Model Constructor)
func (*VpcV1) NewCloudObjectStorageBucketIdentityByName(name string) (model *CloudObjectStorageBucketIdentityByName, err error) {
	model = &CloudObjectStorageBucketIdentityByName{
		Name: core.StringPtr(name),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*CloudObjectStorageBucketIdentityByName) isaCloudObjectStorageBucketIdentity() bool {
	return true
}

// UnmarshalCloudObjectStorageBucketIdentityByName unmarshals an instance of CloudObjectStorageBucketIdentityByName from the specified map of raw messages.
func UnmarshalCloudObjectStorageBucketIdentityByName(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CloudObjectStorageBucketIdentityByName)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostProfileMemoryDependent : The memory value for a dedicated host with this profile depends on its configuration.
// This model "extends" DedicatedHostProfileMemory
type DedicatedHostProfileMemoryDependent struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the DedicatedHostProfileMemoryDependent.Type property.
// The type for this profile field.
const (
	DedicatedHostProfileMemoryDependentTypeDependentConst = "dependent"
)

func (*DedicatedHostProfileMemoryDependent) isaDedicatedHostProfileMemory() bool {
	return true
}

// UnmarshalDedicatedHostProfileMemoryDependent unmarshals an instance of DedicatedHostProfileMemoryDependent from the specified map of raw messages.
func UnmarshalDedicatedHostProfileMemoryDependent(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostProfileMemoryDependent)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostProfileMemoryEnum : The permitted memory values (in gibibytes) for a dedicated host with this profile.
// This model "extends" DedicatedHostProfileMemory
type DedicatedHostProfileMemoryEnum struct {
	// The default value for this profile field.
	Default *int64 `json:"default" validate:"required"`

	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The permitted values for this profile field.
	Values []int64 `json:"values" validate:"required"`
}

// Constants associated with the DedicatedHostProfileMemoryEnum.Type property.
// The type for this profile field.
const (
	DedicatedHostProfileMemoryEnumTypeEnumConst = "enum"
)

func (*DedicatedHostProfileMemoryEnum) isaDedicatedHostProfileMemory() bool {
	return true
}

// UnmarshalDedicatedHostProfileMemoryEnum unmarshals an instance of DedicatedHostProfileMemoryEnum from the specified map of raw messages.
func UnmarshalDedicatedHostProfileMemoryEnum(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostProfileMemoryEnum)
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "values", &obj.Values)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostProfileMemoryFixed : The memory (in gibibytes) for a dedicated host with this profile.
// This model "extends" DedicatedHostProfileMemory
type DedicatedHostProfileMemoryFixed struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The value for this profile field.
	Value *int64 `json:"value" validate:"required"`
}

// Constants associated with the DedicatedHostProfileMemoryFixed.Type property.
// The type for this profile field.
const (
	DedicatedHostProfileMemoryFixedTypeFixedConst = "fixed"
)

func (*DedicatedHostProfileMemoryFixed) isaDedicatedHostProfileMemory() bool {
	return true
}

// UnmarshalDedicatedHostProfileMemoryFixed unmarshals an instance of DedicatedHostProfileMemoryFixed from the specified map of raw messages.
func UnmarshalDedicatedHostProfileMemoryFixed(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostProfileMemoryFixed)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostProfileMemoryRange : The permitted memory range (in gibibytes) for a dedicated host with this profile.
// This model "extends" DedicatedHostProfileMemory
type DedicatedHostProfileMemoryRange struct {
	// The default value for this profile field.
	Default *int64 `json:"default" validate:"required"`

	// The maximum value for this profile field.
	Max *int64 `json:"max" validate:"required"`

	// The minimum value for this profile field.
	Min *int64 `json:"min" validate:"required"`

	// The increment step value for this profile field.
	Step *int64 `json:"step" validate:"required"`

	// The type for this profile field.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the DedicatedHostProfileMemoryRange.Type property.
// The type for this profile field.
const (
	DedicatedHostProfileMemoryRangeTypeRangeConst = "range"
)

func (*DedicatedHostProfileMemoryRange) isaDedicatedHostProfileMemory() bool {
	return true
}

// UnmarshalDedicatedHostProfileMemoryRange unmarshals an instance of DedicatedHostProfileMemoryRange from the specified map of raw messages.
func UnmarshalDedicatedHostProfileMemoryRange(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostProfileMemoryRange)
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "max", &obj.Max)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "min", &obj.Min)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "step", &obj.Step)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostProfilePortSpeedDependent : The port speed of each network interface of a dedicated host with this profile depends on its configuration.
// This model "extends" DedicatedHostProfilePortSpeed
type DedicatedHostProfilePortSpeedDependent struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the DedicatedHostProfilePortSpeedDependent.Type property.
// The type for this profile field.
const (
	DedicatedHostProfilePortSpeedDependentTypeDependentConst = "dependent"
)

func (*DedicatedHostProfilePortSpeedDependent) isaDedicatedHostProfilePortSpeed() bool {
	return true
}

// UnmarshalDedicatedHostProfilePortSpeedDependent unmarshals an instance of DedicatedHostProfilePortSpeedDependent from the specified map of raw messages.
func UnmarshalDedicatedHostProfilePortSpeedDependent(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostProfilePortSpeedDependent)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostProfilePortSpeedFixed : The maximum speed (in megabits per second) of each network interface of a dedicated host with this profile.
// This model "extends" DedicatedHostProfilePortSpeed
type DedicatedHostProfilePortSpeedFixed struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The value for this profile field.
	Value *int64 `json:"value" validate:"required"`
}

// Constants associated with the DedicatedHostProfilePortSpeedFixed.Type property.
// The type for this profile field.
const (
	DedicatedHostProfilePortSpeedFixedTypeFixedConst = "fixed"
)

func (*DedicatedHostProfilePortSpeedFixed) isaDedicatedHostProfilePortSpeed() bool {
	return true
}

// UnmarshalDedicatedHostProfilePortSpeedFixed unmarshals an instance of DedicatedHostProfilePortSpeedFixed from the specified map of raw messages.
func UnmarshalDedicatedHostProfilePortSpeedFixed(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostProfilePortSpeedFixed)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostProfileSocketDependent : The CPU socket count for a dedicated host with this profile depends on its configuration.
// This model "extends" DedicatedHostProfileSocket
type DedicatedHostProfileSocketDependent struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the DedicatedHostProfileSocketDependent.Type property.
// The type for this profile field.
const (
	DedicatedHostProfileSocketDependentTypeDependentConst = "dependent"
)

func (*DedicatedHostProfileSocketDependent) isaDedicatedHostProfileSocket() bool {
	return true
}

// UnmarshalDedicatedHostProfileSocketDependent unmarshals an instance of DedicatedHostProfileSocketDependent from the specified map of raw messages.
func UnmarshalDedicatedHostProfileSocketDependent(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostProfileSocketDependent)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostProfileSocketEnum : The permitted values for CPU socket count for a dedicated host with this profile.
// This model "extends" DedicatedHostProfileSocket
type DedicatedHostProfileSocketEnum struct {
	// The default value for this profile field.
	Default *int64 `json:"default" validate:"required"`

	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The permitted values for this profile field.
	Values []int64 `json:"values" validate:"required"`
}

// Constants associated with the DedicatedHostProfileSocketEnum.Type property.
// The type for this profile field.
const (
	DedicatedHostProfileSocketEnumTypeEnumConst = "enum"
)

func (*DedicatedHostProfileSocketEnum) isaDedicatedHostProfileSocket() bool {
	return true
}

// UnmarshalDedicatedHostProfileSocketEnum unmarshals an instance of DedicatedHostProfileSocketEnum from the specified map of raw messages.
func UnmarshalDedicatedHostProfileSocketEnum(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostProfileSocketEnum)
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "values", &obj.Values)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostProfileSocketFixed : The CPU socket count for a dedicated host with this profile.
// This model "extends" DedicatedHostProfileSocket
type DedicatedHostProfileSocketFixed struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The value for this profile field.
	Value *int64 `json:"value" validate:"required"`
}

// Constants associated with the DedicatedHostProfileSocketFixed.Type property.
// The type for this profile field.
const (
	DedicatedHostProfileSocketFixedTypeFixedConst = "fixed"
)

func (*DedicatedHostProfileSocketFixed) isaDedicatedHostProfileSocket() bool {
	return true
}

// UnmarshalDedicatedHostProfileSocketFixed unmarshals an instance of DedicatedHostProfileSocketFixed from the specified map of raw messages.
func UnmarshalDedicatedHostProfileSocketFixed(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostProfileSocketFixed)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostProfileSocketRange : The permitted range for CPU socket count for a dedicated host with this profile.
// This model "extends" DedicatedHostProfileSocket
type DedicatedHostProfileSocketRange struct {
	// The default value for this profile field.
	Default *int64 `json:"default" validate:"required"`

	// The maximum value for this profile field.
	Max *int64 `json:"max" validate:"required"`

	// The minimum value for this profile field.
	Min *int64 `json:"min" validate:"required"`

	// The increment step value for this profile field.
	Step *int64 `json:"step" validate:"required"`

	// The type for this profile field.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the DedicatedHostProfileSocketRange.Type property.
// The type for this profile field.
const (
	DedicatedHostProfileSocketRangeTypeRangeConst = "range"
)

func (*DedicatedHostProfileSocketRange) isaDedicatedHostProfileSocket() bool {
	return true
}

// UnmarshalDedicatedHostProfileSocketRange unmarshals an instance of DedicatedHostProfileSocketRange from the specified map of raw messages.
func UnmarshalDedicatedHostProfileSocketRange(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostProfileSocketRange)
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "max", &obj.Max)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "min", &obj.Min)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "step", &obj.Step)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostProfileVcpuDependent : The VCPU count for a dedicated host with this profile depends on its configuration.
// This model "extends" DedicatedHostProfileVcpu
type DedicatedHostProfileVcpuDependent struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the DedicatedHostProfileVcpuDependent.Type property.
// The type for this profile field.
const (
	DedicatedHostProfileVcpuDependentTypeDependentConst = "dependent"
)

func (*DedicatedHostProfileVcpuDependent) isaDedicatedHostProfileVcpu() bool {
	return true
}

// UnmarshalDedicatedHostProfileVcpuDependent unmarshals an instance of DedicatedHostProfileVcpuDependent from the specified map of raw messages.
func UnmarshalDedicatedHostProfileVcpuDependent(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostProfileVcpuDependent)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostProfileVcpuEnum : The permitted values for VCPU count for a dedicated host with this profile.
// This model "extends" DedicatedHostProfileVcpu
type DedicatedHostProfileVcpuEnum struct {
	// The default value for this profile field.
	Default *int64 `json:"default" validate:"required"`

	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The permitted values for this profile field.
	Values []int64 `json:"values" validate:"required"`
}

// Constants associated with the DedicatedHostProfileVcpuEnum.Type property.
// The type for this profile field.
const (
	DedicatedHostProfileVcpuEnumTypeEnumConst = "enum"
)

func (*DedicatedHostProfileVcpuEnum) isaDedicatedHostProfileVcpu() bool {
	return true
}

// UnmarshalDedicatedHostProfileVcpuEnum unmarshals an instance of DedicatedHostProfileVcpuEnum from the specified map of raw messages.
func UnmarshalDedicatedHostProfileVcpuEnum(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostProfileVcpuEnum)
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "values", &obj.Values)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostProfileVcpuFixed : The VCPU count for a dedicated host with this profile.
// This model "extends" DedicatedHostProfileVcpu
type DedicatedHostProfileVcpuFixed struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The value for this profile field.
	Value *int64 `json:"value" validate:"required"`
}

// Constants associated with the DedicatedHostProfileVcpuFixed.Type property.
// The type for this profile field.
const (
	DedicatedHostProfileVcpuFixedTypeFixedConst = "fixed"
)

func (*DedicatedHostProfileVcpuFixed) isaDedicatedHostProfileVcpu() bool {
	return true
}

// UnmarshalDedicatedHostProfileVcpuFixed unmarshals an instance of DedicatedHostProfileVcpuFixed from the specified map of raw messages.
func UnmarshalDedicatedHostProfileVcpuFixed(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostProfileVcpuFixed)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostProfileVcpuRange : The permitted range for VCPU count for a dedicated host with this profile.
// This model "extends" DedicatedHostProfileVcpu
type DedicatedHostProfileVcpuRange struct {
	// The default value for this profile field.
	Default *int64 `json:"default" validate:"required"`

	// The maximum value for this profile field.
	Max *int64 `json:"max" validate:"required"`

	// The minimum value for this profile field.
	Min *int64 `json:"min" validate:"required"`

	// The increment step value for this profile field.
	Step *int64 `json:"step" validate:"required"`

	// The type for this profile field.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the DedicatedHostProfileVcpuRange.Type property.
// The type for this profile field.
const (
	DedicatedHostProfileVcpuRangeTypeRangeConst = "range"
)

func (*DedicatedHostProfileVcpuRange) isaDedicatedHostProfileVcpu() bool {
	return true
}

// UnmarshalDedicatedHostProfileVcpuRange unmarshals an instance of DedicatedHostProfileVcpuRange from the specified map of raw messages.
func UnmarshalDedicatedHostProfileVcpuRange(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostProfileVcpuRange)
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "max", &obj.Max)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "min", &obj.Min)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "step", &obj.Step)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostPrototypeGroupDedicatedHostGroupIdentityByCRN : DedicatedHostPrototypeGroupDedicatedHostGroupIdentityByCRN struct
// This model "extends" DedicatedHostPrototypeGroup
type DedicatedHostPrototypeGroupDedicatedHostGroupIdentityByCRN struct {
	// The CRN for this dedicated host group.
	CRN *string `json:"crn" validate:"required"`
}

// NewDedicatedHostPrototypeGroupDedicatedHostGroupIdentityByCRN : Instantiate DedicatedHostPrototypeGroupDedicatedHostGroupIdentityByCRN (Generic Model Constructor)
func (*VpcV1) NewDedicatedHostPrototypeGroupDedicatedHostGroupIdentityByCRN(crn string) (model *DedicatedHostPrototypeGroupDedicatedHostGroupIdentityByCRN, err error) {
	model = &DedicatedHostPrototypeGroupDedicatedHostGroupIdentityByCRN{
		CRN: core.StringPtr(crn),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*DedicatedHostPrototypeGroupDedicatedHostGroupIdentityByCRN) isaDedicatedHostPrototypeGroup() bool {
	return true
}

// UnmarshalDedicatedHostPrototypeGroupDedicatedHostGroupIdentityByCRN unmarshals an instance of DedicatedHostPrototypeGroupDedicatedHostGroupIdentityByCRN from the specified map of raw messages.
func UnmarshalDedicatedHostPrototypeGroupDedicatedHostGroupIdentityByCRN(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostPrototypeGroupDedicatedHostGroupIdentityByCRN)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostPrototypeGroupDedicatedHostGroupIdentityByHref : DedicatedHostPrototypeGroupDedicatedHostGroupIdentityByHref struct
// This model "extends" DedicatedHostPrototypeGroup
type DedicatedHostPrototypeGroupDedicatedHostGroupIdentityByHref struct {
	// The URL for this dedicated host group.
	Href *string `json:"href" validate:"required"`
}

// NewDedicatedHostPrototypeGroupDedicatedHostGroupIdentityByHref : Instantiate DedicatedHostPrototypeGroupDedicatedHostGroupIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewDedicatedHostPrototypeGroupDedicatedHostGroupIdentityByHref(href string) (model *DedicatedHostPrototypeGroupDedicatedHostGroupIdentityByHref, err error) {
	model = &DedicatedHostPrototypeGroupDedicatedHostGroupIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*DedicatedHostPrototypeGroupDedicatedHostGroupIdentityByHref) isaDedicatedHostPrototypeGroup() bool {
	return true
}

// UnmarshalDedicatedHostPrototypeGroupDedicatedHostGroupIdentityByHref unmarshals an instance of DedicatedHostPrototypeGroupDedicatedHostGroupIdentityByHref from the specified map of raw messages.
func UnmarshalDedicatedHostPrototypeGroupDedicatedHostGroupIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostPrototypeGroupDedicatedHostGroupIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostPrototypeGroupDedicatedHostGroupIdentityByID : DedicatedHostPrototypeGroupDedicatedHostGroupIdentityByID struct
// This model "extends" DedicatedHostPrototypeGroup
type DedicatedHostPrototypeGroupDedicatedHostGroupIdentityByID struct {
	// The unique identifier for this dedicated host group.
	ID *string `json:"id" validate:"required"`
}

// NewDedicatedHostPrototypeGroupDedicatedHostGroupIdentityByID : Instantiate DedicatedHostPrototypeGroupDedicatedHostGroupIdentityByID (Generic Model Constructor)
func (*VpcV1) NewDedicatedHostPrototypeGroupDedicatedHostGroupIdentityByID(id string) (model *DedicatedHostPrototypeGroupDedicatedHostGroupIdentityByID, err error) {
	model = &DedicatedHostPrototypeGroupDedicatedHostGroupIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*DedicatedHostPrototypeGroupDedicatedHostGroupIdentityByID) isaDedicatedHostPrototypeGroup() bool {
	return true
}

// UnmarshalDedicatedHostPrototypeGroupDedicatedHostGroupIdentityByID unmarshals an instance of DedicatedHostPrototypeGroupDedicatedHostGroupIdentityByID from the specified map of raw messages.
func UnmarshalDedicatedHostPrototypeGroupDedicatedHostGroupIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostPrototypeGroupDedicatedHostGroupIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostPrototypeProfileDedicatedHostProfileIdentityByHref : DedicatedHostPrototypeProfileDedicatedHostProfileIdentityByHref struct
// This model "extends" DedicatedHostPrototypeProfile
type DedicatedHostPrototypeProfileDedicatedHostProfileIdentityByHref struct {
	// The URL for this dedicated host profile.
	Href *string `json:"href" validate:"required"`
}

// NewDedicatedHostPrototypeProfileDedicatedHostProfileIdentityByHref : Instantiate DedicatedHostPrototypeProfileDedicatedHostProfileIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewDedicatedHostPrototypeProfileDedicatedHostProfileIdentityByHref(href string) (model *DedicatedHostPrototypeProfileDedicatedHostProfileIdentityByHref, err error) {
	model = &DedicatedHostPrototypeProfileDedicatedHostProfileIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*DedicatedHostPrototypeProfileDedicatedHostProfileIdentityByHref) isaDedicatedHostPrototypeProfile() bool {
	return true
}

// UnmarshalDedicatedHostPrototypeProfileDedicatedHostProfileIdentityByHref unmarshals an instance of DedicatedHostPrototypeProfileDedicatedHostProfileIdentityByHref from the specified map of raw messages.
func UnmarshalDedicatedHostPrototypeProfileDedicatedHostProfileIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostPrototypeProfileDedicatedHostProfileIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DedicatedHostPrototypeProfileDedicatedHostProfileIdentityByName : DedicatedHostPrototypeProfileDedicatedHostProfileIdentityByName struct
// This model "extends" DedicatedHostPrototypeProfile
type DedicatedHostPrototypeProfileDedicatedHostProfileIdentityByName struct {
	// The name for this dedicated host profile.
	Name *string `json:"name" validate:"required"`
}

// NewDedicatedHostPrototypeProfileDedicatedHostProfileIdentityByName : Instantiate DedicatedHostPrototypeProfileDedicatedHostProfileIdentityByName (Generic Model Constructor)
func (*VpcV1) NewDedicatedHostPrototypeProfileDedicatedHostProfileIdentityByName(name string) (model *DedicatedHostPrototypeProfileDedicatedHostProfileIdentityByName, err error) {
	model = &DedicatedHostPrototypeProfileDedicatedHostProfileIdentityByName{
		Name: core.StringPtr(name),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*DedicatedHostPrototypeProfileDedicatedHostProfileIdentityByName) isaDedicatedHostPrototypeProfile() bool {
	return true
}

// UnmarshalDedicatedHostPrototypeProfileDedicatedHostProfileIdentityByName unmarshals an instance of DedicatedHostPrototypeProfileDedicatedHostProfileIdentityByName from the specified map of raw messages.
func UnmarshalDedicatedHostPrototypeProfileDedicatedHostProfileIdentityByName(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DedicatedHostPrototypeProfileDedicatedHostProfileIdentityByName)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// EncryptionKeyIdentityByCRN : EncryptionKeyIdentityByCRN struct
// This model "extends" EncryptionKeyIdentity
type EncryptionKeyIdentityByCRN struct {
	// The CRN of the [Key Protect Root
	// Key](https://cloud.ibm.com/docs/key-protect?topic=key-protect-getting-started-tutorial) or [Hyper Protect Crypto
	// Service Root Key](https://cloud.ibm.com/docs/hs-crypto?topic=hs-crypto-get-started) for this resource.
	CRN *string `json:"crn" validate:"required"`
}

// NewEncryptionKeyIdentityByCRN : Instantiate EncryptionKeyIdentityByCRN (Generic Model Constructor)
func (*VpcV1) NewEncryptionKeyIdentityByCRN(crn string) (model *EncryptionKeyIdentityByCRN, err error) {
	model = &EncryptionKeyIdentityByCRN{
		CRN: core.StringPtr(crn),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*EncryptionKeyIdentityByCRN) isaEncryptionKeyIdentity() bool {
	return true
}

// UnmarshalEncryptionKeyIdentityByCRN unmarshals an instance of EncryptionKeyIdentityByCRN from the specified map of raw messages.
func UnmarshalEncryptionKeyIdentityByCRN(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(EncryptionKeyIdentityByCRN)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FloatingIPPrototypeFloatingIPByTarget : FloatingIPPrototypeFloatingIPByTarget struct
// This model "extends" FloatingIPPrototype
type FloatingIPPrototypeFloatingIPByTarget struct {
	// The unique user-defined name for this floating IP. If unspecified, the name will be a hyphenated list of
	// randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// The target this address is to be bound to.
	Target NetworkInterfaceIdentityIntf `json:"target" validate:"required"`
}

// NewFloatingIPPrototypeFloatingIPByTarget : Instantiate FloatingIPPrototypeFloatingIPByTarget (Generic Model Constructor)
func (*VpcV1) NewFloatingIPPrototypeFloatingIPByTarget(target NetworkInterfaceIdentityIntf) (model *FloatingIPPrototypeFloatingIPByTarget, err error) {
	model = &FloatingIPPrototypeFloatingIPByTarget{
		Target: target,
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*FloatingIPPrototypeFloatingIPByTarget) isaFloatingIPPrototype() bool {
	return true
}

// UnmarshalFloatingIPPrototypeFloatingIPByTarget unmarshals an instance of FloatingIPPrototypeFloatingIPByTarget from the specified map of raw messages.
func UnmarshalFloatingIPPrototypeFloatingIPByTarget(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FloatingIPPrototypeFloatingIPByTarget)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "target", &obj.Target, UnmarshalNetworkInterfaceIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FloatingIPPrototypeFloatingIPByZone : FloatingIPPrototypeFloatingIPByZone struct
// This model "extends" FloatingIPPrototype
type FloatingIPPrototypeFloatingIPByZone struct {
	// The unique user-defined name for this floating IP. If unspecified, the name will be a hyphenated list of
	// randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// The identity of the zone to provision a floating IP in.
	Zone ZoneIdentityIntf `json:"zone" validate:"required"`
}

// NewFloatingIPPrototypeFloatingIPByZone : Instantiate FloatingIPPrototypeFloatingIPByZone (Generic Model Constructor)
func (*VpcV1) NewFloatingIPPrototypeFloatingIPByZone(zone ZoneIdentityIntf) (model *FloatingIPPrototypeFloatingIPByZone, err error) {
	model = &FloatingIPPrototypeFloatingIPByZone{
		Zone: zone,
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*FloatingIPPrototypeFloatingIPByZone) isaFloatingIPPrototype() bool {
	return true
}

// UnmarshalFloatingIPPrototypeFloatingIPByZone unmarshals an instance of FloatingIPPrototypeFloatingIPByZone from the specified map of raw messages.
func UnmarshalFloatingIPPrototypeFloatingIPByZone(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FloatingIPPrototypeFloatingIPByZone)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FloatingIPTargetNetworkInterfaceReference : FloatingIPTargetNetworkInterfaceReference struct
// This model "extends" FloatingIPTarget
type FloatingIPTargetNetworkInterfaceReference struct {
	// The URL for this network interface.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this network interface.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this network interface.
	Name *string `json:"name" validate:"required"`

	// The primary IPv4 address.
	PrimaryIpv4Address *string `json:"primary_ipv4_address" validate:"required"`

	// The type of resource referenced.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the FloatingIPTargetNetworkInterfaceReference.ResourceType property.
// The type of resource referenced.
const (
	FloatingIPTargetNetworkInterfaceReferenceResourceTypeNetworkInterfaceConst = "network_interface"
)

func (*FloatingIPTargetNetworkInterfaceReference) isaFloatingIPTarget() bool {
	return true
}

// UnmarshalFloatingIPTargetNetworkInterfaceReference unmarshals an instance of FloatingIPTargetNetworkInterfaceReference from the specified map of raw messages.
func UnmarshalFloatingIPTargetNetworkInterfaceReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FloatingIPTargetNetworkInterfaceReference)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "primary_ipv4_address", &obj.PrimaryIpv4Address)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FloatingIPTargetPublicGatewayReference : FloatingIPTargetPublicGatewayReference struct
// This model "extends" FloatingIPTarget
type FloatingIPTargetPublicGatewayReference struct {
	// The CRN for this public gateway.
	CRN *string `json:"crn" validate:"required"`

	// The URL for this public gateway.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this public gateway.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this public gateway.
	Name *string `json:"name" validate:"required"`

	// The type of resource referenced.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the FloatingIPTargetPublicGatewayReference.ResourceType property.
// The type of resource referenced.
const (
	FloatingIPTargetPublicGatewayReferenceResourceTypePublicGatewayConst = "public_gateway"
)

func (*FloatingIPTargetPublicGatewayReference) isaFloatingIPTarget() bool {
	return true
}

// UnmarshalFloatingIPTargetPublicGatewayReference unmarshals an instance of FloatingIPTargetPublicGatewayReference from the specified map of raw messages.
func UnmarshalFloatingIPTargetPublicGatewayReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FloatingIPTargetPublicGatewayReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FlowLogCollectorPrototypeTargetInstanceIdentity : Identifies a virtual server instance by a unique property.
// Models which "extend" this model:
// - FlowLogCollectorPrototypeTargetInstanceIdentityInstanceIdentityByID
// - FlowLogCollectorPrototypeTargetInstanceIdentityInstanceIdentityByCRN
// - FlowLogCollectorPrototypeTargetInstanceIdentityInstanceIdentityByHref
// This model "extends" FlowLogCollectorPrototypeTarget
type FlowLogCollectorPrototypeTargetInstanceIdentity struct {
	// The unique identifier for this virtual server instance.
	ID *string `json:"id,omitempty"`

	// The CRN for this virtual server instance.
	CRN *string `json:"crn,omitempty"`

	// The URL for this virtual server instance.
	Href *string `json:"href,omitempty"`
}

func (*FlowLogCollectorPrototypeTargetInstanceIdentity) isaFlowLogCollectorPrototypeTargetInstanceIdentity() bool {
	return true
}

type FlowLogCollectorPrototypeTargetInstanceIdentityIntf interface {
	FlowLogCollectorPrototypeTargetIntf
	isaFlowLogCollectorPrototypeTargetInstanceIdentity() bool
}

func (*FlowLogCollectorPrototypeTargetInstanceIdentity) isaFlowLogCollectorPrototypeTarget() bool {
	return true
}

// UnmarshalFlowLogCollectorPrototypeTargetInstanceIdentity unmarshals an instance of FlowLogCollectorPrototypeTargetInstanceIdentity from the specified map of raw messages.
func UnmarshalFlowLogCollectorPrototypeTargetInstanceIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FlowLogCollectorPrototypeTargetInstanceIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FlowLogCollectorPrototypeTargetNetworkInterfaceIdentity : Identifies a network interface by a unique property.
// Models which "extend" this model:
// - FlowLogCollectorPrototypeTargetNetworkInterfaceIdentityNetworkInterfaceIdentityByID
// - FlowLogCollectorPrototypeTargetNetworkInterfaceIdentityNetworkInterfaceIdentityByHref
// This model "extends" FlowLogCollectorPrototypeTarget
type FlowLogCollectorPrototypeTargetNetworkInterfaceIdentity struct {
	// The unique identifier for this network interface.
	ID *string `json:"id,omitempty"`

	// The URL for this network interface.
	Href *string `json:"href,omitempty"`
}

func (*FlowLogCollectorPrototypeTargetNetworkInterfaceIdentity) isaFlowLogCollectorPrototypeTargetNetworkInterfaceIdentity() bool {
	return true
}

type FlowLogCollectorPrototypeTargetNetworkInterfaceIdentityIntf interface {
	FlowLogCollectorPrototypeTargetIntf
	isaFlowLogCollectorPrototypeTargetNetworkInterfaceIdentity() bool
}

func (*FlowLogCollectorPrototypeTargetNetworkInterfaceIdentity) isaFlowLogCollectorPrototypeTarget() bool {
	return true
}

// UnmarshalFlowLogCollectorPrototypeTargetNetworkInterfaceIdentity unmarshals an instance of FlowLogCollectorPrototypeTargetNetworkInterfaceIdentity from the specified map of raw messages.
func UnmarshalFlowLogCollectorPrototypeTargetNetworkInterfaceIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FlowLogCollectorPrototypeTargetNetworkInterfaceIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FlowLogCollectorPrototypeTargetSubnetIdentity : Identifies a subnet by a unique property.
// Models which "extend" this model:
// - FlowLogCollectorPrototypeTargetSubnetIdentitySubnetIdentityByID
// - FlowLogCollectorPrototypeTargetSubnetIdentitySubnetIdentityByCRN
// - FlowLogCollectorPrototypeTargetSubnetIdentitySubnetIdentityByHref
// This model "extends" FlowLogCollectorPrototypeTarget
type FlowLogCollectorPrototypeTargetSubnetIdentity struct {
	// The unique identifier for this subnet.
	ID *string `json:"id,omitempty"`

	// The CRN for this subnet.
	CRN *string `json:"crn,omitempty"`

	// The URL for this subnet.
	Href *string `json:"href,omitempty"`
}

func (*FlowLogCollectorPrototypeTargetSubnetIdentity) isaFlowLogCollectorPrototypeTargetSubnetIdentity() bool {
	return true
}

type FlowLogCollectorPrototypeTargetSubnetIdentityIntf interface {
	FlowLogCollectorPrototypeTargetIntf
	isaFlowLogCollectorPrototypeTargetSubnetIdentity() bool
}

func (*FlowLogCollectorPrototypeTargetSubnetIdentity) isaFlowLogCollectorPrototypeTarget() bool {
	return true
}

// UnmarshalFlowLogCollectorPrototypeTargetSubnetIdentity unmarshals an instance of FlowLogCollectorPrototypeTargetSubnetIdentity from the specified map of raw messages.
func UnmarshalFlowLogCollectorPrototypeTargetSubnetIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FlowLogCollectorPrototypeTargetSubnetIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FlowLogCollectorPrototypeTargetVPCIdentity : Identifies a VPC by a unique property.
// Models which "extend" this model:
// - FlowLogCollectorPrototypeTargetVPCIdentityVPCIdentityByID
// - FlowLogCollectorPrototypeTargetVPCIdentityVPCIdentityByCRN
// - FlowLogCollectorPrototypeTargetVPCIdentityVPCIdentityByHref
// This model "extends" FlowLogCollectorPrototypeTarget
type FlowLogCollectorPrototypeTargetVPCIdentity struct {
	// The unique identifier for this VPC.
	ID *string `json:"id,omitempty"`

	// The CRN for this VPC.
	CRN *string `json:"crn,omitempty"`

	// The URL for this VPC.
	Href *string `json:"href,omitempty"`
}

func (*FlowLogCollectorPrototypeTargetVPCIdentity) isaFlowLogCollectorPrototypeTargetVPCIdentity() bool {
	return true
}

type FlowLogCollectorPrototypeTargetVPCIdentityIntf interface {
	FlowLogCollectorPrototypeTargetIntf
	isaFlowLogCollectorPrototypeTargetVPCIdentity() bool
}

func (*FlowLogCollectorPrototypeTargetVPCIdentity) isaFlowLogCollectorPrototypeTarget() bool {
	return true
}

// UnmarshalFlowLogCollectorPrototypeTargetVPCIdentity unmarshals an instance of FlowLogCollectorPrototypeTargetVPCIdentity from the specified map of raw messages.
func UnmarshalFlowLogCollectorPrototypeTargetVPCIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FlowLogCollectorPrototypeTargetVPCIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FlowLogCollectorTargetInstanceReference : FlowLogCollectorTargetInstanceReference struct
// This model "extends" FlowLogCollectorTarget
type FlowLogCollectorTargetInstanceReference struct {
	// The CRN for this virtual server instance.
	CRN *string `json:"crn" validate:"required"`

	// The URL for this virtual server instance.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this virtual server instance.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this virtual server instance (and default system hostname).
	Name *string `json:"name" validate:"required"`

	// The type of resource referenced.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the FlowLogCollectorTargetInstanceReference.ResourceType property.
// The type of resource referenced.
const (
	FlowLogCollectorTargetInstanceReferenceResourceTypeInstanceConst = "instance"
)

func (*FlowLogCollectorTargetInstanceReference) isaFlowLogCollectorTarget() bool {
	return true
}

// UnmarshalFlowLogCollectorTargetInstanceReference unmarshals an instance of FlowLogCollectorTargetInstanceReference from the specified map of raw messages.
func UnmarshalFlowLogCollectorTargetInstanceReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FlowLogCollectorTargetInstanceReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FlowLogCollectorTargetNetworkInterfaceReferenceTargetContext : FlowLogCollectorTargetNetworkInterfaceReferenceTargetContext struct
// This model "extends" FlowLogCollectorTarget
type FlowLogCollectorTargetNetworkInterfaceReferenceTargetContext struct {
	// The URL for this network interface.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this network interface.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this network interface.
	Name *string `json:"name" validate:"required"`

	// The type of resource referenced.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the FlowLogCollectorTargetNetworkInterfaceReferenceTargetContext.ResourceType property.
// The type of resource referenced.
const (
	FlowLogCollectorTargetNetworkInterfaceReferenceTargetContextResourceTypeNetworkInterfaceConst = "network_interface"
)

func (*FlowLogCollectorTargetNetworkInterfaceReferenceTargetContext) isaFlowLogCollectorTarget() bool {
	return true
}

// UnmarshalFlowLogCollectorTargetNetworkInterfaceReferenceTargetContext unmarshals an instance of FlowLogCollectorTargetNetworkInterfaceReferenceTargetContext from the specified map of raw messages.
func UnmarshalFlowLogCollectorTargetNetworkInterfaceReferenceTargetContext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FlowLogCollectorTargetNetworkInterfaceReferenceTargetContext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FlowLogCollectorTargetSubnetReference : FlowLogCollectorTargetSubnetReference struct
// This model "extends" FlowLogCollectorTarget
type FlowLogCollectorTargetSubnetReference struct {
	// The CRN for this subnet.
	CRN *string `json:"crn" validate:"required"`

	// The URL for this subnet.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this subnet.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this subnet.
	Name *string `json:"name" validate:"required"`

	// The type of resource referenced.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the FlowLogCollectorTargetSubnetReference.ResourceType property.
// The type of resource referenced.
const (
	FlowLogCollectorTargetSubnetReferenceResourceTypeSubnetConst = "subnet"
)

func (*FlowLogCollectorTargetSubnetReference) isaFlowLogCollectorTarget() bool {
	return true
}

// UnmarshalFlowLogCollectorTargetSubnetReference unmarshals an instance of FlowLogCollectorTargetSubnetReference from the specified map of raw messages.
func UnmarshalFlowLogCollectorTargetSubnetReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FlowLogCollectorTargetSubnetReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FlowLogCollectorTargetVPCReference : FlowLogCollectorTargetVPCReference struct
// This model "extends" FlowLogCollectorTarget
type FlowLogCollectorTargetVPCReference struct {
	// The CRN for this VPC.
	CRN *string `json:"crn" validate:"required"`

	// The URL for this VPC.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this VPC.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this VPC.
	Name *string `json:"name" validate:"required"`

	// The type of resource referenced.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the FlowLogCollectorTargetVPCReference.ResourceType property.
// The type of resource referenced.
const (
	FlowLogCollectorTargetVPCReferenceResourceTypeVPCConst = "vpc"
)

func (*FlowLogCollectorTargetVPCReference) isaFlowLogCollectorTarget() bool {
	return true
}

// UnmarshalFlowLogCollectorTargetVPCReference unmarshals an instance of FlowLogCollectorTargetVPCReference from the specified map of raw messages.
func UnmarshalFlowLogCollectorTargetVPCReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FlowLogCollectorTargetVPCReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// IkePolicyIdentityByHref : IkePolicyIdentityByHref struct
// This model "extends" IkePolicyIdentity
type IkePolicyIdentityByHref struct {
	// The IKE policy's canonical URL.
	Href *string `json:"href" validate:"required"`
}

// NewIkePolicyIdentityByHref : Instantiate IkePolicyIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewIkePolicyIdentityByHref(href string) (model *IkePolicyIdentityByHref, err error) {
	model = &IkePolicyIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*IkePolicyIdentityByHref) isaIkePolicyIdentity() bool {
	return true
}

// UnmarshalIkePolicyIdentityByHref unmarshals an instance of IkePolicyIdentityByHref from the specified map of raw messages.
func UnmarshalIkePolicyIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(IkePolicyIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// IkePolicyIdentityByID : IkePolicyIdentityByID struct
// This model "extends" IkePolicyIdentity
type IkePolicyIdentityByID struct {
	// The unique identifier for this IKE policy.
	ID *string `json:"id" validate:"required"`
}

// NewIkePolicyIdentityByID : Instantiate IkePolicyIdentityByID (Generic Model Constructor)
func (*VpcV1) NewIkePolicyIdentityByID(id string) (model *IkePolicyIdentityByID, err error) {
	model = &IkePolicyIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*IkePolicyIdentityByID) isaIkePolicyIdentity() bool {
	return true
}

// UnmarshalIkePolicyIdentityByID unmarshals an instance of IkePolicyIdentityByID from the specified map of raw messages.
func UnmarshalIkePolicyIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(IkePolicyIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// IPsecPolicyIdentityByHref : IPsecPolicyIdentityByHref struct
// This model "extends" IPsecPolicyIdentity
type IPsecPolicyIdentityByHref struct {
	// The IPsec policy's canonical URL.
	Href *string `json:"href" validate:"required"`
}

// NewIPsecPolicyIdentityByHref : Instantiate IPsecPolicyIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewIPsecPolicyIdentityByHref(href string) (model *IPsecPolicyIdentityByHref, err error) {
	model = &IPsecPolicyIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*IPsecPolicyIdentityByHref) isaIPsecPolicyIdentity() bool {
	return true
}

// UnmarshalIPsecPolicyIdentityByHref unmarshals an instance of IPsecPolicyIdentityByHref from the specified map of raw messages.
func UnmarshalIPsecPolicyIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(IPsecPolicyIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// IPsecPolicyIdentityByID : IPsecPolicyIdentityByID struct
// This model "extends" IPsecPolicyIdentity
type IPsecPolicyIdentityByID struct {
	// The unique identifier for this IPsec policy.
	ID *string `json:"id" validate:"required"`
}

// NewIPsecPolicyIdentityByID : Instantiate IPsecPolicyIdentityByID (Generic Model Constructor)
func (*VpcV1) NewIPsecPolicyIdentityByID(id string) (model *IPsecPolicyIdentityByID, err error) {
	model = &IPsecPolicyIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*IPsecPolicyIdentityByID) isaIPsecPolicyIdentity() bool {
	return true
}

// UnmarshalIPsecPolicyIdentityByID unmarshals an instance of IPsecPolicyIdentityByID from the specified map of raw messages.
func UnmarshalIPsecPolicyIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(IPsecPolicyIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ImageIdentityByCRN : ImageIdentityByCRN struct
// This model "extends" ImageIdentity
type ImageIdentityByCRN struct {
	// The CRN for this image.
	CRN *string `json:"crn" validate:"required"`
}

// NewImageIdentityByCRN : Instantiate ImageIdentityByCRN (Generic Model Constructor)
func (*VpcV1) NewImageIdentityByCRN(crn string) (model *ImageIdentityByCRN, err error) {
	model = &ImageIdentityByCRN{
		CRN: core.StringPtr(crn),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*ImageIdentityByCRN) isaImageIdentity() bool {
	return true
}

// UnmarshalImageIdentityByCRN unmarshals an instance of ImageIdentityByCRN from the specified map of raw messages.
func UnmarshalImageIdentityByCRN(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ImageIdentityByCRN)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ImageIdentityByHref : ImageIdentityByHref struct
// This model "extends" ImageIdentity
type ImageIdentityByHref struct {
	// The URL for this image.
	Href *string `json:"href" validate:"required"`
}

// NewImageIdentityByHref : Instantiate ImageIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewImageIdentityByHref(href string) (model *ImageIdentityByHref, err error) {
	model = &ImageIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*ImageIdentityByHref) isaImageIdentity() bool {
	return true
}

// UnmarshalImageIdentityByHref unmarshals an instance of ImageIdentityByHref from the specified map of raw messages.
func UnmarshalImageIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ImageIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ImageIdentityByID : ImageIdentityByID struct
// This model "extends" ImageIdentity
type ImageIdentityByID struct {
	// The unique identifier for this image.
	ID *string `json:"id" validate:"required"`
}

// NewImageIdentityByID : Instantiate ImageIdentityByID (Generic Model Constructor)
func (*VpcV1) NewImageIdentityByID(id string) (model *ImageIdentityByID, err error) {
	model = &ImageIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*ImageIdentityByID) isaImageIdentity() bool {
	return true
}

// UnmarshalImageIdentityByID unmarshals an instance of ImageIdentityByID from the specified map of raw messages.
func UnmarshalImageIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ImageIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ImagePrototypeImageByFile : ImagePrototypeImageByFile struct
// This model "extends" ImagePrototype
type ImagePrototypeImageByFile struct {
	// The unique user-defined name for this image. Names starting with "ibm-" are not allowed. If unspecified, the name
	// will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// The file from which to create the image.
	File *ImageFilePrototype `json:"file" validate:"required"`

	// The operating system included in this image.
	OperatingSystem OperatingSystemIdentityIntf `json:"operating_system" validate:"required"`
}

// NewImagePrototypeImageByFile : Instantiate ImagePrototypeImageByFile (Generic Model Constructor)
func (*VpcV1) NewImagePrototypeImageByFile(file *ImageFilePrototype, operatingSystem OperatingSystemIdentityIntf) (model *ImagePrototypeImageByFile, err error) {
	model = &ImagePrototypeImageByFile{
		File:            file,
		OperatingSystem: operatingSystem,
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*ImagePrototypeImageByFile) isaImagePrototype() bool {
	return true
}

// UnmarshalImagePrototypeImageByFile unmarshals an instance of ImagePrototypeImageByFile from the specified map of raw messages.
func UnmarshalImagePrototypeImageByFile(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ImagePrototypeImageByFile)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "file", &obj.File, UnmarshalImageFilePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "operating_system", &obj.OperatingSystem, UnmarshalOperatingSystemIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceGroupManagerPolicyPrototypeInstanceGroupManagerTargetPolicyPrototype : InstanceGroupManagerPolicyPrototypeInstanceGroupManagerTargetPolicyPrototype struct
// This model "extends" InstanceGroupManagerPolicyPrototype
type InstanceGroupManagerPolicyPrototypeInstanceGroupManagerTargetPolicyPrototype struct {
	// The user-defined name for this instance group manager policy. Names must be unique within the instance group
	// manager.
	Name *string `json:"name,omitempty"`

	// The type of metric to be evaluated.
	MetricType *string `json:"metric_type" validate:"required"`

	// The metric value to be evaluated.
	MetricValue *int64 `json:"metric_value" validate:"required"`

	// The type of Policy for the Instance Group.
	PolicyType *string `json:"policy_type" validate:"required"`
}

// Constants associated with the InstanceGroupManagerPolicyPrototypeInstanceGroupManagerTargetPolicyPrototype.MetricType property.
// The type of metric to be evaluated.
const (
	InstanceGroupManagerPolicyPrototypeInstanceGroupManagerTargetPolicyPrototypeMetricTypeCpuConst        = "cpu"
	InstanceGroupManagerPolicyPrototypeInstanceGroupManagerTargetPolicyPrototypeMetricTypeMemoryConst     = "memory"
	InstanceGroupManagerPolicyPrototypeInstanceGroupManagerTargetPolicyPrototypeMetricTypeNetworkInConst  = "network_in"
	InstanceGroupManagerPolicyPrototypeInstanceGroupManagerTargetPolicyPrototypeMetricTypeNetworkOutConst = "network_out"
)

// Constants associated with the InstanceGroupManagerPolicyPrototypeInstanceGroupManagerTargetPolicyPrototype.PolicyType property.
// The type of Policy for the Instance Group.
const (
	InstanceGroupManagerPolicyPrototypeInstanceGroupManagerTargetPolicyPrototypePolicyTypeTargetConst = "target"
)

// NewInstanceGroupManagerPolicyPrototypeInstanceGroupManagerTargetPolicyPrototype : Instantiate InstanceGroupManagerPolicyPrototypeInstanceGroupManagerTargetPolicyPrototype (Generic Model Constructor)
func (*VpcV1) NewInstanceGroupManagerPolicyPrototypeInstanceGroupManagerTargetPolicyPrototype(metricType string, metricValue int64, policyType string) (model *InstanceGroupManagerPolicyPrototypeInstanceGroupManagerTargetPolicyPrototype, err error) {
	model = &InstanceGroupManagerPolicyPrototypeInstanceGroupManagerTargetPolicyPrototype{
		MetricType:  core.StringPtr(metricType),
		MetricValue: core.Int64Ptr(metricValue),
		PolicyType:  core.StringPtr(policyType),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*InstanceGroupManagerPolicyPrototypeInstanceGroupManagerTargetPolicyPrototype) isaInstanceGroupManagerPolicyPrototype() bool {
	return true
}

// UnmarshalInstanceGroupManagerPolicyPrototypeInstanceGroupManagerTargetPolicyPrototype unmarshals an instance of InstanceGroupManagerPolicyPrototypeInstanceGroupManagerTargetPolicyPrototype from the specified map of raw messages.
func UnmarshalInstanceGroupManagerPolicyPrototypeInstanceGroupManagerTargetPolicyPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupManagerPolicyPrototypeInstanceGroupManagerTargetPolicyPrototype)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "metric_type", &obj.MetricType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "metric_value", &obj.MetricValue)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "policy_type", &obj.PolicyType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceGroupManagerPolicyInstanceGroupManagerTargetPolicy : InstanceGroupManagerPolicyInstanceGroupManagerTargetPolicy struct
// This model "extends" InstanceGroupManagerPolicy
type InstanceGroupManagerPolicyInstanceGroupManagerTargetPolicy struct {
	// The URL for this instance group manager policy.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this instance group manager policy.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this instance group manager policy. Names must be unique within the instance group
	// manager.
	Name *string `json:"name" validate:"required"`

	// The type of metric to be evaluated.
	MetricType *string `json:"metric_type" validate:"required"`

	// The metric value to be evaluated.
	MetricValue *int64 `json:"metric_value" validate:"required"`

	// The type of Policy for the Instance Group.
	PolicyType *string `json:"policy_type" validate:"required"`
}

// Constants associated with the InstanceGroupManagerPolicyInstanceGroupManagerTargetPolicy.MetricType property.
// The type of metric to be evaluated.
const (
	InstanceGroupManagerPolicyInstanceGroupManagerTargetPolicyMetricTypeCpuConst        = "cpu"
	InstanceGroupManagerPolicyInstanceGroupManagerTargetPolicyMetricTypeMemoryConst     = "memory"
	InstanceGroupManagerPolicyInstanceGroupManagerTargetPolicyMetricTypeNetworkInConst  = "network_in"
	InstanceGroupManagerPolicyInstanceGroupManagerTargetPolicyMetricTypeNetworkOutConst = "network_out"
)

// Constants associated with the InstanceGroupManagerPolicyInstanceGroupManagerTargetPolicy.PolicyType property.
// The type of Policy for the Instance Group.
const (
	InstanceGroupManagerPolicyInstanceGroupManagerTargetPolicyPolicyTypeTargetConst = "target"
)

func (*InstanceGroupManagerPolicyInstanceGroupManagerTargetPolicy) isaInstanceGroupManagerPolicy() bool {
	return true
}

// UnmarshalInstanceGroupManagerPolicyInstanceGroupManagerTargetPolicy unmarshals an instance of InstanceGroupManagerPolicyInstanceGroupManagerTargetPolicy from the specified map of raw messages.
func UnmarshalInstanceGroupManagerPolicyInstanceGroupManagerTargetPolicy(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupManagerPolicyInstanceGroupManagerTargetPolicy)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "metric_type", &obj.MetricType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "metric_value", &obj.MetricValue)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "policy_type", &obj.PolicyType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceGroupManagerPrototypeInstanceGroupManagerAutoScalePrototype : InstanceGroupManagerPrototypeInstanceGroupManagerAutoScalePrototype struct
// This model "extends" InstanceGroupManagerPrototype
type InstanceGroupManagerPrototypeInstanceGroupManagerAutoScalePrototype struct {
	// If set to `true`, this manager will control the instance group.
	ManagementEnabled *bool `json:"management_enabled,omitempty"`

	// The user-defined name for this instance group manager. Names must be unique within the instance group.
	Name *string `json:"name,omitempty"`

	// The time window in seconds to aggregate metrics prior to evaluation.
	AggregationWindow *int64 `json:"aggregation_window,omitempty"`

	// The duration of time in seconds to pause further scale actions after scaling has taken place.
	Cooldown *int64 `json:"cooldown,omitempty"`

	// The type of instance group manager.
	ManagerType *string `json:"manager_type" validate:"required"`

	// The maximum number of members in a managed instance group.
	MaxMembershipCount *int64 `json:"max_membership_count" validate:"required"`

	// The minimum number of members in a managed instance group.
	MinMembershipCount *int64 `json:"min_membership_count,omitempty"`
}

// Constants associated with the InstanceGroupManagerPrototypeInstanceGroupManagerAutoScalePrototype.ManagerType property.
// The type of instance group manager.
const (
	InstanceGroupManagerPrototypeInstanceGroupManagerAutoScalePrototypeManagerTypeAutoscaleConst = "autoscale"
)

// NewInstanceGroupManagerPrototypeInstanceGroupManagerAutoScalePrototype : Instantiate InstanceGroupManagerPrototypeInstanceGroupManagerAutoScalePrototype (Generic Model Constructor)
func (*VpcV1) NewInstanceGroupManagerPrototypeInstanceGroupManagerAutoScalePrototype(managerType string, maxMembershipCount int64) (model *InstanceGroupManagerPrototypeInstanceGroupManagerAutoScalePrototype, err error) {
	model = &InstanceGroupManagerPrototypeInstanceGroupManagerAutoScalePrototype{
		ManagerType:        core.StringPtr(managerType),
		MaxMembershipCount: core.Int64Ptr(maxMembershipCount),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*InstanceGroupManagerPrototypeInstanceGroupManagerAutoScalePrototype) isaInstanceGroupManagerPrototype() bool {
	return true
}

// UnmarshalInstanceGroupManagerPrototypeInstanceGroupManagerAutoScalePrototype unmarshals an instance of InstanceGroupManagerPrototypeInstanceGroupManagerAutoScalePrototype from the specified map of raw messages.
func UnmarshalInstanceGroupManagerPrototypeInstanceGroupManagerAutoScalePrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceGroupManagerPrototypeInstanceGroupManagerAutoScalePrototype)
	err = core.UnmarshalPrimitive(m, "management_enabled", &obj.ManagementEnabled)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "aggregation_window", &obj.AggregationWindow)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "cooldown", &obj.Cooldown)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "manager_type", &obj.ManagerType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "max_membership_count", &obj.MaxMembershipCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "min_membership_count", &obj.MinMembershipCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstancePlacementDedicatedHostGroupReference : InstancePlacementDedicatedHostGroupReference struct
// This model "extends" InstancePlacement
type InstancePlacementDedicatedHostGroupReference struct {
	// The CRN for this dedicated host group.
	CRN *string `json:"crn" validate:"required"`

	// The URL for this dedicated host group.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this dedicated host group.
	ID *string `json:"id" validate:"required"`

	// The unique user-defined name for this dedicated host group. If unspecified, the name will be a hyphenated list of
	// randomly-selected words.
	Name *string `json:"name" validate:"required"`

	// Type of placement resource.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the InstancePlacementDedicatedHostGroupReference.ResourceType property.
// Type of placement resource.
const (
	InstancePlacementDedicatedHostGroupReferenceResourceTypeDedicatedHostGroupConst = "dedicated_host_group"
)

func (*InstancePlacementDedicatedHostGroupReference) isaInstancePlacement() bool {
	return true
}

// UnmarshalInstancePlacementDedicatedHostGroupReference unmarshals an instance of InstancePlacementDedicatedHostGroupReference from the specified map of raw messages.
func UnmarshalInstancePlacementDedicatedHostGroupReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstancePlacementDedicatedHostGroupReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstancePlacementDedicatedHostReference : InstancePlacementDedicatedHostReference struct
// This model "extends" InstancePlacement
type InstancePlacementDedicatedHostReference struct {
	// The CRN for this dedicated host.
	CRN *string `json:"crn" validate:"required"`

	// The URL for this dedicated host.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this dedicated host.
	ID *string `json:"id" validate:"required"`

	// The unique user-defined name for this dedicated host. If unspecified, the name will be a hyphenated list of
	// randomly-selected words.
	Name *string `json:"name" validate:"required"`

	// Type of placement resource.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the InstancePlacementDedicatedHostReference.ResourceType property.
// Type of placement resource.
const (
	InstancePlacementDedicatedHostReferenceResourceTypeDedicatedHostConst = "dedicated_host"
)

func (*InstancePlacementDedicatedHostReference) isaInstancePlacement() bool {
	return true
}

// UnmarshalInstancePlacementDedicatedHostReference unmarshals an instance of InstancePlacementDedicatedHostReference from the specified map of raw messages.
func UnmarshalInstancePlacementDedicatedHostReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstancePlacementDedicatedHostReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstancePlacementPrototypeDedicatedHostGroupIdentity : Identifies a dedicated host group by a unique property.
// Models which "extend" this model:
// - InstancePlacementPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByID
// - InstancePlacementPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByCRN
// - InstancePlacementPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByHref
// This model "extends" InstancePlacementPrototype
type InstancePlacementPrototypeDedicatedHostGroupIdentity struct {
	// The unique identifier for this dedicated host group.
	ID *string `json:"id,omitempty"`

	// The CRN for this dedicated host group.
	CRN *string `json:"crn,omitempty"`

	// The URL for this dedicated host group.
	Href *string `json:"href,omitempty"`
}

func (*InstancePlacementPrototypeDedicatedHostGroupIdentity) isaInstancePlacementPrototypeDedicatedHostGroupIdentity() bool {
	return true
}

type InstancePlacementPrototypeDedicatedHostGroupIdentityIntf interface {
	InstancePlacementPrototypeIntf
	isaInstancePlacementPrototypeDedicatedHostGroupIdentity() bool
}

func (*InstancePlacementPrototypeDedicatedHostGroupIdentity) isaInstancePlacementPrototype() bool {
	return true
}

// UnmarshalInstancePlacementPrototypeDedicatedHostGroupIdentity unmarshals an instance of InstancePlacementPrototypeDedicatedHostGroupIdentity from the specified map of raw messages.
func UnmarshalInstancePlacementPrototypeDedicatedHostGroupIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstancePlacementPrototypeDedicatedHostGroupIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstancePlacementPrototypeDedicatedHostIdentity : Identifies a dedicated host by a unique property.
// Models which "extend" this model:
// - InstancePlacementPrototypeDedicatedHostIdentityDedicatedHostIdentityByID
// - InstancePlacementPrototypeDedicatedHostIdentityDedicatedHostIdentityByCRN
// - InstancePlacementPrototypeDedicatedHostIdentityDedicatedHostIdentityByHref
// This model "extends" InstancePlacementPrototype
type InstancePlacementPrototypeDedicatedHostIdentity struct {
	// The unique identifier for this dedicated host.
	ID *string `json:"id,omitempty"`

	// The CRN for this dedicated host.
	CRN *string `json:"crn,omitempty"`

	// The URL for this dedicated host.
	Href *string `json:"href,omitempty"`
}

func (*InstancePlacementPrototypeDedicatedHostIdentity) isaInstancePlacementPrototypeDedicatedHostIdentity() bool {
	return true
}

type InstancePlacementPrototypeDedicatedHostIdentityIntf interface {
	InstancePlacementPrototypeIntf
	isaInstancePlacementPrototypeDedicatedHostIdentity() bool
}

func (*InstancePlacementPrototypeDedicatedHostIdentity) isaInstancePlacementPrototype() bool {
	return true
}

// UnmarshalInstancePlacementPrototypeDedicatedHostIdentity unmarshals an instance of InstancePlacementPrototypeDedicatedHostIdentity from the specified map of raw messages.
func UnmarshalInstancePlacementPrototypeDedicatedHostIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstancePlacementPrototypeDedicatedHostIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileBandwidthDependent : The total bandwidth shared across the network interfaces of an instance with this profile depends on its
// configuration.
// This model "extends" InstanceProfileBandwidth
type InstanceProfileBandwidthDependent struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the InstanceProfileBandwidthDependent.Type property.
// The type for this profile field.
const (
	InstanceProfileBandwidthDependentTypeDependentConst = "dependent"
)

func (*InstanceProfileBandwidthDependent) isaInstanceProfileBandwidth() bool {
	return true
}

// UnmarshalInstanceProfileBandwidthDependent unmarshals an instance of InstanceProfileBandwidthDependent from the specified map of raw messages.
func UnmarshalInstanceProfileBandwidthDependent(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileBandwidthDependent)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileBandwidthEnum : The permitted total bandwidth values (in megabits per second) shared across the network interfaces of an instance
// with this profile.
// This model "extends" InstanceProfileBandwidth
type InstanceProfileBandwidthEnum struct {
	// The default value for this profile field.
	Default *int64 `json:"default" validate:"required"`

	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The permitted values for this profile field.
	Values []int64 `json:"values" validate:"required"`
}

// Constants associated with the InstanceProfileBandwidthEnum.Type property.
// The type for this profile field.
const (
	InstanceProfileBandwidthEnumTypeEnumConst = "enum"
)

func (*InstanceProfileBandwidthEnum) isaInstanceProfileBandwidth() bool {
	return true
}

// UnmarshalInstanceProfileBandwidthEnum unmarshals an instance of InstanceProfileBandwidthEnum from the specified map of raw messages.
func UnmarshalInstanceProfileBandwidthEnum(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileBandwidthEnum)
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "values", &obj.Values)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileBandwidthFixed : The total bandwidth (in megabits per second) shared across the network interfaces of an instance with this profile.
// This model "extends" InstanceProfileBandwidth
type InstanceProfileBandwidthFixed struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The value for this profile field.
	Value *int64 `json:"value" validate:"required"`
}

// Constants associated with the InstanceProfileBandwidthFixed.Type property.
// The type for this profile field.
const (
	InstanceProfileBandwidthFixedTypeFixedConst = "fixed"
)

func (*InstanceProfileBandwidthFixed) isaInstanceProfileBandwidth() bool {
	return true
}

// UnmarshalInstanceProfileBandwidthFixed unmarshals an instance of InstanceProfileBandwidthFixed from the specified map of raw messages.
func UnmarshalInstanceProfileBandwidthFixed(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileBandwidthFixed)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileBandwidthRange : The permitted total bandwidth range (in megabits per second) shared across the network interfaces of an instance with
// this profile.
// This model "extends" InstanceProfileBandwidth
type InstanceProfileBandwidthRange struct {
	// The default value for this profile field.
	Default *int64 `json:"default" validate:"required"`

	// The maximum value for this profile field.
	Max *int64 `json:"max" validate:"required"`

	// The minimum value for this profile field.
	Min *int64 `json:"min" validate:"required"`

	// The increment step value for this profile field.
	Step *int64 `json:"step" validate:"required"`

	// The type for this profile field.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the InstanceProfileBandwidthRange.Type property.
// The type for this profile field.
const (
	InstanceProfileBandwidthRangeTypeRangeConst = "range"
)

func (*InstanceProfileBandwidthRange) isaInstanceProfileBandwidth() bool {
	return true
}

// UnmarshalInstanceProfileBandwidthRange unmarshals an instance of InstanceProfileBandwidthRange from the specified map of raw messages.
func UnmarshalInstanceProfileBandwidthRange(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileBandwidthRange)
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "max", &obj.Max)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "min", &obj.Min)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "step", &obj.Step)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileGpuDependent : The GPU count for an instance with this profile depends on its configuration.
// This model "extends" InstanceProfileGpu
type InstanceProfileGpuDependent struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the InstanceProfileGpuDependent.Type property.
// The type for this profile field.
const (
	InstanceProfileGpuDependentTypeDependentConst = "dependent"
)

func (*InstanceProfileGpuDependent) isaInstanceProfileGpu() bool {
	return true
}

// UnmarshalInstanceProfileGpuDependent unmarshals an instance of InstanceProfileGpuDependent from the specified map of raw messages.
func UnmarshalInstanceProfileGpuDependent(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileGpuDependent)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileGpuEnum : The permitted GPU count values for an instance with this profile.
// This model "extends" InstanceProfileGpu
type InstanceProfileGpuEnum struct {
	// The default value for this profile field.
	Default *int64 `json:"default" validate:"required"`

	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The permitted values for this profile field.
	Values []int64 `json:"values" validate:"required"`
}

// Constants associated with the InstanceProfileGpuEnum.Type property.
// The type for this profile field.
const (
	InstanceProfileGpuEnumTypeEnumConst = "enum"
)

func (*InstanceProfileGpuEnum) isaInstanceProfileGpu() bool {
	return true
}

// UnmarshalInstanceProfileGpuEnum unmarshals an instance of InstanceProfileGpuEnum from the specified map of raw messages.
func UnmarshalInstanceProfileGpuEnum(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileGpuEnum)
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "values", &obj.Values)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileGpuFixed : The GPU count for an instance with this profile.
// This model "extends" InstanceProfileGpu
type InstanceProfileGpuFixed struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The value for this profile field.
	Value *int64 `json:"value" validate:"required"`
}

// Constants associated with the InstanceProfileGpuFixed.Type property.
// The type for this profile field.
const (
	InstanceProfileGpuFixedTypeFixedConst = "fixed"
)

func (*InstanceProfileGpuFixed) isaInstanceProfileGpu() bool {
	return true
}

// UnmarshalInstanceProfileGpuFixed unmarshals an instance of InstanceProfileGpuFixed from the specified map of raw messages.
func UnmarshalInstanceProfileGpuFixed(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileGpuFixed)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileGpuMemoryDependent : The overall GPU memory value for an instance with this profile depends on its configuration.
// This model "extends" InstanceProfileGpuMemory
type InstanceProfileGpuMemoryDependent struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the InstanceProfileGpuMemoryDependent.Type property.
// The type for this profile field.
const (
	InstanceProfileGpuMemoryDependentTypeDependentConst = "dependent"
)

func (*InstanceProfileGpuMemoryDependent) isaInstanceProfileGpuMemory() bool {
	return true
}

// UnmarshalInstanceProfileGpuMemoryDependent unmarshals an instance of InstanceProfileGpuMemoryDependent from the specified map of raw messages.
func UnmarshalInstanceProfileGpuMemoryDependent(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileGpuMemoryDependent)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileGpuMemoryEnum : The permitted overall GPU memory values in GiB (gibibytes) for an instance with this profile.
// This model "extends" InstanceProfileGpuMemory
type InstanceProfileGpuMemoryEnum struct {
	// The default value for this profile field.
	Default *int64 `json:"default" validate:"required"`

	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The permitted values for this profile field.
	Values []int64 `json:"values" validate:"required"`
}

// Constants associated with the InstanceProfileGpuMemoryEnum.Type property.
// The type for this profile field.
const (
	InstanceProfileGpuMemoryEnumTypeEnumConst = "enum"
)

func (*InstanceProfileGpuMemoryEnum) isaInstanceProfileGpuMemory() bool {
	return true
}

// UnmarshalInstanceProfileGpuMemoryEnum unmarshals an instance of InstanceProfileGpuMemoryEnum from the specified map of raw messages.
func UnmarshalInstanceProfileGpuMemoryEnum(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileGpuMemoryEnum)
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "values", &obj.Values)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileGpuMemoryFixed : The overall GPU memory in GiB (gibibytes) for an instance with this profile.
// This model "extends" InstanceProfileGpuMemory
type InstanceProfileGpuMemoryFixed struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The value for this profile field.
	Value *int64 `json:"value" validate:"required"`
}

// Constants associated with the InstanceProfileGpuMemoryFixed.Type property.
// The type for this profile field.
const (
	InstanceProfileGpuMemoryFixedTypeFixedConst = "fixed"
)

func (*InstanceProfileGpuMemoryFixed) isaInstanceProfileGpuMemory() bool {
	return true
}

// UnmarshalInstanceProfileGpuMemoryFixed unmarshals an instance of InstanceProfileGpuMemoryFixed from the specified map of raw messages.
func UnmarshalInstanceProfileGpuMemoryFixed(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileGpuMemoryFixed)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileGpuMemoryRange : The permitted overall GPU memory range in GiB (gibibytes) for an instance with this profile.
// This model "extends" InstanceProfileGpuMemory
type InstanceProfileGpuMemoryRange struct {
	// The default value for this profile field.
	Default *int64 `json:"default" validate:"required"`

	// The maximum value for this profile field.
	Max *int64 `json:"max" validate:"required"`

	// The minimum value for this profile field.
	Min *int64 `json:"min" validate:"required"`

	// The increment step value for this profile field.
	Step *int64 `json:"step" validate:"required"`

	// The type for this profile field.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the InstanceProfileGpuMemoryRange.Type property.
// The type for this profile field.
const (
	InstanceProfileGpuMemoryRangeTypeRangeConst = "range"
)

func (*InstanceProfileGpuMemoryRange) isaInstanceProfileGpuMemory() bool {
	return true
}

// UnmarshalInstanceProfileGpuMemoryRange unmarshals an instance of InstanceProfileGpuMemoryRange from the specified map of raw messages.
func UnmarshalInstanceProfileGpuMemoryRange(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileGpuMemoryRange)
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "max", &obj.Max)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "min", &obj.Min)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "step", &obj.Step)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileGpuRange : The permitted GPU count range for an instance with this profile.
// This model "extends" InstanceProfileGpu
type InstanceProfileGpuRange struct {
	// The default value for this profile field.
	Default *int64 `json:"default" validate:"required"`

	// The maximum value for this profile field.
	Max *int64 `json:"max" validate:"required"`

	// The minimum value for this profile field.
	Min *int64 `json:"min" validate:"required"`

	// The increment step value for this profile field.
	Step *int64 `json:"step" validate:"required"`

	// The type for this profile field.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the InstanceProfileGpuRange.Type property.
// The type for this profile field.
const (
	InstanceProfileGpuRangeTypeRangeConst = "range"
)

func (*InstanceProfileGpuRange) isaInstanceProfileGpu() bool {
	return true
}

// UnmarshalInstanceProfileGpuRange unmarshals an instance of InstanceProfileGpuRange from the specified map of raw messages.
func UnmarshalInstanceProfileGpuRange(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileGpuRange)
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "max", &obj.Max)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "min", &obj.Min)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "step", &obj.Step)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileIdentityByHref : InstanceProfileIdentityByHref struct
// This model "extends" InstanceProfileIdentity
type InstanceProfileIdentityByHref struct {
	// The URL for this virtual server instance profile.
	Href *string `json:"href" validate:"required"`
}

// NewInstanceProfileIdentityByHref : Instantiate InstanceProfileIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewInstanceProfileIdentityByHref(href string) (model *InstanceProfileIdentityByHref, err error) {
	model = &InstanceProfileIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*InstanceProfileIdentityByHref) isaInstanceProfileIdentity() bool {
	return true
}

// UnmarshalInstanceProfileIdentityByHref unmarshals an instance of InstanceProfileIdentityByHref from the specified map of raw messages.
func UnmarshalInstanceProfileIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileIdentityByName : InstanceProfileIdentityByName struct
// This model "extends" InstanceProfileIdentity
type InstanceProfileIdentityByName struct {
	// The name for this virtual server instance profile.
	Name *string `json:"name" validate:"required"`
}

// NewInstanceProfileIdentityByName : Instantiate InstanceProfileIdentityByName (Generic Model Constructor)
func (*VpcV1) NewInstanceProfileIdentityByName(name string) (model *InstanceProfileIdentityByName, err error) {
	model = &InstanceProfileIdentityByName{
		Name: core.StringPtr(name),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*InstanceProfileIdentityByName) isaInstanceProfileIdentity() bool {
	return true
}

// UnmarshalInstanceProfileIdentityByName unmarshals an instance of InstanceProfileIdentityByName from the specified map of raw messages.
func UnmarshalInstanceProfileIdentityByName(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileIdentityByName)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileMemoryDependent : The memory value for an instance with this profile depends on its configuration.
// This model "extends" InstanceProfileMemory
type InstanceProfileMemoryDependent struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the InstanceProfileMemoryDependent.Type property.
// The type for this profile field.
const (
	InstanceProfileMemoryDependentTypeDependentConst = "dependent"
)

func (*InstanceProfileMemoryDependent) isaInstanceProfileMemory() bool {
	return true
}

// UnmarshalInstanceProfileMemoryDependent unmarshals an instance of InstanceProfileMemoryDependent from the specified map of raw messages.
func UnmarshalInstanceProfileMemoryDependent(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileMemoryDependent)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileMemoryEnum : The permitted memory values (in gibibytes) for an instance with this profile.
// This model "extends" InstanceProfileMemory
type InstanceProfileMemoryEnum struct {
	// The default value for this profile field.
	Default *int64 `json:"default" validate:"required"`

	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The permitted values for this profile field.
	Values []int64 `json:"values" validate:"required"`
}

// Constants associated with the InstanceProfileMemoryEnum.Type property.
// The type for this profile field.
const (
	InstanceProfileMemoryEnumTypeEnumConst = "enum"
)

func (*InstanceProfileMemoryEnum) isaInstanceProfileMemory() bool {
	return true
}

// UnmarshalInstanceProfileMemoryEnum unmarshals an instance of InstanceProfileMemoryEnum from the specified map of raw messages.
func UnmarshalInstanceProfileMemoryEnum(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileMemoryEnum)
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "values", &obj.Values)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileMemoryFixed : The memory (in gibibytes) for an instance with this profile.
// This model "extends" InstanceProfileMemory
type InstanceProfileMemoryFixed struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The value for this profile field.
	Value *int64 `json:"value" validate:"required"`
}

// Constants associated with the InstanceProfileMemoryFixed.Type property.
// The type for this profile field.
const (
	InstanceProfileMemoryFixedTypeFixedConst = "fixed"
)

func (*InstanceProfileMemoryFixed) isaInstanceProfileMemory() bool {
	return true
}

// UnmarshalInstanceProfileMemoryFixed unmarshals an instance of InstanceProfileMemoryFixed from the specified map of raw messages.
func UnmarshalInstanceProfileMemoryFixed(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileMemoryFixed)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileMemoryRange : The permitted memory range (in gibibytes) for an instance with this profile.
// This model "extends" InstanceProfileMemory
type InstanceProfileMemoryRange struct {
	// The default value for this profile field.
	Default *int64 `json:"default" validate:"required"`

	// The maximum value for this profile field.
	Max *int64 `json:"max" validate:"required"`

	// The minimum value for this profile field.
	Min *int64 `json:"min" validate:"required"`

	// The increment step value for this profile field.
	Step *int64 `json:"step" validate:"required"`

	// The type for this profile field.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the InstanceProfileMemoryRange.Type property.
// The type for this profile field.
const (
	InstanceProfileMemoryRangeTypeRangeConst = "range"
)

func (*InstanceProfileMemoryRange) isaInstanceProfileMemory() bool {
	return true
}

// UnmarshalInstanceProfileMemoryRange unmarshals an instance of InstanceProfileMemoryRange from the specified map of raw messages.
func UnmarshalInstanceProfileMemoryRange(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileMemoryRange)
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "max", &obj.Max)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "min", &obj.Min)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "step", &obj.Step)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfilePortSpeedDependent : The port speed of each network interface of an instance with this profile depends on its configuration.
// This model "extends" InstanceProfilePortSpeed
type InstanceProfilePortSpeedDependent struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the InstanceProfilePortSpeedDependent.Type property.
// The type for this profile field.
const (
	InstanceProfilePortSpeedDependentTypeDependentConst = "dependent"
)

func (*InstanceProfilePortSpeedDependent) isaInstanceProfilePortSpeed() bool {
	return true
}

// UnmarshalInstanceProfilePortSpeedDependent unmarshals an instance of InstanceProfilePortSpeedDependent from the specified map of raw messages.
func UnmarshalInstanceProfilePortSpeedDependent(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfilePortSpeedDependent)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfilePortSpeedFixed : The maximum speed (in megabits per second) of each network interface of an instance with this profile.
// This model "extends" InstanceProfilePortSpeed
type InstanceProfilePortSpeedFixed struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The value for this profile field.
	Value *int64 `json:"value" validate:"required"`
}

// Constants associated with the InstanceProfilePortSpeedFixed.Type property.
// The type for this profile field.
const (
	InstanceProfilePortSpeedFixedTypeFixedConst = "fixed"
)

func (*InstanceProfilePortSpeedFixed) isaInstanceProfilePortSpeed() bool {
	return true
}

// UnmarshalInstanceProfilePortSpeedFixed unmarshals an instance of InstanceProfilePortSpeedFixed from the specified map of raw messages.
func UnmarshalInstanceProfilePortSpeedFixed(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfilePortSpeedFixed)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileVcpuDependent : The VCPU count for an instance with this profile depends on its configuration.
// This model "extends" InstanceProfileVcpu
type InstanceProfileVcpuDependent struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the InstanceProfileVcpuDependent.Type property.
// The type for this profile field.
const (
	InstanceProfileVcpuDependentTypeDependentConst = "dependent"
)

func (*InstanceProfileVcpuDependent) isaInstanceProfileVcpu() bool {
	return true
}

// UnmarshalInstanceProfileVcpuDependent unmarshals an instance of InstanceProfileVcpuDependent from the specified map of raw messages.
func UnmarshalInstanceProfileVcpuDependent(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileVcpuDependent)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileVcpuEnum : The permitted values for VCPU count for an instance with this profile.
// This model "extends" InstanceProfileVcpu
type InstanceProfileVcpuEnum struct {
	// The default value for this profile field.
	Default *int64 `json:"default" validate:"required"`

	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The permitted values for this profile field.
	Values []int64 `json:"values" validate:"required"`
}

// Constants associated with the InstanceProfileVcpuEnum.Type property.
// The type for this profile field.
const (
	InstanceProfileVcpuEnumTypeEnumConst = "enum"
)

func (*InstanceProfileVcpuEnum) isaInstanceProfileVcpu() bool {
	return true
}

// UnmarshalInstanceProfileVcpuEnum unmarshals an instance of InstanceProfileVcpuEnum from the specified map of raw messages.
func UnmarshalInstanceProfileVcpuEnum(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileVcpuEnum)
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "values", &obj.Values)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileVcpuFixed : The VCPU count for an instance with this profile.
// This model "extends" InstanceProfileVcpu
type InstanceProfileVcpuFixed struct {
	// The type for this profile field.
	Type *string `json:"type" validate:"required"`

	// The value for this profile field.
	Value *int64 `json:"value" validate:"required"`
}

// Constants associated with the InstanceProfileVcpuFixed.Type property.
// The type for this profile field.
const (
	InstanceProfileVcpuFixedTypeFixedConst = "fixed"
)

func (*InstanceProfileVcpuFixed) isaInstanceProfileVcpu() bool {
	return true
}

// UnmarshalInstanceProfileVcpuFixed unmarshals an instance of InstanceProfileVcpuFixed from the specified map of raw messages.
func UnmarshalInstanceProfileVcpuFixed(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileVcpuFixed)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceProfileVcpuRange : The permitted range for VCPU count for an instance with this profile.
// This model "extends" InstanceProfileVcpu
type InstanceProfileVcpuRange struct {
	// The default value for this profile field.
	Default *int64 `json:"default" validate:"required"`

	// The maximum value for this profile field.
	Max *int64 `json:"max" validate:"required"`

	// The minimum value for this profile field.
	Min *int64 `json:"min" validate:"required"`

	// The increment step value for this profile field.
	Step *int64 `json:"step" validate:"required"`

	// The type for this profile field.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the InstanceProfileVcpuRange.Type property.
// The type for this profile field.
const (
	InstanceProfileVcpuRangeTypeRangeConst = "range"
)

func (*InstanceProfileVcpuRange) isaInstanceProfileVcpu() bool {
	return true
}

// UnmarshalInstanceProfileVcpuRange unmarshals an instance of InstanceProfileVcpuRange from the specified map of raw messages.
func UnmarshalInstanceProfileVcpuRange(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceProfileVcpuRange)
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "max", &obj.Max)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "min", &obj.Min)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "step", &obj.Step)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstancePrototypeInstanceByImage : InstancePrototypeInstanceByImage struct
// This model "extends" InstancePrototype
type InstancePrototypeInstanceByImage struct {
	// The public SSH keys to install on the virtual server instance. Up to 10 keys may be provided; if no keys are
	// provided the instance will be inaccessible unless the image used provides a means of access. For Windows instances,
	// one of the keys will be used to encrypt the administrator password.
	Keys []KeyIdentityIntf `json:"keys,omitempty"`

	// The unique user-defined name for this virtual server instance (and default system hostname). If unspecified, the
	// name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// Collection of additional network interfaces to create for the virtual server instance.
	NetworkInterfaces []NetworkInterfacePrototype `json:"network_interfaces,omitempty"`

	// The placement for the virtual server instance.
	PlacementTarget InstancePlacementPrototypeIntf `json:"placement_target,omitempty"`

	// The profile to use for this virtual server instance.
	Profile InstanceProfileIdentityIntf `json:"profile,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// User data to be made available when setting up the virtual server instance.
	UserData *string `json:"user_data,omitempty"`

	// Collection of volume attachments.
	VolumeAttachments []VolumeAttachmentPrototypeInstanceContext `json:"volume_attachments,omitempty"`

	// The VPC the virtual server instance is to be a part of. If provided, must match the
	// VPC tied to the subnets of the instance's network interfaces.
	VPC VPCIdentityIntf `json:"vpc,omitempty"`

	// The boot volume attachment for the virtual server instance.
	BootVolumeAttachment *VolumeAttachmentPrototypeInstanceByImageContext `json:"boot_volume_attachment,omitempty"`

	// The identity of the image to be used when provisioning the virtual server instance.
	Image ImageIdentityIntf `json:"image" validate:"required"`

	// Primary network interface.
	PrimaryNetworkInterface *NetworkInterfacePrototype `json:"primary_network_interface" validate:"required"`

	// The identity of the zone to provision the virtual server instance in.
	Zone ZoneIdentityIntf `json:"zone" validate:"required"`
}

// NewInstancePrototypeInstanceByImage : Instantiate InstancePrototypeInstanceByImage (Generic Model Constructor)
func (*VpcV1) NewInstancePrototypeInstanceByImage(image ImageIdentityIntf, primaryNetworkInterface *NetworkInterfacePrototype, zone ZoneIdentityIntf) (model *InstancePrototypeInstanceByImage, err error) {
	model = &InstancePrototypeInstanceByImage{
		Image:                   image,
		PrimaryNetworkInterface: primaryNetworkInterface,
		Zone:                    zone,
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*InstancePrototypeInstanceByImage) isaInstancePrototype() bool {
	return true
}

// UnmarshalInstancePrototypeInstanceByImage unmarshals an instance of InstancePrototypeInstanceByImage from the specified map of raw messages.
func UnmarshalInstancePrototypeInstanceByImage(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstancePrototypeInstanceByImage)
	err = core.UnmarshalModel(m, "keys", &obj.Keys, UnmarshalKeyIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "network_interfaces", &obj.NetworkInterfaces, UnmarshalNetworkInterfacePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "placement_target", &obj.PlacementTarget, UnmarshalInstancePlacementPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "profile", &obj.Profile, UnmarshalInstanceProfileIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "user_data", &obj.UserData)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "volume_attachments", &obj.VolumeAttachments, UnmarshalVolumeAttachmentPrototypeInstanceContext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vpc", &obj.VPC, UnmarshalVPCIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "boot_volume_attachment", &obj.BootVolumeAttachment, UnmarshalVolumeAttachmentPrototypeInstanceByImageContext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "image", &obj.Image, UnmarshalImageIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "primary_network_interface", &obj.PrimaryNetworkInterface, UnmarshalNetworkInterfacePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstancePrototypeInstanceBySourceTemplate : InstancePrototypeInstanceBySourceTemplate struct
// This model "extends" InstancePrototype
type InstancePrototypeInstanceBySourceTemplate struct {
	// The public SSH keys to install on the virtual server instance. Up to 10 keys may be provided; if no keys are
	// provided the instance will be inaccessible unless the image used provides a means of access. For Windows instances,
	// one of the keys will be used to encrypt the administrator password.
	Keys []KeyIdentityIntf `json:"keys,omitempty"`

	// The unique user-defined name for this virtual server instance (and default system hostname). If unspecified, the
	// name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// Collection of additional network interfaces to create for the virtual server instance.
	NetworkInterfaces []NetworkInterfacePrototype `json:"network_interfaces,omitempty"`

	// The placement for the virtual server instance.
	PlacementTarget InstancePlacementPrototypeIntf `json:"placement_target,omitempty"`

	// The profile to use for this virtual server instance.
	Profile InstanceProfileIdentityIntf `json:"profile,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// User data to be made available when setting up the virtual server instance.
	UserData *string `json:"user_data,omitempty"`

	// Collection of volume attachments.
	VolumeAttachments []VolumeAttachmentPrototypeInstanceContext `json:"volume_attachments,omitempty"`

	// The VPC the virtual server instance is to be a part of. If provided, must match the
	// VPC tied to the subnets of the instance's network interfaces.
	VPC VPCIdentityIntf `json:"vpc,omitempty"`

	// The boot volume attachment for the virtual server instance.
	BootVolumeAttachment *VolumeAttachmentPrototypeInstanceByImageContext `json:"boot_volume_attachment,omitempty"`

	// The identity of the image to be used when provisioning the virtual server instance.
	Image ImageIdentityIntf `json:"image,omitempty"`

	// Primary network interface.
	PrimaryNetworkInterface *NetworkInterfacePrototype `json:"primary_network_interface,omitempty"`

	// Identifies an instance template by a unique property.
	SourceTemplate InstanceTemplateIdentityIntf `json:"source_template" validate:"required"`

	// The identity of the zone to provision the virtual server instance in.
	Zone ZoneIdentityIntf `json:"zone,omitempty"`
}

// NewInstancePrototypeInstanceBySourceTemplate : Instantiate InstancePrototypeInstanceBySourceTemplate (Generic Model Constructor)
func (*VpcV1) NewInstancePrototypeInstanceBySourceTemplate(sourceTemplate InstanceTemplateIdentityIntf) (model *InstancePrototypeInstanceBySourceTemplate, err error) {
	model = &InstancePrototypeInstanceBySourceTemplate{
		SourceTemplate: sourceTemplate,
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*InstancePrototypeInstanceBySourceTemplate) isaInstancePrototype() bool {
	return true
}

// UnmarshalInstancePrototypeInstanceBySourceTemplate unmarshals an instance of InstancePrototypeInstanceBySourceTemplate from the specified map of raw messages.
func UnmarshalInstancePrototypeInstanceBySourceTemplate(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstancePrototypeInstanceBySourceTemplate)
	err = core.UnmarshalModel(m, "keys", &obj.Keys, UnmarshalKeyIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "network_interfaces", &obj.NetworkInterfaces, UnmarshalNetworkInterfacePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "placement_target", &obj.PlacementTarget, UnmarshalInstancePlacementPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "profile", &obj.Profile, UnmarshalInstanceProfileIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "user_data", &obj.UserData)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "volume_attachments", &obj.VolumeAttachments, UnmarshalVolumeAttachmentPrototypeInstanceContext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vpc", &obj.VPC, UnmarshalVPCIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "boot_volume_attachment", &obj.BootVolumeAttachment, UnmarshalVolumeAttachmentPrototypeInstanceByImageContext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "image", &obj.Image, UnmarshalImageIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "primary_network_interface", &obj.PrimaryNetworkInterface, UnmarshalNetworkInterfacePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "source_template", &obj.SourceTemplate, UnmarshalInstanceTemplateIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceTemplateIdentityByCRN : InstanceTemplateIdentityByCRN struct
// This model "extends" InstanceTemplateIdentity
type InstanceTemplateIdentityByCRN struct {
	// The CRN for this instance template.
	CRN *string `json:"crn" validate:"required"`
}

// NewInstanceTemplateIdentityByCRN : Instantiate InstanceTemplateIdentityByCRN (Generic Model Constructor)
func (*VpcV1) NewInstanceTemplateIdentityByCRN(crn string) (model *InstanceTemplateIdentityByCRN, err error) {
	model = &InstanceTemplateIdentityByCRN{
		CRN: core.StringPtr(crn),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*InstanceTemplateIdentityByCRN) isaInstanceTemplateIdentity() bool {
	return true
}

// UnmarshalInstanceTemplateIdentityByCRN unmarshals an instance of InstanceTemplateIdentityByCRN from the specified map of raw messages.
func UnmarshalInstanceTemplateIdentityByCRN(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceTemplateIdentityByCRN)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceTemplateIdentityByHref : InstanceTemplateIdentityByHref struct
// This model "extends" InstanceTemplateIdentity
type InstanceTemplateIdentityByHref struct {
	// The URL for this instance template.
	Href *string `json:"href" validate:"required"`
}

// NewInstanceTemplateIdentityByHref : Instantiate InstanceTemplateIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewInstanceTemplateIdentityByHref(href string) (model *InstanceTemplateIdentityByHref, err error) {
	model = &InstanceTemplateIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*InstanceTemplateIdentityByHref) isaInstanceTemplateIdentity() bool {
	return true
}

// UnmarshalInstanceTemplateIdentityByHref unmarshals an instance of InstanceTemplateIdentityByHref from the specified map of raw messages.
func UnmarshalInstanceTemplateIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceTemplateIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceTemplateIdentityByID : InstanceTemplateIdentityByID struct
// This model "extends" InstanceTemplateIdentity
type InstanceTemplateIdentityByID struct {
	// The unique identifier for this instance template.
	ID *string `json:"id" validate:"required"`
}

// NewInstanceTemplateIdentityByID : Instantiate InstanceTemplateIdentityByID (Generic Model Constructor)
func (*VpcV1) NewInstanceTemplateIdentityByID(id string) (model *InstanceTemplateIdentityByID, err error) {
	model = &InstanceTemplateIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*InstanceTemplateIdentityByID) isaInstanceTemplateIdentity() bool {
	return true
}

// UnmarshalInstanceTemplateIdentityByID unmarshals an instance of InstanceTemplateIdentityByID from the specified map of raw messages.
func UnmarshalInstanceTemplateIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceTemplateIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceTemplatePrototypeInstanceByImage : InstanceTemplatePrototypeInstanceByImage struct
// This model "extends" InstanceTemplatePrototype
type InstanceTemplatePrototypeInstanceByImage struct {
	// The public SSH keys to install on the virtual server instance. Up to 10 keys may be provided; if no keys are
	// provided the instance will be inaccessible unless the image used provides a means of access. For Windows instances,
	// one of the keys will be used to encrypt the administrator password.
	Keys []KeyIdentityIntf `json:"keys,omitempty"`

	// The unique user-defined name for this virtual server instance (and default system hostname). If unspecified, the
	// name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// Collection of additional network interfaces to create for the virtual server instance.
	NetworkInterfaces []NetworkInterfacePrototype `json:"network_interfaces,omitempty"`

	// The placement for the virtual server instance.
	PlacementTarget InstancePlacementPrototypeIntf `json:"placement_target,omitempty"`

	// The profile to use for this virtual server instance.
	Profile InstanceProfileIdentityIntf `json:"profile,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// User data to be made available when setting up the virtual server instance.
	UserData *string `json:"user_data,omitempty"`

	// Collection of volume attachments.
	VolumeAttachments []VolumeAttachmentPrototypeInstanceContext `json:"volume_attachments,omitempty"`

	// The VPC the virtual server instance is to be a part of. If provided, must match the
	// VPC tied to the subnets of the instance's network interfaces.
	VPC VPCIdentityIntf `json:"vpc,omitempty"`

	// The boot volume attachment for the virtual server instance.
	BootVolumeAttachment *VolumeAttachmentPrototypeInstanceByImageContext `json:"boot_volume_attachment,omitempty"`

	// The identity of the image to be used when provisioning the virtual server instance.
	Image ImageIdentityIntf `json:"image" validate:"required"`

	// Primary network interface.
	PrimaryNetworkInterface *NetworkInterfacePrototype `json:"primary_network_interface" validate:"required"`

	// The identity of the zone to provision the virtual server instance in.
	Zone ZoneIdentityIntf `json:"zone" validate:"required"`
}

// NewInstanceTemplatePrototypeInstanceByImage : Instantiate InstanceTemplatePrototypeInstanceByImage (Generic Model Constructor)
func (*VpcV1) NewInstanceTemplatePrototypeInstanceByImage(image ImageIdentityIntf, primaryNetworkInterface *NetworkInterfacePrototype, zone ZoneIdentityIntf) (model *InstanceTemplatePrototypeInstanceByImage, err error) {
	model = &InstanceTemplatePrototypeInstanceByImage{
		Image:                   image,
		PrimaryNetworkInterface: primaryNetworkInterface,
		Zone:                    zone,
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*InstanceTemplatePrototypeInstanceByImage) isaInstanceTemplatePrototype() bool {
	return true
}

// UnmarshalInstanceTemplatePrototypeInstanceByImage unmarshals an instance of InstanceTemplatePrototypeInstanceByImage from the specified map of raw messages.
func UnmarshalInstanceTemplatePrototypeInstanceByImage(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceTemplatePrototypeInstanceByImage)
	err = core.UnmarshalModel(m, "keys", &obj.Keys, UnmarshalKeyIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "network_interfaces", &obj.NetworkInterfaces, UnmarshalNetworkInterfacePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "placement_target", &obj.PlacementTarget, UnmarshalInstancePlacementPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "profile", &obj.Profile, UnmarshalInstanceProfileIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "user_data", &obj.UserData)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "volume_attachments", &obj.VolumeAttachments, UnmarshalVolumeAttachmentPrototypeInstanceContext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vpc", &obj.VPC, UnmarshalVPCIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "boot_volume_attachment", &obj.BootVolumeAttachment, UnmarshalVolumeAttachmentPrototypeInstanceByImageContext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "image", &obj.Image, UnmarshalImageIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "primary_network_interface", &obj.PrimaryNetworkInterface, UnmarshalNetworkInterfacePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceTemplatePrototypeInstanceBySourceTemplate : InstanceTemplatePrototypeInstanceBySourceTemplate struct
// This model "extends" InstanceTemplatePrototype
type InstanceTemplatePrototypeInstanceBySourceTemplate struct {
	// The public SSH keys to install on the virtual server instance. Up to 10 keys may be provided; if no keys are
	// provided the instance will be inaccessible unless the image used provides a means of access. For Windows instances,
	// one of the keys will be used to encrypt the administrator password.
	Keys []KeyIdentityIntf `json:"keys,omitempty"`

	// The unique user-defined name for this virtual server instance (and default system hostname). If unspecified, the
	// name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// Collection of additional network interfaces to create for the virtual server instance.
	NetworkInterfaces []NetworkInterfacePrototype `json:"network_interfaces,omitempty"`

	// The placement for the virtual server instance.
	PlacementTarget InstancePlacementPrototypeIntf `json:"placement_target,omitempty"`

	// The profile to use for this virtual server instance.
	Profile InstanceProfileIdentityIntf `json:"profile,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// User data to be made available when setting up the virtual server instance.
	UserData *string `json:"user_data,omitempty"`

	// Collection of volume attachments.
	VolumeAttachments []VolumeAttachmentPrototypeInstanceContext `json:"volume_attachments,omitempty"`

	// The VPC the virtual server instance is to be a part of. If provided, must match the
	// VPC tied to the subnets of the instance's network interfaces.
	VPC VPCIdentityIntf `json:"vpc,omitempty"`

	// The boot volume attachment for the virtual server instance.
	BootVolumeAttachment *VolumeAttachmentPrototypeInstanceByImageContext `json:"boot_volume_attachment,omitempty"`

	// The identity of the image to be used when provisioning the virtual server instance.
	Image ImageIdentityIntf `json:"image,omitempty"`

	// Primary network interface.
	PrimaryNetworkInterface *NetworkInterfacePrototype `json:"primary_network_interface,omitempty"`

	// Identifies an instance template by a unique property.
	SourceTemplate InstanceTemplateIdentityIntf `json:"source_template" validate:"required"`

	// The identity of the zone to provision the virtual server instance in.
	Zone ZoneIdentityIntf `json:"zone,omitempty"`
}

// NewInstanceTemplatePrototypeInstanceBySourceTemplate : Instantiate InstanceTemplatePrototypeInstanceBySourceTemplate (Generic Model Constructor)
func (*VpcV1) NewInstanceTemplatePrototypeInstanceBySourceTemplate(sourceTemplate InstanceTemplateIdentityIntf) (model *InstanceTemplatePrototypeInstanceBySourceTemplate, err error) {
	model = &InstanceTemplatePrototypeInstanceBySourceTemplate{
		SourceTemplate: sourceTemplate,
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*InstanceTemplatePrototypeInstanceBySourceTemplate) isaInstanceTemplatePrototype() bool {
	return true
}

// UnmarshalInstanceTemplatePrototypeInstanceBySourceTemplate unmarshals an instance of InstanceTemplatePrototypeInstanceBySourceTemplate from the specified map of raw messages.
func UnmarshalInstanceTemplatePrototypeInstanceBySourceTemplate(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceTemplatePrototypeInstanceBySourceTemplate)
	err = core.UnmarshalModel(m, "keys", &obj.Keys, UnmarshalKeyIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "network_interfaces", &obj.NetworkInterfaces, UnmarshalNetworkInterfacePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "placement_target", &obj.PlacementTarget, UnmarshalInstancePlacementPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "profile", &obj.Profile, UnmarshalInstanceProfileIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "user_data", &obj.UserData)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "volume_attachments", &obj.VolumeAttachments, UnmarshalVolumeAttachmentPrototypeInstanceContext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vpc", &obj.VPC, UnmarshalVPCIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "boot_volume_attachment", &obj.BootVolumeAttachment, UnmarshalVolumeAttachmentPrototypeInstanceByImageContext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "image", &obj.Image, UnmarshalImageIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "primary_network_interface", &obj.PrimaryNetworkInterface, UnmarshalNetworkInterfacePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "source_template", &obj.SourceTemplate, UnmarshalInstanceTemplateIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceTemplateInstanceByImage : InstanceTemplateInstanceByImage struct
// This model "extends" InstanceTemplate
type InstanceTemplateInstanceByImage struct {
	// The date and time that the instance template was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The CRN for this instance template.
	CRN *string `json:"crn" validate:"required"`

	// The URL for this instance template.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this instance template.
	ID *string `json:"id" validate:"required"`

	// The public SSH keys to install on the virtual server instance. Up to 10 keys may be provided; if no keys are
	// provided the instance will be inaccessible unless the image used provides a means of access. For Windows instances,
	// one of the keys will be used to encrypt the administrator password.
	Keys []KeyIdentityIntf `json:"keys,omitempty"`

	// The unique user-defined name for this instance template.
	Name *string `json:"name" validate:"required"`

	// Collection of additional network interfaces to create for the virtual server instance.
	NetworkInterfaces []NetworkInterfacePrototype `json:"network_interfaces,omitempty"`

	// The placement for the virtual server instance.
	PlacementTarget InstancePlacementPrototypeIntf `json:"placement_target,omitempty"`

	// The profile to use for this virtual server instance.
	Profile InstanceProfileIdentityIntf `json:"profile,omitempty"`

	// The resource group of the instance template.
	ResourceGroup *ResourceGroupReference `json:"resource_group" validate:"required"`

	// User data to be made available when setting up the virtual server instance.
	UserData *string `json:"user_data,omitempty"`

	// Collection of volume attachments.
	VolumeAttachments []VolumeAttachmentPrototypeInstanceContext `json:"volume_attachments,omitempty"`

	// The VPC the virtual server instance is to be a part of. If provided, must match the
	// VPC tied to the subnets of the instance's network interfaces.
	VPC VPCIdentityIntf `json:"vpc,omitempty"`

	// The boot volume attachment for the virtual server instance.
	BootVolumeAttachment *VolumeAttachmentPrototypeInstanceByImageContext `json:"boot_volume_attachment,omitempty"`

	// The identity of the image to be used when provisioning the virtual server instance.
	Image ImageIdentityIntf `json:"image" validate:"required"`

	// Primary network interface.
	PrimaryNetworkInterface *NetworkInterfacePrototype `json:"primary_network_interface" validate:"required"`

	// The identity of the zone to provision the virtual server instance in.
	Zone ZoneIdentityIntf `json:"zone" validate:"required"`
}

func (*InstanceTemplateInstanceByImage) isaInstanceTemplate() bool {
	return true
}

// UnmarshalInstanceTemplateInstanceByImage unmarshals an instance of InstanceTemplateInstanceByImage from the specified map of raw messages.
func UnmarshalInstanceTemplateInstanceByImage(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceTemplateInstanceByImage)
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "keys", &obj.Keys, UnmarshalKeyIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "network_interfaces", &obj.NetworkInterfaces, UnmarshalNetworkInterfacePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "placement_target", &obj.PlacementTarget, UnmarshalInstancePlacementPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "profile", &obj.Profile, UnmarshalInstanceProfileIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "user_data", &obj.UserData)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "volume_attachments", &obj.VolumeAttachments, UnmarshalVolumeAttachmentPrototypeInstanceContext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vpc", &obj.VPC, UnmarshalVPCIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "boot_volume_attachment", &obj.BootVolumeAttachment, UnmarshalVolumeAttachmentPrototypeInstanceByImageContext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "image", &obj.Image, UnmarshalImageIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "primary_network_interface", &obj.PrimaryNetworkInterface, UnmarshalNetworkInterfacePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstanceTemplateInstanceBySourceTemplate : InstanceTemplateInstanceBySourceTemplate struct
// This model "extends" InstanceTemplate
type InstanceTemplateInstanceBySourceTemplate struct {
	// The date and time that the instance template was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The CRN for this instance template.
	CRN *string `json:"crn" validate:"required"`

	// The URL for this instance template.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this instance template.
	ID *string `json:"id" validate:"required"`

	// The public SSH keys to install on the virtual server instance. Up to 10 keys may be provided; if no keys are
	// provided the instance will be inaccessible unless the image used provides a means of access. For Windows instances,
	// one of the keys will be used to encrypt the administrator password.
	Keys []KeyIdentityIntf `json:"keys,omitempty"`

	// The unique user-defined name for this instance template.
	Name *string `json:"name" validate:"required"`

	// Collection of additional network interfaces to create for the virtual server instance.
	NetworkInterfaces []NetworkInterfacePrototype `json:"network_interfaces,omitempty"`

	// The placement for the virtual server instance.
	PlacementTarget InstancePlacementPrototypeIntf `json:"placement_target,omitempty"`

	// The profile to use for this virtual server instance.
	Profile InstanceProfileIdentityIntf `json:"profile,omitempty"`

	// The resource group of the instance template.
	ResourceGroup *ResourceGroupReference `json:"resource_group" validate:"required"`

	// User data to be made available when setting up the virtual server instance.
	UserData *string `json:"user_data,omitempty"`

	// Collection of volume attachments.
	VolumeAttachments []VolumeAttachmentPrototypeInstanceContext `json:"volume_attachments,omitempty"`

	// The VPC the virtual server instance is to be a part of. If provided, must match the
	// VPC tied to the subnets of the instance's network interfaces.
	VPC VPCIdentityIntf `json:"vpc,omitempty"`

	// The boot volume attachment for the virtual server instance.
	BootVolumeAttachment *VolumeAttachmentPrototypeInstanceByImageContext `json:"boot_volume_attachment,omitempty"`

	// The identity of the image to be used when provisioning the virtual server instance.
	Image ImageIdentityIntf `json:"image,omitempty"`

	// Primary network interface.
	PrimaryNetworkInterface *NetworkInterfacePrototype `json:"primary_network_interface,omitempty"`

	// Identifies an instance template by a unique property.
	SourceTemplate InstanceTemplateIdentityIntf `json:"source_template" validate:"required"`

	// The identity of the zone to provision the virtual server instance in.
	Zone ZoneIdentityIntf `json:"zone,omitempty"`
}

func (*InstanceTemplateInstanceBySourceTemplate) isaInstanceTemplate() bool {
	return true
}

// UnmarshalInstanceTemplateInstanceBySourceTemplate unmarshals an instance of InstanceTemplateInstanceBySourceTemplate from the specified map of raw messages.
func UnmarshalInstanceTemplateInstanceBySourceTemplate(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstanceTemplateInstanceBySourceTemplate)
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "keys", &obj.Keys, UnmarshalKeyIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "network_interfaces", &obj.NetworkInterfaces, UnmarshalNetworkInterfacePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "placement_target", &obj.PlacementTarget, UnmarshalInstancePlacementPrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "profile", &obj.Profile, UnmarshalInstanceProfileIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "user_data", &obj.UserData)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "volume_attachments", &obj.VolumeAttachments, UnmarshalVolumeAttachmentPrototypeInstanceContext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vpc", &obj.VPC, UnmarshalVPCIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "boot_volume_attachment", &obj.BootVolumeAttachment, UnmarshalVolumeAttachmentPrototypeInstanceByImageContext)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "image", &obj.Image, UnmarshalImageIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "primary_network_interface", &obj.PrimaryNetworkInterface, UnmarshalNetworkInterfacePrototype)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "source_template", &obj.SourceTemplate, UnmarshalInstanceTemplateIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// KeyIdentityByCRN : KeyIdentityByCRN struct
// This model "extends" KeyIdentity
type KeyIdentityByCRN struct {
	// The CRN for this key.
	CRN *string `json:"crn" validate:"required"`
}

// NewKeyIdentityByCRN : Instantiate KeyIdentityByCRN (Generic Model Constructor)
func (*VpcV1) NewKeyIdentityByCRN(crn string) (model *KeyIdentityByCRN, err error) {
	model = &KeyIdentityByCRN{
		CRN: core.StringPtr(crn),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*KeyIdentityByCRN) isaKeyIdentity() bool {
	return true
}

// UnmarshalKeyIdentityByCRN unmarshals an instance of KeyIdentityByCRN from the specified map of raw messages.
func UnmarshalKeyIdentityByCRN(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(KeyIdentityByCRN)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// KeyIdentityByFingerprint : KeyIdentityByFingerprint struct
// This model "extends" KeyIdentity
type KeyIdentityByFingerprint struct {
	// The fingerprint for this key.  The value is returned base64-encoded and prefixed with the hash algorithm (always
	// `SHA256`).
	Fingerprint *string `json:"fingerprint" validate:"required"`
}

// NewKeyIdentityByFingerprint : Instantiate KeyIdentityByFingerprint (Generic Model Constructor)
func (*VpcV1) NewKeyIdentityByFingerprint(fingerprint string) (model *KeyIdentityByFingerprint, err error) {
	model = &KeyIdentityByFingerprint{
		Fingerprint: core.StringPtr(fingerprint),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*KeyIdentityByFingerprint) isaKeyIdentity() bool {
	return true
}

// UnmarshalKeyIdentityByFingerprint unmarshals an instance of KeyIdentityByFingerprint from the specified map of raw messages.
func UnmarshalKeyIdentityByFingerprint(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(KeyIdentityByFingerprint)
	err = core.UnmarshalPrimitive(m, "fingerprint", &obj.Fingerprint)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// KeyIdentityByHref : KeyIdentityByHref struct
// This model "extends" KeyIdentity
type KeyIdentityByHref struct {
	// The URL for this key.
	Href *string `json:"href" validate:"required"`
}

// NewKeyIdentityByHref : Instantiate KeyIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewKeyIdentityByHref(href string) (model *KeyIdentityByHref, err error) {
	model = &KeyIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*KeyIdentityByHref) isaKeyIdentity() bool {
	return true
}

// UnmarshalKeyIdentityByHref unmarshals an instance of KeyIdentityByHref from the specified map of raw messages.
func UnmarshalKeyIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(KeyIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// KeyIdentityByID : KeyIdentityByID struct
// This model "extends" KeyIdentity
type KeyIdentityByID struct {
	// The unique identifier for this key.
	ID *string `json:"id" validate:"required"`
}

// NewKeyIdentityByID : Instantiate KeyIdentityByID (Generic Model Constructor)
func (*VpcV1) NewKeyIdentityByID(id string) (model *KeyIdentityByID, err error) {
	model = &KeyIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*KeyIdentityByID) isaKeyIdentity() bool {
	return true
}

// UnmarshalKeyIdentityByID unmarshals an instance of KeyIdentityByID from the specified map of raw messages.
func UnmarshalKeyIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(KeyIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// KeyReferenceInstanceInitializationContextKeyIdentityByFingerprint : KeyReferenceInstanceInitializationContextKeyIdentityByFingerprint struct
// This model "extends" KeyReferenceInstanceInitializationContext
type KeyReferenceInstanceInitializationContextKeyIdentityByFingerprint struct {
	// The fingerprint for this key.  The value is returned base64-encoded and prefixed with the hash algorithm (always
	// `SHA256`).
	Fingerprint *string `json:"fingerprint" validate:"required"`
}

func (*KeyReferenceInstanceInitializationContextKeyIdentityByFingerprint) isaKeyReferenceInstanceInitializationContext() bool {
	return true
}

// UnmarshalKeyReferenceInstanceInitializationContextKeyIdentityByFingerprint unmarshals an instance of KeyReferenceInstanceInitializationContextKeyIdentityByFingerprint from the specified map of raw messages.
func UnmarshalKeyReferenceInstanceInitializationContextKeyIdentityByFingerprint(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(KeyReferenceInstanceInitializationContextKeyIdentityByFingerprint)
	err = core.UnmarshalPrimitive(m, "fingerprint", &obj.Fingerprint)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// KeyReferenceInstanceInitializationContextKeyReference : KeyReferenceInstanceInitializationContextKeyReference struct
// This model "extends" KeyReferenceInstanceInitializationContext
type KeyReferenceInstanceInitializationContextKeyReference struct {
	// The CRN for this key.
	CRN *string `json:"crn" validate:"required"`

	// The fingerprint for this key.  The value is returned base64-encoded and prefixed with the hash algorithm (always
	// `SHA256`).
	Fingerprint *string `json:"fingerprint" validate:"required"`

	// The URL for this key.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this key.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this key.
	Name *string `json:"name" validate:"required"`
}

func (*KeyReferenceInstanceInitializationContextKeyReference) isaKeyReferenceInstanceInitializationContext() bool {
	return true
}

// UnmarshalKeyReferenceInstanceInitializationContextKeyReference unmarshals an instance of KeyReferenceInstanceInitializationContextKeyReference from the specified map of raw messages.
func UnmarshalKeyReferenceInstanceInitializationContextKeyReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(KeyReferenceInstanceInitializationContextKeyReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "fingerprint", &obj.Fingerprint)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerIdentityByCRN : LoadBalancerIdentityByCRN struct
// This model "extends" LoadBalancerIdentity
type LoadBalancerIdentityByCRN struct {
	// The load balancer's CRN.
	CRN *string `json:"crn" validate:"required"`
}

// NewLoadBalancerIdentityByCRN : Instantiate LoadBalancerIdentityByCRN (Generic Model Constructor)
func (*VpcV1) NewLoadBalancerIdentityByCRN(crn string) (model *LoadBalancerIdentityByCRN, err error) {
	model = &LoadBalancerIdentityByCRN{
		CRN: core.StringPtr(crn),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*LoadBalancerIdentityByCRN) isaLoadBalancerIdentity() bool {
	return true
}

// UnmarshalLoadBalancerIdentityByCRN unmarshals an instance of LoadBalancerIdentityByCRN from the specified map of raw messages.
func UnmarshalLoadBalancerIdentityByCRN(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerIdentityByCRN)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerIdentityByHref : LoadBalancerIdentityByHref struct
// This model "extends" LoadBalancerIdentity
type LoadBalancerIdentityByHref struct {
	// The load balancer's canonical URL.
	Href *string `json:"href" validate:"required"`
}

// NewLoadBalancerIdentityByHref : Instantiate LoadBalancerIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewLoadBalancerIdentityByHref(href string) (model *LoadBalancerIdentityByHref, err error) {
	model = &LoadBalancerIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*LoadBalancerIdentityByHref) isaLoadBalancerIdentity() bool {
	return true
}

// UnmarshalLoadBalancerIdentityByHref unmarshals an instance of LoadBalancerIdentityByHref from the specified map of raw messages.
func UnmarshalLoadBalancerIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerIdentityByID : LoadBalancerIdentityByID struct
// This model "extends" LoadBalancerIdentity
type LoadBalancerIdentityByID struct {
	// The unique identifier for this load balancer.
	ID *string `json:"id" validate:"required"`
}

// NewLoadBalancerIdentityByID : Instantiate LoadBalancerIdentityByID (Generic Model Constructor)
func (*VpcV1) NewLoadBalancerIdentityByID(id string) (model *LoadBalancerIdentityByID, err error) {
	model = &LoadBalancerIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*LoadBalancerIdentityByID) isaLoadBalancerIdentity() bool {
	return true
}

// UnmarshalLoadBalancerIdentityByID unmarshals an instance of LoadBalancerIdentityByID from the specified map of raw messages.
func UnmarshalLoadBalancerIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerListenerPolicyPatchTargetLoadBalancerListenerPolicyRedirectURLPatch : LoadBalancerListenerPolicyPatchTargetLoadBalancerListenerPolicyRedirectURLPatch struct
// This model "extends" LoadBalancerListenerPolicyPatchTarget
type LoadBalancerListenerPolicyPatchTargetLoadBalancerListenerPolicyRedirectURLPatch struct {
	// The http status code in the redirect response.
	HTTPStatusCode *int64 `json:"http_status_code,omitempty"`

	// The redirect target URL.
	URL *string `json:"url,omitempty"`
}

func (*LoadBalancerListenerPolicyPatchTargetLoadBalancerListenerPolicyRedirectURLPatch) isaLoadBalancerListenerPolicyPatchTarget() bool {
	return true
}

// UnmarshalLoadBalancerListenerPolicyPatchTargetLoadBalancerListenerPolicyRedirectURLPatch unmarshals an instance of LoadBalancerListenerPolicyPatchTargetLoadBalancerListenerPolicyRedirectURLPatch from the specified map of raw messages.
func UnmarshalLoadBalancerListenerPolicyPatchTargetLoadBalancerListenerPolicyRedirectURLPatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerListenerPolicyPatchTargetLoadBalancerListenerPolicyRedirectURLPatch)
	err = core.UnmarshalPrimitive(m, "http_status_code", &obj.HTTPStatusCode)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "url", &obj.URL)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentity : Identifies a load balancer pool by a unique property.
// Models which "extend" this model:
// - LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID
// - LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref
// This model "extends" LoadBalancerListenerPolicyPatchTarget
type LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentity struct {
	// The unique identifier for this load balancer pool.
	ID *string `json:"id,omitempty"`

	// The pool's canonical URL.
	Href *string `json:"href,omitempty"`
}

func (*LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentity) isaLoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentity() bool {
	return true
}

type LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityIntf interface {
	LoadBalancerListenerPolicyPatchTargetIntf
	isaLoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentity() bool
}

func (*LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentity) isaLoadBalancerListenerPolicyPatchTarget() bool {
	return true
}

// UnmarshalLoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentity unmarshals an instance of LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentity from the specified map of raw messages.
func UnmarshalLoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerListenerPolicyPrototypeTargetLoadBalancerListenerPolicyRedirectURLPrototype : LoadBalancerListenerPolicyPrototypeTargetLoadBalancerListenerPolicyRedirectURLPrototype struct
// This model "extends" LoadBalancerListenerPolicyPrototypeTarget
type LoadBalancerListenerPolicyPrototypeTargetLoadBalancerListenerPolicyRedirectURLPrototype struct {
	// The http status code in the redirect response.
	HTTPStatusCode *int64 `json:"http_status_code" validate:"required"`

	// The redirect target URL.
	URL *string `json:"url" validate:"required"`
}

// NewLoadBalancerListenerPolicyPrototypeTargetLoadBalancerListenerPolicyRedirectURLPrototype : Instantiate LoadBalancerListenerPolicyPrototypeTargetLoadBalancerListenerPolicyRedirectURLPrototype (Generic Model Constructor)
func (*VpcV1) NewLoadBalancerListenerPolicyPrototypeTargetLoadBalancerListenerPolicyRedirectURLPrototype(httpStatusCode int64, url string) (model *LoadBalancerListenerPolicyPrototypeTargetLoadBalancerListenerPolicyRedirectURLPrototype, err error) {
	model = &LoadBalancerListenerPolicyPrototypeTargetLoadBalancerListenerPolicyRedirectURLPrototype{
		HTTPStatusCode: core.Int64Ptr(httpStatusCode),
		URL:            core.StringPtr(url),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*LoadBalancerListenerPolicyPrototypeTargetLoadBalancerListenerPolicyRedirectURLPrototype) isaLoadBalancerListenerPolicyPrototypeTarget() bool {
	return true
}

// UnmarshalLoadBalancerListenerPolicyPrototypeTargetLoadBalancerListenerPolicyRedirectURLPrototype unmarshals an instance of LoadBalancerListenerPolicyPrototypeTargetLoadBalancerListenerPolicyRedirectURLPrototype from the specified map of raw messages.
func UnmarshalLoadBalancerListenerPolicyPrototypeTargetLoadBalancerListenerPolicyRedirectURLPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerListenerPolicyPrototypeTargetLoadBalancerListenerPolicyRedirectURLPrototype)
	err = core.UnmarshalPrimitive(m, "http_status_code", &obj.HTTPStatusCode)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "url", &obj.URL)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentity : Identifies a load balancer pool by a unique property.
// Models which "extend" this model:
// - LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID
// - LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref
// This model "extends" LoadBalancerListenerPolicyPrototypeTarget
type LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentity struct {
	// The unique identifier for this load balancer pool.
	ID *string `json:"id,omitempty"`

	// The pool's canonical URL.
	Href *string `json:"href,omitempty"`
}

func (*LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentity) isaLoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentity() bool {
	return true
}

type LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityIntf interface {
	LoadBalancerListenerPolicyPrototypeTargetIntf
	isaLoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentity() bool
}

func (*LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentity) isaLoadBalancerListenerPolicyPrototypeTarget() bool {
	return true
}

// UnmarshalLoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentity unmarshals an instance of LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentity from the specified map of raw messages.
func UnmarshalLoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerListenerPolicyTargetReferenceLoadBalancerListenerPolicyRedirectURL : LoadBalancerListenerPolicyTargetReferenceLoadBalancerListenerPolicyRedirectURL struct
// This model "extends" LoadBalancerListenerPolicyTargetReference
type LoadBalancerListenerPolicyTargetReferenceLoadBalancerListenerPolicyRedirectURL struct {
	// The http status code in the redirect response.
	HTTPStatusCode *int64 `json:"http_status_code" validate:"required"`

	// The redirect target URL.
	URL *string `json:"url" validate:"required"`
}

func (*LoadBalancerListenerPolicyTargetReferenceLoadBalancerListenerPolicyRedirectURL) isaLoadBalancerListenerPolicyTargetReference() bool {
	return true
}

// UnmarshalLoadBalancerListenerPolicyTargetReferenceLoadBalancerListenerPolicyRedirectURL unmarshals an instance of LoadBalancerListenerPolicyTargetReferenceLoadBalancerListenerPolicyRedirectURL from the specified map of raw messages.
func UnmarshalLoadBalancerListenerPolicyTargetReferenceLoadBalancerListenerPolicyRedirectURL(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerListenerPolicyTargetReferenceLoadBalancerListenerPolicyRedirectURL)
	err = core.UnmarshalPrimitive(m, "http_status_code", &obj.HTTPStatusCode)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "url", &obj.URL)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerListenerPolicyTargetReferenceLoadBalancerPoolReference : LoadBalancerListenerPolicyTargetReferenceLoadBalancerPoolReference struct
// This model "extends" LoadBalancerListenerPolicyTargetReference
type LoadBalancerListenerPolicyTargetReferenceLoadBalancerPoolReference struct {
	// The pool's canonical URL.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this load balancer pool.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this load balancer pool.
	Name *string `json:"name" validate:"required"`
}

func (*LoadBalancerListenerPolicyTargetReferenceLoadBalancerPoolReference) isaLoadBalancerListenerPolicyTargetReference() bool {
	return true
}

// UnmarshalLoadBalancerListenerPolicyTargetReferenceLoadBalancerPoolReference unmarshals an instance of LoadBalancerListenerPolicyTargetReferenceLoadBalancerPoolReference from the specified map of raw messages.
func UnmarshalLoadBalancerListenerPolicyTargetReferenceLoadBalancerPoolReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerListenerPolicyTargetReferenceLoadBalancerPoolReference)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerPoolIdentityByHref : LoadBalancerPoolIdentityByHref struct
// This model "extends" LoadBalancerPoolIdentity
type LoadBalancerPoolIdentityByHref struct {
	// The pool's canonical URL.
	Href *string `json:"href" validate:"required"`
}

// NewLoadBalancerPoolIdentityByHref : Instantiate LoadBalancerPoolIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewLoadBalancerPoolIdentityByHref(href string) (model *LoadBalancerPoolIdentityByHref, err error) {
	model = &LoadBalancerPoolIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*LoadBalancerPoolIdentityByHref) isaLoadBalancerPoolIdentity() bool {
	return true
}

// UnmarshalLoadBalancerPoolIdentityByHref unmarshals an instance of LoadBalancerPoolIdentityByHref from the specified map of raw messages.
func UnmarshalLoadBalancerPoolIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerPoolIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerPoolIdentityByID : LoadBalancerPoolIdentityByID struct
// This model "extends" LoadBalancerPoolIdentity
type LoadBalancerPoolIdentityByID struct {
	// The unique identifier for this load balancer pool.
	ID *string `json:"id" validate:"required"`
}

// NewLoadBalancerPoolIdentityByID : Instantiate LoadBalancerPoolIdentityByID (Generic Model Constructor)
func (*VpcV1) NewLoadBalancerPoolIdentityByID(id string) (model *LoadBalancerPoolIdentityByID, err error) {
	model = &LoadBalancerPoolIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*LoadBalancerPoolIdentityByID) isaLoadBalancerPoolIdentity() bool {
	return true
}

// UnmarshalLoadBalancerPoolIdentityByID unmarshals an instance of LoadBalancerPoolIdentityByID from the specified map of raw messages.
func UnmarshalLoadBalancerPoolIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerPoolIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerPoolMemberTargetPrototypeIP : LoadBalancerPoolMemberTargetPrototypeIP struct
// This model "extends" LoadBalancerPoolMemberTargetPrototype
type LoadBalancerPoolMemberTargetPrototypeIP struct {
	// The IP address. This property may add support for IPv6 addresses in the future. When processing a value in this
	// property, verify that the address is in an expected format. If it is not, log an error. Optionally halt processing
	// and surface the error, or bypass the resource on which the unexpected IP address format was encountered.
	Address *string `json:"address" validate:"required"`
}

// NewLoadBalancerPoolMemberTargetPrototypeIP : Instantiate LoadBalancerPoolMemberTargetPrototypeIP (Generic Model Constructor)
func (*VpcV1) NewLoadBalancerPoolMemberTargetPrototypeIP(address string) (model *LoadBalancerPoolMemberTargetPrototypeIP, err error) {
	model = &LoadBalancerPoolMemberTargetPrototypeIP{
		Address: core.StringPtr(address),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*LoadBalancerPoolMemberTargetPrototypeIP) isaLoadBalancerPoolMemberTargetPrototype() bool {
	return true
}

// UnmarshalLoadBalancerPoolMemberTargetPrototypeIP unmarshals an instance of LoadBalancerPoolMemberTargetPrototypeIP from the specified map of raw messages.
func UnmarshalLoadBalancerPoolMemberTargetPrototypeIP(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerPoolMemberTargetPrototypeIP)
	err = core.UnmarshalPrimitive(m, "address", &obj.Address)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerPoolMemberTargetPrototypeInstanceIdentity : Identifies a virtual server instance by a unique property.
// Models which "extend" this model:
// - LoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByID
// - LoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByCRN
// - LoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByHref
// This model "extends" LoadBalancerPoolMemberTargetPrototype
type LoadBalancerPoolMemberTargetPrototypeInstanceIdentity struct {
	// The unique identifier for this virtual server instance.
	ID *string `json:"id,omitempty"`

	// The CRN for this virtual server instance.
	CRN *string `json:"crn,omitempty"`

	// The URL for this virtual server instance.
	Href *string `json:"href,omitempty"`
}

func (*LoadBalancerPoolMemberTargetPrototypeInstanceIdentity) isaLoadBalancerPoolMemberTargetPrototypeInstanceIdentity() bool {
	return true
}

type LoadBalancerPoolMemberTargetPrototypeInstanceIdentityIntf interface {
	LoadBalancerPoolMemberTargetPrototypeIntf
	isaLoadBalancerPoolMemberTargetPrototypeInstanceIdentity() bool
}

func (*LoadBalancerPoolMemberTargetPrototypeInstanceIdentity) isaLoadBalancerPoolMemberTargetPrototype() bool {
	return true
}

// UnmarshalLoadBalancerPoolMemberTargetPrototypeInstanceIdentity unmarshals an instance of LoadBalancerPoolMemberTargetPrototypeInstanceIdentity from the specified map of raw messages.
func UnmarshalLoadBalancerPoolMemberTargetPrototypeInstanceIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerPoolMemberTargetPrototypeInstanceIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerPoolMemberTargetIP : LoadBalancerPoolMemberTargetIP struct
// This model "extends" LoadBalancerPoolMemberTarget
type LoadBalancerPoolMemberTargetIP struct {
	// The IP address. This property may add support for IPv6 addresses in the future. When processing a value in this
	// property, verify that the address is in an expected format. If it is not, log an error. Optionally halt processing
	// and surface the error, or bypass the resource on which the unexpected IP address format was encountered.
	Address *string `json:"address" validate:"required"`
}

func (*LoadBalancerPoolMemberTargetIP) isaLoadBalancerPoolMemberTarget() bool {
	return true
}

// UnmarshalLoadBalancerPoolMemberTargetIP unmarshals an instance of LoadBalancerPoolMemberTargetIP from the specified map of raw messages.
func UnmarshalLoadBalancerPoolMemberTargetIP(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerPoolMemberTargetIP)
	err = core.UnmarshalPrimitive(m, "address", &obj.Address)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerPoolMemberTargetInstanceReference : LoadBalancerPoolMemberTargetInstanceReference struct
// This model "extends" LoadBalancerPoolMemberTarget
type LoadBalancerPoolMemberTargetInstanceReference struct {
	// The CRN for this virtual server instance.
	CRN *string `json:"crn" validate:"required"`

	// The URL for this virtual server instance.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this virtual server instance.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this virtual server instance (and default system hostname).
	Name *string `json:"name" validate:"required"`

	// The type of resource referenced.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the LoadBalancerPoolMemberTargetInstanceReference.ResourceType property.
// The type of resource referenced.
const (
	LoadBalancerPoolMemberTargetInstanceReferenceResourceTypeInstanceConst = "instance"
)

func (*LoadBalancerPoolMemberTargetInstanceReference) isaLoadBalancerPoolMemberTarget() bool {
	return true
}

// UnmarshalLoadBalancerPoolMemberTargetInstanceReference unmarshals an instance of LoadBalancerPoolMemberTargetInstanceReference from the specified map of raw messages.
func UnmarshalLoadBalancerPoolMemberTargetInstanceReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerPoolMemberTargetInstanceReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerProfileIdentityByHref : LoadBalancerProfileIdentityByHref struct
// This model "extends" LoadBalancerProfileIdentity
type LoadBalancerProfileIdentityByHref struct {
	// The URL for this load balancer profile.
	Href *string `json:"href" validate:"required"`
}

// NewLoadBalancerProfileIdentityByHref : Instantiate LoadBalancerProfileIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewLoadBalancerProfileIdentityByHref(href string) (model *LoadBalancerProfileIdentityByHref, err error) {
	model = &LoadBalancerProfileIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*LoadBalancerProfileIdentityByHref) isaLoadBalancerProfileIdentity() bool {
	return true
}

// UnmarshalLoadBalancerProfileIdentityByHref unmarshals an instance of LoadBalancerProfileIdentityByHref from the specified map of raw messages.
func UnmarshalLoadBalancerProfileIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerProfileIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerProfileIdentityByName : LoadBalancerProfileIdentityByName struct
// This model "extends" LoadBalancerProfileIdentity
type LoadBalancerProfileIdentityByName struct {
	// The name for this load balancer profile.
	Name *string `json:"name" validate:"required"`
}

// NewLoadBalancerProfileIdentityByName : Instantiate LoadBalancerProfileIdentityByName (Generic Model Constructor)
func (*VpcV1) NewLoadBalancerProfileIdentityByName(name string) (model *LoadBalancerProfileIdentityByName, err error) {
	model = &LoadBalancerProfileIdentityByName{
		Name: core.StringPtr(name),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*LoadBalancerProfileIdentityByName) isaLoadBalancerProfileIdentity() bool {
	return true
}

// UnmarshalLoadBalancerProfileIdentityByName unmarshals an instance of LoadBalancerProfileIdentityByName from the specified map of raw messages.
func UnmarshalLoadBalancerProfileIdentityByName(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerProfileIdentityByName)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkACLIdentityByCRN : NetworkACLIdentityByCRN struct
// This model "extends" NetworkACLIdentity
type NetworkACLIdentityByCRN struct {
	// The CRN for this network ACL.
	CRN *string `json:"crn" validate:"required"`
}

// NewNetworkACLIdentityByCRN : Instantiate NetworkACLIdentityByCRN (Generic Model Constructor)
func (*VpcV1) NewNetworkACLIdentityByCRN(crn string) (model *NetworkACLIdentityByCRN, err error) {
	model = &NetworkACLIdentityByCRN{
		CRN: core.StringPtr(crn),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*NetworkACLIdentityByCRN) isaNetworkACLIdentity() bool {
	return true
}

// UnmarshalNetworkACLIdentityByCRN unmarshals an instance of NetworkACLIdentityByCRN from the specified map of raw messages.
func UnmarshalNetworkACLIdentityByCRN(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkACLIdentityByCRN)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkACLIdentityByHref : NetworkACLIdentityByHref struct
// This model "extends" NetworkACLIdentity
type NetworkACLIdentityByHref struct {
	// The URL for this network ACL.
	Href *string `json:"href" validate:"required"`
}

// NewNetworkACLIdentityByHref : Instantiate NetworkACLIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewNetworkACLIdentityByHref(href string) (model *NetworkACLIdentityByHref, err error) {
	model = &NetworkACLIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*NetworkACLIdentityByHref) isaNetworkACLIdentity() bool {
	return true
}

// UnmarshalNetworkACLIdentityByHref unmarshals an instance of NetworkACLIdentityByHref from the specified map of raw messages.
func UnmarshalNetworkACLIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkACLIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkACLIdentityByID : NetworkACLIdentityByID struct
// This model "extends" NetworkACLIdentity
type NetworkACLIdentityByID struct {
	// The unique identifier for this network ACL.
	ID *string `json:"id" validate:"required"`
}

// NewNetworkACLIdentityByID : Instantiate NetworkACLIdentityByID (Generic Model Constructor)
func (*VpcV1) NewNetworkACLIdentityByID(id string) (model *NetworkACLIdentityByID, err error) {
	model = &NetworkACLIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*NetworkACLIdentityByID) isaNetworkACLIdentity() bool {
	return true
}

// UnmarshalNetworkACLIdentityByID unmarshals an instance of NetworkACLIdentityByID from the specified map of raw messages.
func UnmarshalNetworkACLIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkACLIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkACLPrototypeNetworkACLByRules : NetworkACLPrototypeNetworkACLByRules struct
// This model "extends" NetworkACLPrototype
type NetworkACLPrototypeNetworkACLByRules struct {
	// The user-defined name for this network ACL. Names must be unique within the VPC the Network ACL resides in. If
	// unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// The VPC this network ACL is to be a part of.
	VPC VPCIdentityIntf `json:"vpc" validate:"required"`

	// Array of prototype objects for rules to create along with this network ACL. If unspecified, no rules will be
	// created, resulting in all traffic being denied.
	Rules []NetworkACLRulePrototypeNetworkACLContextIntf `json:"rules,omitempty"`
}

// NewNetworkACLPrototypeNetworkACLByRules : Instantiate NetworkACLPrototypeNetworkACLByRules (Generic Model Constructor)
func (*VpcV1) NewNetworkACLPrototypeNetworkACLByRules(vpc VPCIdentityIntf) (model *NetworkACLPrototypeNetworkACLByRules, err error) {
	model = &NetworkACLPrototypeNetworkACLByRules{
		VPC: vpc,
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*NetworkACLPrototypeNetworkACLByRules) isaNetworkACLPrototype() bool {
	return true
}

// UnmarshalNetworkACLPrototypeNetworkACLByRules unmarshals an instance of NetworkACLPrototypeNetworkACLByRules from the specified map of raw messages.
func UnmarshalNetworkACLPrototypeNetworkACLByRules(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkACLPrototypeNetworkACLByRules)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vpc", &obj.VPC, UnmarshalVPCIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "rules", &obj.Rules, UnmarshalNetworkACLRulePrototypeNetworkACLContext)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkACLPrototypeNetworkACLBySourceNetworkACL : NetworkACLPrototypeNetworkACLBySourceNetworkACL struct
// This model "extends" NetworkACLPrototype
type NetworkACLPrototypeNetworkACLBySourceNetworkACL struct {
	// The user-defined name for this network ACL. Names must be unique within the VPC the Network ACL resides in. If
	// unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// The VPC this network ACL is to be a part of.
	VPC VPCIdentityIntf `json:"vpc" validate:"required"`

	// Network ACL to copy rules from.
	SourceNetworkACL NetworkACLIdentityIntf `json:"source_network_acl" validate:"required"`
}

// NewNetworkACLPrototypeNetworkACLBySourceNetworkACL : Instantiate NetworkACLPrototypeNetworkACLBySourceNetworkACL (Generic Model Constructor)
func (*VpcV1) NewNetworkACLPrototypeNetworkACLBySourceNetworkACL(vpc VPCIdentityIntf, sourceNetworkACL NetworkACLIdentityIntf) (model *NetworkACLPrototypeNetworkACLBySourceNetworkACL, err error) {
	model = &NetworkACLPrototypeNetworkACLBySourceNetworkACL{
		VPC:              vpc,
		SourceNetworkACL: sourceNetworkACL,
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*NetworkACLPrototypeNetworkACLBySourceNetworkACL) isaNetworkACLPrototype() bool {
	return true
}

// UnmarshalNetworkACLPrototypeNetworkACLBySourceNetworkACL unmarshals an instance of NetworkACLPrototypeNetworkACLBySourceNetworkACL from the specified map of raw messages.
func UnmarshalNetworkACLPrototypeNetworkACLBySourceNetworkACL(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkACLPrototypeNetworkACLBySourceNetworkACL)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vpc", &obj.VPC, UnmarshalVPCIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "source_network_acl", &obj.SourceNetworkACL, UnmarshalNetworkACLIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkACLRuleItemNetworkACLRuleProtocolAll : NetworkACLRuleItemNetworkACLRuleProtocolAll struct
// This model "extends" NetworkACLRuleItem
type NetworkACLRuleItemNetworkACLRuleProtocolAll struct {
	// Whether to allow or deny matching traffic.
	Action *string `json:"action" validate:"required"`

	// The rule that this rule is immediately before. If absent, this is the last rule.
	Before *NetworkACLRuleReference `json:"before,omitempty"`

	// The date and time that the rule was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The destination CIDR block. The CIDR block `0.0.0.0/0` applies to all addresses.
	Destination *string `json:"destination" validate:"required"`

	// Whether the traffic to be matched is `inbound` or `outbound`.
	Direction *string `json:"direction" validate:"required"`

	// The URL for this Network ACL rule.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this Network ACL rule.
	ID *string `json:"id" validate:"required"`

	// The IP version for this rule.
	IPVersion *string `json:"ip_version" validate:"required"`

	// The user-defined name for this rule. Names must be unique within the network ACL the rule resides in. If
	// unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name" validate:"required"`

	// The protocol to enforce.
	Protocol *string `json:"protocol,omitempty"`

	// The source CIDR block. The CIDR block `0.0.0.0/0` applies to all addresses.
	Source *string `json:"source" validate:"required"`
}

// Constants associated with the NetworkACLRuleItemNetworkACLRuleProtocolAll.Action property.
// Whether to allow or deny matching traffic.
const (
	NetworkACLRuleItemNetworkACLRuleProtocolAllActionAllowConst = "allow"
	NetworkACLRuleItemNetworkACLRuleProtocolAllActionDenyConst  = "deny"
)

// Constants associated with the NetworkACLRuleItemNetworkACLRuleProtocolAll.Direction property.
// Whether the traffic to be matched is `inbound` or `outbound`.
const (
	NetworkACLRuleItemNetworkACLRuleProtocolAllDirectionInboundConst  = "inbound"
	NetworkACLRuleItemNetworkACLRuleProtocolAllDirectionOutboundConst = "outbound"
)

// Constants associated with the NetworkACLRuleItemNetworkACLRuleProtocolAll.IPVersion property.
// The IP version for this rule.
const (
	NetworkACLRuleItemNetworkACLRuleProtocolAllIPVersionIpv4Const = "ipv4"
	NetworkACLRuleItemNetworkACLRuleProtocolAllIPVersionIpv6Const = "ipv6"
)

// Constants associated with the NetworkACLRuleItemNetworkACLRuleProtocolAll.Protocol property.
// The protocol to enforce.
const (
	NetworkACLRuleItemNetworkACLRuleProtocolAllProtocolAllConst  = "all"
	NetworkACLRuleItemNetworkACLRuleProtocolAllProtocolIcmpConst = "icmp"
	NetworkACLRuleItemNetworkACLRuleProtocolAllProtocolTCPConst  = "tcp"
	NetworkACLRuleItemNetworkACLRuleProtocolAllProtocolUDPConst  = "udp"
)

func (*NetworkACLRuleItemNetworkACLRuleProtocolAll) isaNetworkACLRuleItem() bool {
	return true
}

// UnmarshalNetworkACLRuleItemNetworkACLRuleProtocolAll unmarshals an instance of NetworkACLRuleItemNetworkACLRuleProtocolAll from the specified map of raw messages.
func UnmarshalNetworkACLRuleItemNetworkACLRuleProtocolAll(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkACLRuleItemNetworkACLRuleProtocolAll)
	err = core.UnmarshalPrimitive(m, "action", &obj.Action)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "before", &obj.Before, UnmarshalNetworkACLRuleReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "destination", &obj.Destination)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "direction", &obj.Direction)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ip_version", &obj.IPVersion)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "protocol", &obj.Protocol)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "source", &obj.Source)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkACLRuleItemNetworkACLRuleProtocolIcmp : NetworkACLRuleItemNetworkACLRuleProtocolIcmp struct
// This model "extends" NetworkACLRuleItem
type NetworkACLRuleItemNetworkACLRuleProtocolIcmp struct {
	// Whether to allow or deny matching traffic.
	Action *string `json:"action" validate:"required"`

	// The rule that this rule is immediately before. If absent, this is the last rule.
	Before *NetworkACLRuleReference `json:"before,omitempty"`

	// The date and time that the rule was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The destination CIDR block. The CIDR block `0.0.0.0/0` applies to all addresses.
	Destination *string `json:"destination" validate:"required"`

	// Whether the traffic to be matched is `inbound` or `outbound`.
	Direction *string `json:"direction" validate:"required"`

	// The URL for this Network ACL rule.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this Network ACL rule.
	ID *string `json:"id" validate:"required"`

	// The IP version for this rule.
	IPVersion *string `json:"ip_version" validate:"required"`

	// The user-defined name for this rule. Names must be unique within the network ACL the rule resides in. If
	// unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name" validate:"required"`

	// The protocol to enforce.
	Protocol *string `json:"protocol,omitempty"`

	// The source CIDR block. The CIDR block `0.0.0.0/0` applies to all addresses.
	Source *string `json:"source" validate:"required"`

	// The ICMP traffic code to allow. If unspecified, all codes are allowed. This can only be specified if type is also
	// specified.
	Code *int64 `json:"code,omitempty"`

	// The ICMP traffic type to allow. If unspecified, all types are allowed by this rule.
	Type *int64 `json:"type,omitempty"`
}

// Constants associated with the NetworkACLRuleItemNetworkACLRuleProtocolIcmp.Action property.
// Whether to allow or deny matching traffic.
const (
	NetworkACLRuleItemNetworkACLRuleProtocolIcmpActionAllowConst = "allow"
	NetworkACLRuleItemNetworkACLRuleProtocolIcmpActionDenyConst  = "deny"
)

// Constants associated with the NetworkACLRuleItemNetworkACLRuleProtocolIcmp.Direction property.
// Whether the traffic to be matched is `inbound` or `outbound`.
const (
	NetworkACLRuleItemNetworkACLRuleProtocolIcmpDirectionInboundConst  = "inbound"
	NetworkACLRuleItemNetworkACLRuleProtocolIcmpDirectionOutboundConst = "outbound"
)

// Constants associated with the NetworkACLRuleItemNetworkACLRuleProtocolIcmp.IPVersion property.
// The IP version for this rule.
const (
	NetworkACLRuleItemNetworkACLRuleProtocolIcmpIPVersionIpv4Const = "ipv4"
	NetworkACLRuleItemNetworkACLRuleProtocolIcmpIPVersionIpv6Const = "ipv6"
)

// Constants associated with the NetworkACLRuleItemNetworkACLRuleProtocolIcmp.Protocol property.
// The protocol to enforce.
const (
	NetworkACLRuleItemNetworkACLRuleProtocolIcmpProtocolAllConst  = "all"
	NetworkACLRuleItemNetworkACLRuleProtocolIcmpProtocolIcmpConst = "icmp"
	NetworkACLRuleItemNetworkACLRuleProtocolIcmpProtocolTCPConst  = "tcp"
	NetworkACLRuleItemNetworkACLRuleProtocolIcmpProtocolUDPConst  = "udp"
)

func (*NetworkACLRuleItemNetworkACLRuleProtocolIcmp) isaNetworkACLRuleItem() bool {
	return true
}

// UnmarshalNetworkACLRuleItemNetworkACLRuleProtocolIcmp unmarshals an instance of NetworkACLRuleItemNetworkACLRuleProtocolIcmp from the specified map of raw messages.
func UnmarshalNetworkACLRuleItemNetworkACLRuleProtocolIcmp(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkACLRuleItemNetworkACLRuleProtocolIcmp)
	err = core.UnmarshalPrimitive(m, "action", &obj.Action)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "before", &obj.Before, UnmarshalNetworkACLRuleReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "destination", &obj.Destination)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "direction", &obj.Direction)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ip_version", &obj.IPVersion)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "protocol", &obj.Protocol)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "source", &obj.Source)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "code", &obj.Code)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkACLRuleItemNetworkACLRuleProtocolTcpudp : NetworkACLRuleItemNetworkACLRuleProtocolTcpudp struct
// This model "extends" NetworkACLRuleItem
type NetworkACLRuleItemNetworkACLRuleProtocolTcpudp struct {
	// Whether to allow or deny matching traffic.
	Action *string `json:"action" validate:"required"`

	// The rule that this rule is immediately before. If absent, this is the last rule.
	Before *NetworkACLRuleReference `json:"before,omitempty"`

	// The date and time that the rule was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The destination CIDR block. The CIDR block `0.0.0.0/0` applies to all addresses.
	Destination *string `json:"destination" validate:"required"`

	// Whether the traffic to be matched is `inbound` or `outbound`.
	Direction *string `json:"direction" validate:"required"`

	// The URL for this Network ACL rule.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this Network ACL rule.
	ID *string `json:"id" validate:"required"`

	// The IP version for this rule.
	IPVersion *string `json:"ip_version" validate:"required"`

	// The user-defined name for this rule. Names must be unique within the network ACL the rule resides in. If
	// unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name" validate:"required"`

	// The protocol to enforce.
	Protocol *string `json:"protocol,omitempty"`

	// The source CIDR block. The CIDR block `0.0.0.0/0` applies to all addresses.
	Source *string `json:"source" validate:"required"`

	// The inclusive upper bound of TCP/UDP destination port range.
	DestinationPortMax *int64 `json:"destination_port_max,omitempty"`

	// The inclusive lower bound of TCP/UDP destination port range.
	DestinationPortMin *int64 `json:"destination_port_min,omitempty"`

	// The inclusive upper bound of TCP/UDP source port range.
	SourcePortMax *int64 `json:"source_port_max,omitempty"`

	// The inclusive lower bound of TCP/UDP source port range.
	SourcePortMin *int64 `json:"source_port_min,omitempty"`
}

// Constants associated with the NetworkACLRuleItemNetworkACLRuleProtocolTcpudp.Action property.
// Whether to allow or deny matching traffic.
const (
	NetworkACLRuleItemNetworkACLRuleProtocolTcpudpActionAllowConst = "allow"
	NetworkACLRuleItemNetworkACLRuleProtocolTcpudpActionDenyConst  = "deny"
)

// Constants associated with the NetworkACLRuleItemNetworkACLRuleProtocolTcpudp.Direction property.
// Whether the traffic to be matched is `inbound` or `outbound`.
const (
	NetworkACLRuleItemNetworkACLRuleProtocolTcpudpDirectionInboundConst  = "inbound"
	NetworkACLRuleItemNetworkACLRuleProtocolTcpudpDirectionOutboundConst = "outbound"
)

// Constants associated with the NetworkACLRuleItemNetworkACLRuleProtocolTcpudp.IPVersion property.
// The IP version for this rule.
const (
	NetworkACLRuleItemNetworkACLRuleProtocolTcpudpIPVersionIpv4Const = "ipv4"
	NetworkACLRuleItemNetworkACLRuleProtocolTcpudpIPVersionIpv6Const = "ipv6"
)

// Constants associated with the NetworkACLRuleItemNetworkACLRuleProtocolTcpudp.Protocol property.
// The protocol to enforce.
const (
	NetworkACLRuleItemNetworkACLRuleProtocolTcpudpProtocolAllConst  = "all"
	NetworkACLRuleItemNetworkACLRuleProtocolTcpudpProtocolIcmpConst = "icmp"
	NetworkACLRuleItemNetworkACLRuleProtocolTcpudpProtocolTCPConst  = "tcp"
	NetworkACLRuleItemNetworkACLRuleProtocolTcpudpProtocolUDPConst  = "udp"
)

func (*NetworkACLRuleItemNetworkACLRuleProtocolTcpudp) isaNetworkACLRuleItem() bool {
	return true
}

// UnmarshalNetworkACLRuleItemNetworkACLRuleProtocolTcpudp unmarshals an instance of NetworkACLRuleItemNetworkACLRuleProtocolTcpudp from the specified map of raw messages.
func UnmarshalNetworkACLRuleItemNetworkACLRuleProtocolTcpudp(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkACLRuleItemNetworkACLRuleProtocolTcpudp)
	err = core.UnmarshalPrimitive(m, "action", &obj.Action)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "before", &obj.Before, UnmarshalNetworkACLRuleReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "destination", &obj.Destination)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "direction", &obj.Direction)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ip_version", &obj.IPVersion)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "protocol", &obj.Protocol)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "source", &obj.Source)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "destination_port_max", &obj.DestinationPortMax)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "destination_port_min", &obj.DestinationPortMin)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "source_port_max", &obj.SourcePortMax)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "source_port_min", &obj.SourcePortMin)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkACLRulePatchBeforeNetworkACLRuleIdentityByHref : NetworkACLRulePatchBeforeNetworkACLRuleIdentityByHref struct
// This model "extends" NetworkACLRulePatchBefore
type NetworkACLRulePatchBeforeNetworkACLRuleIdentityByHref struct {
	// The URL for this Network ACL rule.
	Href *string `json:"href" validate:"required"`
}

// NewNetworkACLRulePatchBeforeNetworkACLRuleIdentityByHref : Instantiate NetworkACLRulePatchBeforeNetworkACLRuleIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewNetworkACLRulePatchBeforeNetworkACLRuleIdentityByHref(href string) (model *NetworkACLRulePatchBeforeNetworkACLRuleIdentityByHref, err error) {
	model = &NetworkACLRulePatchBeforeNetworkACLRuleIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*NetworkACLRulePatchBeforeNetworkACLRuleIdentityByHref) isaNetworkACLRulePatchBefore() bool {
	return true
}

// UnmarshalNetworkACLRulePatchBeforeNetworkACLRuleIdentityByHref unmarshals an instance of NetworkACLRulePatchBeforeNetworkACLRuleIdentityByHref from the specified map of raw messages.
func UnmarshalNetworkACLRulePatchBeforeNetworkACLRuleIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkACLRulePatchBeforeNetworkACLRuleIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkACLRulePatchBeforeNetworkACLRuleIdentityByID : NetworkACLRulePatchBeforeNetworkACLRuleIdentityByID struct
// This model "extends" NetworkACLRulePatchBefore
type NetworkACLRulePatchBeforeNetworkACLRuleIdentityByID struct {
	// The unique identifier for this Network ACL rule.
	ID *string `json:"id" validate:"required"`
}

// NewNetworkACLRulePatchBeforeNetworkACLRuleIdentityByID : Instantiate NetworkACLRulePatchBeforeNetworkACLRuleIdentityByID (Generic Model Constructor)
func (*VpcV1) NewNetworkACLRulePatchBeforeNetworkACLRuleIdentityByID(id string) (model *NetworkACLRulePatchBeforeNetworkACLRuleIdentityByID, err error) {
	model = &NetworkACLRulePatchBeforeNetworkACLRuleIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*NetworkACLRulePatchBeforeNetworkACLRuleIdentityByID) isaNetworkACLRulePatchBefore() bool {
	return true
}

// UnmarshalNetworkACLRulePatchBeforeNetworkACLRuleIdentityByID unmarshals an instance of NetworkACLRulePatchBeforeNetworkACLRuleIdentityByID from the specified map of raw messages.
func UnmarshalNetworkACLRulePatchBeforeNetworkACLRuleIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkACLRulePatchBeforeNetworkACLRuleIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkACLRuleProtocolAll : NetworkACLRuleProtocolAll struct
// This model "extends" NetworkACLRule
type NetworkACLRuleProtocolAll struct {
	// Whether to allow or deny matching traffic.
	Action *string `json:"action" validate:"required"`

	// The rule that this rule is immediately before. If absent, this is the last rule.
	Before *NetworkACLRuleReference `json:"before,omitempty"`

	// The date and time that the rule was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The destination CIDR block. The CIDR block `0.0.0.0/0` applies to all addresses.
	Destination *string `json:"destination" validate:"required"`

	// Whether the traffic to be matched is `inbound` or `outbound`.
	Direction *string `json:"direction" validate:"required"`

	// The URL for this Network ACL rule.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this Network ACL rule.
	ID *string `json:"id" validate:"required"`

	// The IP version for this rule.
	IPVersion *string `json:"ip_version" validate:"required"`

	// The user-defined name for this rule. Names must be unique within the network ACL the rule resides in. If
	// unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name" validate:"required"`

	// The protocol to enforce.
	Protocol *string `json:"protocol,omitempty"`

	// The source CIDR block. The CIDR block `0.0.0.0/0` applies to all addresses.
	Source *string `json:"source" validate:"required"`
}

// Constants associated with the NetworkACLRuleProtocolAll.Action property.
// Whether to allow or deny matching traffic.
const (
	NetworkACLRuleProtocolAllActionAllowConst = "allow"
	NetworkACLRuleProtocolAllActionDenyConst  = "deny"
)

// Constants associated with the NetworkACLRuleProtocolAll.Direction property.
// Whether the traffic to be matched is `inbound` or `outbound`.
const (
	NetworkACLRuleProtocolAllDirectionInboundConst  = "inbound"
	NetworkACLRuleProtocolAllDirectionOutboundConst = "outbound"
)

// Constants associated with the NetworkACLRuleProtocolAll.IPVersion property.
// The IP version for this rule.
const (
	NetworkACLRuleProtocolAllIPVersionIpv4Const = "ipv4"
	NetworkACLRuleProtocolAllIPVersionIpv6Const = "ipv6"
)

// Constants associated with the NetworkACLRuleProtocolAll.Protocol property.
// The protocol to enforce.
const (
	NetworkACLRuleProtocolAllProtocolAllConst  = "all"
	NetworkACLRuleProtocolAllProtocolIcmpConst = "icmp"
	NetworkACLRuleProtocolAllProtocolTCPConst  = "tcp"
	NetworkACLRuleProtocolAllProtocolUDPConst  = "udp"
)

func (*NetworkACLRuleProtocolAll) isaNetworkACLRule() bool {
	return true
}

// UnmarshalNetworkACLRuleProtocolAll unmarshals an instance of NetworkACLRuleProtocolAll from the specified map of raw messages.
func UnmarshalNetworkACLRuleProtocolAll(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkACLRuleProtocolAll)
	err = core.UnmarshalPrimitive(m, "action", &obj.Action)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "before", &obj.Before, UnmarshalNetworkACLRuleReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "destination", &obj.Destination)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "direction", &obj.Direction)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ip_version", &obj.IPVersion)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "protocol", &obj.Protocol)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "source", &obj.Source)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkACLRuleProtocolIcmp : NetworkACLRuleProtocolIcmp struct
// This model "extends" NetworkACLRule
type NetworkACLRuleProtocolIcmp struct {
	// Whether to allow or deny matching traffic.
	Action *string `json:"action" validate:"required"`

	// The rule that this rule is immediately before. If absent, this is the last rule.
	Before *NetworkACLRuleReference `json:"before,omitempty"`

	// The date and time that the rule was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The destination CIDR block. The CIDR block `0.0.0.0/0` applies to all addresses.
	Destination *string `json:"destination" validate:"required"`

	// Whether the traffic to be matched is `inbound` or `outbound`.
	Direction *string `json:"direction" validate:"required"`

	// The URL for this Network ACL rule.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this Network ACL rule.
	ID *string `json:"id" validate:"required"`

	// The IP version for this rule.
	IPVersion *string `json:"ip_version" validate:"required"`

	// The user-defined name for this rule. Names must be unique within the network ACL the rule resides in. If
	// unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name" validate:"required"`

	// The protocol to enforce.
	Protocol *string `json:"protocol,omitempty"`

	// The source CIDR block. The CIDR block `0.0.0.0/0` applies to all addresses.
	Source *string `json:"source" validate:"required"`

	// The ICMP traffic code to allow. If unspecified, all codes are allowed. This can only be specified if type is also
	// specified.
	Code *int64 `json:"code,omitempty"`

	// The ICMP traffic type to allow. If unspecified, all types are allowed by this rule.
	Type *int64 `json:"type,omitempty"`
}

// Constants associated with the NetworkACLRuleProtocolIcmp.Action property.
// Whether to allow or deny matching traffic.
const (
	NetworkACLRuleProtocolIcmpActionAllowConst = "allow"
	NetworkACLRuleProtocolIcmpActionDenyConst  = "deny"
)

// Constants associated with the NetworkACLRuleProtocolIcmp.Direction property.
// Whether the traffic to be matched is `inbound` or `outbound`.
const (
	NetworkACLRuleProtocolIcmpDirectionInboundConst  = "inbound"
	NetworkACLRuleProtocolIcmpDirectionOutboundConst = "outbound"
)

// Constants associated with the NetworkACLRuleProtocolIcmp.IPVersion property.
// The IP version for this rule.
const (
	NetworkACLRuleProtocolIcmpIPVersionIpv4Const = "ipv4"
	NetworkACLRuleProtocolIcmpIPVersionIpv6Const = "ipv6"
)

// Constants associated with the NetworkACLRuleProtocolIcmp.Protocol property.
// The protocol to enforce.
const (
	NetworkACLRuleProtocolIcmpProtocolAllConst  = "all"
	NetworkACLRuleProtocolIcmpProtocolIcmpConst = "icmp"
	NetworkACLRuleProtocolIcmpProtocolTCPConst  = "tcp"
	NetworkACLRuleProtocolIcmpProtocolUDPConst  = "udp"
)

func (*NetworkACLRuleProtocolIcmp) isaNetworkACLRule() bool {
	return true
}

// UnmarshalNetworkACLRuleProtocolIcmp unmarshals an instance of NetworkACLRuleProtocolIcmp from the specified map of raw messages.
func UnmarshalNetworkACLRuleProtocolIcmp(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkACLRuleProtocolIcmp)
	err = core.UnmarshalPrimitive(m, "action", &obj.Action)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "before", &obj.Before, UnmarshalNetworkACLRuleReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "destination", &obj.Destination)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "direction", &obj.Direction)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ip_version", &obj.IPVersion)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "protocol", &obj.Protocol)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "source", &obj.Source)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "code", &obj.Code)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkACLRuleProtocolTcpudp : NetworkACLRuleProtocolTcpudp struct
// This model "extends" NetworkACLRule
type NetworkACLRuleProtocolTcpudp struct {
	// Whether to allow or deny matching traffic.
	Action *string `json:"action" validate:"required"`

	// The rule that this rule is immediately before. If absent, this is the last rule.
	Before *NetworkACLRuleReference `json:"before,omitempty"`

	// The date and time that the rule was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The destination CIDR block. The CIDR block `0.0.0.0/0` applies to all addresses.
	Destination *string `json:"destination" validate:"required"`

	// Whether the traffic to be matched is `inbound` or `outbound`.
	Direction *string `json:"direction" validate:"required"`

	// The URL for this Network ACL rule.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this Network ACL rule.
	ID *string `json:"id" validate:"required"`

	// The IP version for this rule.
	IPVersion *string `json:"ip_version" validate:"required"`

	// The user-defined name for this rule. Names must be unique within the network ACL the rule resides in. If
	// unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name" validate:"required"`

	// The protocol to enforce.
	Protocol *string `json:"protocol,omitempty"`

	// The source CIDR block. The CIDR block `0.0.0.0/0` applies to all addresses.
	Source *string `json:"source" validate:"required"`

	// The inclusive upper bound of TCP/UDP destination port range.
	DestinationPortMax *int64 `json:"destination_port_max,omitempty"`

	// The inclusive lower bound of TCP/UDP destination port range.
	DestinationPortMin *int64 `json:"destination_port_min,omitempty"`

	// The inclusive upper bound of TCP/UDP source port range.
	SourcePortMax *int64 `json:"source_port_max,omitempty"`

	// The inclusive lower bound of TCP/UDP source port range.
	SourcePortMin *int64 `json:"source_port_min,omitempty"`
}

// Constants associated with the NetworkACLRuleProtocolTcpudp.Action property.
// Whether to allow or deny matching traffic.
const (
	NetworkACLRuleProtocolTcpudpActionAllowConst = "allow"
	NetworkACLRuleProtocolTcpudpActionDenyConst  = "deny"
)

// Constants associated with the NetworkACLRuleProtocolTcpudp.Direction property.
// Whether the traffic to be matched is `inbound` or `outbound`.
const (
	NetworkACLRuleProtocolTcpudpDirectionInboundConst  = "inbound"
	NetworkACLRuleProtocolTcpudpDirectionOutboundConst = "outbound"
)

// Constants associated with the NetworkACLRuleProtocolTcpudp.IPVersion property.
// The IP version for this rule.
const (
	NetworkACLRuleProtocolTcpudpIPVersionIpv4Const = "ipv4"
	NetworkACLRuleProtocolTcpudpIPVersionIpv6Const = "ipv6"
)

// Constants associated with the NetworkACLRuleProtocolTcpudp.Protocol property.
// The protocol to enforce.
const (
	NetworkACLRuleProtocolTcpudpProtocolAllConst  = "all"
	NetworkACLRuleProtocolTcpudpProtocolIcmpConst = "icmp"
	NetworkACLRuleProtocolTcpudpProtocolTCPConst  = "tcp"
	NetworkACLRuleProtocolTcpudpProtocolUDPConst  = "udp"
)

func (*NetworkACLRuleProtocolTcpudp) isaNetworkACLRule() bool {
	return true
}

// UnmarshalNetworkACLRuleProtocolTcpudp unmarshals an instance of NetworkACLRuleProtocolTcpudp from the specified map of raw messages.
func UnmarshalNetworkACLRuleProtocolTcpudp(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkACLRuleProtocolTcpudp)
	err = core.UnmarshalPrimitive(m, "action", &obj.Action)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "before", &obj.Before, UnmarshalNetworkACLRuleReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "destination", &obj.Destination)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "direction", &obj.Direction)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ip_version", &obj.IPVersion)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "protocol", &obj.Protocol)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "source", &obj.Source)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "destination_port_max", &obj.DestinationPortMax)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "destination_port_min", &obj.DestinationPortMin)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "source_port_max", &obj.SourcePortMax)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "source_port_min", &obj.SourcePortMin)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByHref : NetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByHref struct
// This model "extends" NetworkACLRulePrototypeBefore
type NetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByHref struct {
	// The URL for this Network ACL rule.
	Href *string `json:"href" validate:"required"`
}

// NewNetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByHref : Instantiate NetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewNetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByHref(href string) (model *NetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByHref, err error) {
	model = &NetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*NetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByHref) isaNetworkACLRulePrototypeBefore() bool {
	return true
}

// UnmarshalNetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByHref unmarshals an instance of NetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByHref from the specified map of raw messages.
func UnmarshalNetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByID : NetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByID struct
// This model "extends" NetworkACLRulePrototypeBefore
type NetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByID struct {
	// The unique identifier for this Network ACL rule.
	ID *string `json:"id" validate:"required"`
}

// NewNetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByID : Instantiate NetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByID (Generic Model Constructor)
func (*VpcV1) NewNetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByID(id string) (model *NetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByID, err error) {
	model = &NetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*NetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByID) isaNetworkACLRulePrototypeBefore() bool {
	return true
}

// UnmarshalNetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByID unmarshals an instance of NetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByID from the specified map of raw messages.
func UnmarshalNetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkACLRulePrototypeBeforeNetworkACLRuleIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAll : NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAll struct
// This model "extends" NetworkACLRulePrototypeNetworkACLContext
type NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAll struct {
	// Whether to allow or deny matching traffic.
	Action *string `json:"action" validate:"required"`

	// The rule that this rule is immediately before. If absent, this is the last rule.
	Before *NetworkACLRuleReference `json:"before,omitempty"`

	// The date and time that the rule was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The destination CIDR block. The CIDR block `0.0.0.0/0` applies to all addresses.
	Destination *string `json:"destination" validate:"required"`

	// Whether the traffic to be matched is `inbound` or `outbound`.
	Direction *string `json:"direction" validate:"required"`

	// The URL for this Network ACL rule.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this Network ACL rule.
	ID *string `json:"id" validate:"required"`

	// The IP version for this rule.
	IPVersion *string `json:"ip_version" validate:"required"`

	// The user-defined name for this rule. Names must be unique within the network ACL the rule resides in. If
	// unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name" validate:"required"`

	// The protocol to enforce.
	Protocol *string `json:"protocol,omitempty"`

	// The source CIDR block. The CIDR block `0.0.0.0/0` applies to all addresses.
	Source *string `json:"source" validate:"required"`
}

// Constants associated with the NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAll.Action property.
// Whether to allow or deny matching traffic.
const (
	NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAllActionAllowConst = "allow"
	NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAllActionDenyConst  = "deny"
)

// Constants associated with the NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAll.Direction property.
// Whether the traffic to be matched is `inbound` or `outbound`.
const (
	NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAllDirectionInboundConst  = "inbound"
	NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAllDirectionOutboundConst = "outbound"
)

// Constants associated with the NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAll.IPVersion property.
// The IP version for this rule.
const (
	NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAllIPVersionIpv4Const = "ipv4"
	NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAllIPVersionIpv6Const = "ipv6"
)

// Constants associated with the NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAll.Protocol property.
// The protocol to enforce.
const (
	NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAllProtocolAllConst  = "all"
	NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAllProtocolIcmpConst = "icmp"
	NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAllProtocolTCPConst  = "tcp"
	NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAllProtocolUDPConst  = "udp"
)

// NewNetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAll : Instantiate NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAll (Generic Model Constructor)
func (*VpcV1) NewNetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAll(action string, createdAt *strfmt.DateTime, destination string, direction string, href string, id string, ipVersion string, name string, source string) (model *NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAll, err error) {
	model = &NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAll{
		Action:      core.StringPtr(action),
		CreatedAt:   createdAt,
		Destination: core.StringPtr(destination),
		Direction:   core.StringPtr(direction),
		Href:        core.StringPtr(href),
		ID:          core.StringPtr(id),
		IPVersion:   core.StringPtr(ipVersion),
		Name:        core.StringPtr(name),
		Source:      core.StringPtr(source),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAll) isaNetworkACLRulePrototypeNetworkACLContext() bool {
	return true
}

// UnmarshalNetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAll unmarshals an instance of NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAll from the specified map of raw messages.
func UnmarshalNetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAll(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolAll)
	err = core.UnmarshalPrimitive(m, "action", &obj.Action)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "before", &obj.Before, UnmarshalNetworkACLRuleReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "destination", &obj.Destination)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "direction", &obj.Direction)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ip_version", &obj.IPVersion)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "protocol", &obj.Protocol)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "source", &obj.Source)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolIcmp : NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolIcmp struct
// This model "extends" NetworkACLRulePrototypeNetworkACLContext
type NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolIcmp struct {
	// Whether to allow or deny matching traffic.
	Action *string `json:"action" validate:"required"`

	// The rule that this rule is immediately before. If absent, this is the last rule.
	Before *NetworkACLRuleReference `json:"before,omitempty"`

	// The date and time that the rule was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The destination CIDR block. The CIDR block `0.0.0.0/0` applies to all addresses.
	Destination *string `json:"destination" validate:"required"`

	// Whether the traffic to be matched is `inbound` or `outbound`.
	Direction *string `json:"direction" validate:"required"`

	// The URL for this Network ACL rule.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this Network ACL rule.
	ID *string `json:"id" validate:"required"`

	// The IP version for this rule.
	IPVersion *string `json:"ip_version" validate:"required"`

	// The user-defined name for this rule. Names must be unique within the network ACL the rule resides in. If
	// unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name" validate:"required"`

	// The protocol to enforce.
	Protocol *string `json:"protocol,omitempty"`

	// The source CIDR block. The CIDR block `0.0.0.0/0` applies to all addresses.
	Source *string `json:"source" validate:"required"`

	// The ICMP traffic code to allow. If unspecified, all codes are allowed. This can only be specified if type is also
	// specified.
	Code *int64 `json:"code,omitempty"`

	// The ICMP traffic type to allow. If unspecified, all types are allowed by this rule.
	Type *int64 `json:"type,omitempty"`
}

// Constants associated with the NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolIcmp.Action property.
// Whether to allow or deny matching traffic.
const (
	NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolIcmpActionAllowConst = "allow"
	NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolIcmpActionDenyConst  = "deny"
)

// Constants associated with the NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolIcmp.Direction property.
// Whether the traffic to be matched is `inbound` or `outbound`.
const (
	NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolIcmpDirectionInboundConst  = "inbound"
	NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolIcmpDirectionOutboundConst = "outbound"
)

// Constants associated with the NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolIcmp.IPVersion property.
// The IP version for this rule.
const (
	NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolIcmpIPVersionIpv4Const = "ipv4"
	NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolIcmpIPVersionIpv6Const = "ipv6"
)

// Constants associated with the NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolIcmp.Protocol property.
// The protocol to enforce.
const (
	NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolIcmpProtocolAllConst  = "all"
	NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolIcmpProtocolIcmpConst = "icmp"
	NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolIcmpProtocolTCPConst  = "tcp"
	NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolIcmpProtocolUDPConst  = "udp"
)

// NewNetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolIcmp : Instantiate NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolIcmp (Generic Model Constructor)
func (*VpcV1) NewNetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolIcmp(action string, createdAt *strfmt.DateTime, destination string, direction string, href string, id string, ipVersion string, name string, source string) (model *NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolIcmp, err error) {
	model = &NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolIcmp{
		Action:      core.StringPtr(action),
		CreatedAt:   createdAt,
		Destination: core.StringPtr(destination),
		Direction:   core.StringPtr(direction),
		Href:        core.StringPtr(href),
		ID:          core.StringPtr(id),
		IPVersion:   core.StringPtr(ipVersion),
		Name:        core.StringPtr(name),
		Source:      core.StringPtr(source),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolIcmp) isaNetworkACLRulePrototypeNetworkACLContext() bool {
	return true
}

// UnmarshalNetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolIcmp unmarshals an instance of NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolIcmp from the specified map of raw messages.
func UnmarshalNetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolIcmp(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolIcmp)
	err = core.UnmarshalPrimitive(m, "action", &obj.Action)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "before", &obj.Before, UnmarshalNetworkACLRuleReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "destination", &obj.Destination)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "direction", &obj.Direction)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ip_version", &obj.IPVersion)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "protocol", &obj.Protocol)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "source", &obj.Source)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "code", &obj.Code)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTcpudp : NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTcpudp struct
// This model "extends" NetworkACLRulePrototypeNetworkACLContext
type NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTcpudp struct {
	// Whether to allow or deny matching traffic.
	Action *string `json:"action" validate:"required"`

	// The rule that this rule is immediately before. If absent, this is the last rule.
	Before *NetworkACLRuleReference `json:"before,omitempty"`

	// The date and time that the rule was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The destination CIDR block. The CIDR block `0.0.0.0/0` applies to all addresses.
	Destination *string `json:"destination" validate:"required"`

	// Whether the traffic to be matched is `inbound` or `outbound`.
	Direction *string `json:"direction" validate:"required"`

	// The URL for this Network ACL rule.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this Network ACL rule.
	ID *string `json:"id" validate:"required"`

	// The IP version for this rule.
	IPVersion *string `json:"ip_version" validate:"required"`

	// The user-defined name for this rule. Names must be unique within the network ACL the rule resides in. If
	// unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name" validate:"required"`

	// The protocol to enforce.
	Protocol *string `json:"protocol,omitempty"`

	// The source CIDR block. The CIDR block `0.0.0.0/0` applies to all addresses.
	Source *string `json:"source" validate:"required"`

	// The inclusive upper bound of TCP/UDP destination port range.
	DestinationPortMax *int64 `json:"destination_port_max,omitempty"`

	// The inclusive lower bound of TCP/UDP destination port range.
	DestinationPortMin *int64 `json:"destination_port_min,omitempty"`

	// The inclusive upper bound of TCP/UDP source port range.
	SourcePortMax *int64 `json:"source_port_max,omitempty"`

	// The inclusive lower bound of TCP/UDP source port range.
	SourcePortMin *int64 `json:"source_port_min,omitempty"`
}

// Constants associated with the NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTcpudp.Action property.
// Whether to allow or deny matching traffic.
const (
	NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTcpudpActionAllowConst = "allow"
	NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTcpudpActionDenyConst  = "deny"
)

// Constants associated with the NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTcpudp.Direction property.
// Whether the traffic to be matched is `inbound` or `outbound`.
const (
	NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTcpudpDirectionInboundConst  = "inbound"
	NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTcpudpDirectionOutboundConst = "outbound"
)

// Constants associated with the NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTcpudp.IPVersion property.
// The IP version for this rule.
const (
	NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTcpudpIPVersionIpv4Const = "ipv4"
	NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTcpudpIPVersionIpv6Const = "ipv6"
)

// Constants associated with the NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTcpudp.Protocol property.
// The protocol to enforce.
const (
	NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTcpudpProtocolAllConst  = "all"
	NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTcpudpProtocolIcmpConst = "icmp"
	NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTcpudpProtocolTCPConst  = "tcp"
	NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTcpudpProtocolUDPConst  = "udp"
)

// NewNetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTcpudp : Instantiate NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTcpudp (Generic Model Constructor)
func (*VpcV1) NewNetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTcpudp(action string, createdAt *strfmt.DateTime, destination string, direction string, href string, id string, ipVersion string, name string, source string) (model *NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTcpudp, err error) {
	model = &NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTcpudp{
		Action:      core.StringPtr(action),
		CreatedAt:   createdAt,
		Destination: core.StringPtr(destination),
		Direction:   core.StringPtr(direction),
		Href:        core.StringPtr(href),
		ID:          core.StringPtr(id),
		IPVersion:   core.StringPtr(ipVersion),
		Name:        core.StringPtr(name),
		Source:      core.StringPtr(source),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTcpudp) isaNetworkACLRulePrototypeNetworkACLContext() bool {
	return true
}

// UnmarshalNetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTcpudp unmarshals an instance of NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTcpudp from the specified map of raw messages.
func UnmarshalNetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTcpudp(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkACLRulePrototypeNetworkACLContextNetworkACLRuleProtocolTcpudp)
	err = core.UnmarshalPrimitive(m, "action", &obj.Action)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "before", &obj.Before, UnmarshalNetworkACLRuleReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "destination", &obj.Destination)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "direction", &obj.Direction)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ip_version", &obj.IPVersion)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "protocol", &obj.Protocol)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "source", &obj.Source)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "destination_port_max", &obj.DestinationPortMax)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "destination_port_min", &obj.DestinationPortMin)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "source_port_max", &obj.SourcePortMax)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "source_port_min", &obj.SourcePortMin)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkACLRulePrototypeNetworkACLRuleProtocolAll : NetworkACLRulePrototypeNetworkACLRuleProtocolAll struct
// This model "extends" NetworkACLRulePrototype
type NetworkACLRulePrototypeNetworkACLRuleProtocolAll struct {
	// Whether to allow or deny matching traffic.
	Action *string `json:"action" validate:"required"`

	// The rule that this rule is immediately before. If absent, this is the last rule.
	Before *NetworkACLRuleReference `json:"before,omitempty"`

	// The date and time that the rule was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The destination CIDR block. The CIDR block `0.0.0.0/0` applies to all addresses.
	Destination *string `json:"destination" validate:"required"`

	// Whether the traffic to be matched is `inbound` or `outbound`.
	Direction *string `json:"direction" validate:"required"`

	// The URL for this Network ACL rule.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this Network ACL rule.
	ID *string `json:"id" validate:"required"`

	// The IP version for this rule.
	IPVersion *string `json:"ip_version" validate:"required"`

	// The user-defined name for this rule. Names must be unique within the network ACL the rule resides in. If
	// unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name" validate:"required"`

	// The protocol to enforce.
	Protocol *string `json:"protocol,omitempty"`

	// The source CIDR block. The CIDR block `0.0.0.0/0` applies to all addresses.
	Source *string `json:"source" validate:"required"`
}

// Constants associated with the NetworkACLRulePrototypeNetworkACLRuleProtocolAll.Action property.
// Whether to allow or deny matching traffic.
const (
	NetworkACLRulePrototypeNetworkACLRuleProtocolAllActionAllowConst = "allow"
	NetworkACLRulePrototypeNetworkACLRuleProtocolAllActionDenyConst  = "deny"
)

// Constants associated with the NetworkACLRulePrototypeNetworkACLRuleProtocolAll.Direction property.
// Whether the traffic to be matched is `inbound` or `outbound`.
const (
	NetworkACLRulePrototypeNetworkACLRuleProtocolAllDirectionInboundConst  = "inbound"
	NetworkACLRulePrototypeNetworkACLRuleProtocolAllDirectionOutboundConst = "outbound"
)

// Constants associated with the NetworkACLRulePrototypeNetworkACLRuleProtocolAll.IPVersion property.
// The IP version for this rule.
const (
	NetworkACLRulePrototypeNetworkACLRuleProtocolAllIPVersionIpv4Const = "ipv4"
	NetworkACLRulePrototypeNetworkACLRuleProtocolAllIPVersionIpv6Const = "ipv6"
)

// Constants associated with the NetworkACLRulePrototypeNetworkACLRuleProtocolAll.Protocol property.
// The protocol to enforce.
const (
	NetworkACLRulePrototypeNetworkACLRuleProtocolAllProtocolAllConst  = "all"
	NetworkACLRulePrototypeNetworkACLRuleProtocolAllProtocolIcmpConst = "icmp"
	NetworkACLRulePrototypeNetworkACLRuleProtocolAllProtocolTCPConst  = "tcp"
	NetworkACLRulePrototypeNetworkACLRuleProtocolAllProtocolUDPConst  = "udp"
)

// NewNetworkACLRulePrototypeNetworkACLRuleProtocolAll : Instantiate NetworkACLRulePrototypeNetworkACLRuleProtocolAll (Generic Model Constructor)
func (*VpcV1) NewNetworkACLRulePrototypeNetworkACLRuleProtocolAll(action string, createdAt *strfmt.DateTime, destination string, direction string, href string, id string, ipVersion string, name string, source string) (model *NetworkACLRulePrototypeNetworkACLRuleProtocolAll, err error) {
	model = &NetworkACLRulePrototypeNetworkACLRuleProtocolAll{
		Action:      core.StringPtr(action),
		CreatedAt:   createdAt,
		Destination: core.StringPtr(destination),
		Direction:   core.StringPtr(direction),
		Href:        core.StringPtr(href),
		ID:          core.StringPtr(id),
		IPVersion:   core.StringPtr(ipVersion),
		Name:        core.StringPtr(name),
		Source:      core.StringPtr(source),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*NetworkACLRulePrototypeNetworkACLRuleProtocolAll) isaNetworkACLRulePrototype() bool {
	return true
}

// UnmarshalNetworkACLRulePrototypeNetworkACLRuleProtocolAll unmarshals an instance of NetworkACLRulePrototypeNetworkACLRuleProtocolAll from the specified map of raw messages.
func UnmarshalNetworkACLRulePrototypeNetworkACLRuleProtocolAll(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkACLRulePrototypeNetworkACLRuleProtocolAll)
	err = core.UnmarshalPrimitive(m, "action", &obj.Action)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "before", &obj.Before, UnmarshalNetworkACLRuleReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "destination", &obj.Destination)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "direction", &obj.Direction)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ip_version", &obj.IPVersion)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "protocol", &obj.Protocol)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "source", &obj.Source)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkACLRulePrototypeNetworkACLRuleProtocolIcmp : NetworkACLRulePrototypeNetworkACLRuleProtocolIcmp struct
// This model "extends" NetworkACLRulePrototype
type NetworkACLRulePrototypeNetworkACLRuleProtocolIcmp struct {
	// Whether to allow or deny matching traffic.
	Action *string `json:"action" validate:"required"`

	// The rule that this rule is immediately before. If absent, this is the last rule.
	Before *NetworkACLRuleReference `json:"before,omitempty"`

	// The date and time that the rule was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The destination CIDR block. The CIDR block `0.0.0.0/0` applies to all addresses.
	Destination *string `json:"destination" validate:"required"`

	// Whether the traffic to be matched is `inbound` or `outbound`.
	Direction *string `json:"direction" validate:"required"`

	// The URL for this Network ACL rule.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this Network ACL rule.
	ID *string `json:"id" validate:"required"`

	// The IP version for this rule.
	IPVersion *string `json:"ip_version" validate:"required"`

	// The user-defined name for this rule. Names must be unique within the network ACL the rule resides in. If
	// unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name" validate:"required"`

	// The protocol to enforce.
	Protocol *string `json:"protocol,omitempty"`

	// The source CIDR block. The CIDR block `0.0.0.0/0` applies to all addresses.
	Source *string `json:"source" validate:"required"`

	// The ICMP traffic code to allow. If unspecified, all codes are allowed. This can only be specified if type is also
	// specified.
	Code *int64 `json:"code,omitempty"`

	// The ICMP traffic type to allow. If unspecified, all types are allowed by this rule.
	Type *int64 `json:"type,omitempty"`
}

// Constants associated with the NetworkACLRulePrototypeNetworkACLRuleProtocolIcmp.Action property.
// Whether to allow or deny matching traffic.
const (
	NetworkACLRulePrototypeNetworkACLRuleProtocolIcmpActionAllowConst = "allow"
	NetworkACLRulePrototypeNetworkACLRuleProtocolIcmpActionDenyConst  = "deny"
)

// Constants associated with the NetworkACLRulePrototypeNetworkACLRuleProtocolIcmp.Direction property.
// Whether the traffic to be matched is `inbound` or `outbound`.
const (
	NetworkACLRulePrototypeNetworkACLRuleProtocolIcmpDirectionInboundConst  = "inbound"
	NetworkACLRulePrototypeNetworkACLRuleProtocolIcmpDirectionOutboundConst = "outbound"
)

// Constants associated with the NetworkACLRulePrototypeNetworkACLRuleProtocolIcmp.IPVersion property.
// The IP version for this rule.
const (
	NetworkACLRulePrototypeNetworkACLRuleProtocolIcmpIPVersionIpv4Const = "ipv4"
	NetworkACLRulePrototypeNetworkACLRuleProtocolIcmpIPVersionIpv6Const = "ipv6"
)

// Constants associated with the NetworkACLRulePrototypeNetworkACLRuleProtocolIcmp.Protocol property.
// The protocol to enforce.
const (
	NetworkACLRulePrototypeNetworkACLRuleProtocolIcmpProtocolAllConst  = "all"
	NetworkACLRulePrototypeNetworkACLRuleProtocolIcmpProtocolIcmpConst = "icmp"
	NetworkACLRulePrototypeNetworkACLRuleProtocolIcmpProtocolTCPConst  = "tcp"
	NetworkACLRulePrototypeNetworkACLRuleProtocolIcmpProtocolUDPConst  = "udp"
)

// NewNetworkACLRulePrototypeNetworkACLRuleProtocolIcmp : Instantiate NetworkACLRulePrototypeNetworkACLRuleProtocolIcmp (Generic Model Constructor)
func (*VpcV1) NewNetworkACLRulePrototypeNetworkACLRuleProtocolIcmp(action string, createdAt *strfmt.DateTime, destination string, direction string, href string, id string, ipVersion string, name string, source string) (model *NetworkACLRulePrototypeNetworkACLRuleProtocolIcmp, err error) {
	model = &NetworkACLRulePrototypeNetworkACLRuleProtocolIcmp{
		Action:      core.StringPtr(action),
		CreatedAt:   createdAt,
		Destination: core.StringPtr(destination),
		Direction:   core.StringPtr(direction),
		Href:        core.StringPtr(href),
		ID:          core.StringPtr(id),
		IPVersion:   core.StringPtr(ipVersion),
		Name:        core.StringPtr(name),
		Source:      core.StringPtr(source),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*NetworkACLRulePrototypeNetworkACLRuleProtocolIcmp) isaNetworkACLRulePrototype() bool {
	return true
}

// UnmarshalNetworkACLRulePrototypeNetworkACLRuleProtocolIcmp unmarshals an instance of NetworkACLRulePrototypeNetworkACLRuleProtocolIcmp from the specified map of raw messages.
func UnmarshalNetworkACLRulePrototypeNetworkACLRuleProtocolIcmp(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkACLRulePrototypeNetworkACLRuleProtocolIcmp)
	err = core.UnmarshalPrimitive(m, "action", &obj.Action)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "before", &obj.Before, UnmarshalNetworkACLRuleReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "destination", &obj.Destination)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "direction", &obj.Direction)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ip_version", &obj.IPVersion)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "protocol", &obj.Protocol)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "source", &obj.Source)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "code", &obj.Code)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkACLRulePrototypeNetworkACLRuleProtocolTcpudp : NetworkACLRulePrototypeNetworkACLRuleProtocolTcpudp struct
// This model "extends" NetworkACLRulePrototype
type NetworkACLRulePrototypeNetworkACLRuleProtocolTcpudp struct {
	// Whether to allow or deny matching traffic.
	Action *string `json:"action" validate:"required"`

	// The rule that this rule is immediately before. If absent, this is the last rule.
	Before *NetworkACLRuleReference `json:"before,omitempty"`

	// The date and time that the rule was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The destination CIDR block. The CIDR block `0.0.0.0/0` applies to all addresses.
	Destination *string `json:"destination" validate:"required"`

	// Whether the traffic to be matched is `inbound` or `outbound`.
	Direction *string `json:"direction" validate:"required"`

	// The URL for this Network ACL rule.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this Network ACL rule.
	ID *string `json:"id" validate:"required"`

	// The IP version for this rule.
	IPVersion *string `json:"ip_version" validate:"required"`

	// The user-defined name for this rule. Names must be unique within the network ACL the rule resides in. If
	// unspecified, the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name" validate:"required"`

	// The protocol to enforce.
	Protocol *string `json:"protocol,omitempty"`

	// The source CIDR block. The CIDR block `0.0.0.0/0` applies to all addresses.
	Source *string `json:"source" validate:"required"`

	// The inclusive upper bound of TCP/UDP destination port range.
	DestinationPortMax *int64 `json:"destination_port_max,omitempty"`

	// The inclusive lower bound of TCP/UDP destination port range.
	DestinationPortMin *int64 `json:"destination_port_min,omitempty"`

	// The inclusive upper bound of TCP/UDP source port range.
	SourcePortMax *int64 `json:"source_port_max,omitempty"`

	// The inclusive lower bound of TCP/UDP source port range.
	SourcePortMin *int64 `json:"source_port_min,omitempty"`
}

// Constants associated with the NetworkACLRulePrototypeNetworkACLRuleProtocolTcpudp.Action property.
// Whether to allow or deny matching traffic.
const (
	NetworkACLRulePrototypeNetworkACLRuleProtocolTcpudpActionAllowConst = "allow"
	NetworkACLRulePrototypeNetworkACLRuleProtocolTcpudpActionDenyConst  = "deny"
)

// Constants associated with the NetworkACLRulePrototypeNetworkACLRuleProtocolTcpudp.Direction property.
// Whether the traffic to be matched is `inbound` or `outbound`.
const (
	NetworkACLRulePrototypeNetworkACLRuleProtocolTcpudpDirectionInboundConst  = "inbound"
	NetworkACLRulePrototypeNetworkACLRuleProtocolTcpudpDirectionOutboundConst = "outbound"
)

// Constants associated with the NetworkACLRulePrototypeNetworkACLRuleProtocolTcpudp.IPVersion property.
// The IP version for this rule.
const (
	NetworkACLRulePrototypeNetworkACLRuleProtocolTcpudpIPVersionIpv4Const = "ipv4"
	NetworkACLRulePrototypeNetworkACLRuleProtocolTcpudpIPVersionIpv6Const = "ipv6"
)

// Constants associated with the NetworkACLRulePrototypeNetworkACLRuleProtocolTcpudp.Protocol property.
// The protocol to enforce.
const (
	NetworkACLRulePrototypeNetworkACLRuleProtocolTcpudpProtocolAllConst  = "all"
	NetworkACLRulePrototypeNetworkACLRuleProtocolTcpudpProtocolIcmpConst = "icmp"
	NetworkACLRulePrototypeNetworkACLRuleProtocolTcpudpProtocolTCPConst  = "tcp"
	NetworkACLRulePrototypeNetworkACLRuleProtocolTcpudpProtocolUDPConst  = "udp"
)

// NewNetworkACLRulePrototypeNetworkACLRuleProtocolTcpudp : Instantiate NetworkACLRulePrototypeNetworkACLRuleProtocolTcpudp (Generic Model Constructor)
func (*VpcV1) NewNetworkACLRulePrototypeNetworkACLRuleProtocolTcpudp(action string, createdAt *strfmt.DateTime, destination string, direction string, href string, id string, ipVersion string, name string, source string) (model *NetworkACLRulePrototypeNetworkACLRuleProtocolTcpudp, err error) {
	model = &NetworkACLRulePrototypeNetworkACLRuleProtocolTcpudp{
		Action:      core.StringPtr(action),
		CreatedAt:   createdAt,
		Destination: core.StringPtr(destination),
		Direction:   core.StringPtr(direction),
		Href:        core.StringPtr(href),
		ID:          core.StringPtr(id),
		IPVersion:   core.StringPtr(ipVersion),
		Name:        core.StringPtr(name),
		Source:      core.StringPtr(source),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*NetworkACLRulePrototypeNetworkACLRuleProtocolTcpudp) isaNetworkACLRulePrototype() bool {
	return true
}

// UnmarshalNetworkACLRulePrototypeNetworkACLRuleProtocolTcpudp unmarshals an instance of NetworkACLRulePrototypeNetworkACLRuleProtocolTcpudp from the specified map of raw messages.
func UnmarshalNetworkACLRulePrototypeNetworkACLRuleProtocolTcpudp(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkACLRulePrototypeNetworkACLRuleProtocolTcpudp)
	err = core.UnmarshalPrimitive(m, "action", &obj.Action)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "before", &obj.Before, UnmarshalNetworkACLRuleReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "destination", &obj.Destination)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "direction", &obj.Direction)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ip_version", &obj.IPVersion)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "protocol", &obj.Protocol)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "source", &obj.Source)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "destination_port_max", &obj.DestinationPortMax)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "destination_port_min", &obj.DestinationPortMin)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "source_port_max", &obj.SourcePortMax)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "source_port_min", &obj.SourcePortMin)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkInterfaceIdentityByHref : NetworkInterfaceIdentityByHref struct
// This model "extends" NetworkInterfaceIdentity
type NetworkInterfaceIdentityByHref struct {
	// The URL for this network interface.
	Href *string `json:"href" validate:"required"`
}

// NewNetworkInterfaceIdentityByHref : Instantiate NetworkInterfaceIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewNetworkInterfaceIdentityByHref(href string) (model *NetworkInterfaceIdentityByHref, err error) {
	model = &NetworkInterfaceIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*NetworkInterfaceIdentityByHref) isaNetworkInterfaceIdentity() bool {
	return true
}

// UnmarshalNetworkInterfaceIdentityByHref unmarshals an instance of NetworkInterfaceIdentityByHref from the specified map of raw messages.
func UnmarshalNetworkInterfaceIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkInterfaceIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkInterfaceIdentityByID : NetworkInterfaceIdentityByID struct
// This model "extends" NetworkInterfaceIdentity
type NetworkInterfaceIdentityByID struct {
	// The unique identifier for this network interface.
	ID *string `json:"id" validate:"required"`
}

// NewNetworkInterfaceIdentityByID : Instantiate NetworkInterfaceIdentityByID (Generic Model Constructor)
func (*VpcV1) NewNetworkInterfaceIdentityByID(id string) (model *NetworkInterfaceIdentityByID, err error) {
	model = &NetworkInterfaceIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*NetworkInterfaceIdentityByID) isaNetworkInterfaceIdentity() bool {
	return true
}

// UnmarshalNetworkInterfaceIdentityByID unmarshals an instance of NetworkInterfaceIdentityByID from the specified map of raw messages.
func UnmarshalNetworkInterfaceIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkInterfaceIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// OperatingSystemIdentityByHref : OperatingSystemIdentityByHref struct
// This model "extends" OperatingSystemIdentity
type OperatingSystemIdentityByHref struct {
	// The URL for this operating system.
	Href *string `json:"href" validate:"required"`
}

// NewOperatingSystemIdentityByHref : Instantiate OperatingSystemIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewOperatingSystemIdentityByHref(href string) (model *OperatingSystemIdentityByHref, err error) {
	model = &OperatingSystemIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*OperatingSystemIdentityByHref) isaOperatingSystemIdentity() bool {
	return true
}

// UnmarshalOperatingSystemIdentityByHref unmarshals an instance of OperatingSystemIdentityByHref from the specified map of raw messages.
func UnmarshalOperatingSystemIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(OperatingSystemIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// OperatingSystemIdentityByName : OperatingSystemIdentityByName struct
// This model "extends" OperatingSystemIdentity
type OperatingSystemIdentityByName struct {
	// The unique name of the operating system.
	Name *string `json:"name" validate:"required"`
}

// NewOperatingSystemIdentityByName : Instantiate OperatingSystemIdentityByName (Generic Model Constructor)
func (*VpcV1) NewOperatingSystemIdentityByName(name string) (model *OperatingSystemIdentityByName, err error) {
	model = &OperatingSystemIdentityByName{
		Name: core.StringPtr(name),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*OperatingSystemIdentityByName) isaOperatingSystemIdentity() bool {
	return true
}

// UnmarshalOperatingSystemIdentityByName unmarshals an instance of OperatingSystemIdentityByName from the specified map of raw messages.
func UnmarshalOperatingSystemIdentityByName(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(OperatingSystemIdentityByName)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PublicGatewayIdentityByCRN : PublicGatewayIdentityByCRN struct
// This model "extends" PublicGatewayIdentity
type PublicGatewayIdentityByCRN struct {
	// The CRN for this public gateway.
	CRN *string `json:"crn" validate:"required"`
}

// NewPublicGatewayIdentityByCRN : Instantiate PublicGatewayIdentityByCRN (Generic Model Constructor)
func (*VpcV1) NewPublicGatewayIdentityByCRN(crn string) (model *PublicGatewayIdentityByCRN, err error) {
	model = &PublicGatewayIdentityByCRN{
		CRN: core.StringPtr(crn),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*PublicGatewayIdentityByCRN) isaPublicGatewayIdentity() bool {
	return true
}

// UnmarshalPublicGatewayIdentityByCRN unmarshals an instance of PublicGatewayIdentityByCRN from the specified map of raw messages.
func UnmarshalPublicGatewayIdentityByCRN(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PublicGatewayIdentityByCRN)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PublicGatewayIdentityByHref : PublicGatewayIdentityByHref struct
// This model "extends" PublicGatewayIdentity
type PublicGatewayIdentityByHref struct {
	// The URL for this public gateway.
	Href *string `json:"href" validate:"required"`
}

// NewPublicGatewayIdentityByHref : Instantiate PublicGatewayIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewPublicGatewayIdentityByHref(href string) (model *PublicGatewayIdentityByHref, err error) {
	model = &PublicGatewayIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*PublicGatewayIdentityByHref) isaPublicGatewayIdentity() bool {
	return true
}

// UnmarshalPublicGatewayIdentityByHref unmarshals an instance of PublicGatewayIdentityByHref from the specified map of raw messages.
func UnmarshalPublicGatewayIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PublicGatewayIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PublicGatewayIdentityByID : PublicGatewayIdentityByID struct
// This model "extends" PublicGatewayIdentity
type PublicGatewayIdentityByID struct {
	// The unique identifier for this public gateway.
	ID *string `json:"id" validate:"required"`
}

// NewPublicGatewayIdentityByID : Instantiate PublicGatewayIdentityByID (Generic Model Constructor)
func (*VpcV1) NewPublicGatewayIdentityByID(id string) (model *PublicGatewayIdentityByID, err error) {
	model = &PublicGatewayIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*PublicGatewayIdentityByID) isaPublicGatewayIdentity() bool {
	return true
}

// UnmarshalPublicGatewayIdentityByID unmarshals an instance of PublicGatewayIdentityByID from the specified map of raw messages.
func UnmarshalPublicGatewayIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PublicGatewayIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PublicGatewayPrototypeFloatingIPFloatingIPIdentity : Identifies a floating IP by a unique property.
// Models which "extend" this model:
// - PublicGatewayPrototypeFloatingIPFloatingIPIdentityFloatingIPIdentityByID
// - PublicGatewayPrototypeFloatingIPFloatingIPIdentityFloatingIPIdentityByCRN
// - PublicGatewayPrototypeFloatingIPFloatingIPIdentityFloatingIPIdentityByHref
// - PublicGatewayPrototypeFloatingIPFloatingIPIdentityFloatingIPIdentityByAddress
// This model "extends" PublicGatewayPrototypeFloatingIP
type PublicGatewayPrototypeFloatingIPFloatingIPIdentity struct {
	// The unique identifier for this floating IP.
	ID *string `json:"id,omitempty"`

	// The CRN for this floating IP.
	CRN *string `json:"crn,omitempty"`

	// The URL for this floating IP.
	Href *string `json:"href,omitempty"`

	// The globally unique IP address.
	Address *string `json:"address,omitempty"`
}

func (*PublicGatewayPrototypeFloatingIPFloatingIPIdentity) isaPublicGatewayPrototypeFloatingIPFloatingIPIdentity() bool {
	return true
}

type PublicGatewayPrototypeFloatingIPFloatingIPIdentityIntf interface {
	PublicGatewayPrototypeFloatingIPIntf
	isaPublicGatewayPrototypeFloatingIPFloatingIPIdentity() bool
}

func (*PublicGatewayPrototypeFloatingIPFloatingIPIdentity) isaPublicGatewayPrototypeFloatingIP() bool {
	return true
}

// UnmarshalPublicGatewayPrototypeFloatingIPFloatingIPIdentity unmarshals an instance of PublicGatewayPrototypeFloatingIPFloatingIPIdentity from the specified map of raw messages.
func UnmarshalPublicGatewayPrototypeFloatingIPFloatingIPIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PublicGatewayPrototypeFloatingIPFloatingIPIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "address", &obj.Address)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PublicGatewayPrototypeFloatingIPFloatingIPPrototypeTargetContext : PublicGatewayPrototypeFloatingIPFloatingIPPrototypeTargetContext struct
// This model "extends" PublicGatewayPrototypeFloatingIP
type PublicGatewayPrototypeFloatingIPFloatingIPPrototypeTargetContext struct {
	// The unique user-defined name for this floating IP. If unspecified, the name will be a hyphenated list of
	// randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`
}

func (*PublicGatewayPrototypeFloatingIPFloatingIPPrototypeTargetContext) isaPublicGatewayPrototypeFloatingIP() bool {
	return true
}

// UnmarshalPublicGatewayPrototypeFloatingIPFloatingIPPrototypeTargetContext unmarshals an instance of PublicGatewayPrototypeFloatingIPFloatingIPPrototypeTargetContext from the specified map of raw messages.
func UnmarshalPublicGatewayPrototypeFloatingIPFloatingIPPrototypeTargetContext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PublicGatewayPrototypeFloatingIPFloatingIPPrototypeTargetContext)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ResourceGroupIdentityByID : ResourceGroupIdentityByID struct
// This model "extends" ResourceGroupIdentity
type ResourceGroupIdentityByID struct {
	// The unique identifier for this resource group.
	ID *string `json:"id" validate:"required"`
}

// NewResourceGroupIdentityByID : Instantiate ResourceGroupIdentityByID (Generic Model Constructor)
func (*VpcV1) NewResourceGroupIdentityByID(id string) (model *ResourceGroupIdentityByID, err error) {
	model = &ResourceGroupIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*ResourceGroupIdentityByID) isaResourceGroupIdentity() bool {
	return true
}

// UnmarshalResourceGroupIdentityByID unmarshals an instance of ResourceGroupIdentityByID from the specified map of raw messages.
func UnmarshalResourceGroupIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ResourceGroupIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RouteNextHopIP : RouteNextHopIP struct
// This model "extends" RouteNextHop
type RouteNextHopIP struct {
	// The IP address. This property may add support for IPv6 addresses in the future. When processing a value in this
	// property, verify that the address is in an expected format. If it is not, log an error. Optionally halt processing
	// and surface the error, or bypass the resource on which the unexpected IP address format was encountered.
	Address *string `json:"address" validate:"required"`
}

func (*RouteNextHopIP) isaRouteNextHop() bool {
	return true
}

// UnmarshalRouteNextHopIP unmarshals an instance of RouteNextHopIP from the specified map of raw messages.
func UnmarshalRouteNextHopIP(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RouteNextHopIP)
	err = core.UnmarshalPrimitive(m, "address", &obj.Address)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RouteNextHopPrototypeRouteNextHopConnection : The next hop packets will be routed to.
// Models which "extend" this model:
// - RouteNextHopPrototypeRouteNextHopConnectionRouteNextHopConnectionVPNGatewayConnectionIdentityByID
// - RouteNextHopPrototypeRouteNextHopConnectionRouteNextHopConnectionVPNGatewayConnectionIdentityByHref
// This model "extends" RouteNextHopPrototype
type RouteNextHopPrototypeRouteNextHopConnection struct {
	// The unique identifier for this VPN connection.
	ID *string `json:"id,omitempty"`

	// The VPN connection's canonical URL.
	Href *string `json:"href,omitempty"`
}

func (*RouteNextHopPrototypeRouteNextHopConnection) isaRouteNextHopPrototypeRouteNextHopConnection() bool {
	return true
}

type RouteNextHopPrototypeRouteNextHopConnectionIntf interface {
	RouteNextHopPrototypeIntf
	isaRouteNextHopPrototypeRouteNextHopConnection() bool
}

func (*RouteNextHopPrototypeRouteNextHopConnection) isaRouteNextHopPrototype() bool {
	return true
}

// UnmarshalRouteNextHopPrototypeRouteNextHopConnection unmarshals an instance of RouteNextHopPrototypeRouteNextHopConnection from the specified map of raw messages.
func UnmarshalRouteNextHopPrototypeRouteNextHopConnection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RouteNextHopPrototypeRouteNextHopConnection)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RouteNextHopPrototypeRouteNextHopIP : The IP address of the next hop to which to route packets. Must be an IP address within a subnet assigned to `zone`.
// This model "extends" RouteNextHopPrototype
type RouteNextHopPrototypeRouteNextHopIP struct {
	// The IP address. This property may add support for IPv6 addresses in the future. When processing a value in this
	// property, verify that the address is in an expected format. If it is not, log an error. Optionally halt processing
	// and surface the error, or bypass the resource on which the unexpected IP address format was encountered.
	Address *string `json:"address" validate:"required"`
}

// NewRouteNextHopPrototypeRouteNextHopIP : Instantiate RouteNextHopPrototypeRouteNextHopIP (Generic Model Constructor)
func (*VpcV1) NewRouteNextHopPrototypeRouteNextHopIP(address string) (model *RouteNextHopPrototypeRouteNextHopIP, err error) {
	model = &RouteNextHopPrototypeRouteNextHopIP{
		Address: core.StringPtr(address),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*RouteNextHopPrototypeRouteNextHopIP) isaRouteNextHopPrototype() bool {
	return true
}

// UnmarshalRouteNextHopPrototypeRouteNextHopIP unmarshals an instance of RouteNextHopPrototypeRouteNextHopIP from the specified map of raw messages.
func UnmarshalRouteNextHopPrototypeRouteNextHopIP(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RouteNextHopPrototypeRouteNextHopIP)
	err = core.UnmarshalPrimitive(m, "address", &obj.Address)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RouteNextHopVPNGatewayConnectionReference : RouteNextHopVPNGatewayConnectionReference struct
// This model "extends" RouteNextHop
type RouteNextHopVPNGatewayConnectionReference struct {
	// The VPN connection's canonical URL.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this VPN connection.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this VPN connection.
	Name *string `json:"name" validate:"required"`
}

func (*RouteNextHopVPNGatewayConnectionReference) isaRouteNextHop() bool {
	return true
}

// UnmarshalRouteNextHopVPNGatewayConnectionReference unmarshals an instance of RouteNextHopVPNGatewayConnectionReference from the specified map of raw messages.
func UnmarshalRouteNextHopVPNGatewayConnectionReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RouteNextHopVPNGatewayConnectionReference)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RoutingTableIdentityByHref : RoutingTableIdentityByHref struct
// This model "extends" RoutingTableIdentity
type RoutingTableIdentityByHref struct {
	// The URL for this routing table.
	Href *string `json:"href" validate:"required"`
}

// NewRoutingTableIdentityByHref : Instantiate RoutingTableIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewRoutingTableIdentityByHref(href string) (model *RoutingTableIdentityByHref, err error) {
	model = &RoutingTableIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*RoutingTableIdentityByHref) isaRoutingTableIdentity() bool {
	return true
}

// UnmarshalRoutingTableIdentityByHref unmarshals an instance of RoutingTableIdentityByHref from the specified map of raw messages.
func UnmarshalRoutingTableIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RoutingTableIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RoutingTableIdentityByID : RoutingTableIdentityByID struct
// This model "extends" RoutingTableIdentity
type RoutingTableIdentityByID struct {
	// The unique identifier for this routing table.
	ID *string `json:"id" validate:"required"`
}

// NewRoutingTableIdentityByID : Instantiate RoutingTableIdentityByID (Generic Model Constructor)
func (*VpcV1) NewRoutingTableIdentityByID(id string) (model *RoutingTableIdentityByID, err error) {
	model = &RoutingTableIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*RoutingTableIdentityByID) isaRoutingTableIdentity() bool {
	return true
}

// UnmarshalRoutingTableIdentityByID unmarshals an instance of RoutingTableIdentityByID from the specified map of raw messages.
func UnmarshalRoutingTableIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RoutingTableIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupIdentityByCRN : SecurityGroupIdentityByCRN struct
// This model "extends" SecurityGroupIdentity
type SecurityGroupIdentityByCRN struct {
	// The security group's CRN.
	CRN *string `json:"crn" validate:"required"`
}

// NewSecurityGroupIdentityByCRN : Instantiate SecurityGroupIdentityByCRN (Generic Model Constructor)
func (*VpcV1) NewSecurityGroupIdentityByCRN(crn string) (model *SecurityGroupIdentityByCRN, err error) {
	model = &SecurityGroupIdentityByCRN{
		CRN: core.StringPtr(crn),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*SecurityGroupIdentityByCRN) isaSecurityGroupIdentity() bool {
	return true
}

// UnmarshalSecurityGroupIdentityByCRN unmarshals an instance of SecurityGroupIdentityByCRN from the specified map of raw messages.
func UnmarshalSecurityGroupIdentityByCRN(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupIdentityByCRN)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupIdentityByHref : SecurityGroupIdentityByHref struct
// This model "extends" SecurityGroupIdentity
type SecurityGroupIdentityByHref struct {
	// The security group's canonical URL.
	Href *string `json:"href" validate:"required"`
}

// NewSecurityGroupIdentityByHref : Instantiate SecurityGroupIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewSecurityGroupIdentityByHref(href string) (model *SecurityGroupIdentityByHref, err error) {
	model = &SecurityGroupIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*SecurityGroupIdentityByHref) isaSecurityGroupIdentity() bool {
	return true
}

// UnmarshalSecurityGroupIdentityByHref unmarshals an instance of SecurityGroupIdentityByHref from the specified map of raw messages.
func UnmarshalSecurityGroupIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupIdentityByID : SecurityGroupIdentityByID struct
// This model "extends" SecurityGroupIdentity
type SecurityGroupIdentityByID struct {
	// The unique identifier for this security group.
	ID *string `json:"id" validate:"required"`
}

// NewSecurityGroupIdentityByID : Instantiate SecurityGroupIdentityByID (Generic Model Constructor)
func (*VpcV1) NewSecurityGroupIdentityByID(id string) (model *SecurityGroupIdentityByID, err error) {
	model = &SecurityGroupIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*SecurityGroupIdentityByID) isaSecurityGroupIdentity() bool {
	return true
}

// UnmarshalSecurityGroupIdentityByID unmarshals an instance of SecurityGroupIdentityByID from the specified map of raw messages.
func UnmarshalSecurityGroupIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupRulePatchRemoteCIDR : SecurityGroupRulePatchRemoteCIDR struct
// This model "extends" SecurityGroupRulePatchRemote
type SecurityGroupRulePatchRemoteCIDR struct {
	// The CIDR block. This property may add support for IPv6 CIDR blocks in the future. When processing a value in this
	// property, verify that the CIDR block is in an expected format. If it is not, log an error. Optionally halt
	// processing and surface the error, or bypass the resource on which the unexpected CIDR block format was encountered.
	CIDRBlock *string `json:"cidr_block" validate:"required"`
}

// NewSecurityGroupRulePatchRemoteCIDR : Instantiate SecurityGroupRulePatchRemoteCIDR (Generic Model Constructor)
func (*VpcV1) NewSecurityGroupRulePatchRemoteCIDR(cidrBlock string) (model *SecurityGroupRulePatchRemoteCIDR, err error) {
	model = &SecurityGroupRulePatchRemoteCIDR{
		CIDRBlock: core.StringPtr(cidrBlock),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*SecurityGroupRulePatchRemoteCIDR) isaSecurityGroupRulePatchRemote() bool {
	return true
}

// UnmarshalSecurityGroupRulePatchRemoteCIDR unmarshals an instance of SecurityGroupRulePatchRemoteCIDR from the specified map of raw messages.
func UnmarshalSecurityGroupRulePatchRemoteCIDR(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupRulePatchRemoteCIDR)
	err = core.UnmarshalPrimitive(m, "cidr_block", &obj.CIDRBlock)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupRulePatchRemoteIP : SecurityGroupRulePatchRemoteIP struct
// This model "extends" SecurityGroupRulePatchRemote
type SecurityGroupRulePatchRemoteIP struct {
	// The IP address. This property may add support for IPv6 addresses in the future. When processing a value in this
	// property, verify that the address is in an expected format. If it is not, log an error. Optionally halt processing
	// and surface the error, or bypass the resource on which the unexpected IP address format was encountered.
	Address *string `json:"address" validate:"required"`
}

// NewSecurityGroupRulePatchRemoteIP : Instantiate SecurityGroupRulePatchRemoteIP (Generic Model Constructor)
func (*VpcV1) NewSecurityGroupRulePatchRemoteIP(address string) (model *SecurityGroupRulePatchRemoteIP, err error) {
	model = &SecurityGroupRulePatchRemoteIP{
		Address: core.StringPtr(address),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*SecurityGroupRulePatchRemoteIP) isaSecurityGroupRulePatchRemote() bool {
	return true
}

// UnmarshalSecurityGroupRulePatchRemoteIP unmarshals an instance of SecurityGroupRulePatchRemoteIP from the specified map of raw messages.
func UnmarshalSecurityGroupRulePatchRemoteIP(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupRulePatchRemoteIP)
	err = core.UnmarshalPrimitive(m, "address", &obj.Address)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupRulePatchRemoteSecurityGroupIdentity : Identifies a security group by a unique property.
// Models which "extend" this model:
// - SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByID
// - SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN
// - SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByHref
// This model "extends" SecurityGroupRulePatchRemote
type SecurityGroupRulePatchRemoteSecurityGroupIdentity struct {
	// The unique identifier for this security group.
	ID *string `json:"id,omitempty"`

	// The security group's CRN.
	CRN *string `json:"crn,omitempty"`

	// The security group's canonical URL.
	Href *string `json:"href,omitempty"`
}

func (*SecurityGroupRulePatchRemoteSecurityGroupIdentity) isaSecurityGroupRulePatchRemoteSecurityGroupIdentity() bool {
	return true
}

type SecurityGroupRulePatchRemoteSecurityGroupIdentityIntf interface {
	SecurityGroupRulePatchRemoteIntf
	isaSecurityGroupRulePatchRemoteSecurityGroupIdentity() bool
}

func (*SecurityGroupRulePatchRemoteSecurityGroupIdentity) isaSecurityGroupRulePatchRemote() bool {
	return true
}

// UnmarshalSecurityGroupRulePatchRemoteSecurityGroupIdentity unmarshals an instance of SecurityGroupRulePatchRemoteSecurityGroupIdentity from the specified map of raw messages.
func UnmarshalSecurityGroupRulePatchRemoteSecurityGroupIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupRulePatchRemoteSecurityGroupIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupRuleProtocolAll : When `protocol` is `all`, then it's invalid to specify `port_min`, `port_max`, `type` or
// `code`.
// This model "extends" SecurityGroupRule
type SecurityGroupRuleProtocolAll struct {
	// The direction of traffic to enforce, either `inbound` or `outbound`.
	Direction *string `json:"direction" validate:"required"`

	// The URL for this security group rule.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this security group rule.
	ID *string `json:"id" validate:"required"`

	// The IP version to enforce. The format of `remote.address` or `remote.cidr_block` must match this field, if they are
	// used. Alternatively, if `remote` references a security group, then this rule only applies to IP addresses (network
	// interfaces) in that group matching this IP version.
	IPVersion *string `json:"ip_version,omitempty"`

	// The protocol to enforce.
	Protocol *string `json:"protocol,omitempty"`

	// The IP addresses or security groups from which this rule allows traffic (or to which,
	// for outbound rules). Can be specified as an IP address, a CIDR block, or a security
	// group. A CIDR block of `0.0.0.0/0` allows traffic from any source (or to any source,
	// for outbound rules).
	Remote SecurityGroupRuleProtocolAllRemoteIntf `json:"remote" validate:"required"`
}

// Constants associated with the SecurityGroupRuleProtocolAll.Direction property.
// The direction of traffic to enforce, either `inbound` or `outbound`.
const (
	SecurityGroupRuleProtocolAllDirectionInboundConst  = "inbound"
	SecurityGroupRuleProtocolAllDirectionOutboundConst = "outbound"
)

// Constants associated with the SecurityGroupRuleProtocolAll.IPVersion property.
// The IP version to enforce. The format of `remote.address` or `remote.cidr_block` must match this field, if they are
// used. Alternatively, if `remote` references a security group, then this rule only applies to IP addresses (network
// interfaces) in that group matching this IP version.
const (
	SecurityGroupRuleProtocolAllIPVersionIpv4Const = "ipv4"
)

// Constants associated with the SecurityGroupRuleProtocolAll.Protocol property.
// The protocol to enforce.
const (
	SecurityGroupRuleProtocolAllProtocolAllConst  = "all"
	SecurityGroupRuleProtocolAllProtocolIcmpConst = "icmp"
	SecurityGroupRuleProtocolAllProtocolTCPConst  = "tcp"
	SecurityGroupRuleProtocolAllProtocolUDPConst  = "udp"
)

func (*SecurityGroupRuleProtocolAll) isaSecurityGroupRule() bool {
	return true
}

// UnmarshalSecurityGroupRuleProtocolAll unmarshals an instance of SecurityGroupRuleProtocolAll from the specified map of raw messages.
func UnmarshalSecurityGroupRuleProtocolAll(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupRuleProtocolAll)
	err = core.UnmarshalPrimitive(m, "direction", &obj.Direction)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ip_version", &obj.IPVersion)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "protocol", &obj.Protocol)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "remote", &obj.Remote, UnmarshalSecurityGroupRuleProtocolAllRemote)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupRuleProtocolAllRemoteCIDR : SecurityGroupRuleProtocolAllRemoteCIDR struct
// This model "extends" SecurityGroupRuleProtocolAllRemote
type SecurityGroupRuleProtocolAllRemoteCIDR struct {
	// The CIDR block. This property may add support for IPv6 CIDR blocks in the future. When processing a value in this
	// property, verify that the CIDR block is in an expected format. If it is not, log an error. Optionally halt
	// processing and surface the error, or bypass the resource on which the unexpected CIDR block format was encountered.
	CIDRBlock *string `json:"cidr_block" validate:"required"`
}

func (*SecurityGroupRuleProtocolAllRemoteCIDR) isaSecurityGroupRuleProtocolAllRemote() bool {
	return true
}

// UnmarshalSecurityGroupRuleProtocolAllRemoteCIDR unmarshals an instance of SecurityGroupRuleProtocolAllRemoteCIDR from the specified map of raw messages.
func UnmarshalSecurityGroupRuleProtocolAllRemoteCIDR(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupRuleProtocolAllRemoteCIDR)
	err = core.UnmarshalPrimitive(m, "cidr_block", &obj.CIDRBlock)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupRuleProtocolAllRemoteIP : SecurityGroupRuleProtocolAllRemoteIP struct
// This model "extends" SecurityGroupRuleProtocolAllRemote
type SecurityGroupRuleProtocolAllRemoteIP struct {
	// The IP address. This property may add support for IPv6 addresses in the future. When processing a value in this
	// property, verify that the address is in an expected format. If it is not, log an error. Optionally halt processing
	// and surface the error, or bypass the resource on which the unexpected IP address format was encountered.
	Address *string `json:"address" validate:"required"`
}

func (*SecurityGroupRuleProtocolAllRemoteIP) isaSecurityGroupRuleProtocolAllRemote() bool {
	return true
}

// UnmarshalSecurityGroupRuleProtocolAllRemoteIP unmarshals an instance of SecurityGroupRuleProtocolAllRemoteIP from the specified map of raw messages.
func UnmarshalSecurityGroupRuleProtocolAllRemoteIP(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupRuleProtocolAllRemoteIP)
	err = core.UnmarshalPrimitive(m, "address", &obj.Address)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupRuleProtocolAllRemoteSecurityGroupReference : SecurityGroupRuleProtocolAllRemoteSecurityGroupReference struct
// This model "extends" SecurityGroupRuleProtocolAllRemote
type SecurityGroupRuleProtocolAllRemoteSecurityGroupReference struct {
	// The security group's CRN.
	CRN *string `json:"crn" validate:"required"`

	// The security group's canonical URL.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this security group.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this security group. Names must be unique within the VPC the security group resides in.
	Name *string `json:"name" validate:"required"`
}

func (*SecurityGroupRuleProtocolAllRemoteSecurityGroupReference) isaSecurityGroupRuleProtocolAllRemote() bool {
	return true
}

// UnmarshalSecurityGroupRuleProtocolAllRemoteSecurityGroupReference unmarshals an instance of SecurityGroupRuleProtocolAllRemoteSecurityGroupReference from the specified map of raw messages.
func UnmarshalSecurityGroupRuleProtocolAllRemoteSecurityGroupReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupRuleProtocolAllRemoteSecurityGroupReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupRuleProtocolIcmp : When `protocol` is `icmp`, then the rule may also contain fields to specify an ICMP `type` and `code`. Field `code`
// may only be specified if `type` is also specified. If type is not specified, then traffic is allowed for all types
// and codes. If type is specified and code is not specified, then traffic is allowed with the specified type for all
// codes.
// This model "extends" SecurityGroupRule
type SecurityGroupRuleProtocolIcmp struct {
	// The direction of traffic to enforce, either `inbound` or `outbound`.
	Direction *string `json:"direction" validate:"required"`

	// The URL for this security group rule.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this security group rule.
	ID *string `json:"id" validate:"required"`

	// The IP version to enforce. The format of `remote.address` or `remote.cidr_block` must match this field, if they are
	// used. Alternatively, if `remote` references a security group, then this rule only applies to IP addresses (network
	// interfaces) in that group matching this IP version.
	IPVersion *string `json:"ip_version,omitempty"`

	// The protocol to enforce.
	Protocol *string `json:"protocol,omitempty"`

	// The IP addresses or security groups from which this rule allows traffic (or to which,
	// for outbound rules). Can be specified as an IP address, a CIDR block, or a security
	// group. A CIDR block of `0.0.0.0/0` allows traffic from any source (or to any source,
	// for outbound rules).
	Remote SecurityGroupRuleProtocolIcmpRemoteIntf `json:"remote" validate:"required"`

	// The ICMP traffic code to allow.
	Code *int64 `json:"code,omitempty"`

	// The ICMP traffic type to allow.
	Type *int64 `json:"type,omitempty"`
}

// Constants associated with the SecurityGroupRuleProtocolIcmp.Direction property.
// The direction of traffic to enforce, either `inbound` or `outbound`.
const (
	SecurityGroupRuleProtocolIcmpDirectionInboundConst  = "inbound"
	SecurityGroupRuleProtocolIcmpDirectionOutboundConst = "outbound"
)

// Constants associated with the SecurityGroupRuleProtocolIcmp.IPVersion property.
// The IP version to enforce. The format of `remote.address` or `remote.cidr_block` must match this field, if they are
// used. Alternatively, if `remote` references a security group, then this rule only applies to IP addresses (network
// interfaces) in that group matching this IP version.
const (
	SecurityGroupRuleProtocolIcmpIPVersionIpv4Const = "ipv4"
)

// Constants associated with the SecurityGroupRuleProtocolIcmp.Protocol property.
// The protocol to enforce.
const (
	SecurityGroupRuleProtocolIcmpProtocolAllConst  = "all"
	SecurityGroupRuleProtocolIcmpProtocolIcmpConst = "icmp"
	SecurityGroupRuleProtocolIcmpProtocolTCPConst  = "tcp"
	SecurityGroupRuleProtocolIcmpProtocolUDPConst  = "udp"
)

func (*SecurityGroupRuleProtocolIcmp) isaSecurityGroupRule() bool {
	return true
}

// UnmarshalSecurityGroupRuleProtocolIcmp unmarshals an instance of SecurityGroupRuleProtocolIcmp from the specified map of raw messages.
func UnmarshalSecurityGroupRuleProtocolIcmp(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupRuleProtocolIcmp)
	err = core.UnmarshalPrimitive(m, "direction", &obj.Direction)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ip_version", &obj.IPVersion)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "protocol", &obj.Protocol)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "remote", &obj.Remote, UnmarshalSecurityGroupRuleProtocolIcmpRemote)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "code", &obj.Code)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupRuleProtocolIcmpRemoteCIDR : SecurityGroupRuleProtocolIcmpRemoteCIDR struct
// This model "extends" SecurityGroupRuleProtocolIcmpRemote
type SecurityGroupRuleProtocolIcmpRemoteCIDR struct {
	// The CIDR block. This property may add support for IPv6 CIDR blocks in the future. When processing a value in this
	// property, verify that the CIDR block is in an expected format. If it is not, log an error. Optionally halt
	// processing and surface the error, or bypass the resource on which the unexpected CIDR block format was encountered.
	CIDRBlock *string `json:"cidr_block" validate:"required"`
}

func (*SecurityGroupRuleProtocolIcmpRemoteCIDR) isaSecurityGroupRuleProtocolIcmpRemote() bool {
	return true
}

// UnmarshalSecurityGroupRuleProtocolIcmpRemoteCIDR unmarshals an instance of SecurityGroupRuleProtocolIcmpRemoteCIDR from the specified map of raw messages.
func UnmarshalSecurityGroupRuleProtocolIcmpRemoteCIDR(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupRuleProtocolIcmpRemoteCIDR)
	err = core.UnmarshalPrimitive(m, "cidr_block", &obj.CIDRBlock)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupRuleProtocolIcmpRemoteIP : SecurityGroupRuleProtocolIcmpRemoteIP struct
// This model "extends" SecurityGroupRuleProtocolIcmpRemote
type SecurityGroupRuleProtocolIcmpRemoteIP struct {
	// The IP address. This property may add support for IPv6 addresses in the future. When processing a value in this
	// property, verify that the address is in an expected format. If it is not, log an error. Optionally halt processing
	// and surface the error, or bypass the resource on which the unexpected IP address format was encountered.
	Address *string `json:"address" validate:"required"`
}

func (*SecurityGroupRuleProtocolIcmpRemoteIP) isaSecurityGroupRuleProtocolIcmpRemote() bool {
	return true
}

// UnmarshalSecurityGroupRuleProtocolIcmpRemoteIP unmarshals an instance of SecurityGroupRuleProtocolIcmpRemoteIP from the specified map of raw messages.
func UnmarshalSecurityGroupRuleProtocolIcmpRemoteIP(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupRuleProtocolIcmpRemoteIP)
	err = core.UnmarshalPrimitive(m, "address", &obj.Address)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupRuleProtocolIcmpRemoteSecurityGroupReference : SecurityGroupRuleProtocolIcmpRemoteSecurityGroupReference struct
// This model "extends" SecurityGroupRuleProtocolIcmpRemote
type SecurityGroupRuleProtocolIcmpRemoteSecurityGroupReference struct {
	// The security group's CRN.
	CRN *string `json:"crn" validate:"required"`

	// The security group's canonical URL.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this security group.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this security group. Names must be unique within the VPC the security group resides in.
	Name *string `json:"name" validate:"required"`
}

func (*SecurityGroupRuleProtocolIcmpRemoteSecurityGroupReference) isaSecurityGroupRuleProtocolIcmpRemote() bool {
	return true
}

// UnmarshalSecurityGroupRuleProtocolIcmpRemoteSecurityGroupReference unmarshals an instance of SecurityGroupRuleProtocolIcmpRemoteSecurityGroupReference from the specified map of raw messages.
func UnmarshalSecurityGroupRuleProtocolIcmpRemoteSecurityGroupReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupRuleProtocolIcmpRemoteSecurityGroupReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupRuleProtocolTcpudp : If `protocol` is either `tcp` or `udp`, then the rule may also contain `port_min` and
// `port_max`. Either both should be set, or neither. When neither is set then traffic is allowed on all ports. For a
// single port, set both to the same value.
// This model "extends" SecurityGroupRule
type SecurityGroupRuleProtocolTcpudp struct {
	// The direction of traffic to enforce, either `inbound` or `outbound`.
	Direction *string `json:"direction" validate:"required"`

	// The URL for this security group rule.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this security group rule.
	ID *string `json:"id" validate:"required"`

	// The IP version to enforce. The format of `remote.address` or `remote.cidr_block` must match this field, if they are
	// used. Alternatively, if `remote` references a security group, then this rule only applies to IP addresses (network
	// interfaces) in that group matching this IP version.
	IPVersion *string `json:"ip_version,omitempty"`

	// The protocol to enforce.
	Protocol *string `json:"protocol,omitempty"`

	// The IP addresses or security groups from which this rule allows traffic (or to which, for outbound rules). Can be
	// specified as an IP address, a CIDR block, or a security group. A CIDR block of `0.0.0.0/0` allows traffic from any
	// source (or to any source, for outbound rules).
	Remote interface{} `json:"remote" validate:"required"`

	// The inclusive upper bound of TCP/UDP port range.
	PortMax *int64 `json:"port_max,omitempty"`

	// The inclusive lower bound of TCP/UDP port range.
	PortMin *int64 `json:"port_min,omitempty"`
}

// Constants associated with the SecurityGroupRuleProtocolTcpudp.Direction property.
// The direction of traffic to enforce, either `inbound` or `outbound`.
const (
	SecurityGroupRuleProtocolTcpudpDirectionInboundConst  = "inbound"
	SecurityGroupRuleProtocolTcpudpDirectionOutboundConst = "outbound"
)

// Constants associated with the SecurityGroupRuleProtocolTcpudp.IPVersion property.
// The IP version to enforce. The format of `remote.address` or `remote.cidr_block` must match this field, if they are
// used. Alternatively, if `remote` references a security group, then this rule only applies to IP addresses (network
// interfaces) in that group matching this IP version.
const (
	SecurityGroupRuleProtocolTcpudpIPVersionIpv4Const = "ipv4"
)

// Constants associated with the SecurityGroupRuleProtocolTcpudp.Protocol property.
// The protocol to enforce.
const (
	SecurityGroupRuleProtocolTcpudpProtocolAllConst  = "all"
	SecurityGroupRuleProtocolTcpudpProtocolIcmpConst = "icmp"
	SecurityGroupRuleProtocolTcpudpProtocolTCPConst  = "tcp"
	SecurityGroupRuleProtocolTcpudpProtocolUDPConst  = "udp"
)

func (*SecurityGroupRuleProtocolTcpudp) isaSecurityGroupRule() bool {
	return true
}

// UnmarshalSecurityGroupRuleProtocolTcpudp unmarshals an instance of SecurityGroupRuleProtocolTcpudp from the specified map of raw messages.
func UnmarshalSecurityGroupRuleProtocolTcpudp(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupRuleProtocolTcpudp)
	err = core.UnmarshalPrimitive(m, "direction", &obj.Direction)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ip_version", &obj.IPVersion)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "protocol", &obj.Protocol)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "remote", &obj.Remote)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "port_max", &obj.PortMax)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "port_min", &obj.PortMin)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupRulePrototypeRemoteCIDR : SecurityGroupRulePrototypeRemoteCIDR struct
// This model "extends" SecurityGroupRulePrototypeRemote
type SecurityGroupRulePrototypeRemoteCIDR struct {
	// The CIDR block. This property may add support for IPv6 CIDR blocks in the future. When processing a value in this
	// property, verify that the CIDR block is in an expected format. If it is not, log an error. Optionally halt
	// processing and surface the error, or bypass the resource on which the unexpected CIDR block format was encountered.
	CIDRBlock *string `json:"cidr_block" validate:"required"`
}

// NewSecurityGroupRulePrototypeRemoteCIDR : Instantiate SecurityGroupRulePrototypeRemoteCIDR (Generic Model Constructor)
func (*VpcV1) NewSecurityGroupRulePrototypeRemoteCIDR(cidrBlock string) (model *SecurityGroupRulePrototypeRemoteCIDR, err error) {
	model = &SecurityGroupRulePrototypeRemoteCIDR{
		CIDRBlock: core.StringPtr(cidrBlock),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*SecurityGroupRulePrototypeRemoteCIDR) isaSecurityGroupRulePrototypeRemote() bool {
	return true
}

// UnmarshalSecurityGroupRulePrototypeRemoteCIDR unmarshals an instance of SecurityGroupRulePrototypeRemoteCIDR from the specified map of raw messages.
func UnmarshalSecurityGroupRulePrototypeRemoteCIDR(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupRulePrototypeRemoteCIDR)
	err = core.UnmarshalPrimitive(m, "cidr_block", &obj.CIDRBlock)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupRulePrototypeRemoteIP : SecurityGroupRulePrototypeRemoteIP struct
// This model "extends" SecurityGroupRulePrototypeRemote
type SecurityGroupRulePrototypeRemoteIP struct {
	// The IP address. This property may add support for IPv6 addresses in the future. When processing a value in this
	// property, verify that the address is in an expected format. If it is not, log an error. Optionally halt processing
	// and surface the error, or bypass the resource on which the unexpected IP address format was encountered.
	Address *string `json:"address" validate:"required"`
}

// NewSecurityGroupRulePrototypeRemoteIP : Instantiate SecurityGroupRulePrototypeRemoteIP (Generic Model Constructor)
func (*VpcV1) NewSecurityGroupRulePrototypeRemoteIP(address string) (model *SecurityGroupRulePrototypeRemoteIP, err error) {
	model = &SecurityGroupRulePrototypeRemoteIP{
		Address: core.StringPtr(address),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*SecurityGroupRulePrototypeRemoteIP) isaSecurityGroupRulePrototypeRemote() bool {
	return true
}

// UnmarshalSecurityGroupRulePrototypeRemoteIP unmarshals an instance of SecurityGroupRulePrototypeRemoteIP from the specified map of raw messages.
func UnmarshalSecurityGroupRulePrototypeRemoteIP(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupRulePrototypeRemoteIP)
	err = core.UnmarshalPrimitive(m, "address", &obj.Address)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupRulePrototypeRemoteSecurityGroupIdentity : Identifies a security group by a unique property.
// Models which "extend" this model:
// - SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByID
// - SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN
// - SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByHref
// This model "extends" SecurityGroupRulePrototypeRemote
type SecurityGroupRulePrototypeRemoteSecurityGroupIdentity struct {
	// The unique identifier for this security group.
	ID *string `json:"id,omitempty"`

	// The security group's CRN.
	CRN *string `json:"crn,omitempty"`

	// The security group's canonical URL.
	Href *string `json:"href,omitempty"`
}

func (*SecurityGroupRulePrototypeRemoteSecurityGroupIdentity) isaSecurityGroupRulePrototypeRemoteSecurityGroupIdentity() bool {
	return true
}

type SecurityGroupRulePrototypeRemoteSecurityGroupIdentityIntf interface {
	SecurityGroupRulePrototypeRemoteIntf
	isaSecurityGroupRulePrototypeRemoteSecurityGroupIdentity() bool
}

func (*SecurityGroupRulePrototypeRemoteSecurityGroupIdentity) isaSecurityGroupRulePrototypeRemote() bool {
	return true
}

// UnmarshalSecurityGroupRulePrototypeRemoteSecurityGroupIdentity unmarshals an instance of SecurityGroupRulePrototypeRemoteSecurityGroupIdentity from the specified map of raw messages.
func UnmarshalSecurityGroupRulePrototypeRemoteSecurityGroupIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupRulePrototypeRemoteSecurityGroupIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteCIDR : SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteCIDR struct
// This model "extends" SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemote
type SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteCIDR struct {
	// The CIDR block. This property may add support for IPv6 CIDR blocks in the future. When processing a value in this
	// property, verify that the CIDR block is in an expected format. If it is not, log an error. Optionally halt
	// processing and surface the error, or bypass the resource on which the unexpected CIDR block format was encountered.
	CIDRBlock *string `json:"cidr_block" validate:"required"`
}

// NewSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteCIDR : Instantiate SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteCIDR (Generic Model Constructor)
func (*VpcV1) NewSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteCIDR(cidrBlock string) (model *SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteCIDR, err error) {
	model = &SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteCIDR{
		CIDRBlock: core.StringPtr(cidrBlock),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteCIDR) isaSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemote() bool {
	return true
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteCIDR unmarshals an instance of SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteCIDR from the specified map of raw messages.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteCIDR(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteCIDR)
	err = core.UnmarshalPrimitive(m, "cidr_block", &obj.CIDRBlock)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteIP : SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteIP struct
// This model "extends" SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemote
type SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteIP struct {
	// The IP address. This property may add support for IPv6 addresses in the future. When processing a value in this
	// property, verify that the address is in an expected format. If it is not, log an error. Optionally halt processing
	// and surface the error, or bypass the resource on which the unexpected IP address format was encountered.
	Address *string `json:"address" validate:"required"`
}

// NewSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteIP : Instantiate SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteIP (Generic Model Constructor)
func (*VpcV1) NewSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteIP(address string) (model *SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteIP, err error) {
	model = &SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteIP{
		Address: core.StringPtr(address),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteIP) isaSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemote() bool {
	return true
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteIP unmarshals an instance of SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteIP from the specified map of raw messages.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteIP(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteIP)
	err = core.UnmarshalPrimitive(m, "address", &obj.Address)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupReference : SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupReference struct
// This model "extends" SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemote
type SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupReference struct {
	// The security group's CRN.
	CRN *string `json:"crn" validate:"required"`

	// The security group's canonical URL.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this security group.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this security group. Names must be unique within the VPC the security group resides in.
	Name *string `json:"name" validate:"required"`
}

// NewSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupReference : Instantiate SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupReference (Generic Model Constructor)
func (*VpcV1) NewSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupReference(crn string, href string, id string, name string) (model *SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupReference, err error) {
	model = &SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupReference{
		CRN:  core.StringPtr(crn),
		Href: core.StringPtr(href),
		ID:   core.StringPtr(id),
		Name: core.StringPtr(name),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupReference) isaSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemote() bool {
	return true
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupReference unmarshals an instance of SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupReference from the specified map of raw messages.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteSecurityGroupReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmpRemoteCIDR : SecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmpRemoteCIDR struct
// This model "extends" SecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmpRemote
type SecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmpRemoteCIDR struct {
	// The CIDR block. This property may add support for IPv6 CIDR blocks in the future. When processing a value in this
	// property, verify that the CIDR block is in an expected format. If it is not, log an error. Optionally halt
	// processing and surface the error, or bypass the resource on which the unexpected CIDR block format was encountered.
	CIDRBlock *string `json:"cidr_block" validate:"required"`
}

// NewSecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmpRemoteCIDR : Instantiate SecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmpRemoteCIDR (Generic Model Constructor)
func (*VpcV1) NewSecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmpRemoteCIDR(cidrBlock string) (model *SecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmpRemoteCIDR, err error) {
	model = &SecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmpRemoteCIDR{
		CIDRBlock: core.StringPtr(cidrBlock),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*SecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmpRemoteCIDR) isaSecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmpRemote() bool {
	return true
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmpRemoteCIDR unmarshals an instance of SecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmpRemoteCIDR from the specified map of raw messages.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmpRemoteCIDR(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmpRemoteCIDR)
	err = core.UnmarshalPrimitive(m, "cidr_block", &obj.CIDRBlock)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmpRemoteIP : SecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmpRemoteIP struct
// This model "extends" SecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmpRemote
type SecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmpRemoteIP struct {
	// The IP address. This property may add support for IPv6 addresses in the future. When processing a value in this
	// property, verify that the address is in an expected format. If it is not, log an error. Optionally halt processing
	// and surface the error, or bypass the resource on which the unexpected IP address format was encountered.
	Address *string `json:"address" validate:"required"`
}

// NewSecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmpRemoteIP : Instantiate SecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmpRemoteIP (Generic Model Constructor)
func (*VpcV1) NewSecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmpRemoteIP(address string) (model *SecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmpRemoteIP, err error) {
	model = &SecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmpRemoteIP{
		Address: core.StringPtr(address),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*SecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmpRemoteIP) isaSecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmpRemote() bool {
	return true
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmpRemoteIP unmarshals an instance of SecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmpRemoteIP from the specified map of raw messages.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmpRemoteIP(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmpRemoteIP)
	err = core.UnmarshalPrimitive(m, "address", &obj.Address)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmpRemoteSecurityGroupReference : SecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmpRemoteSecurityGroupReference struct
// This model "extends" SecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmpRemote
type SecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmpRemoteSecurityGroupReference struct {
	// The security group's CRN.
	CRN *string `json:"crn" validate:"required"`

	// The security group's canonical URL.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this security group.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this security group. Names must be unique within the VPC the security group resides in.
	Name *string `json:"name" validate:"required"`
}

// NewSecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmpRemoteSecurityGroupReference : Instantiate SecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmpRemoteSecurityGroupReference (Generic Model Constructor)
func (*VpcV1) NewSecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmpRemoteSecurityGroupReference(crn string, href string, id string, name string) (model *SecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmpRemoteSecurityGroupReference, err error) {
	model = &SecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmpRemoteSecurityGroupReference{
		CRN:  core.StringPtr(crn),
		Href: core.StringPtr(href),
		ID:   core.StringPtr(id),
		Name: core.StringPtr(name),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*SecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmpRemoteSecurityGroupReference) isaSecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmpRemote() bool {
	return true
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmpRemoteSecurityGroupReference unmarshals an instance of SecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmpRemoteSecurityGroupReference from the specified map of raw messages.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmpRemoteSecurityGroupReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmpRemoteSecurityGroupReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudpRemoteCIDR : SecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudpRemoteCIDR struct
// This model "extends" SecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudpRemote
type SecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudpRemoteCIDR struct {
	// The CIDR block. This property may add support for IPv6 CIDR blocks in the future. When processing a value in this
	// property, verify that the CIDR block is in an expected format. If it is not, log an error. Optionally halt
	// processing and surface the error, or bypass the resource on which the unexpected CIDR block format was encountered.
	CIDRBlock *string `json:"cidr_block" validate:"required"`
}

// NewSecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudpRemoteCIDR : Instantiate SecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudpRemoteCIDR (Generic Model Constructor)
func (*VpcV1) NewSecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudpRemoteCIDR(cidrBlock string) (model *SecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudpRemoteCIDR, err error) {
	model = &SecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudpRemoteCIDR{
		CIDRBlock: core.StringPtr(cidrBlock),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*SecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudpRemoteCIDR) isaSecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudpRemote() bool {
	return true
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudpRemoteCIDR unmarshals an instance of SecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudpRemoteCIDR from the specified map of raw messages.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudpRemoteCIDR(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudpRemoteCIDR)
	err = core.UnmarshalPrimitive(m, "cidr_block", &obj.CIDRBlock)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudpRemoteIP : SecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudpRemoteIP struct
// This model "extends" SecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudpRemote
type SecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudpRemoteIP struct {
	// The IP address. This property may add support for IPv6 addresses in the future. When processing a value in this
	// property, verify that the address is in an expected format. If it is not, log an error. Optionally halt processing
	// and surface the error, or bypass the resource on which the unexpected IP address format was encountered.
	Address *string `json:"address" validate:"required"`
}

// NewSecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudpRemoteIP : Instantiate SecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudpRemoteIP (Generic Model Constructor)
func (*VpcV1) NewSecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudpRemoteIP(address string) (model *SecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudpRemoteIP, err error) {
	model = &SecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudpRemoteIP{
		Address: core.StringPtr(address),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*SecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudpRemoteIP) isaSecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudpRemote() bool {
	return true
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudpRemoteIP unmarshals an instance of SecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudpRemoteIP from the specified map of raw messages.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudpRemoteIP(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudpRemoteIP)
	err = core.UnmarshalPrimitive(m, "address", &obj.Address)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudpRemoteSecurityGroupReference : SecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudpRemoteSecurityGroupReference struct
// This model "extends" SecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudpRemote
type SecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudpRemoteSecurityGroupReference struct {
	// The security group's CRN.
	CRN *string `json:"crn" validate:"required"`

	// The security group's canonical URL.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this security group.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this security group. Names must be unique within the VPC the security group resides in.
	Name *string `json:"name" validate:"required"`
}

// NewSecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudpRemoteSecurityGroupReference : Instantiate SecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudpRemoteSecurityGroupReference (Generic Model Constructor)
func (*VpcV1) NewSecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudpRemoteSecurityGroupReference(crn string, href string, id string, name string) (model *SecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudpRemoteSecurityGroupReference, err error) {
	model = &SecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudpRemoteSecurityGroupReference{
		CRN:  core.StringPtr(crn),
		Href: core.StringPtr(href),
		ID:   core.StringPtr(id),
		Name: core.StringPtr(name),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*SecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudpRemoteSecurityGroupReference) isaSecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudpRemote() bool {
	return true
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudpRemoteSecurityGroupReference unmarshals an instance of SecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudpRemoteSecurityGroupReference from the specified map of raw messages.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudpRemoteSecurityGroupReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudpRemoteSecurityGroupReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupRulePrototypeSecurityGroupRuleProtocolAll : When `protocol` is `all`, then it's invalid to specify `port_min`, `port_max`, `type` or
// `code`.
// This model "extends" SecurityGroupRulePrototype
type SecurityGroupRulePrototypeSecurityGroupRuleProtocolAll struct {
	// The direction of traffic to enforce, either `inbound` or `outbound`.
	Direction *string `json:"direction" validate:"required"`

	// The URL for this security group rule.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this security group rule.
	ID *string `json:"id" validate:"required"`

	// The IP version to enforce. The format of `remote.address` or `remote.cidr_block` must match this field, if they are
	// used. Alternatively, if `remote` references a security group, then this rule only applies to IP addresses (network
	// interfaces) in that group matching this IP version.
	IPVersion *string `json:"ip_version,omitempty"`

	// The protocol to enforce.
	Protocol *string `json:"protocol,omitempty"`

	// The IP addresses or security groups from which this rule allows traffic (or to which,
	// for outbound rules). Can be specified as an IP address, a CIDR block, or a security
	// group. A CIDR block of `0.0.0.0/0` allows traffic from any source (or to any source,
	// for outbound rules).
	Remote SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteIntf `json:"remote" validate:"required"`
}

// Constants associated with the SecurityGroupRulePrototypeSecurityGroupRuleProtocolAll.Direction property.
// The direction of traffic to enforce, either `inbound` or `outbound`.
const (
	SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllDirectionInboundConst  = "inbound"
	SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllDirectionOutboundConst = "outbound"
)

// Constants associated with the SecurityGroupRulePrototypeSecurityGroupRuleProtocolAll.IPVersion property.
// The IP version to enforce. The format of `remote.address` or `remote.cidr_block` must match this field, if they are
// used. Alternatively, if `remote` references a security group, then this rule only applies to IP addresses (network
// interfaces) in that group matching this IP version.
const (
	SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllIPVersionIpv4Const = "ipv4"
)

// Constants associated with the SecurityGroupRulePrototypeSecurityGroupRuleProtocolAll.Protocol property.
// The protocol to enforce.
const (
	SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllProtocolAllConst  = "all"
	SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllProtocolIcmpConst = "icmp"
	SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllProtocolTCPConst  = "tcp"
	SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllProtocolUDPConst  = "udp"
)

// NewSecurityGroupRulePrototypeSecurityGroupRuleProtocolAll : Instantiate SecurityGroupRulePrototypeSecurityGroupRuleProtocolAll (Generic Model Constructor)
func (*VpcV1) NewSecurityGroupRulePrototypeSecurityGroupRuleProtocolAll(direction string, href string, id string, remote SecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemoteIntf) (model *SecurityGroupRulePrototypeSecurityGroupRuleProtocolAll, err error) {
	model = &SecurityGroupRulePrototypeSecurityGroupRuleProtocolAll{
		Direction: core.StringPtr(direction),
		Href:      core.StringPtr(href),
		ID:        core.StringPtr(id),
		Remote:    remote,
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*SecurityGroupRulePrototypeSecurityGroupRuleProtocolAll) isaSecurityGroupRulePrototype() bool {
	return true
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAll unmarshals an instance of SecurityGroupRulePrototypeSecurityGroupRuleProtocolAll from the specified map of raw messages.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAll(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupRulePrototypeSecurityGroupRuleProtocolAll)
	err = core.UnmarshalPrimitive(m, "direction", &obj.Direction)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ip_version", &obj.IPVersion)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "protocol", &obj.Protocol)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "remote", &obj.Remote, UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolAllRemote)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmp : When `protocol` is `icmp`, then the rule may also contain fields to specify an ICMP `type` and `code`. Field `code`
// may only be specified if `type` is also specified. If type is not specified, then traffic is allowed for all types
// and codes. If type is specified and code is not specified, then traffic is allowed with the specified type for all
// codes.
// This model "extends" SecurityGroupRulePrototype
type SecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmp struct {
	// The direction of traffic to enforce, either `inbound` or `outbound`.
	Direction *string `json:"direction" validate:"required"`

	// The URL for this security group rule.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this security group rule.
	ID *string `json:"id" validate:"required"`

	// The IP version to enforce. The format of `remote.address` or `remote.cidr_block` must match this field, if they are
	// used. Alternatively, if `remote` references a security group, then this rule only applies to IP addresses (network
	// interfaces) in that group matching this IP version.
	IPVersion *string `json:"ip_version,omitempty"`

	// The protocol to enforce.
	Protocol *string `json:"protocol,omitempty"`

	// The IP addresses or security groups from which this rule allows traffic (or to which,
	// for outbound rules). Can be specified as an IP address, a CIDR block, or a security
	// group. A CIDR block of `0.0.0.0/0` allows traffic from any source (or to any source,
	// for outbound rules).
	Remote SecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmpRemoteIntf `json:"remote" validate:"required"`

	// The ICMP traffic code to allow.
	Code *int64 `json:"code,omitempty"`

	// The ICMP traffic type to allow.
	Type *int64 `json:"type,omitempty"`
}

// Constants associated with the SecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmp.Direction property.
// The direction of traffic to enforce, either `inbound` or `outbound`.
const (
	SecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmpDirectionInboundConst  = "inbound"
	SecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmpDirectionOutboundConst = "outbound"
)

// Constants associated with the SecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmp.IPVersion property.
// The IP version to enforce. The format of `remote.address` or `remote.cidr_block` must match this field, if they are
// used. Alternatively, if `remote` references a security group, then this rule only applies to IP addresses (network
// interfaces) in that group matching this IP version.
const (
	SecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmpIPVersionIpv4Const = "ipv4"
)

// Constants associated with the SecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmp.Protocol property.
// The protocol to enforce.
const (
	SecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmpProtocolAllConst  = "all"
	SecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmpProtocolIcmpConst = "icmp"
	SecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmpProtocolTCPConst  = "tcp"
	SecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmpProtocolUDPConst  = "udp"
)

// NewSecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmp : Instantiate SecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmp (Generic Model Constructor)
func (*VpcV1) NewSecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmp(direction string, href string, id string, remote SecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmpRemoteIntf) (model *SecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmp, err error) {
	model = &SecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmp{
		Direction: core.StringPtr(direction),
		Href:      core.StringPtr(href),
		ID:        core.StringPtr(id),
		Remote:    remote,
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*SecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmp) isaSecurityGroupRulePrototype() bool {
	return true
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmp unmarshals an instance of SecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmp from the specified map of raw messages.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmp(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmp)
	err = core.UnmarshalPrimitive(m, "direction", &obj.Direction)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ip_version", &obj.IPVersion)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "protocol", &obj.Protocol)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "remote", &obj.Remote, UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolIcmpRemote)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "code", &obj.Code)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudp : If `protocol` is either `tcp` or `udp`, then the rule may also contain `port_min` and
// `port_max`. Either both should be set, or neither. When neither is set then traffic is allowed on all ports. For a
// single port, set both to the same value.
// This model "extends" SecurityGroupRulePrototype
type SecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudp struct {
	// The direction of traffic to enforce, either `inbound` or `outbound`.
	Direction *string `json:"direction" validate:"required"`

	// The URL for this security group rule.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this security group rule.
	ID *string `json:"id" validate:"required"`

	// The IP version to enforce. The format of `remote.address` or `remote.cidr_block` must match this field, if they are
	// used. Alternatively, if `remote` references a security group, then this rule only applies to IP addresses (network
	// interfaces) in that group matching this IP version.
	IPVersion *string `json:"ip_version,omitempty"`

	// The protocol to enforce.
	Protocol *string `json:"protocol,omitempty"`

	// The IP addresses or security groups from which this rule allows traffic (or to which,
	// for outbound rules). Can be specified as an IP address, a CIDR block, or a security
	// group. A CIDR block of `0.0.0.0/0` allows traffic from any source (or to any source,
	// for outbound rules).
	Remote SecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudpRemoteIntf `json:"remote" validate:"required"`

	// The inclusive upper bound of TCP/UDP port range.
	PortMax *int64 `json:"port_max,omitempty"`

	// The inclusive lower bound of TCP/UDP port range.
	PortMin *int64 `json:"port_min,omitempty"`
}

// Constants associated with the SecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudp.Direction property.
// The direction of traffic to enforce, either `inbound` or `outbound`.
const (
	SecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudpDirectionInboundConst  = "inbound"
	SecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudpDirectionOutboundConst = "outbound"
)

// Constants associated with the SecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudp.IPVersion property.
// The IP version to enforce. The format of `remote.address` or `remote.cidr_block` must match this field, if they are
// used. Alternatively, if `remote` references a security group, then this rule only applies to IP addresses (network
// interfaces) in that group matching this IP version.
const (
	SecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudpIPVersionIpv4Const = "ipv4"
)

// Constants associated with the SecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudp.Protocol property.
// The protocol to enforce.
const (
	SecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudpProtocolAllConst  = "all"
	SecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudpProtocolIcmpConst = "icmp"
	SecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudpProtocolTCPConst  = "tcp"
	SecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudpProtocolUDPConst  = "udp"
)

// NewSecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudp : Instantiate SecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudp (Generic Model Constructor)
func (*VpcV1) NewSecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudp(direction string, href string, id string, remote SecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudpRemoteIntf) (model *SecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudp, err error) {
	model = &SecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudp{
		Direction: core.StringPtr(direction),
		Href:      core.StringPtr(href),
		ID:        core.StringPtr(id),
		Remote:    remote,
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*SecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudp) isaSecurityGroupRulePrototype() bool {
	return true
}

// UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudp unmarshals an instance of SecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudp from the specified map of raw messages.
func UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudp(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudp)
	err = core.UnmarshalPrimitive(m, "direction", &obj.Direction)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ip_version", &obj.IPVersion)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "protocol", &obj.Protocol)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "remote", &obj.Remote, UnmarshalSecurityGroupRulePrototypeSecurityGroupRuleProtocolTcpudpRemote)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "port_max", &obj.PortMax)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "port_min", &obj.PortMin)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupRuleRemoteCIDR : SecurityGroupRuleRemoteCIDR struct
// This model "extends" SecurityGroupRuleRemote
type SecurityGroupRuleRemoteCIDR struct {
	// The CIDR block. This property may add support for IPv6 CIDR blocks in the future. When processing a value in this
	// property, verify that the CIDR block is in an expected format. If it is not, log an error. Optionally halt
	// processing and surface the error, or bypass the resource on which the unexpected CIDR block format was encountered.
	CIDRBlock *string `json:"cidr_block" validate:"required"`
}

func (*SecurityGroupRuleRemoteCIDR) isaSecurityGroupRuleRemote() bool {
	return true
}

// UnmarshalSecurityGroupRuleRemoteCIDR unmarshals an instance of SecurityGroupRuleRemoteCIDR from the specified map of raw messages.
func UnmarshalSecurityGroupRuleRemoteCIDR(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupRuleRemoteCIDR)
	err = core.UnmarshalPrimitive(m, "cidr_block", &obj.CIDRBlock)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupRuleRemoteIP : SecurityGroupRuleRemoteIP struct
// This model "extends" SecurityGroupRuleRemote
type SecurityGroupRuleRemoteIP struct {
	// The IP address. This property may add support for IPv6 addresses in the future. When processing a value in this
	// property, verify that the address is in an expected format. If it is not, log an error. Optionally halt processing
	// and surface the error, or bypass the resource on which the unexpected IP address format was encountered.
	Address *string `json:"address" validate:"required"`
}

func (*SecurityGroupRuleRemoteIP) isaSecurityGroupRuleRemote() bool {
	return true
}

// UnmarshalSecurityGroupRuleRemoteIP unmarshals an instance of SecurityGroupRuleRemoteIP from the specified map of raw messages.
func UnmarshalSecurityGroupRuleRemoteIP(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupRuleRemoteIP)
	err = core.UnmarshalPrimitive(m, "address", &obj.Address)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupRuleRemoteSecurityGroupReference : SecurityGroupRuleRemoteSecurityGroupReference struct
// This model "extends" SecurityGroupRuleRemote
type SecurityGroupRuleRemoteSecurityGroupReference struct {
	// The security group's CRN.
	CRN *string `json:"crn" validate:"required"`

	// The security group's canonical URL.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this security group.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this security group. Names must be unique within the VPC the security group resides in.
	Name *string `json:"name" validate:"required"`
}

func (*SecurityGroupRuleRemoteSecurityGroupReference) isaSecurityGroupRuleRemote() bool {
	return true
}

// UnmarshalSecurityGroupRuleRemoteSecurityGroupReference unmarshals an instance of SecurityGroupRuleRemoteSecurityGroupReference from the specified map of raw messages.
func UnmarshalSecurityGroupRuleRemoteSecurityGroupReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupRuleRemoteSecurityGroupReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubnetIdentityByCRN : SubnetIdentityByCRN struct
// This model "extends" SubnetIdentity
type SubnetIdentityByCRN struct {
	// The CRN for this subnet.
	CRN *string `json:"crn" validate:"required"`
}

// NewSubnetIdentityByCRN : Instantiate SubnetIdentityByCRN (Generic Model Constructor)
func (*VpcV1) NewSubnetIdentityByCRN(crn string) (model *SubnetIdentityByCRN, err error) {
	model = &SubnetIdentityByCRN{
		CRN: core.StringPtr(crn),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*SubnetIdentityByCRN) isaSubnetIdentity() bool {
	return true
}

// UnmarshalSubnetIdentityByCRN unmarshals an instance of SubnetIdentityByCRN from the specified map of raw messages.
func UnmarshalSubnetIdentityByCRN(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubnetIdentityByCRN)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubnetIdentityByHref : SubnetIdentityByHref struct
// This model "extends" SubnetIdentity
type SubnetIdentityByHref struct {
	// The URL for this subnet.
	Href *string `json:"href" validate:"required"`
}

// NewSubnetIdentityByHref : Instantiate SubnetIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewSubnetIdentityByHref(href string) (model *SubnetIdentityByHref, err error) {
	model = &SubnetIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*SubnetIdentityByHref) isaSubnetIdentity() bool {
	return true
}

// UnmarshalSubnetIdentityByHref unmarshals an instance of SubnetIdentityByHref from the specified map of raw messages.
func UnmarshalSubnetIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubnetIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubnetIdentityByID : SubnetIdentityByID struct
// This model "extends" SubnetIdentity
type SubnetIdentityByID struct {
	// The unique identifier for this subnet.
	ID *string `json:"id" validate:"required"`
}

// NewSubnetIdentityByID : Instantiate SubnetIdentityByID (Generic Model Constructor)
func (*VpcV1) NewSubnetIdentityByID(id string) (model *SubnetIdentityByID, err error) {
	model = &SubnetIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*SubnetIdentityByID) isaSubnetIdentity() bool {
	return true
}

// UnmarshalSubnetIdentityByID unmarshals an instance of SubnetIdentityByID from the specified map of raw messages.
func UnmarshalSubnetIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubnetIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubnetPrototypeSubnetByCIDR : SubnetPrototypeSubnetByCIDR struct
// This model "extends" SubnetPrototype
type SubnetPrototypeSubnetByCIDR struct {
	// The IP version(s) supported by this subnet; if unspecified, `ipv4` is used.
	IPVersion *string `json:"ip_version,omitempty"`

	// The user-defined name for this subnet. Names must be unique within the VPC the subnet resides in. If unspecified,
	// the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The network ACL to use for this subnet.
	NetworkACL NetworkACLIdentityIntf `json:"network_acl,omitempty"`

	// The public gateway to handle internet bound traffic for this subnet.
	PublicGateway PublicGatewayIdentityIntf `json:"public_gateway,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// The routing table to use for this subnet; if unspecified, the default routing table
	// for the VPC is used.
	RoutingTable RoutingTableIdentityIntf `json:"routing_table,omitempty"`

	// The VPC the subnet is to be a part of.
	VPC VPCIdentityIntf `json:"vpc" validate:"required"`

	// The IPv4 range of the subnet, expressed in CIDR format. The prefix length of the subnet's CIDR must be between `/8`
	// (16,777,216 addresses) and `/29` (8 addresses). The IPv4 range of the subnet's CIDR must fall within an existing
	// address prefix in the VPC. The subnet will be created in the zone of the address prefix that contains the IPv4 CIDR.
	// If zone is specified, it must match the zone of the address prefix that contains the subnet's IPv4 CIDR.
	Ipv4CIDRBlock *string `json:"ipv4_cidr_block" validate:"required"`

	// The zone the subnet is to reside in.
	Zone ZoneIdentityIntf `json:"zone,omitempty"`
}

// Constants associated with the SubnetPrototypeSubnetByCIDR.IPVersion property.
// The IP version(s) supported by this subnet; if unspecified, `ipv4` is used.
const (
	SubnetPrototypeSubnetByCIDRIPVersionBothConst = "both"
	SubnetPrototypeSubnetByCIDRIPVersionIpv4Const = "ipv4"
	SubnetPrototypeSubnetByCIDRIPVersionIpv6Const = "ipv6"
)

// NewSubnetPrototypeSubnetByCIDR : Instantiate SubnetPrototypeSubnetByCIDR (Generic Model Constructor)
func (*VpcV1) NewSubnetPrototypeSubnetByCIDR(vpc VPCIdentityIntf, ipv4CIDRBlock string) (model *SubnetPrototypeSubnetByCIDR, err error) {
	model = &SubnetPrototypeSubnetByCIDR{
		VPC:           vpc,
		Ipv4CIDRBlock: core.StringPtr(ipv4CIDRBlock),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*SubnetPrototypeSubnetByCIDR) isaSubnetPrototype() bool {
	return true
}

// UnmarshalSubnetPrototypeSubnetByCIDR unmarshals an instance of SubnetPrototypeSubnetByCIDR from the specified map of raw messages.
func UnmarshalSubnetPrototypeSubnetByCIDR(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubnetPrototypeSubnetByCIDR)
	err = core.UnmarshalPrimitive(m, "ip_version", &obj.IPVersion)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "network_acl", &obj.NetworkACL, UnmarshalNetworkACLIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "public_gateway", &obj.PublicGateway, UnmarshalPublicGatewayIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "routing_table", &obj.RoutingTable, UnmarshalRoutingTableIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vpc", &obj.VPC, UnmarshalVPCIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ipv4_cidr_block", &obj.Ipv4CIDRBlock)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubnetPrototypeSubnetByTotalCount : SubnetPrototypeSubnetByTotalCount struct
// This model "extends" SubnetPrototype
type SubnetPrototypeSubnetByTotalCount struct {
	// The IP version(s) supported by this subnet; if unspecified, `ipv4` is used.
	IPVersion *string `json:"ip_version,omitempty"`

	// The user-defined name for this subnet. Names must be unique within the VPC the subnet resides in. If unspecified,
	// the name will be a hyphenated list of randomly-selected words.
	Name *string `json:"name,omitempty"`

	// The network ACL to use for this subnet.
	NetworkACL NetworkACLIdentityIntf `json:"network_acl,omitempty"`

	// The public gateway to handle internet bound traffic for this subnet.
	PublicGateway PublicGatewayIdentityIntf `json:"public_gateway,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// The routing table to use for this subnet; if unspecified, the default routing table
	// for the VPC is used.
	RoutingTable RoutingTableIdentityIntf `json:"routing_table,omitempty"`

	// The VPC the subnet is to be a part of.
	VPC VPCIdentityIntf `json:"vpc" validate:"required"`

	// The total number of IPv4 addresses required. Must be a power of 2. The VPC must have a default address prefix in the
	// specified zone, and that prefix must have a free CIDR range with at least this number of addresses.
	TotalIpv4AddressCount *int64 `json:"total_ipv4_address_count" validate:"required"`

	// The zone the subnet is to reside in.
	Zone ZoneIdentityIntf `json:"zone" validate:"required"`
}

// Constants associated with the SubnetPrototypeSubnetByTotalCount.IPVersion property.
// The IP version(s) supported by this subnet; if unspecified, `ipv4` is used.
const (
	SubnetPrototypeSubnetByTotalCountIPVersionBothConst = "both"
	SubnetPrototypeSubnetByTotalCountIPVersionIpv4Const = "ipv4"
	SubnetPrototypeSubnetByTotalCountIPVersionIpv6Const = "ipv6"
)

// NewSubnetPrototypeSubnetByTotalCount : Instantiate SubnetPrototypeSubnetByTotalCount (Generic Model Constructor)
func (*VpcV1) NewSubnetPrototypeSubnetByTotalCount(vpc VPCIdentityIntf, totalIpv4AddressCount int64, zone ZoneIdentityIntf) (model *SubnetPrototypeSubnetByTotalCount, err error) {
	model = &SubnetPrototypeSubnetByTotalCount{
		VPC:                   vpc,
		TotalIpv4AddressCount: core.Int64Ptr(totalIpv4AddressCount),
		Zone:                  zone,
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*SubnetPrototypeSubnetByTotalCount) isaSubnetPrototype() bool {
	return true
}

// UnmarshalSubnetPrototypeSubnetByTotalCount unmarshals an instance of SubnetPrototypeSubnetByTotalCount from the specified map of raw messages.
func UnmarshalSubnetPrototypeSubnetByTotalCount(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubnetPrototypeSubnetByTotalCount)
	err = core.UnmarshalPrimitive(m, "ip_version", &obj.IPVersion)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "network_acl", &obj.NetworkACL, UnmarshalNetworkACLIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "public_gateway", &obj.PublicGateway, UnmarshalPublicGatewayIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "routing_table", &obj.RoutingTable, UnmarshalRoutingTableIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vpc", &obj.VPC, UnmarshalVPCIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_ipv4_address_count", &obj.TotalIpv4AddressCount)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneIdentity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPCIdentityByCRN : VPCIdentityByCRN struct
// This model "extends" VPCIdentity
type VPCIdentityByCRN struct {
	// The CRN for this VPC.
	CRN *string `json:"crn" validate:"required"`
}

// NewVPCIdentityByCRN : Instantiate VPCIdentityByCRN (Generic Model Constructor)
func (*VpcV1) NewVPCIdentityByCRN(crn string) (model *VPCIdentityByCRN, err error) {
	model = &VPCIdentityByCRN{
		CRN: core.StringPtr(crn),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*VPCIdentityByCRN) isaVPCIdentity() bool {
	return true
}

// UnmarshalVPCIdentityByCRN unmarshals an instance of VPCIdentityByCRN from the specified map of raw messages.
func UnmarshalVPCIdentityByCRN(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPCIdentityByCRN)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPCIdentityByHref : VPCIdentityByHref struct
// This model "extends" VPCIdentity
type VPCIdentityByHref struct {
	// The URL for this VPC.
	Href *string `json:"href" validate:"required"`
}

// NewVPCIdentityByHref : Instantiate VPCIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewVPCIdentityByHref(href string) (model *VPCIdentityByHref, err error) {
	model = &VPCIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*VPCIdentityByHref) isaVPCIdentity() bool {
	return true
}

// UnmarshalVPCIdentityByHref unmarshals an instance of VPCIdentityByHref from the specified map of raw messages.
func UnmarshalVPCIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPCIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPCIdentityByID : VPCIdentityByID struct
// This model "extends" VPCIdentity
type VPCIdentityByID struct {
	// The unique identifier for this VPC.
	ID *string `json:"id" validate:"required"`
}

// NewVPCIdentityByID : Instantiate VPCIdentityByID (Generic Model Constructor)
func (*VpcV1) NewVPCIdentityByID(id string) (model *VPCIdentityByID, err error) {
	model = &VPCIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*VPCIdentityByID) isaVPCIdentity() bool {
	return true
}

// UnmarshalVPCIdentityByID unmarshals an instance of VPCIdentityByID from the specified map of raw messages.
func UnmarshalVPCIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPCIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentity : Identifies a volume by a unique property.
// Models which "extend" this model:
// - VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByID
// - VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByCRN
// - VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByHref
// This model "extends" VolumeAttachmentPrototypeInstanceContextVolume
type VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentity struct {
	// The unique identifier for this volume.
	ID *string `json:"id,omitempty"`

	// The CRN for this volume.
	CRN *string `json:"crn,omitempty"`

	// The URL for this volume.
	Href *string `json:"href,omitempty"`
}

func (*VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentity) isaVolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentity() bool {
	return true
}

type VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityIntf interface {
	VolumeAttachmentPrototypeInstanceContextVolumeIntf
	isaVolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentity() bool
}

func (*VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentity) isaVolumeAttachmentPrototypeInstanceContextVolume() bool {
	return true
}

// UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentity unmarshals an instance of VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentity from the specified map of raw messages.
func UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContext : VolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContext struct
// Models which "extend" this model:
// - VolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeByCapacity
// This model "extends" VolumeAttachmentPrototypeInstanceContextVolume
type VolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContext struct {
	// A reference to the root key to use to wrap the data encryption key for the volume.
	//
	// If this property is not provided, the `encryption` type for the volume will be
	// `provider_managed`.
	EncryptionKey EncryptionKeyIdentityIntf `json:"encryption_key,omitempty"`

	// The bandwidth for the volume.
	Iops *int64 `json:"iops,omitempty"`

	// The unique user-defined name for this volume.
	Name *string `json:"name,omitempty"`

	// The profile to use for this volume.
	Profile VolumeProfileIdentityIntf `json:"profile" validate:"required"`

	// The capacity of the volume in gigabytes. Note that the specified minimum and maximum capacity values for creating or
	// updating volumes may expand in the future.
	Capacity *int64 `json:"capacity,omitempty"`
}

func (*VolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContext) isaVolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContext() bool {
	return true
}

type VolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContextIntf interface {
	VolumeAttachmentPrototypeInstanceContextVolumeIntf
	isaVolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContext() bool
}

func (*VolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContext) isaVolumeAttachmentPrototypeInstanceContextVolume() bool {
	return true
}

// UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContext unmarshals an instance of VolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContext from the specified map of raw messages.
func UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContext)
	err = core.UnmarshalModel(m, "encryption_key", &obj.EncryptionKey, UnmarshalEncryptionKeyIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "iops", &obj.Iops)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "profile", &obj.Profile, UnmarshalVolumeProfileIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "capacity", &obj.Capacity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeIdentityByCRN : VolumeIdentityByCRN struct
// This model "extends" VolumeIdentity
type VolumeIdentityByCRN struct {
	// The CRN for this volume.
	CRN *string `json:"crn" validate:"required"`
}

// NewVolumeIdentityByCRN : Instantiate VolumeIdentityByCRN (Generic Model Constructor)
func (*VpcV1) NewVolumeIdentityByCRN(crn string) (model *VolumeIdentityByCRN, err error) {
	model = &VolumeIdentityByCRN{
		CRN: core.StringPtr(crn),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*VolumeIdentityByCRN) isaVolumeIdentity() bool {
	return true
}

// UnmarshalVolumeIdentityByCRN unmarshals an instance of VolumeIdentityByCRN from the specified map of raw messages.
func UnmarshalVolumeIdentityByCRN(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeIdentityByCRN)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeIdentityByHref : VolumeIdentityByHref struct
// This model "extends" VolumeIdentity
type VolumeIdentityByHref struct {
	// The URL for this volume.
	Href *string `json:"href" validate:"required"`
}

// NewVolumeIdentityByHref : Instantiate VolumeIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewVolumeIdentityByHref(href string) (model *VolumeIdentityByHref, err error) {
	model = &VolumeIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*VolumeIdentityByHref) isaVolumeIdentity() bool {
	return true
}

// UnmarshalVolumeIdentityByHref unmarshals an instance of VolumeIdentityByHref from the specified map of raw messages.
func UnmarshalVolumeIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeIdentityByID : VolumeIdentityByID struct
// This model "extends" VolumeIdentity
type VolumeIdentityByID struct {
	// The unique identifier for this volume.
	ID *string `json:"id" validate:"required"`
}

// NewVolumeIdentityByID : Instantiate VolumeIdentityByID (Generic Model Constructor)
func (*VpcV1) NewVolumeIdentityByID(id string) (model *VolumeIdentityByID, err error) {
	model = &VolumeIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*VolumeIdentityByID) isaVolumeIdentity() bool {
	return true
}

// UnmarshalVolumeIdentityByID unmarshals an instance of VolumeIdentityByID from the specified map of raw messages.
func UnmarshalVolumeIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeProfileIdentityByHref : VolumeProfileIdentityByHref struct
// This model "extends" VolumeProfileIdentity
type VolumeProfileIdentityByHref struct {
	// The URL for this volume profile.
	Href *string `json:"href" validate:"required"`
}

// NewVolumeProfileIdentityByHref : Instantiate VolumeProfileIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewVolumeProfileIdentityByHref(href string) (model *VolumeProfileIdentityByHref, err error) {
	model = &VolumeProfileIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*VolumeProfileIdentityByHref) isaVolumeProfileIdentity() bool {
	return true
}

// UnmarshalVolumeProfileIdentityByHref unmarshals an instance of VolumeProfileIdentityByHref from the specified map of raw messages.
func UnmarshalVolumeProfileIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeProfileIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeProfileIdentityByName : VolumeProfileIdentityByName struct
// This model "extends" VolumeProfileIdentity
type VolumeProfileIdentityByName struct {
	// The name for this volume profile.
	Name *string `json:"name" validate:"required"`
}

// NewVolumeProfileIdentityByName : Instantiate VolumeProfileIdentityByName (Generic Model Constructor)
func (*VpcV1) NewVolumeProfileIdentityByName(name string) (model *VolumeProfileIdentityByName, err error) {
	model = &VolumeProfileIdentityByName{
		Name: core.StringPtr(name),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*VolumeProfileIdentityByName) isaVolumeProfileIdentity() bool {
	return true
}

// UnmarshalVolumeProfileIdentityByName unmarshals an instance of VolumeProfileIdentityByName from the specified map of raw messages.
func UnmarshalVolumeProfileIdentityByName(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeProfileIdentityByName)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumePrototypeVolumeByCapacity : VolumePrototypeVolumeByCapacity struct
// This model "extends" VolumePrototype
type VolumePrototypeVolumeByCapacity struct {
	// A reference to the root key to use to wrap the data encryption key for the volume.
	//
	// If this property is not provided, the `encryption` type for the volume will be
	// `provider_managed`.
	EncryptionKey EncryptionKeyIdentityIntf `json:"encryption_key,omitempty"`

	// The bandwidth for the volume.
	Iops *int64 `json:"iops,omitempty"`

	// The unique user-defined name for this volume.
	Name *string `json:"name,omitempty"`

	// The profile to use for this volume.
	Profile VolumeProfileIdentityIntf `json:"profile" validate:"required"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
	ResourceGroup ResourceGroupIdentityIntf `json:"resource_group,omitempty"`

	// The location of the volume.
	Zone ZoneIdentityIntf `json:"zone" validate:"required"`

	// The capacity of the volume in gigabytes. Note that the specified minimum and maximum capacity values for creating or
	// updating volumes may expand in the future.
	Capacity *int64 `json:"capacity" validate:"required"`
}

// NewVolumePrototypeVolumeByCapacity : Instantiate VolumePrototypeVolumeByCapacity (Generic Model Constructor)
func (*VpcV1) NewVolumePrototypeVolumeByCapacity(profile VolumeProfileIdentityIntf, zone ZoneIdentityIntf, capacity int64) (model *VolumePrototypeVolumeByCapacity, err error) {
	model = &VolumePrototypeVolumeByCapacity{
		Profile:  profile,
		Zone:     zone,
		Capacity: core.Int64Ptr(capacity),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*VolumePrototypeVolumeByCapacity) isaVolumePrototype() bool {
	return true
}

// UnmarshalVolumePrototypeVolumeByCapacity unmarshals an instance of VolumePrototypeVolumeByCapacity from the specified map of raw messages.
func UnmarshalVolumePrototypeVolumeByCapacity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumePrototypeVolumeByCapacity)
	err = core.UnmarshalModel(m, "encryption_key", &obj.EncryptionKey, UnmarshalEncryptionKeyIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "iops", &obj.Iops)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "profile", &obj.Profile, UnmarshalVolumeProfileIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "capacity", &obj.Capacity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ZoneIdentityByHref : ZoneIdentityByHref struct
// This model "extends" ZoneIdentity
type ZoneIdentityByHref struct {
	// The URL for this zone.
	Href *string `json:"href" validate:"required"`
}

// NewZoneIdentityByHref : Instantiate ZoneIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewZoneIdentityByHref(href string) (model *ZoneIdentityByHref, err error) {
	model = &ZoneIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*ZoneIdentityByHref) isaZoneIdentity() bool {
	return true
}

// UnmarshalZoneIdentityByHref unmarshals an instance of ZoneIdentityByHref from the specified map of raw messages.
func UnmarshalZoneIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ZoneIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ZoneIdentityByName : ZoneIdentityByName struct
// This model "extends" ZoneIdentity
type ZoneIdentityByName struct {
	// The name for this zone.
	Name *string `json:"name" validate:"required"`
}

// NewZoneIdentityByName : Instantiate ZoneIdentityByName (Generic Model Constructor)
func (*VpcV1) NewZoneIdentityByName(name string) (model *ZoneIdentityByName, err error) {
	model = &ZoneIdentityByName{
		Name: core.StringPtr(name),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*ZoneIdentityByName) isaZoneIdentity() bool {
	return true
}

// UnmarshalZoneIdentityByName unmarshals an instance of ZoneIdentityByName from the specified map of raw messages.
func UnmarshalZoneIdentityByName(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ZoneIdentityByName)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FlowLogCollectorPrototypeTargetInstanceIdentityInstanceIdentityByCRN : FlowLogCollectorPrototypeTargetInstanceIdentityInstanceIdentityByCRN struct
// This model "extends" FlowLogCollectorPrototypeTargetInstanceIdentity
type FlowLogCollectorPrototypeTargetInstanceIdentityInstanceIdentityByCRN struct {
	// The CRN for this virtual server instance.
	CRN *string `json:"crn" validate:"required"`
}

// NewFlowLogCollectorPrototypeTargetInstanceIdentityInstanceIdentityByCRN : Instantiate FlowLogCollectorPrototypeTargetInstanceIdentityInstanceIdentityByCRN (Generic Model Constructor)
func (*VpcV1) NewFlowLogCollectorPrototypeTargetInstanceIdentityInstanceIdentityByCRN(crn string) (model *FlowLogCollectorPrototypeTargetInstanceIdentityInstanceIdentityByCRN, err error) {
	model = &FlowLogCollectorPrototypeTargetInstanceIdentityInstanceIdentityByCRN{
		CRN: core.StringPtr(crn),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*FlowLogCollectorPrototypeTargetInstanceIdentityInstanceIdentityByCRN) isaFlowLogCollectorPrototypeTargetInstanceIdentity() bool {
	return true
}

func (*FlowLogCollectorPrototypeTargetInstanceIdentityInstanceIdentityByCRN) isaFlowLogCollectorPrototypeTarget() bool {
	return true
}

// UnmarshalFlowLogCollectorPrototypeTargetInstanceIdentityInstanceIdentityByCRN unmarshals an instance of FlowLogCollectorPrototypeTargetInstanceIdentityInstanceIdentityByCRN from the specified map of raw messages.
func UnmarshalFlowLogCollectorPrototypeTargetInstanceIdentityInstanceIdentityByCRN(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FlowLogCollectorPrototypeTargetInstanceIdentityInstanceIdentityByCRN)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FlowLogCollectorPrototypeTargetInstanceIdentityInstanceIdentityByHref : FlowLogCollectorPrototypeTargetInstanceIdentityInstanceIdentityByHref struct
// This model "extends" FlowLogCollectorPrototypeTargetInstanceIdentity
type FlowLogCollectorPrototypeTargetInstanceIdentityInstanceIdentityByHref struct {
	// The URL for this virtual server instance.
	Href *string `json:"href" validate:"required"`
}

// NewFlowLogCollectorPrototypeTargetInstanceIdentityInstanceIdentityByHref : Instantiate FlowLogCollectorPrototypeTargetInstanceIdentityInstanceIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewFlowLogCollectorPrototypeTargetInstanceIdentityInstanceIdentityByHref(href string) (model *FlowLogCollectorPrototypeTargetInstanceIdentityInstanceIdentityByHref, err error) {
	model = &FlowLogCollectorPrototypeTargetInstanceIdentityInstanceIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*FlowLogCollectorPrototypeTargetInstanceIdentityInstanceIdentityByHref) isaFlowLogCollectorPrototypeTargetInstanceIdentity() bool {
	return true
}

func (*FlowLogCollectorPrototypeTargetInstanceIdentityInstanceIdentityByHref) isaFlowLogCollectorPrototypeTarget() bool {
	return true
}

// UnmarshalFlowLogCollectorPrototypeTargetInstanceIdentityInstanceIdentityByHref unmarshals an instance of FlowLogCollectorPrototypeTargetInstanceIdentityInstanceIdentityByHref from the specified map of raw messages.
func UnmarshalFlowLogCollectorPrototypeTargetInstanceIdentityInstanceIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FlowLogCollectorPrototypeTargetInstanceIdentityInstanceIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FlowLogCollectorPrototypeTargetInstanceIdentityInstanceIdentityByID : FlowLogCollectorPrototypeTargetInstanceIdentityInstanceIdentityByID struct
// This model "extends" FlowLogCollectorPrototypeTargetInstanceIdentity
type FlowLogCollectorPrototypeTargetInstanceIdentityInstanceIdentityByID struct {
	// The unique identifier for this virtual server instance.
	ID *string `json:"id" validate:"required"`
}

// NewFlowLogCollectorPrototypeTargetInstanceIdentityInstanceIdentityByID : Instantiate FlowLogCollectorPrototypeTargetInstanceIdentityInstanceIdentityByID (Generic Model Constructor)
func (*VpcV1) NewFlowLogCollectorPrototypeTargetInstanceIdentityInstanceIdentityByID(id string) (model *FlowLogCollectorPrototypeTargetInstanceIdentityInstanceIdentityByID, err error) {
	model = &FlowLogCollectorPrototypeTargetInstanceIdentityInstanceIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*FlowLogCollectorPrototypeTargetInstanceIdentityInstanceIdentityByID) isaFlowLogCollectorPrototypeTargetInstanceIdentity() bool {
	return true
}

func (*FlowLogCollectorPrototypeTargetInstanceIdentityInstanceIdentityByID) isaFlowLogCollectorPrototypeTarget() bool {
	return true
}

// UnmarshalFlowLogCollectorPrototypeTargetInstanceIdentityInstanceIdentityByID unmarshals an instance of FlowLogCollectorPrototypeTargetInstanceIdentityInstanceIdentityByID from the specified map of raw messages.
func UnmarshalFlowLogCollectorPrototypeTargetInstanceIdentityInstanceIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FlowLogCollectorPrototypeTargetInstanceIdentityInstanceIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FlowLogCollectorPrototypeTargetNetworkInterfaceIdentityNetworkInterfaceIdentityByHref : FlowLogCollectorPrototypeTargetNetworkInterfaceIdentityNetworkInterfaceIdentityByHref struct
// This model "extends" FlowLogCollectorPrototypeTargetNetworkInterfaceIdentity
type FlowLogCollectorPrototypeTargetNetworkInterfaceIdentityNetworkInterfaceIdentityByHref struct {
	// The URL for this network interface.
	Href *string `json:"href" validate:"required"`
}

// NewFlowLogCollectorPrototypeTargetNetworkInterfaceIdentityNetworkInterfaceIdentityByHref : Instantiate FlowLogCollectorPrototypeTargetNetworkInterfaceIdentityNetworkInterfaceIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewFlowLogCollectorPrototypeTargetNetworkInterfaceIdentityNetworkInterfaceIdentityByHref(href string) (model *FlowLogCollectorPrototypeTargetNetworkInterfaceIdentityNetworkInterfaceIdentityByHref, err error) {
	model = &FlowLogCollectorPrototypeTargetNetworkInterfaceIdentityNetworkInterfaceIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*FlowLogCollectorPrototypeTargetNetworkInterfaceIdentityNetworkInterfaceIdentityByHref) isaFlowLogCollectorPrototypeTargetNetworkInterfaceIdentity() bool {
	return true
}

func (*FlowLogCollectorPrototypeTargetNetworkInterfaceIdentityNetworkInterfaceIdentityByHref) isaFlowLogCollectorPrototypeTarget() bool {
	return true
}

// UnmarshalFlowLogCollectorPrototypeTargetNetworkInterfaceIdentityNetworkInterfaceIdentityByHref unmarshals an instance of FlowLogCollectorPrototypeTargetNetworkInterfaceIdentityNetworkInterfaceIdentityByHref from the specified map of raw messages.
func UnmarshalFlowLogCollectorPrototypeTargetNetworkInterfaceIdentityNetworkInterfaceIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FlowLogCollectorPrototypeTargetNetworkInterfaceIdentityNetworkInterfaceIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FlowLogCollectorPrototypeTargetNetworkInterfaceIdentityNetworkInterfaceIdentityByID : FlowLogCollectorPrototypeTargetNetworkInterfaceIdentityNetworkInterfaceIdentityByID struct
// This model "extends" FlowLogCollectorPrototypeTargetNetworkInterfaceIdentity
type FlowLogCollectorPrototypeTargetNetworkInterfaceIdentityNetworkInterfaceIdentityByID struct {
	// The unique identifier for this network interface.
	ID *string `json:"id" validate:"required"`
}

// NewFlowLogCollectorPrototypeTargetNetworkInterfaceIdentityNetworkInterfaceIdentityByID : Instantiate FlowLogCollectorPrototypeTargetNetworkInterfaceIdentityNetworkInterfaceIdentityByID (Generic Model Constructor)
func (*VpcV1) NewFlowLogCollectorPrototypeTargetNetworkInterfaceIdentityNetworkInterfaceIdentityByID(id string) (model *FlowLogCollectorPrototypeTargetNetworkInterfaceIdentityNetworkInterfaceIdentityByID, err error) {
	model = &FlowLogCollectorPrototypeTargetNetworkInterfaceIdentityNetworkInterfaceIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*FlowLogCollectorPrototypeTargetNetworkInterfaceIdentityNetworkInterfaceIdentityByID) isaFlowLogCollectorPrototypeTargetNetworkInterfaceIdentity() bool {
	return true
}

func (*FlowLogCollectorPrototypeTargetNetworkInterfaceIdentityNetworkInterfaceIdentityByID) isaFlowLogCollectorPrototypeTarget() bool {
	return true
}

// UnmarshalFlowLogCollectorPrototypeTargetNetworkInterfaceIdentityNetworkInterfaceIdentityByID unmarshals an instance of FlowLogCollectorPrototypeTargetNetworkInterfaceIdentityNetworkInterfaceIdentityByID from the specified map of raw messages.
func UnmarshalFlowLogCollectorPrototypeTargetNetworkInterfaceIdentityNetworkInterfaceIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FlowLogCollectorPrototypeTargetNetworkInterfaceIdentityNetworkInterfaceIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FlowLogCollectorPrototypeTargetSubnetIdentitySubnetIdentityByCRN : FlowLogCollectorPrototypeTargetSubnetIdentitySubnetIdentityByCRN struct
// This model "extends" FlowLogCollectorPrototypeTargetSubnetIdentity
type FlowLogCollectorPrototypeTargetSubnetIdentitySubnetIdentityByCRN struct {
	// The CRN for this subnet.
	CRN *string `json:"crn" validate:"required"`
}

// NewFlowLogCollectorPrototypeTargetSubnetIdentitySubnetIdentityByCRN : Instantiate FlowLogCollectorPrototypeTargetSubnetIdentitySubnetIdentityByCRN (Generic Model Constructor)
func (*VpcV1) NewFlowLogCollectorPrototypeTargetSubnetIdentitySubnetIdentityByCRN(crn string) (model *FlowLogCollectorPrototypeTargetSubnetIdentitySubnetIdentityByCRN, err error) {
	model = &FlowLogCollectorPrototypeTargetSubnetIdentitySubnetIdentityByCRN{
		CRN: core.StringPtr(crn),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*FlowLogCollectorPrototypeTargetSubnetIdentitySubnetIdentityByCRN) isaFlowLogCollectorPrototypeTargetSubnetIdentity() bool {
	return true
}

func (*FlowLogCollectorPrototypeTargetSubnetIdentitySubnetIdentityByCRN) isaFlowLogCollectorPrototypeTarget() bool {
	return true
}

// UnmarshalFlowLogCollectorPrototypeTargetSubnetIdentitySubnetIdentityByCRN unmarshals an instance of FlowLogCollectorPrototypeTargetSubnetIdentitySubnetIdentityByCRN from the specified map of raw messages.
func UnmarshalFlowLogCollectorPrototypeTargetSubnetIdentitySubnetIdentityByCRN(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FlowLogCollectorPrototypeTargetSubnetIdentitySubnetIdentityByCRN)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FlowLogCollectorPrototypeTargetSubnetIdentitySubnetIdentityByHref : FlowLogCollectorPrototypeTargetSubnetIdentitySubnetIdentityByHref struct
// This model "extends" FlowLogCollectorPrototypeTargetSubnetIdentity
type FlowLogCollectorPrototypeTargetSubnetIdentitySubnetIdentityByHref struct {
	// The URL for this subnet.
	Href *string `json:"href" validate:"required"`
}

// NewFlowLogCollectorPrototypeTargetSubnetIdentitySubnetIdentityByHref : Instantiate FlowLogCollectorPrototypeTargetSubnetIdentitySubnetIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewFlowLogCollectorPrototypeTargetSubnetIdentitySubnetIdentityByHref(href string) (model *FlowLogCollectorPrototypeTargetSubnetIdentitySubnetIdentityByHref, err error) {
	model = &FlowLogCollectorPrototypeTargetSubnetIdentitySubnetIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*FlowLogCollectorPrototypeTargetSubnetIdentitySubnetIdentityByHref) isaFlowLogCollectorPrototypeTargetSubnetIdentity() bool {
	return true
}

func (*FlowLogCollectorPrototypeTargetSubnetIdentitySubnetIdentityByHref) isaFlowLogCollectorPrototypeTarget() bool {
	return true
}

// UnmarshalFlowLogCollectorPrototypeTargetSubnetIdentitySubnetIdentityByHref unmarshals an instance of FlowLogCollectorPrototypeTargetSubnetIdentitySubnetIdentityByHref from the specified map of raw messages.
func UnmarshalFlowLogCollectorPrototypeTargetSubnetIdentitySubnetIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FlowLogCollectorPrototypeTargetSubnetIdentitySubnetIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FlowLogCollectorPrototypeTargetSubnetIdentitySubnetIdentityByID : FlowLogCollectorPrototypeTargetSubnetIdentitySubnetIdentityByID struct
// This model "extends" FlowLogCollectorPrototypeTargetSubnetIdentity
type FlowLogCollectorPrototypeTargetSubnetIdentitySubnetIdentityByID struct {
	// The unique identifier for this subnet.
	ID *string `json:"id" validate:"required"`
}

// NewFlowLogCollectorPrototypeTargetSubnetIdentitySubnetIdentityByID : Instantiate FlowLogCollectorPrototypeTargetSubnetIdentitySubnetIdentityByID (Generic Model Constructor)
func (*VpcV1) NewFlowLogCollectorPrototypeTargetSubnetIdentitySubnetIdentityByID(id string) (model *FlowLogCollectorPrototypeTargetSubnetIdentitySubnetIdentityByID, err error) {
	model = &FlowLogCollectorPrototypeTargetSubnetIdentitySubnetIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*FlowLogCollectorPrototypeTargetSubnetIdentitySubnetIdentityByID) isaFlowLogCollectorPrototypeTargetSubnetIdentity() bool {
	return true
}

func (*FlowLogCollectorPrototypeTargetSubnetIdentitySubnetIdentityByID) isaFlowLogCollectorPrototypeTarget() bool {
	return true
}

// UnmarshalFlowLogCollectorPrototypeTargetSubnetIdentitySubnetIdentityByID unmarshals an instance of FlowLogCollectorPrototypeTargetSubnetIdentitySubnetIdentityByID from the specified map of raw messages.
func UnmarshalFlowLogCollectorPrototypeTargetSubnetIdentitySubnetIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FlowLogCollectorPrototypeTargetSubnetIdentitySubnetIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FlowLogCollectorPrototypeTargetVPCIdentityVPCIdentityByCRN : FlowLogCollectorPrototypeTargetVPCIdentityVPCIdentityByCRN struct
// This model "extends" FlowLogCollectorPrototypeTargetVPCIdentity
type FlowLogCollectorPrototypeTargetVPCIdentityVPCIdentityByCRN struct {
	// The CRN for this VPC.
	CRN *string `json:"crn" validate:"required"`
}

// NewFlowLogCollectorPrototypeTargetVPCIdentityVPCIdentityByCRN : Instantiate FlowLogCollectorPrototypeTargetVPCIdentityVPCIdentityByCRN (Generic Model Constructor)
func (*VpcV1) NewFlowLogCollectorPrototypeTargetVPCIdentityVPCIdentityByCRN(crn string) (model *FlowLogCollectorPrototypeTargetVPCIdentityVPCIdentityByCRN, err error) {
	model = &FlowLogCollectorPrototypeTargetVPCIdentityVPCIdentityByCRN{
		CRN: core.StringPtr(crn),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*FlowLogCollectorPrototypeTargetVPCIdentityVPCIdentityByCRN) isaFlowLogCollectorPrototypeTargetVPCIdentity() bool {
	return true
}

func (*FlowLogCollectorPrototypeTargetVPCIdentityVPCIdentityByCRN) isaFlowLogCollectorPrototypeTarget() bool {
	return true
}

// UnmarshalFlowLogCollectorPrototypeTargetVPCIdentityVPCIdentityByCRN unmarshals an instance of FlowLogCollectorPrototypeTargetVPCIdentityVPCIdentityByCRN from the specified map of raw messages.
func UnmarshalFlowLogCollectorPrototypeTargetVPCIdentityVPCIdentityByCRN(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FlowLogCollectorPrototypeTargetVPCIdentityVPCIdentityByCRN)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FlowLogCollectorPrototypeTargetVPCIdentityVPCIdentityByHref : FlowLogCollectorPrototypeTargetVPCIdentityVPCIdentityByHref struct
// This model "extends" FlowLogCollectorPrototypeTargetVPCIdentity
type FlowLogCollectorPrototypeTargetVPCIdentityVPCIdentityByHref struct {
	// The URL for this VPC.
	Href *string `json:"href" validate:"required"`
}

// NewFlowLogCollectorPrototypeTargetVPCIdentityVPCIdentityByHref : Instantiate FlowLogCollectorPrototypeTargetVPCIdentityVPCIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewFlowLogCollectorPrototypeTargetVPCIdentityVPCIdentityByHref(href string) (model *FlowLogCollectorPrototypeTargetVPCIdentityVPCIdentityByHref, err error) {
	model = &FlowLogCollectorPrototypeTargetVPCIdentityVPCIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*FlowLogCollectorPrototypeTargetVPCIdentityVPCIdentityByHref) isaFlowLogCollectorPrototypeTargetVPCIdentity() bool {
	return true
}

func (*FlowLogCollectorPrototypeTargetVPCIdentityVPCIdentityByHref) isaFlowLogCollectorPrototypeTarget() bool {
	return true
}

// UnmarshalFlowLogCollectorPrototypeTargetVPCIdentityVPCIdentityByHref unmarshals an instance of FlowLogCollectorPrototypeTargetVPCIdentityVPCIdentityByHref from the specified map of raw messages.
func UnmarshalFlowLogCollectorPrototypeTargetVPCIdentityVPCIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FlowLogCollectorPrototypeTargetVPCIdentityVPCIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FlowLogCollectorPrototypeTargetVPCIdentityVPCIdentityByID : FlowLogCollectorPrototypeTargetVPCIdentityVPCIdentityByID struct
// This model "extends" FlowLogCollectorPrototypeTargetVPCIdentity
type FlowLogCollectorPrototypeTargetVPCIdentityVPCIdentityByID struct {
	// The unique identifier for this VPC.
	ID *string `json:"id" validate:"required"`
}

// NewFlowLogCollectorPrototypeTargetVPCIdentityVPCIdentityByID : Instantiate FlowLogCollectorPrototypeTargetVPCIdentityVPCIdentityByID (Generic Model Constructor)
func (*VpcV1) NewFlowLogCollectorPrototypeTargetVPCIdentityVPCIdentityByID(id string) (model *FlowLogCollectorPrototypeTargetVPCIdentityVPCIdentityByID, err error) {
	model = &FlowLogCollectorPrototypeTargetVPCIdentityVPCIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*FlowLogCollectorPrototypeTargetVPCIdentityVPCIdentityByID) isaFlowLogCollectorPrototypeTargetVPCIdentity() bool {
	return true
}

func (*FlowLogCollectorPrototypeTargetVPCIdentityVPCIdentityByID) isaFlowLogCollectorPrototypeTarget() bool {
	return true
}

// UnmarshalFlowLogCollectorPrototypeTargetVPCIdentityVPCIdentityByID unmarshals an instance of FlowLogCollectorPrototypeTargetVPCIdentityVPCIdentityByID from the specified map of raw messages.
func UnmarshalFlowLogCollectorPrototypeTargetVPCIdentityVPCIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FlowLogCollectorPrototypeTargetVPCIdentityVPCIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstancePlacementPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByCRN : InstancePlacementPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByCRN struct
// This model "extends" InstancePlacementPrototypeDedicatedHostGroupIdentity
type InstancePlacementPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByCRN struct {
	// The CRN for this dedicated host group.
	CRN *string `json:"crn" validate:"required"`
}

// NewInstancePlacementPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByCRN : Instantiate InstancePlacementPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByCRN (Generic Model Constructor)
func (*VpcV1) NewInstancePlacementPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByCRN(crn string) (model *InstancePlacementPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByCRN, err error) {
	model = &InstancePlacementPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByCRN{
		CRN: core.StringPtr(crn),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*InstancePlacementPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByCRN) isaInstancePlacementPrototypeDedicatedHostGroupIdentity() bool {
	return true
}

func (*InstancePlacementPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByCRN) isaInstancePlacementPrototype() bool {
	return true
}

// UnmarshalInstancePlacementPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByCRN unmarshals an instance of InstancePlacementPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByCRN from the specified map of raw messages.
func UnmarshalInstancePlacementPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByCRN(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstancePlacementPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByCRN)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstancePlacementPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByHref : InstancePlacementPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByHref struct
// This model "extends" InstancePlacementPrototypeDedicatedHostGroupIdentity
type InstancePlacementPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByHref struct {
	// The URL for this dedicated host group.
	Href *string `json:"href" validate:"required"`
}

// NewInstancePlacementPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByHref : Instantiate InstancePlacementPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewInstancePlacementPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByHref(href string) (model *InstancePlacementPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByHref, err error) {
	model = &InstancePlacementPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*InstancePlacementPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByHref) isaInstancePlacementPrototypeDedicatedHostGroupIdentity() bool {
	return true
}

func (*InstancePlacementPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByHref) isaInstancePlacementPrototype() bool {
	return true
}

// UnmarshalInstancePlacementPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByHref unmarshals an instance of InstancePlacementPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByHref from the specified map of raw messages.
func UnmarshalInstancePlacementPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstancePlacementPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstancePlacementPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByID : InstancePlacementPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByID struct
// This model "extends" InstancePlacementPrototypeDedicatedHostGroupIdentity
type InstancePlacementPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByID struct {
	// The unique identifier for this dedicated host group.
	ID *string `json:"id" validate:"required"`
}

// NewInstancePlacementPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByID : Instantiate InstancePlacementPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByID (Generic Model Constructor)
func (*VpcV1) NewInstancePlacementPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByID(id string) (model *InstancePlacementPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByID, err error) {
	model = &InstancePlacementPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*InstancePlacementPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByID) isaInstancePlacementPrototypeDedicatedHostGroupIdentity() bool {
	return true
}

func (*InstancePlacementPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByID) isaInstancePlacementPrototype() bool {
	return true
}

// UnmarshalInstancePlacementPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByID unmarshals an instance of InstancePlacementPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByID from the specified map of raw messages.
func UnmarshalInstancePlacementPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstancePlacementPrototypeDedicatedHostGroupIdentityDedicatedHostGroupIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstancePlacementPrototypeDedicatedHostIdentityDedicatedHostIdentityByCRN : InstancePlacementPrototypeDedicatedHostIdentityDedicatedHostIdentityByCRN struct
// This model "extends" InstancePlacementPrototypeDedicatedHostIdentity
type InstancePlacementPrototypeDedicatedHostIdentityDedicatedHostIdentityByCRN struct {
	// The CRN for this dedicated host.
	CRN *string `json:"crn" validate:"required"`
}

// NewInstancePlacementPrototypeDedicatedHostIdentityDedicatedHostIdentityByCRN : Instantiate InstancePlacementPrototypeDedicatedHostIdentityDedicatedHostIdentityByCRN (Generic Model Constructor)
func (*VpcV1) NewInstancePlacementPrototypeDedicatedHostIdentityDedicatedHostIdentityByCRN(crn string) (model *InstancePlacementPrototypeDedicatedHostIdentityDedicatedHostIdentityByCRN, err error) {
	model = &InstancePlacementPrototypeDedicatedHostIdentityDedicatedHostIdentityByCRN{
		CRN: core.StringPtr(crn),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*InstancePlacementPrototypeDedicatedHostIdentityDedicatedHostIdentityByCRN) isaInstancePlacementPrototypeDedicatedHostIdentity() bool {
	return true
}

func (*InstancePlacementPrototypeDedicatedHostIdentityDedicatedHostIdentityByCRN) isaInstancePlacementPrototype() bool {
	return true
}

// UnmarshalInstancePlacementPrototypeDedicatedHostIdentityDedicatedHostIdentityByCRN unmarshals an instance of InstancePlacementPrototypeDedicatedHostIdentityDedicatedHostIdentityByCRN from the specified map of raw messages.
func UnmarshalInstancePlacementPrototypeDedicatedHostIdentityDedicatedHostIdentityByCRN(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstancePlacementPrototypeDedicatedHostIdentityDedicatedHostIdentityByCRN)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstancePlacementPrototypeDedicatedHostIdentityDedicatedHostIdentityByHref : InstancePlacementPrototypeDedicatedHostIdentityDedicatedHostIdentityByHref struct
// This model "extends" InstancePlacementPrototypeDedicatedHostIdentity
type InstancePlacementPrototypeDedicatedHostIdentityDedicatedHostIdentityByHref struct {
	// The URL for this dedicated host.
	Href *string `json:"href" validate:"required"`
}

// NewInstancePlacementPrototypeDedicatedHostIdentityDedicatedHostIdentityByHref : Instantiate InstancePlacementPrototypeDedicatedHostIdentityDedicatedHostIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewInstancePlacementPrototypeDedicatedHostIdentityDedicatedHostIdentityByHref(href string) (model *InstancePlacementPrototypeDedicatedHostIdentityDedicatedHostIdentityByHref, err error) {
	model = &InstancePlacementPrototypeDedicatedHostIdentityDedicatedHostIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*InstancePlacementPrototypeDedicatedHostIdentityDedicatedHostIdentityByHref) isaInstancePlacementPrototypeDedicatedHostIdentity() bool {
	return true
}

func (*InstancePlacementPrototypeDedicatedHostIdentityDedicatedHostIdentityByHref) isaInstancePlacementPrototype() bool {
	return true
}

// UnmarshalInstancePlacementPrototypeDedicatedHostIdentityDedicatedHostIdentityByHref unmarshals an instance of InstancePlacementPrototypeDedicatedHostIdentityDedicatedHostIdentityByHref from the specified map of raw messages.
func UnmarshalInstancePlacementPrototypeDedicatedHostIdentityDedicatedHostIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstancePlacementPrototypeDedicatedHostIdentityDedicatedHostIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InstancePlacementPrototypeDedicatedHostIdentityDedicatedHostIdentityByID : InstancePlacementPrototypeDedicatedHostIdentityDedicatedHostIdentityByID struct
// This model "extends" InstancePlacementPrototypeDedicatedHostIdentity
type InstancePlacementPrototypeDedicatedHostIdentityDedicatedHostIdentityByID struct {
	// The unique identifier for this dedicated host.
	ID *string `json:"id" validate:"required"`
}

// NewInstancePlacementPrototypeDedicatedHostIdentityDedicatedHostIdentityByID : Instantiate InstancePlacementPrototypeDedicatedHostIdentityDedicatedHostIdentityByID (Generic Model Constructor)
func (*VpcV1) NewInstancePlacementPrototypeDedicatedHostIdentityDedicatedHostIdentityByID(id string) (model *InstancePlacementPrototypeDedicatedHostIdentityDedicatedHostIdentityByID, err error) {
	model = &InstancePlacementPrototypeDedicatedHostIdentityDedicatedHostIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*InstancePlacementPrototypeDedicatedHostIdentityDedicatedHostIdentityByID) isaInstancePlacementPrototypeDedicatedHostIdentity() bool {
	return true
}

func (*InstancePlacementPrototypeDedicatedHostIdentityDedicatedHostIdentityByID) isaInstancePlacementPrototype() bool {
	return true
}

// UnmarshalInstancePlacementPrototypeDedicatedHostIdentityDedicatedHostIdentityByID unmarshals an instance of InstancePlacementPrototypeDedicatedHostIdentityDedicatedHostIdentityByID from the specified map of raw messages.
func UnmarshalInstancePlacementPrototypeDedicatedHostIdentityDedicatedHostIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(InstancePlacementPrototypeDedicatedHostIdentityDedicatedHostIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref : LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref struct
// This model "extends" LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentity
type LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref struct {
	// The pool's canonical URL.
	Href *string `json:"href" validate:"required"`
}

// NewLoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref : Instantiate LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewLoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref(href string) (model *LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref, err error) {
	model = &LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref) isaLoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentity() bool {
	return true
}

func (*LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref) isaLoadBalancerListenerPolicyPatchTarget() bool {
	return true
}

// UnmarshalLoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref unmarshals an instance of LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref from the specified map of raw messages.
func UnmarshalLoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID : LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID struct
// This model "extends" LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentity
type LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID struct {
	// The unique identifier for this load balancer pool.
	ID *string `json:"id" validate:"required"`
}

// NewLoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID : Instantiate LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID (Generic Model Constructor)
func (*VpcV1) NewLoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID(id string) (model *LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID, err error) {
	model = &LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID) isaLoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentity() bool {
	return true
}

func (*LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID) isaLoadBalancerListenerPolicyPatchTarget() bool {
	return true
}

// UnmarshalLoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID unmarshals an instance of LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID from the specified map of raw messages.
func UnmarshalLoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerListenerPolicyPatchTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref : LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref struct
// This model "extends" LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentity
type LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref struct {
	// The pool's canonical URL.
	Href *string `json:"href" validate:"required"`
}

// NewLoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref : Instantiate LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewLoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref(href string) (model *LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref, err error) {
	model = &LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref) isaLoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentity() bool {
	return true
}

func (*LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref) isaLoadBalancerListenerPolicyPrototypeTarget() bool {
	return true
}

// UnmarshalLoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref unmarshals an instance of LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref from the specified map of raw messages.
func UnmarshalLoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID : LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID struct
// This model "extends" LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentity
type LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID struct {
	// The unique identifier for this load balancer pool.
	ID *string `json:"id" validate:"required"`
}

// NewLoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID : Instantiate LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID (Generic Model Constructor)
func (*VpcV1) NewLoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID(id string) (model *LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID, err error) {
	model = &LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID) isaLoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentity() bool {
	return true
}

func (*LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID) isaLoadBalancerListenerPolicyPrototypeTarget() bool {
	return true
}

// UnmarshalLoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID unmarshals an instance of LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID from the specified map of raw messages.
func UnmarshalLoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerListenerPolicyPrototypeTargetLoadBalancerPoolIdentityLoadBalancerPoolIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByCRN : LoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByCRN struct
// This model "extends" LoadBalancerPoolMemberTargetPrototypeInstanceIdentity
type LoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByCRN struct {
	// The CRN for this virtual server instance.
	CRN *string `json:"crn" validate:"required"`
}

// NewLoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByCRN : Instantiate LoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByCRN (Generic Model Constructor)
func (*VpcV1) NewLoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByCRN(crn string) (model *LoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByCRN, err error) {
	model = &LoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByCRN{
		CRN: core.StringPtr(crn),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*LoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByCRN) isaLoadBalancerPoolMemberTargetPrototypeInstanceIdentity() bool {
	return true
}

func (*LoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByCRN) isaLoadBalancerPoolMemberTargetPrototype() bool {
	return true
}

// UnmarshalLoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByCRN unmarshals an instance of LoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByCRN from the specified map of raw messages.
func UnmarshalLoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByCRN(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByCRN)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByHref : LoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByHref struct
// This model "extends" LoadBalancerPoolMemberTargetPrototypeInstanceIdentity
type LoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByHref struct {
	// The URL for this virtual server instance.
	Href *string `json:"href" validate:"required"`
}

// NewLoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByHref : Instantiate LoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewLoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByHref(href string) (model *LoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByHref, err error) {
	model = &LoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*LoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByHref) isaLoadBalancerPoolMemberTargetPrototypeInstanceIdentity() bool {
	return true
}

func (*LoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByHref) isaLoadBalancerPoolMemberTargetPrototype() bool {
	return true
}

// UnmarshalLoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByHref unmarshals an instance of LoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByHref from the specified map of raw messages.
func UnmarshalLoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByID : LoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByID struct
// This model "extends" LoadBalancerPoolMemberTargetPrototypeInstanceIdentity
type LoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByID struct {
	// The unique identifier for this virtual server instance.
	ID *string `json:"id" validate:"required"`
}

// NewLoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByID : Instantiate LoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByID (Generic Model Constructor)
func (*VpcV1) NewLoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByID(id string) (model *LoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByID, err error) {
	model = &LoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*LoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByID) isaLoadBalancerPoolMemberTargetPrototypeInstanceIdentity() bool {
	return true
}

func (*LoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByID) isaLoadBalancerPoolMemberTargetPrototype() bool {
	return true
}

// UnmarshalLoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByID unmarshals an instance of LoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByID from the specified map of raw messages.
func UnmarshalLoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LoadBalancerPoolMemberTargetPrototypeInstanceIdentityInstanceIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PublicGatewayPrototypeFloatingIPFloatingIPIdentityFloatingIPIdentityByAddress : PublicGatewayPrototypeFloatingIPFloatingIPIdentityFloatingIPIdentityByAddress struct
// This model "extends" PublicGatewayPrototypeFloatingIPFloatingIPIdentity
type PublicGatewayPrototypeFloatingIPFloatingIPIdentityFloatingIPIdentityByAddress struct {
	// The globally unique IP address.
	Address *string `json:"address" validate:"required"`
}

// NewPublicGatewayPrototypeFloatingIPFloatingIPIdentityFloatingIPIdentityByAddress : Instantiate PublicGatewayPrototypeFloatingIPFloatingIPIdentityFloatingIPIdentityByAddress (Generic Model Constructor)
func (*VpcV1) NewPublicGatewayPrototypeFloatingIPFloatingIPIdentityFloatingIPIdentityByAddress(address string) (model *PublicGatewayPrototypeFloatingIPFloatingIPIdentityFloatingIPIdentityByAddress, err error) {
	model = &PublicGatewayPrototypeFloatingIPFloatingIPIdentityFloatingIPIdentityByAddress{
		Address: core.StringPtr(address),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*PublicGatewayPrototypeFloatingIPFloatingIPIdentityFloatingIPIdentityByAddress) isaPublicGatewayPrototypeFloatingIPFloatingIPIdentity() bool {
	return true
}

func (*PublicGatewayPrototypeFloatingIPFloatingIPIdentityFloatingIPIdentityByAddress) isaPublicGatewayPrototypeFloatingIP() bool {
	return true
}

// UnmarshalPublicGatewayPrototypeFloatingIPFloatingIPIdentityFloatingIPIdentityByAddress unmarshals an instance of PublicGatewayPrototypeFloatingIPFloatingIPIdentityFloatingIPIdentityByAddress from the specified map of raw messages.
func UnmarshalPublicGatewayPrototypeFloatingIPFloatingIPIdentityFloatingIPIdentityByAddress(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PublicGatewayPrototypeFloatingIPFloatingIPIdentityFloatingIPIdentityByAddress)
	err = core.UnmarshalPrimitive(m, "address", &obj.Address)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PublicGatewayPrototypeFloatingIPFloatingIPIdentityFloatingIPIdentityByCRN : PublicGatewayPrototypeFloatingIPFloatingIPIdentityFloatingIPIdentityByCRN struct
// This model "extends" PublicGatewayPrototypeFloatingIPFloatingIPIdentity
type PublicGatewayPrototypeFloatingIPFloatingIPIdentityFloatingIPIdentityByCRN struct {
	// The CRN for this floating IP.
	CRN *string `json:"crn" validate:"required"`
}

// NewPublicGatewayPrototypeFloatingIPFloatingIPIdentityFloatingIPIdentityByCRN : Instantiate PublicGatewayPrototypeFloatingIPFloatingIPIdentityFloatingIPIdentityByCRN (Generic Model Constructor)
func (*VpcV1) NewPublicGatewayPrototypeFloatingIPFloatingIPIdentityFloatingIPIdentityByCRN(crn string) (model *PublicGatewayPrototypeFloatingIPFloatingIPIdentityFloatingIPIdentityByCRN, err error) {
	model = &PublicGatewayPrototypeFloatingIPFloatingIPIdentityFloatingIPIdentityByCRN{
		CRN: core.StringPtr(crn),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*PublicGatewayPrototypeFloatingIPFloatingIPIdentityFloatingIPIdentityByCRN) isaPublicGatewayPrototypeFloatingIPFloatingIPIdentity() bool {
	return true
}

func (*PublicGatewayPrototypeFloatingIPFloatingIPIdentityFloatingIPIdentityByCRN) isaPublicGatewayPrototypeFloatingIP() bool {
	return true
}

// UnmarshalPublicGatewayPrototypeFloatingIPFloatingIPIdentityFloatingIPIdentityByCRN unmarshals an instance of PublicGatewayPrototypeFloatingIPFloatingIPIdentityFloatingIPIdentityByCRN from the specified map of raw messages.
func UnmarshalPublicGatewayPrototypeFloatingIPFloatingIPIdentityFloatingIPIdentityByCRN(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PublicGatewayPrototypeFloatingIPFloatingIPIdentityFloatingIPIdentityByCRN)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PublicGatewayPrototypeFloatingIPFloatingIPIdentityFloatingIPIdentityByHref : PublicGatewayPrototypeFloatingIPFloatingIPIdentityFloatingIPIdentityByHref struct
// This model "extends" PublicGatewayPrototypeFloatingIPFloatingIPIdentity
type PublicGatewayPrototypeFloatingIPFloatingIPIdentityFloatingIPIdentityByHref struct {
	// The URL for this floating IP.
	Href *string `json:"href" validate:"required"`
}

// NewPublicGatewayPrototypeFloatingIPFloatingIPIdentityFloatingIPIdentityByHref : Instantiate PublicGatewayPrototypeFloatingIPFloatingIPIdentityFloatingIPIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewPublicGatewayPrototypeFloatingIPFloatingIPIdentityFloatingIPIdentityByHref(href string) (model *PublicGatewayPrototypeFloatingIPFloatingIPIdentityFloatingIPIdentityByHref, err error) {
	model = &PublicGatewayPrototypeFloatingIPFloatingIPIdentityFloatingIPIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*PublicGatewayPrototypeFloatingIPFloatingIPIdentityFloatingIPIdentityByHref) isaPublicGatewayPrototypeFloatingIPFloatingIPIdentity() bool {
	return true
}

func (*PublicGatewayPrototypeFloatingIPFloatingIPIdentityFloatingIPIdentityByHref) isaPublicGatewayPrototypeFloatingIP() bool {
	return true
}

// UnmarshalPublicGatewayPrototypeFloatingIPFloatingIPIdentityFloatingIPIdentityByHref unmarshals an instance of PublicGatewayPrototypeFloatingIPFloatingIPIdentityFloatingIPIdentityByHref from the specified map of raw messages.
func UnmarshalPublicGatewayPrototypeFloatingIPFloatingIPIdentityFloatingIPIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PublicGatewayPrototypeFloatingIPFloatingIPIdentityFloatingIPIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PublicGatewayPrototypeFloatingIPFloatingIPIdentityFloatingIPIdentityByID : PublicGatewayPrototypeFloatingIPFloatingIPIdentityFloatingIPIdentityByID struct
// This model "extends" PublicGatewayPrototypeFloatingIPFloatingIPIdentity
type PublicGatewayPrototypeFloatingIPFloatingIPIdentityFloatingIPIdentityByID struct {
	// The unique identifier for this floating IP.
	ID *string `json:"id" validate:"required"`
}

// NewPublicGatewayPrototypeFloatingIPFloatingIPIdentityFloatingIPIdentityByID : Instantiate PublicGatewayPrototypeFloatingIPFloatingIPIdentityFloatingIPIdentityByID (Generic Model Constructor)
func (*VpcV1) NewPublicGatewayPrototypeFloatingIPFloatingIPIdentityFloatingIPIdentityByID(id string) (model *PublicGatewayPrototypeFloatingIPFloatingIPIdentityFloatingIPIdentityByID, err error) {
	model = &PublicGatewayPrototypeFloatingIPFloatingIPIdentityFloatingIPIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*PublicGatewayPrototypeFloatingIPFloatingIPIdentityFloatingIPIdentityByID) isaPublicGatewayPrototypeFloatingIPFloatingIPIdentity() bool {
	return true
}

func (*PublicGatewayPrototypeFloatingIPFloatingIPIdentityFloatingIPIdentityByID) isaPublicGatewayPrototypeFloatingIP() bool {
	return true
}

// UnmarshalPublicGatewayPrototypeFloatingIPFloatingIPIdentityFloatingIPIdentityByID unmarshals an instance of PublicGatewayPrototypeFloatingIPFloatingIPIdentityFloatingIPIdentityByID from the specified map of raw messages.
func UnmarshalPublicGatewayPrototypeFloatingIPFloatingIPIdentityFloatingIPIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PublicGatewayPrototypeFloatingIPFloatingIPIdentityFloatingIPIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RouteNextHopPrototypeRouteNextHopConnectionRouteNextHopConnectionVPNGatewayConnectionIdentityByHref : RouteNextHopPrototypeRouteNextHopConnectionRouteNextHopConnectionVPNGatewayConnectionIdentityByHref struct
// This model "extends" RouteNextHopPrototypeRouteNextHopConnection
type RouteNextHopPrototypeRouteNextHopConnectionRouteNextHopConnectionVPNGatewayConnectionIdentityByHref struct {
	// The VPN connection's canonical URL.
	Href *string `json:"href" validate:"required"`
}

// NewRouteNextHopPrototypeRouteNextHopConnectionRouteNextHopConnectionVPNGatewayConnectionIdentityByHref : Instantiate RouteNextHopPrototypeRouteNextHopConnectionRouteNextHopConnectionVPNGatewayConnectionIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewRouteNextHopPrototypeRouteNextHopConnectionRouteNextHopConnectionVPNGatewayConnectionIdentityByHref(href string) (model *RouteNextHopPrototypeRouteNextHopConnectionRouteNextHopConnectionVPNGatewayConnectionIdentityByHref, err error) {
	model = &RouteNextHopPrototypeRouteNextHopConnectionRouteNextHopConnectionVPNGatewayConnectionIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*RouteNextHopPrototypeRouteNextHopConnectionRouteNextHopConnectionVPNGatewayConnectionIdentityByHref) isaRouteNextHopPrototypeRouteNextHopConnection() bool {
	return true
}

func (*RouteNextHopPrototypeRouteNextHopConnectionRouteNextHopConnectionVPNGatewayConnectionIdentityByHref) isaRouteNextHopPrototype() bool {
	return true
}

// UnmarshalRouteNextHopPrototypeRouteNextHopConnectionRouteNextHopConnectionVPNGatewayConnectionIdentityByHref unmarshals an instance of RouteNextHopPrototypeRouteNextHopConnectionRouteNextHopConnectionVPNGatewayConnectionIdentityByHref from the specified map of raw messages.
func UnmarshalRouteNextHopPrototypeRouteNextHopConnectionRouteNextHopConnectionVPNGatewayConnectionIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RouteNextHopPrototypeRouteNextHopConnectionRouteNextHopConnectionVPNGatewayConnectionIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RouteNextHopPrototypeRouteNextHopConnectionRouteNextHopConnectionVPNGatewayConnectionIdentityByID : RouteNextHopPrototypeRouteNextHopConnectionRouteNextHopConnectionVPNGatewayConnectionIdentityByID struct
// This model "extends" RouteNextHopPrototypeRouteNextHopConnection
type RouteNextHopPrototypeRouteNextHopConnectionRouteNextHopConnectionVPNGatewayConnectionIdentityByID struct {
	// The unique identifier for this VPN connection.
	ID *string `json:"id" validate:"required"`
}

// NewRouteNextHopPrototypeRouteNextHopConnectionRouteNextHopConnectionVPNGatewayConnectionIdentityByID : Instantiate RouteNextHopPrototypeRouteNextHopConnectionRouteNextHopConnectionVPNGatewayConnectionIdentityByID (Generic Model Constructor)
func (*VpcV1) NewRouteNextHopPrototypeRouteNextHopConnectionRouteNextHopConnectionVPNGatewayConnectionIdentityByID(id string) (model *RouteNextHopPrototypeRouteNextHopConnectionRouteNextHopConnectionVPNGatewayConnectionIdentityByID, err error) {
	model = &RouteNextHopPrototypeRouteNextHopConnectionRouteNextHopConnectionVPNGatewayConnectionIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*RouteNextHopPrototypeRouteNextHopConnectionRouteNextHopConnectionVPNGatewayConnectionIdentityByID) isaRouteNextHopPrototypeRouteNextHopConnection() bool {
	return true
}

func (*RouteNextHopPrototypeRouteNextHopConnectionRouteNextHopConnectionVPNGatewayConnectionIdentityByID) isaRouteNextHopPrototype() bool {
	return true
}

// UnmarshalRouteNextHopPrototypeRouteNextHopConnectionRouteNextHopConnectionVPNGatewayConnectionIdentityByID unmarshals an instance of RouteNextHopPrototypeRouteNextHopConnectionRouteNextHopConnectionVPNGatewayConnectionIdentityByID from the specified map of raw messages.
func UnmarshalRouteNextHopPrototypeRouteNextHopConnectionRouteNextHopConnectionVPNGatewayConnectionIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RouteNextHopPrototypeRouteNextHopConnectionRouteNextHopConnectionVPNGatewayConnectionIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN : SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN struct
// This model "extends" SecurityGroupRulePatchRemoteSecurityGroupIdentity
type SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN struct {
	// The security group's CRN.
	CRN *string `json:"crn" validate:"required"`
}

// NewSecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN : Instantiate SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN (Generic Model Constructor)
func (*VpcV1) NewSecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN(crn string) (model *SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN, err error) {
	model = &SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN{
		CRN: core.StringPtr(crn),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN) isaSecurityGroupRulePatchRemoteSecurityGroupIdentity() bool {
	return true
}

func (*SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN) isaSecurityGroupRulePatchRemote() bool {
	return true
}

// UnmarshalSecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN unmarshals an instance of SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN from the specified map of raw messages.
func UnmarshalSecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByHref : SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByHref struct
// This model "extends" SecurityGroupRulePatchRemoteSecurityGroupIdentity
type SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByHref struct {
	// The security group's canonical URL.
	Href *string `json:"href" validate:"required"`
}

// NewSecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByHref : Instantiate SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewSecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByHref(href string) (model *SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByHref, err error) {
	model = &SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByHref) isaSecurityGroupRulePatchRemoteSecurityGroupIdentity() bool {
	return true
}

func (*SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByHref) isaSecurityGroupRulePatchRemote() bool {
	return true
}

// UnmarshalSecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByHref unmarshals an instance of SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByHref from the specified map of raw messages.
func UnmarshalSecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByID : SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByID struct
// This model "extends" SecurityGroupRulePatchRemoteSecurityGroupIdentity
type SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByID struct {
	// The unique identifier for this security group.
	ID *string `json:"id" validate:"required"`
}

// NewSecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByID : Instantiate SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByID (Generic Model Constructor)
func (*VpcV1) NewSecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByID(id string) (model *SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByID, err error) {
	model = &SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByID) isaSecurityGroupRulePatchRemoteSecurityGroupIdentity() bool {
	return true
}

func (*SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByID) isaSecurityGroupRulePatchRemote() bool {
	return true
}

// UnmarshalSecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByID unmarshals an instance of SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByID from the specified map of raw messages.
func UnmarshalSecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupRulePatchRemoteSecurityGroupIdentitySecurityGroupIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN : SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN struct
// This model "extends" SecurityGroupRulePrototypeRemoteSecurityGroupIdentity
type SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN struct {
	// The security group's CRN.
	CRN *string `json:"crn" validate:"required"`
}

// NewSecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN : Instantiate SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN (Generic Model Constructor)
func (*VpcV1) NewSecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN(crn string) (model *SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN, err error) {
	model = &SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN{
		CRN: core.StringPtr(crn),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN) isaSecurityGroupRulePrototypeRemoteSecurityGroupIdentity() bool {
	return true
}

func (*SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN) isaSecurityGroupRulePrototypeRemote() bool {
	return true
}

// UnmarshalSecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN unmarshals an instance of SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN from the specified map of raw messages.
func UnmarshalSecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByCRN)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByHref : SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByHref struct
// This model "extends" SecurityGroupRulePrototypeRemoteSecurityGroupIdentity
type SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByHref struct {
	// The security group's canonical URL.
	Href *string `json:"href" validate:"required"`
}

// NewSecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByHref : Instantiate SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewSecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByHref(href string) (model *SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByHref, err error) {
	model = &SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByHref) isaSecurityGroupRulePrototypeRemoteSecurityGroupIdentity() bool {
	return true
}

func (*SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByHref) isaSecurityGroupRulePrototypeRemote() bool {
	return true
}

// UnmarshalSecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByHref unmarshals an instance of SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByHref from the specified map of raw messages.
func UnmarshalSecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByID : SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByID struct
// This model "extends" SecurityGroupRulePrototypeRemoteSecurityGroupIdentity
type SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByID struct {
	// The unique identifier for this security group.
	ID *string `json:"id" validate:"required"`
}

// NewSecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByID : Instantiate SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByID (Generic Model Constructor)
func (*VpcV1) NewSecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByID(id string) (model *SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByID, err error) {
	model = &SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByID) isaSecurityGroupRulePrototypeRemoteSecurityGroupIdentity() bool {
	return true
}

func (*SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByID) isaSecurityGroupRulePrototypeRemote() bool {
	return true
}

// UnmarshalSecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByID unmarshals an instance of SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByID from the specified map of raw messages.
func UnmarshalSecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecurityGroupRulePrototypeRemoteSecurityGroupIdentitySecurityGroupIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByCRN : VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByCRN struct
// This model "extends" VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentity
type VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByCRN struct {
	// The CRN for this volume.
	CRN *string `json:"crn" validate:"required"`
}

// NewVolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByCRN : Instantiate VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByCRN (Generic Model Constructor)
func (*VpcV1) NewVolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByCRN(crn string) (model *VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByCRN, err error) {
	model = &VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByCRN{
		CRN: core.StringPtr(crn),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByCRN) isaVolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentity() bool {
	return true
}

func (*VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByCRN) isaVolumeAttachmentPrototypeInstanceContextVolume() bool {
	return true
}

// UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByCRN unmarshals an instance of VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByCRN from the specified map of raw messages.
func UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByCRN(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByCRN)
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByHref : VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByHref struct
// This model "extends" VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentity
type VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByHref struct {
	// The URL for this volume.
	Href *string `json:"href" validate:"required"`
}

// NewVolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByHref : Instantiate VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByHref (Generic Model Constructor)
func (*VpcV1) NewVolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByHref(href string) (model *VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByHref, err error) {
	model = &VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByHref{
		Href: core.StringPtr(href),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByHref) isaVolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentity() bool {
	return true
}

func (*VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByHref) isaVolumeAttachmentPrototypeInstanceContextVolume() bool {
	return true
}

// UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByHref unmarshals an instance of VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByHref from the specified map of raw messages.
func UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByHref(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByHref)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByID : VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByID struct
// This model "extends" VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentity
type VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByID struct {
	// The unique identifier for this volume.
	ID *string `json:"id" validate:"required"`
}

// NewVolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByID : Instantiate VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByID (Generic Model Constructor)
func (*VpcV1) NewVolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByID(id string) (model *VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByID, err error) {
	model = &VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByID{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByID) isaVolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentity() bool {
	return true
}

func (*VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByID) isaVolumeAttachmentPrototypeInstanceContextVolume() bool {
	return true
}

// UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByID unmarshals an instance of VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByID from the specified map of raw messages.
func UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByID(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeAttachmentPrototypeInstanceContextVolumeVolumeIdentityVolumeIdentityByID)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeByCapacity : VolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeByCapacity struct
// This model "extends" VolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContext
type VolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeByCapacity struct {
	// A reference to the root key to use to wrap the data encryption key for the volume.
	//
	// If this property is not provided, the `encryption` type for the volume will be
	// `provider_managed`.
	EncryptionKey EncryptionKeyIdentityIntf `json:"encryption_key,omitempty"`

	// The bandwidth for the volume.
	Iops *int64 `json:"iops,omitempty"`

	// The unique user-defined name for this volume.
	Name *string `json:"name,omitempty"`

	// The profile to use for this volume.
	Profile VolumeProfileIdentityIntf `json:"profile" validate:"required"`

	// The capacity of the volume in gigabytes. Note that the specified minimum and maximum capacity values for creating or
	// updating volumes may expand in the future.
	Capacity *int64 `json:"capacity" validate:"required"`
}

// NewVolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeByCapacity : Instantiate VolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeByCapacity (Generic Model Constructor)
func (*VpcV1) NewVolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeByCapacity(profile VolumeProfileIdentityIntf, capacity int64) (model *VolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeByCapacity, err error) {
	model = &VolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeByCapacity{
		Profile:  profile,
		Capacity: core.Int64Ptr(capacity),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

func (*VolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeByCapacity) isaVolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContext() bool {
	return true
}

func (*VolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeByCapacity) isaVolumeAttachmentPrototypeInstanceContextVolume() bool {
	return true
}

// UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeByCapacity unmarshals an instance of VolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeByCapacity from the specified map of raw messages.
func UnmarshalVolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeByCapacity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeAttachmentPrototypeInstanceContextVolumeVolumePrototypeInstanceContextVolumePrototypeInstanceContextVolumeByCapacity)
	err = core.UnmarshalModel(m, "encryption_key", &obj.EncryptionKey, UnmarshalEncryptionKeyIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "iops", &obj.Iops)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "profile", &obj.Profile, UnmarshalVolumeProfileIdentity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "capacity", &obj.Capacity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}
